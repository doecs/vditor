"use strict";
(function() {

Error.stackTraceLimit = Infinity;

var $global, $module;
if (typeof window !== "undefined") { /* web page */
  console.log('webpage')
  $global = window;
} else if (typeof self !== "undefined") { /* web worker */
  console.log('webworker')
  $global = self;
} else if (typeof global !== "undefined") { /* Node.js */
  console.log('Nodejs')
  $global = global;
  $global.require = require;
} else { /* others (e.g. Nashorn) */
  console.log('others')
  $global = this;
}

if ($global === undefined || $global.Array === undefined) {
  throw new Error("no global object found");
}
if (typeof module !== "undefined") {
  $module = module;
}

var $packages = {}, $idCounter = 0;
var $keys = function(m) { return m ? Object.keys(m) : []; };
var $flushConsole = function() {};
var $throwRuntimeError; /* set by package "runtime" */
var $throwNilPointerError = function() { $throwRuntimeError("invalid memory address or nil pointer dereference"); };
var $call = function(fn, rcvr, args) { return fn.apply(rcvr, args); };
var $makeFunc = function(fn) { return function() { return $externalize(fn(this, new ($sliceType($jsObjectPtr))($global.Array.prototype.slice.call(arguments, []))), $emptyInterface); }; };
var $unused = function(v) {};

var $mapArray = function(array, f) {
  var newArray = new array.constructor(array.length);
  for (var i = 0; i < array.length; i++) {
    newArray[i] = f(array[i]);
  }
  return newArray;
};

var $methodVal = function(recv, name) {
  var vals = recv.$methodVals || {};
  recv.$methodVals = vals; /* noop for primitives */
  var f = vals[name];
  if (f !== undefined) {
    return f;
  }
  var method = recv[name];
  f = function() {
    $stackDepthOffset--;
    try {
      return method.apply(recv, arguments);
    } finally {
      $stackDepthOffset++;
    }
  };
  vals[name] = f;
  return f;
};

var $methodExpr = function(typ, name) {
  var method = typ.prototype[name];
  if (method.$expr === undefined) {
    method.$expr = function() {
      $stackDepthOffset--;
      try {
        if (typ.wrapped) {
          arguments[0] = new typ(arguments[0]);
        }
        return Function.call.apply(method, arguments);
      } finally {
        $stackDepthOffset++;
      }
    };
  }
  return method.$expr;
};

var $ifaceMethodExprs = {};
var $ifaceMethodExpr = function(name) {
  var expr = $ifaceMethodExprs["$" + name];
  if (expr === undefined) {
    expr = $ifaceMethodExprs["$" + name] = function() {
      $stackDepthOffset--;
      try {
        return Function.call.apply(arguments[0][name], arguments);
      } finally {
        $stackDepthOffset++;
      }
    };
  }
  return expr;
};

var $subslice = function(slice, low, high, max) {
  if (high === undefined) {
    high = slice.$length;
  }
  if (max === undefined) {
    max = slice.$capacity;
  }
  if (low < 0 || high < low || max < high || high > slice.$capacity || max > slice.$capacity) {
    $throwRuntimeError("slice bounds out of range");
  }
  if (slice === slice.constructor.nil) {
    return slice;
  }
  var s = new slice.constructor(slice.$array);
  s.$offset = slice.$offset + low;
  s.$length = high - low;
  s.$capacity = max - low;
  return s;
};

var $substring = function(str, low, high) {
  if (low < 0 || high < low || high > str.length) {
    $throwRuntimeError("slice bounds out of range");
  }
  return str.substring(low, high);
};

var $sliceToArray = function(slice) {
  if (slice.$array.constructor !== Array) {
    return slice.$array.subarray(slice.$offset, slice.$offset + slice.$length);
  }
  return slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
};

var $decodeRune = function(str, pos) {
  var c0 = str.charCodeAt(pos);

  if (c0 < 0x80) {
    return [c0, 1];
  }

  if (c0 !== c0 || c0 < 0xC0) {
    return [0xFFFD, 1];
  }

  var c1 = str.charCodeAt(pos + 1);
  if (c1 !== c1 || c1 < 0x80 || 0xC0 <= c1) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xE0) {
    var r = (c0 & 0x1F) << 6 | (c1 & 0x3F);
    if (r <= 0x7F) {
      return [0xFFFD, 1];
    }
    return [r, 2];
  }

  var c2 = str.charCodeAt(pos + 2);
  if (c2 !== c2 || c2 < 0x80 || 0xC0 <= c2) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xF0) {
    var r = (c0 & 0x0F) << 12 | (c1 & 0x3F) << 6 | (c2 & 0x3F);
    if (r <= 0x7FF) {
      return [0xFFFD, 1];
    }
    if (0xD800 <= r && r <= 0xDFFF) {
      return [0xFFFD, 1];
    }
    return [r, 3];
  }

  var c3 = str.charCodeAt(pos + 3);
  if (c3 !== c3 || c3 < 0x80 || 0xC0 <= c3) {
    return [0xFFFD, 1];
  }

  if (c0 < 0xF8) {
    var r = (c0 & 0x07) << 18 | (c1 & 0x3F) << 12 | (c2 & 0x3F) << 6 | (c3 & 0x3F);
    if (r <= 0xFFFF || 0x10FFFF < r) {
      return [0xFFFD, 1];
    }
    return [r, 4];
  }

  return [0xFFFD, 1];
};

var $encodeRune = function(r) {
  if (r < 0 || r > 0x10FFFF || (0xD800 <= r && r <= 0xDFFF)) {
    r = 0xFFFD;
  }
  if (r <= 0x7F) {
    return String.fromCharCode(r);
  }
  if (r <= 0x7FF) {
    return String.fromCharCode(0xC0 | r >> 6, 0x80 | (r & 0x3F));
  }
  if (r <= 0xFFFF) {
    return String.fromCharCode(0xE0 | r >> 12, 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
  }
  return String.fromCharCode(0xF0 | r >> 18, 0x80 | (r >> 12 & 0x3F), 0x80 | (r >> 6 & 0x3F), 0x80 | (r & 0x3F));
};

var $stringToBytes = function(str) {
  var array = new Uint8Array(str.length);
  for (var i = 0; i < str.length; i++) {
    array[i] = str.charCodeAt(i);
  }
  return array;
};

var $bytesToString = function(slice) {
  if (slice.$length === 0) {
    return "";
  }
  var str = "";
  for (var i = 0; i < slice.$length; i += 10000) {
    str += String.fromCharCode.apply(undefined, slice.$array.subarray(slice.$offset + i, slice.$offset + Math.min(slice.$length, i + 10000)));
  }
  return str;
};

var $stringToRunes = function(str) {
  var array = new Int32Array(str.length);
  var rune, j = 0;
  for (var i = 0; i < str.length; i += rune[1], j++) {
    rune = $decodeRune(str, i);
    array[j] = rune[0];
  }
  return array.subarray(0, j);
};

var $runesToString = function(slice) {
  if (slice.$length === 0) {
    return "";
  }
  var str = "";
  for (var i = 0; i < slice.$length; i++) {
    str += $encodeRune(slice.$array[slice.$offset + i]);
  }
  return str;
};

var $copyString = function(dst, src) {
  var n = Math.min(src.length, dst.$length);
  for (var i = 0; i < n; i++) {
    dst.$array[dst.$offset + i] = src.charCodeAt(i);
  }
  return n;
};

var $copySlice = function(dst, src) {
  var n = Math.min(src.$length, dst.$length);
  $copyArray(dst.$array, src.$array, dst.$offset, src.$offset, n, dst.constructor.elem);
  return n;
};

var $copyArray = function(dst, src, dstOffset, srcOffset, n, elem) {
  if (n === 0 || (dst === src && dstOffset === srcOffset)) {
    return;
  }

  if (src.subarray) {
    dst.set(src.subarray(srcOffset, srcOffset + n), dstOffset);
    return;
  }

  switch (elem.kind) {
  case $kindArray:
  case $kindStruct:
    if (dst === src && dstOffset > srcOffset) {
      for (var i = n - 1; i >= 0; i--) {
        elem.copy(dst[dstOffset + i], src[srcOffset + i]);
      }
      return;
    }
    for (var i = 0; i < n; i++) {
      elem.copy(dst[dstOffset + i], src[srcOffset + i]);
    }
    return;
  }

  if (dst === src && dstOffset > srcOffset) {
    for (var i = n - 1; i >= 0; i--) {
      dst[dstOffset + i] = src[srcOffset + i];
    }
    return;
  }
  for (var i = 0; i < n; i++) {
    dst[dstOffset + i] = src[srcOffset + i];
  }
};

var $clone = function(src, type) {
  var clone = type.zero();
  type.copy(clone, src);
  return clone;
};

var $pointerOfStructConversion = function(obj, type) {
  if(obj.$proxies === undefined) {
    obj.$proxies = {};
    obj.$proxies[obj.constructor.string] = obj;
  }
  var proxy = obj.$proxies[type.string];
  if (proxy === undefined) {
    var properties = {};
    for (var i = 0; i < type.elem.fields.length; i++) {
      (function(fieldProp) {
        properties[fieldProp] = {
          get: function() { return obj[fieldProp]; },
          set: function(value) { obj[fieldProp] = value; }
        };
      })(type.elem.fields[i].prop);
    }
    proxy = Object.create(type.prototype, properties);
    proxy.$val = proxy;
    obj.$proxies[type.string] = proxy;
    proxy.$proxies = obj.$proxies;
  }
  return proxy;
};

var $append = function(slice) {
  return $internalAppend(slice, arguments, 1, arguments.length - 1);
};

var $appendSlice = function(slice, toAppend) {
  if (toAppend.constructor === String) {
    var bytes = $stringToBytes(toAppend);
    return $internalAppend(slice, bytes, 0, bytes.length);
  }
  return $internalAppend(slice, toAppend.$array, toAppend.$offset, toAppend.$length);
};

var $internalAppend = function(slice, array, offset, length) {
  if (length === 0) {
    return slice;
  }

  var newArray = slice.$array;
  var newOffset = slice.$offset;
  var newLength = slice.$length + length;
  var newCapacity = slice.$capacity;

  if (newLength > newCapacity) {
    newOffset = 0;
    newCapacity = Math.max(newLength, slice.$capacity < 1024 ? slice.$capacity * 2 : Math.floor(slice.$capacity * 5 / 4));

    if (slice.$array.constructor === Array) {
      newArray = slice.$array.slice(slice.$offset, slice.$offset + slice.$length);
      newArray.length = newCapacity;
      var zero = slice.constructor.elem.zero;
      for (var i = slice.$length; i < newCapacity; i++) {
        newArray[i] = zero();
      }
    } else {
      newArray = new slice.$array.constructor(newCapacity);
      newArray.set(slice.$array.subarray(slice.$offset, slice.$offset + slice.$length));
    }
  }

  $copyArray(newArray, array, newOffset + slice.$length, offset, length, slice.constructor.elem);

  var newSlice = new slice.constructor(newArray);
  newSlice.$offset = newOffset;
  newSlice.$length = newLength;
  newSlice.$capacity = newCapacity;
  return newSlice;
};

var $equal = function(a, b, type) {
  if (type === $jsObjectPtr) {
    return a === b;
  }
  switch (type.kind) {
  case $kindComplex64:
  case $kindComplex128:
    return a.$real === b.$real && a.$imag === b.$imag;
  case $kindInt64:
  case $kindUint64:
    return a.$high === b.$high && a.$low === b.$low;
  case $kindArray:
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!$equal(a[i], b[i], type.elem)) {
        return false;
      }
    }
    return true;
  case $kindStruct:
    for (var i = 0; i < type.fields.length; i++) {
      var f = type.fields[i];
      if (!$equal(a[f.prop], b[f.prop], f.typ)) {
        return false;
      }
    }
    return true;
  case $kindInterface:
    return $interfaceIsEqual(a, b);
  default:
    return a === b;
  }
};

var $interfaceIsEqual = function(a, b) {
  if (a === $ifaceNil || b === $ifaceNil) {
    return a === b;
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a.constructor === $jsObjectPtr) {
    return a.object === b.object;
  }
  if (!a.constructor.comparable) {
    $throwRuntimeError("comparing uncomparable type " + a.constructor.string);
  }
  return $equal(a.$val, b.$val, a.constructor);
};

var $min = Math.min;
var $mod = function(x, y) { return x % y; };
var $parseInt = parseInt;
var $parseFloat = function(f) {
  if (f !== undefined && f !== null && f.constructor === Number) {
    return f;
  }
  return parseFloat(f);
};

var $froundBuf = new Float32Array(1);
var $fround = Math.fround || function(f) {
  $froundBuf[0] = f;
  return $froundBuf[0];
};

var $imul = Math.imul || function(a, b) {
  var ah = (a >>> 16) & 0xffff;
  var al = a & 0xffff;
  var bh = (b >>> 16) & 0xffff;
  var bl = b & 0xffff;
  return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) >> 0);
};

var $floatKey = function(f) {
  if (f !== f) {
    $idCounter++;
    return "NaN$" + $idCounter;
  }
  return String(f);
};

var $flatten64 = function(x) {
  return x.$high * 4294967296 + x.$low;
};

var $shiftLeft64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high << y | x.$low >>> (32 - y), (x.$low << y) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(x.$low << (y - 32), 0);
  }
  return new x.constructor(0, 0);
};

var $shiftRightInt64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high >> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(x.$high >> 31, (x.$high >> (y - 32)) >>> 0);
  }
  if (x.$high < 0) {
    return new x.constructor(-1, 4294967295);
  }
  return new x.constructor(0, 0);
};

var $shiftRightUint64 = function(x, y) {
  if (y === 0) {
    return x;
  }
  if (y < 32) {
    return new x.constructor(x.$high >>> y, (x.$low >>> y | x.$high << (32 - y)) >>> 0);
  }
  if (y < 64) {
    return new x.constructor(0, x.$high >>> (y - 32));
  }
  return new x.constructor(0, 0);
};

var $mul64 = function(x, y) {
  var high = 0, low = 0;
  if ((y.$low & 1) !== 0) {
    high = x.$high;
    low = x.$low;
  }
  for (var i = 1; i < 32; i++) {
    if ((y.$low & 1<<i) !== 0) {
      high += x.$high << i | x.$low >>> (32 - i);
      low += (x.$low << i) >>> 0;
    }
  }
  for (var i = 0; i < 32; i++) {
    if ((y.$high & 1<<i) !== 0) {
      high += x.$low << i;
    }
  }
  return new x.constructor(high, low);
};

var $div64 = function(x, y, returnRemainder) {
  if (y.$high === 0 && y.$low === 0) {
    $throwRuntimeError("integer divide by zero");
  }

  var s = 1;
  var rs = 1;

  var xHigh = x.$high;
  var xLow = x.$low;
  if (xHigh < 0) {
    s = -1;
    rs = -1;
    xHigh = -xHigh;
    if (xLow !== 0) {
      xHigh--;
      xLow = 4294967296 - xLow;
    }
  }

  var yHigh = y.$high;
  var yLow = y.$low;
  if (y.$high < 0) {
    s *= -1;
    yHigh = -yHigh;
    if (yLow !== 0) {
      yHigh--;
      yLow = 4294967296 - yLow;
    }
  }

  var high = 0, low = 0, n = 0;
  while (yHigh < 2147483648 && ((xHigh > yHigh) || (xHigh === yHigh && xLow > yLow))) {
    yHigh = (yHigh << 1 | yLow >>> 31) >>> 0;
    yLow = (yLow << 1) >>> 0;
    n++;
  }
  for (var i = 0; i <= n; i++) {
    high = high << 1 | low >>> 31;
    low = (low << 1) >>> 0;
    if ((xHigh > yHigh) || (xHigh === yHigh && xLow >= yLow)) {
      xHigh = xHigh - yHigh;
      xLow = xLow - yLow;
      if (xLow < 0) {
        xHigh--;
        xLow += 4294967296;
      }
      low++;
      if (low === 4294967296) {
        high++;
        low = 0;
      }
    }
    yLow = (yLow >>> 1 | yHigh << (32 - 1)) >>> 0;
    yHigh = yHigh >>> 1;
  }

  if (returnRemainder) {
    return new x.constructor(xHigh * rs, xLow * rs);
  }
  return new x.constructor(high * s, low * s);
};

var $divComplex = function(n, d) {
  var ninf = n.$real === Infinity || n.$real === -Infinity || n.$imag === Infinity || n.$imag === -Infinity;
  var dinf = d.$real === Infinity || d.$real === -Infinity || d.$imag === Infinity || d.$imag === -Infinity;
  var nnan = !ninf && (n.$real !== n.$real || n.$imag !== n.$imag);
  var dnan = !dinf && (d.$real !== d.$real || d.$imag !== d.$imag);
  if(nnan || dnan) {
    return new n.constructor(NaN, NaN);
  }
  if (ninf && !dinf) {
    return new n.constructor(Infinity, Infinity);
  }
  if (!ninf && dinf) {
    return new n.constructor(0, 0);
  }
  if (d.$real === 0 && d.$imag === 0) {
    if (n.$real === 0 && n.$imag === 0) {
      return new n.constructor(NaN, NaN);
    }
    return new n.constructor(Infinity, Infinity);
  }
  var a = Math.abs(d.$real);
  var b = Math.abs(d.$imag);
  if (a <= b) {
    var ratio = d.$real / d.$imag;
    var denom = d.$real * ratio + d.$imag;
    return new n.constructor((n.$real * ratio + n.$imag) / denom, (n.$imag * ratio - n.$real) / denom);
  }
  var ratio = d.$imag / d.$real;
  var denom = d.$imag * ratio + d.$real;
  return new n.constructor((n.$imag * ratio + n.$real) / denom, (n.$imag - n.$real * ratio) / denom);
};

var $kindBool = 1;
var $kindInt = 2;
var $kindInt8 = 3;
var $kindInt16 = 4;
var $kindInt32 = 5;
var $kindInt64 = 6;
var $kindUint = 7;
var $kindUint8 = 8;
var $kindUint16 = 9;
var $kindUint32 = 10;
var $kindUint64 = 11;
var $kindUintptr = 12;
var $kindFloat32 = 13;
var $kindFloat64 = 14;
var $kindComplex64 = 15;
var $kindComplex128 = 16;
var $kindArray = 17;
var $kindChan = 18;
var $kindFunc = 19;
var $kindInterface = 20;
var $kindMap = 21;
var $kindPtr = 22;
var $kindSlice = 23;
var $kindString = 24;
var $kindStruct = 25;
var $kindUnsafePointer = 26;

var $methodSynthesizers = [];
var $addMethodSynthesizer = function(f) {
  if ($methodSynthesizers === null) {
    f();
    return;
  }
  $methodSynthesizers.push(f);
};
var $synthesizeMethods = function() {
  $methodSynthesizers.forEach(function(f) { f(); });
  $methodSynthesizers = null;
};

var $ifaceKeyFor = function(x) {
  if (x === $ifaceNil) {
    return 'nil';
  }
  var c = x.constructor;
  return c.string + '$' + c.keyFor(x.$val);
};

var $identity = function(x) { return x; };

var $typeIDCounter = 0;

var $idKey = function(x) {
  if (x.$id === undefined) {
    $idCounter++;
    x.$id = $idCounter;
  }
  return String(x.$id);
};

var $newType = function(size, kind, string, named, pkg, exported, constructor) {
  var typ;
  switch(kind) {
  case $kindBool:
  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8:
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindUnsafePointer:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = $identity;
    break;

  case $kindString:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = function(x) { return "$" + x; };
    break;

  case $kindFloat32:
  case $kindFloat64:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = function(x) { return $floatKey(x); };
    break;

  case $kindInt64:
    typ = function(high, low) {
      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >> 0;
      this.$low = low >>> 0;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$high + "$" + x.$low; };
    break;

  case $kindUint64:
    typ = function(high, low) {
      this.$high = (high + Math.floor(Math.ceil(low) / 4294967296)) >>> 0;
      this.$low = low >>> 0;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$high + "$" + x.$low; };
    break;

  case $kindComplex64:
    typ = function(real, imag) {
      this.$real = $fround(real);
      this.$imag = $fround(imag);
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$real + "$" + x.$imag; };
    break;

  case $kindComplex128:
    typ = function(real, imag) {
      this.$real = real;
      this.$imag = imag;
      this.$val = this;
    };
    typ.keyFor = function(x) { return x.$real + "$" + x.$imag; };
    break;

  case $kindArray:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.ptr = $newType(4, $kindPtr, "*" + string, false, "", false, function(array) {
      this.$get = function() { return array; };
      this.$set = function(v) { typ.copy(this, v); };
      this.$val = array;
    });
    typ.init = function(elem, len) {
      typ.elem = elem;
      typ.len = len;
      typ.comparable = elem.comparable;
      typ.keyFor = function(x) {
        return Array.prototype.join.call($mapArray(x, function(e) {
          return String(elem.keyFor(e)).replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
        }), "$");
      };
      typ.copy = function(dst, src) {
        $copyArray(dst, src, 0, 0, src.length, elem);
      };
      typ.ptr.init(typ);
      Object.defineProperty(typ.ptr.nil, "nilCheck", { get: $throwNilPointerError });
    };
    break;

  case $kindChan:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.keyFor = $idKey;
    typ.init = function(elem, sendOnly, recvOnly) {
      typ.elem = elem;
      typ.sendOnly = sendOnly;
      typ.recvOnly = recvOnly;
    };
    break;

  case $kindFunc:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.init = function(params, results, variadic) {
      typ.params = params;
      typ.results = results;
      typ.variadic = variadic;
      typ.comparable = false;
    };
    break;

  case $kindInterface:
    typ = { implementedBy: {}, missingMethodFor: {} };
    typ.keyFor = $ifaceKeyFor;
    typ.init = function(methods) {
      typ.methods = methods;
      methods.forEach(function(m) {
        $ifaceNil[m.prop] = $throwNilPointerError;
      });
    };
    break;

  case $kindMap:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.init = function(key, elem) {
      typ.key = key;
      typ.elem = elem;
      typ.comparable = false;
    };
    break;

  case $kindPtr:
    typ = constructor || function(getter, setter, target) {
      this.$get = getter;
      this.$set = setter;
      this.$target = target;
      this.$val = this;
    };
    typ.keyFor = $idKey;
    typ.init = function(elem) {
      typ.elem = elem;
      typ.wrapped = (elem.kind === $kindArray);
      typ.nil = new typ($throwNilPointerError, $throwNilPointerError);
    };
    break;

  case $kindSlice:
    typ = function(array) {
      if (array.constructor !== typ.nativeArray) {
        array = new typ.nativeArray(array);
      }
      this.$array = array;
      this.$offset = 0;
      this.$length = array.length;
      this.$capacity = array.length;
      this.$val = this;
    };
    typ.init = function(elem) {
      typ.elem = elem;
      typ.comparable = false;
      typ.nativeArray = $nativeArray(elem.kind);
      typ.nil = new typ([]);
    };
    break;

  case $kindStruct:
    typ = function(v) { this.$val = v; };
    typ.wrapped = true;
    typ.ptr = $newType(4, $kindPtr, "*" + string, false, pkg, exported, constructor);
    typ.ptr.elem = typ;
    typ.ptr.prototype.$get = function() { return this; };
    typ.ptr.prototype.$set = function(v) { typ.copy(this, v); };
    typ.init = function(pkgPath, fields) {
      typ.pkgPath = pkgPath;
      typ.fields = fields;
      fields.forEach(function(f) {
        if (!f.typ.comparable) {
          typ.comparable = false;
        }
      });
      typ.keyFor = function(x) {
        var val = x.$val;
        return $mapArray(fields, function(f) {
          return String(f.typ.keyFor(val[f.prop])).replace(/\\/g, "\\\\").replace(/\$/g, "\\$");
        }).join("$");
      };
      typ.copy = function(dst, src) {
        for (var i = 0; i < fields.length; i++) {
          var f = fields[i];
          switch (f.typ.kind) {
          case $kindArray:
          case $kindStruct:
            f.typ.copy(dst[f.prop], src[f.prop]);
            continue;
          default:
            dst[f.prop] = src[f.prop];
            continue;
          }
        }
      };
      /* nil value */
      var properties = {};
      fields.forEach(function(f) {
        properties[f.prop] = { get: $throwNilPointerError, set: $throwNilPointerError };
      });
      typ.ptr.nil = Object.create(constructor.prototype, properties);
      typ.ptr.nil.$val = typ.ptr.nil;
      /* methods for embedded fields */
      $addMethodSynthesizer(function() {
        var synthesizeMethod = function(target, m, f) {
          if (target.prototype[m.prop] !== undefined) { return; }
          target.prototype[m.prop] = function() {
            var v = this.$val[f.prop];
            if (f.typ === $jsObjectPtr) {
              v = new $jsObjectPtr(v);
            }
            if (v.$val === undefined) {
              v = new f.typ(v);
            }
            return v[m.prop].apply(v, arguments);
          };
        };
        fields.forEach(function(f) {
          if (f.embedded) {
            $methodSet(f.typ).forEach(function(m) {
              synthesizeMethod(typ, m, f);
              synthesizeMethod(typ.ptr, m, f);
            });
            $methodSet($ptrType(f.typ)).forEach(function(m) {
              synthesizeMethod(typ.ptr, m, f);
            });
          }
        });
      });
    };
    break;

  default:
    $panic(new $String("invalid kind: " + kind));
  }

  switch (kind) {
  case $kindBool:
  case $kindMap:
    typ.zero = function() { return false; };
    break;

  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8 :
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindUnsafePointer:
  case $kindFloat32:
  case $kindFloat64:
    typ.zero = function() { return 0; };
    break;

  case $kindString:
    typ.zero = function() { return ""; };
    break;

  case $kindInt64:
  case $kindUint64:
  case $kindComplex64:
  case $kindComplex128:
    var zero = new typ(0, 0);
    typ.zero = function() { return zero; };
    break;

  case $kindPtr:
  case $kindSlice:
    typ.zero = function() { return typ.nil; };
    break;

  case $kindChan:
    typ.zero = function() { return $chanNil; };
    break;

  case $kindFunc:
    typ.zero = function() { return $throwNilPointerError; };
    break;

  case $kindInterface:
    typ.zero = function() { return $ifaceNil; };
    break;

  case $kindArray:
    typ.zero = function() {
      var arrayClass = $nativeArray(typ.elem.kind);
      if (arrayClass !== Array) {
        return new arrayClass(typ.len);
      }
      var array = new Array(typ.len);
      for (var i = 0; i < typ.len; i++) {
        array[i] = typ.elem.zero();
      }
      return array;
    };
    break;

  case $kindStruct:
    typ.zero = function() { return new typ.ptr(); };
    break;

  default:
    $panic(new $String("invalid kind: " + kind));
  }

  typ.id = $typeIDCounter;
  $typeIDCounter++;
  typ.size = size;
  typ.kind = kind;
  typ.string = string;
  typ.named = named;
  typ.pkg = pkg;
  typ.exported = exported;
  typ.methods = [];
  typ.methodSetCache = null;
  typ.comparable = true;
  return typ;
};

var $methodSet = function(typ) {
  if (typ.methodSetCache !== null) {
    return typ.methodSetCache;
  }
  var base = {};

  var isPtr = (typ.kind === $kindPtr);
  if (isPtr && typ.elem.kind === $kindInterface) {
    typ.methodSetCache = [];
    return [];
  }

  var current = [{typ: isPtr ? typ.elem : typ, indirect: isPtr}];

  var seen = {};

  while (current.length > 0) {
    var next = [];
    var mset = [];

    current.forEach(function(e) {
      if (seen[e.typ.string]) {
        return;
      }
      seen[e.typ.string] = true;

      if (e.typ.named) {
        mset = mset.concat(e.typ.methods);
        if (e.indirect) {
          mset = mset.concat($ptrType(e.typ).methods);
        }
      }

      switch (e.typ.kind) {
      case $kindStruct:
        e.typ.fields.forEach(function(f) {
          if (f.embedded) {
            var fTyp = f.typ;
            var fIsPtr = (fTyp.kind === $kindPtr);
            next.push({typ: fIsPtr ? fTyp.elem : fTyp, indirect: e.indirect || fIsPtr});
          }
        });
        break;

      case $kindInterface:
        mset = mset.concat(e.typ.methods);
        break;
      }
    });

    mset.forEach(function(m) {
      if (base[m.name] === undefined) {
        base[m.name] = m;
      }
    });

    current = next;
  }

  typ.methodSetCache = [];
  Object.keys(base).sort().forEach(function(name) {
    typ.methodSetCache.push(base[name]);
  });
  return typ.methodSetCache;
};

var $Bool          = $newType( 1, $kindBool,          "bool",           true, "", false, null);
var $Int           = $newType( 4, $kindInt,           "int",            true, "", false, null);
var $Int8          = $newType( 1, $kindInt8,          "int8",           true, "", false, null);
var $Int16         = $newType( 2, $kindInt16,         "int16",          true, "", false, null);
var $Int32         = $newType( 4, $kindInt32,         "int32",          true, "", false, null);
var $Int64         = $newType( 8, $kindInt64,         "int64",          true, "", false, null);
var $Uint          = $newType( 4, $kindUint,          "uint",           true, "", false, null);
var $Uint8         = $newType( 1, $kindUint8,         "uint8",          true, "", false, null);
var $Uint16        = $newType( 2, $kindUint16,        "uint16",         true, "", false, null);
var $Uint32        = $newType( 4, $kindUint32,        "uint32",         true, "", false, null);
var $Uint64        = $newType( 8, $kindUint64,        "uint64",         true, "", false, null);
var $Uintptr       = $newType( 4, $kindUintptr,       "uintptr",        true, "", false, null);
var $Float32       = $newType( 4, $kindFloat32,       "float32",        true, "", false, null);
var $Float64       = $newType( 8, $kindFloat64,       "float64",        true, "", false, null);
var $Complex64     = $newType( 8, $kindComplex64,     "complex64",      true, "", false, null);
var $Complex128    = $newType(16, $kindComplex128,    "complex128",     true, "", false, null);
var $String        = $newType( 8, $kindString,        "string",         true, "", false, null);
var $UnsafePointer = $newType( 4, $kindUnsafePointer, "unsafe.Pointer", true, "", false, null);

var $nativeArray = function(elemKind) {
  switch (elemKind) {
  case $kindInt:
    return Int32Array;
  case $kindInt8:
    return Int8Array;
  case $kindInt16:
    return Int16Array;
  case $kindInt32:
    return Int32Array;
  case $kindUint:
    return Uint32Array;
  case $kindUint8:
    return Uint8Array;
  case $kindUint16:
    return Uint16Array;
  case $kindUint32:
    return Uint32Array;
  case $kindUintptr:
    return Uint32Array;
  case $kindFloat32:
    return Float32Array;
  case $kindFloat64:
    return Float64Array;
  default:
    return Array;
  }
};
var $toNativeArray = function(elemKind, array) {
  var nativeArray = $nativeArray(elemKind);
  if (nativeArray === Array) {
    return array;
  }
  return new nativeArray(array);
};
var $arrayTypes = {};
var $arrayType = function(elem, len) {
  var typeKey = elem.id + "$" + len;
  var typ = $arrayTypes[typeKey];
  if (typ === undefined) {
    typ = $newType(12, $kindArray, "[" + len + "]" + elem.string, false, "", false, null);
    $arrayTypes[typeKey] = typ;
    typ.init(elem, len);
  }
  return typ;
};

var $chanType = function(elem, sendOnly, recvOnly) {
  var string = (recvOnly ? "<-" : "") + "chan" + (sendOnly ? "<- " : " ") + elem.string;
  var field = sendOnly ? "SendChan" : (recvOnly ? "RecvChan" : "Chan");
  var typ = elem[field];
  if (typ === undefined) {
    typ = $newType(4, $kindChan, string, false, "", false, null);
    elem[field] = typ;
    typ.init(elem, sendOnly, recvOnly);
  }
  return typ;
};
var $Chan = function(elem, capacity) {
  if (capacity < 0 || capacity > 2147483647) {
    $throwRuntimeError("makechan: size out of range");
  }
  this.$elem = elem;
  this.$capacity = capacity;
  this.$buffer = [];
  this.$sendQueue = [];
  this.$recvQueue = [];
  this.$closed = false;
};
var $chanNil = new $Chan(null, 0);
$chanNil.$sendQueue = $chanNil.$recvQueue = { length: 0, push: function() {}, shift: function() { return undefined; }, indexOf: function() { return -1; } };

var $funcTypes = {};
var $funcType = function(params, results, variadic) {
  var typeKey = $mapArray(params, function(p) { return p.id; }).join(",") + "$" + $mapArray(results, function(r) { return r.id; }).join(",") + "$" + variadic;
  var typ = $funcTypes[typeKey];
  if (typ === undefined) {
    var paramTypes = $mapArray(params, function(p) { return p.string; });
    if (variadic) {
      paramTypes[paramTypes.length - 1] = "..." + paramTypes[paramTypes.length - 1].substr(2);
    }
    var string = "func(" + paramTypes.join(", ") + ")";
    if (results.length === 1) {
      string += " " + results[0].string;
    } else if (results.length > 1) {
      string += " (" + $mapArray(results, function(r) { return r.string; }).join(", ") + ")";
    }
    typ = $newType(4, $kindFunc, string, false, "", false, null);
    $funcTypes[typeKey] = typ;
    typ.init(params, results, variadic);
  }
  return typ;
};

var $interfaceTypes = {};
var $interfaceType = function(methods) {
  var typeKey = $mapArray(methods, function(m) { return m.pkg + "," + m.name + "," + m.typ.id; }).join("$");
  var typ = $interfaceTypes[typeKey];
  if (typ === undefined) {
    var string = "interface {}";
    if (methods.length !== 0) {
      string = "interface { " + $mapArray(methods, function(m) {
        return (m.pkg !== "" ? m.pkg + "." : "") + m.name + m.typ.string.substr(4);
      }).join("; ") + " }";
    }
    typ = $newType(8, $kindInterface, string, false, "", false, null);
    $interfaceTypes[typeKey] = typ;
    typ.init(methods);
  }
  return typ;
};
var $emptyInterface = $interfaceType([]);
var $ifaceNil = {};
var $error = $newType(8, $kindInterface, "error", true, "", false, null);
$error.init([{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}]);

var $mapTypes = {};
var $mapType = function(key, elem) {
  var typeKey = key.id + "$" + elem.id;
  var typ = $mapTypes[typeKey];
  if (typ === undefined) {
    typ = $newType(4, $kindMap, "map[" + key.string + "]" + elem.string, false, "", false, null);
    $mapTypes[typeKey] = typ;
    typ.init(key, elem);
  }
  return typ;
};
var $makeMap = function(keyForFunc, entries) {
  var m = {};
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    m[keyForFunc(e.k)] = e;
  }
  return m;
};

var $ptrType = function(elem) {
  var typ = elem.ptr;
  if (typ === undefined) {
    typ = $newType(4, $kindPtr, "*" + elem.string, false, "", elem.exported, null);
    elem.ptr = typ;
    typ.init(elem);
  }
  return typ;
};

var $newDataPointer = function(data, constructor) {
  if (constructor.elem.kind === $kindStruct) {
    return data;
  }
  return new constructor(function() { return data; }, function(v) { data = v; });
};

var $indexPtr = function(array, index, constructor) {
  array.$ptr = array.$ptr || {};
  return array.$ptr[index] || (array.$ptr[index] = new constructor(function() { return array[index]; }, function(v) { array[index] = v; }));
};

var $sliceType = function(elem) {
  var typ = elem.slice;
  if (typ === undefined) {
    typ = $newType(12, $kindSlice, "[]" + elem.string, false, "", false, null);
    elem.slice = typ;
    typ.init(elem);
  }
  return typ;
};
var $makeSlice = function(typ, length, capacity) {
  capacity = capacity || length;
  if (length < 0 || length > 2147483647) {
    $throwRuntimeError("makeslice: len out of range");
  }
  if (capacity < 0 || capacity < length || capacity > 2147483647) {
    $throwRuntimeError("makeslice: cap out of range");
  }
  var array = new typ.nativeArray(capacity);
  if (typ.nativeArray === Array) {
    for (var i = 0; i < capacity; i++) {
      array[i] = typ.elem.zero();
    }
  }
  var slice = new typ(array);
  slice.$length = length;
  return slice;
};

var $structTypes = {};
var $structType = function(pkgPath, fields) {
  var typeKey = $mapArray(fields, function(f) { return f.name + "," + f.typ.id + "," + f.tag; }).join("$");
  var typ = $structTypes[typeKey];
  if (typ === undefined) {
    var string = "struct { " + $mapArray(fields, function(f) {
      return f.name + " " + f.typ.string + (f.tag !== "" ? (" \"" + f.tag.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"") : "");
    }).join("; ") + " }";
    if (fields.length === 0) {
      string = "struct {}";
    }
    typ = $newType(0, $kindStruct, string, false, "", false, function() {
      this.$val = this;
      for (var i = 0; i < fields.length; i++) {
        var f = fields[i];
        var arg = arguments[i];
        this[f.prop] = arg !== undefined ? arg : f.typ.zero();
      }
    });
    $structTypes[typeKey] = typ;
    typ.init(pkgPath, fields);
  }
  return typ;
};

var $assertType = function(value, type, returnTuple) {
  var isInterface = (type.kind === $kindInterface), ok, missingMethod = "";
  if (value === $ifaceNil) {
    ok = false;
  } else if (!isInterface) {
    ok = value.constructor === type;
  } else {
    var valueTypeString = value.constructor.string;
    ok = type.implementedBy[valueTypeString];
    if (ok === undefined) {
      ok = true;
      var valueMethodSet = $methodSet(value.constructor);
      var interfaceMethods = type.methods;
      for (var i = 0; i < interfaceMethods.length; i++) {
        var tm = interfaceMethods[i];
        var found = false;
        for (var j = 0; j < valueMethodSet.length; j++) {
          var vm = valueMethodSet[j];
          if (vm.name === tm.name && vm.pkg === tm.pkg && vm.typ === tm.typ) {
            found = true;
            break;
          }
        }
        if (!found) {
          ok = false;
          type.missingMethodFor[valueTypeString] = tm.name;
          break;
        }
      }
      type.implementedBy[valueTypeString] = ok;
    }
    if (!ok) {
      missingMethod = type.missingMethodFor[valueTypeString];
    }
  }

  if (!ok) {
    if (returnTuple) {
      return [type.zero(), false];
    }
    $panic(new $packages["runtime"].TypeAssertionError.ptr(
      $packages["runtime"]._type.ptr.nil,
      (value === $ifaceNil ? $packages["runtime"]._type.ptr.nil : new $packages["runtime"]._type.ptr(value.constructor.string)),
      new $packages["runtime"]._type.ptr(type.string),
      missingMethod));
  }

  if (!isInterface) {
    value = value.$val;
  }
  if (type === $jsObjectPtr) {
    value = value.object;
  }
  return returnTuple ? [value, true] : value;
};

var $stackDepthOffset = 0;
var $getStackDepth = function() {
  var err = new Error();
  if (err.stack === undefined) {
    return undefined;
  }
  return $stackDepthOffset + err.stack.split("\n").length;
};

var $panicStackDepth = null, $panicValue;
var $callDeferred = function(deferred, jsErr, fromPanic) {
  if (!fromPanic && deferred !== null && deferred.index >= $curGoroutine.deferStack.length) {
    throw jsErr;
  }
  if (jsErr !== null) {
    var newErr = null;
    try {
      $curGoroutine.deferStack.push(deferred);
      $panic(new $jsErrorPtr(jsErr));
    } catch (err) {
      newErr = err;
    }
    $curGoroutine.deferStack.pop();
    $callDeferred(deferred, newErr);
    return;
  }
  if ($curGoroutine.asleep) {
    return;
  }

  $stackDepthOffset--;
  var outerPanicStackDepth = $panicStackDepth;
  var outerPanicValue = $panicValue;

  var localPanicValue = $curGoroutine.panicStack.pop();
  if (localPanicValue !== undefined) {
    $panicStackDepth = $getStackDepth();
    $panicValue = localPanicValue;
  }

  try {
    while (true) {
      if (deferred === null) {
        deferred = $curGoroutine.deferStack[$curGoroutine.deferStack.length - 1];
        if (deferred === undefined) {
          /* The panic reached the top of the stack. Clear it and throw it as a JavaScript error. */
          $panicStackDepth = null;
          if (localPanicValue.Object instanceof Error) {
            throw localPanicValue.Object;
          }
          var msg;
          if (localPanicValue.constructor === $String) {
            msg = localPanicValue.$val;
          } else if (localPanicValue.Error !== undefined) {
            msg = localPanicValue.Error();
          } else if (localPanicValue.String !== undefined) {
            msg = localPanicValue.String();
          } else {
            msg = localPanicValue;
          }
          throw new Error(msg);
        }
      }
      var call = deferred.pop();
      if (call === undefined) {
        $curGoroutine.deferStack.pop();
        if (localPanicValue !== undefined) {
          deferred = null;
          continue;
        }
        return;
      }
      var r = call[0].apply(call[2], call[1]);
      if (r && r.$blk !== undefined) {
        deferred.push([r.$blk, [], r]);
        if (fromPanic) {
          throw null;
        }
        return;
      }

      if (localPanicValue !== undefined && $panicStackDepth === null) {
        throw null; /* error was recovered */
      }
    }
  } finally {
    if (localPanicValue !== undefined) {
      if ($panicStackDepth !== null) {
        $curGoroutine.panicStack.push(localPanicValue);
      }
      $panicStackDepth = outerPanicStackDepth;
      $panicValue = outerPanicValue;
    }
    $stackDepthOffset++;
  }
};

var $panic = function(value) {
  $curGoroutine.panicStack.push(value);
  $callDeferred(null, null, true);
};
var $recover = function() {
  if ($panicStackDepth === null || ($panicStackDepth !== undefined && $panicStackDepth !== $getStackDepth() - 2)) {
    return $ifaceNil;
  }
  $panicStackDepth = null;
  return $panicValue;
};
var $throw = function(err) { throw err; };

var $noGoroutine = { asleep: false, exit: false, deferStack: [], panicStack: [] };
var $curGoroutine = $noGoroutine, $totalGoroutines = 0, $awakeGoroutines = 0, $checkForDeadlock = true;
var $mainFinished = false;
var $go = function(fun, args) {
  $totalGoroutines++;
  $awakeGoroutines++;
  var $goroutine = function() {
    try {
      $curGoroutine = $goroutine;
      var r = fun.apply(undefined, args);
      if (r && r.$blk !== undefined) {
        fun = function() { return r.$blk(); };
        args = [];
        return;
      }
      $goroutine.exit = true;
    } catch (err) {
      if (!$goroutine.exit) {
        throw err;
      }
    } finally {
      $curGoroutine = $noGoroutine;
      if ($goroutine.exit) { /* also set by runtime.Goexit() */
        $totalGoroutines--;
        $goroutine.asleep = true;
      }
      if ($goroutine.asleep) {
        $awakeGoroutines--;
        if (!$mainFinished && $awakeGoroutines === 0 && $checkForDeadlock) {
          console.error("fatal error: all goroutines are asleep - deadlock!");
          if ($global.process !== undefined) {
            $global.process.exit(2);
          }
        }
      }
    }
  };
  $goroutine.asleep = false;
  $goroutine.exit = false;
  $goroutine.deferStack = [];
  $goroutine.panicStack = [];
  $schedule($goroutine);
};

var $scheduled = [];
var $runScheduled = function() {
  try {
    var r;
    while ((r = $scheduled.shift()) !== undefined) {
      r();
    }
  } finally {
    if ($scheduled.length > 0) {
      setTimeout($runScheduled, 0);
    }
  }
};

var $schedule = function(goroutine) {
  if (goroutine.asleep) {
    goroutine.asleep = false;
    $awakeGoroutines++;
  }
  $scheduled.push(goroutine);
  if ($curGoroutine === $noGoroutine) {
    $runScheduled();
  }
};

var $setTimeout = function(f, t) {
  $awakeGoroutines++;
  return setTimeout(function() {
    $awakeGoroutines--;
    f();
  }, t);
};

var $block = function() {
  if ($curGoroutine === $noGoroutine) {
    $throwRuntimeError("cannot block in JavaScript callback, fix by wrapping code in goroutine");
  }
  $curGoroutine.asleep = true;
};

var $send = function(chan, value) {
  if (chan.$closed) {
    $throwRuntimeError("send on closed channel");
  }
  var queuedRecv = chan.$recvQueue.shift();
  if (queuedRecv !== undefined) {
    queuedRecv([value, true]);
    return;
  }
  if (chan.$buffer.length < chan.$capacity) {
    chan.$buffer.push(value);
    return;
  }

  var thisGoroutine = $curGoroutine;
  var closedDuringSend;
  chan.$sendQueue.push(function(closed) {
    closedDuringSend = closed;
    $schedule(thisGoroutine);
    return value;
  });
  $block();
  return {
    $blk: function() {
      if (closedDuringSend) {
        $throwRuntimeError("send on closed channel");
      }
    }
  };
};
var $recv = function(chan) {
  var queuedSend = chan.$sendQueue.shift();
  if (queuedSend !== undefined) {
    chan.$buffer.push(queuedSend(false));
  }
  var bufferedValue = chan.$buffer.shift();
  if (bufferedValue !== undefined) {
    return [bufferedValue, true];
  }
  if (chan.$closed) {
    return [chan.$elem.zero(), false];
  }

  var thisGoroutine = $curGoroutine;
  var f = { $blk: function() { return this.value; } };
  var queueEntry = function(v) {
    f.value = v;
    $schedule(thisGoroutine);
  };
  chan.$recvQueue.push(queueEntry);
  $block();
  return f;
};
var $close = function(chan) {
  if (chan.$closed) {
    $throwRuntimeError("close of closed channel");
  }
  chan.$closed = true;
  while (true) {
    var queuedSend = chan.$sendQueue.shift();
    if (queuedSend === undefined) {
      break;
    }
    queuedSend(true); /* will panic */
  }
  while (true) {
    var queuedRecv = chan.$recvQueue.shift();
    if (queuedRecv === undefined) {
      break;
    }
    queuedRecv([chan.$elem.zero(), false]);
  }
};
var $select = function(comms) {
  var ready = [];
  var selection = -1;
  for (var i = 0; i < comms.length; i++) {
    var comm = comms[i];
    var chan = comm[0];
    switch (comm.length) {
    case 0: /* default */
      selection = i;
      break;
    case 1: /* recv */
      if (chan.$sendQueue.length !== 0 || chan.$buffer.length !== 0 || chan.$closed) {
        ready.push(i);
      }
      break;
    case 2: /* send */
      if (chan.$closed) {
        $throwRuntimeError("send on closed channel");
      }
      if (chan.$recvQueue.length !== 0 || chan.$buffer.length < chan.$capacity) {
        ready.push(i);
      }
      break;
    }
  }

  if (ready.length !== 0) {
    selection = ready[Math.floor(Math.random() * ready.length)];
  }
  if (selection !== -1) {
    var comm = comms[selection];
    switch (comm.length) {
    case 0: /* default */
      return [selection];
    case 1: /* recv */
      return [selection, $recv(comm[0])];
    case 2: /* send */
      $send(comm[0], comm[1]);
      return [selection];
    }
  }

  var entries = [];
  var thisGoroutine = $curGoroutine;
  var f = { $blk: function() { return this.selection; } };
  var removeFromQueues = function() {
    for (var i = 0; i < entries.length; i++) {
      var entry = entries[i];
      var queue = entry[0];
      var index = queue.indexOf(entry[1]);
      if (index !== -1) {
        queue.splice(index, 1);
      }
    }
  };
  for (var i = 0; i < comms.length; i++) {
    (function(i) {
      var comm = comms[i];
      switch (comm.length) {
      case 1: /* recv */
        var queueEntry = function(value) {
          f.selection = [i, value];
          removeFromQueues();
          $schedule(thisGoroutine);
        };
        entries.push([comm[0].$recvQueue, queueEntry]);
        comm[0].$recvQueue.push(queueEntry);
        break;
      case 2: /* send */
        var queueEntry = function() {
          if (comm[0].$closed) {
            $throwRuntimeError("send on closed channel");
          }
          f.selection = [i];
          removeFromQueues();
          $schedule(thisGoroutine);
          return comm[1];
        };
        entries.push([comm[0].$sendQueue, queueEntry]);
        comm[0].$sendQueue.push(queueEntry);
        break;
      }
    })(i);
  }
  $block();
  return f;
};

var $jsObjectPtr, $jsErrorPtr;

var $needsExternalization = function(t) {
  switch (t.kind) {
    case $kindBool:
    case $kindInt:
    case $kindInt8:
    case $kindInt16:
    case $kindInt32:
    case $kindUint:
    case $kindUint8:
    case $kindUint16:
    case $kindUint32:
    case $kindUintptr:
    case $kindFloat32:
    case $kindFloat64:
      return false;
    default:
      return t !== $jsObjectPtr;
  }
};

var $externalize = function(v, t) {
  if (t === $jsObjectPtr) {
    return v;
  }
  switch (t.kind) {
  case $kindBool:
  case $kindInt:
  case $kindInt8:
  case $kindInt16:
  case $kindInt32:
  case $kindUint:
  case $kindUint8:
  case $kindUint16:
  case $kindUint32:
  case $kindUintptr:
  case $kindFloat32:
  case $kindFloat64:
    return v;
  case $kindInt64:
  case $kindUint64:
    return $flatten64(v);
  case $kindArray:
    if ($needsExternalization(t.elem)) {
      return $mapArray(v, function(e) { return $externalize(e, t.elem); });
    }
    return v;
  case $kindFunc:
    return $externalizeFunction(v, t, false);
  case $kindInterface:
    if (v === $ifaceNil) {
      return null;
    }
    if (v.constructor === $jsObjectPtr) {
      return v.$val.object;
    }
    return $externalize(v.$val, v.constructor);
  case $kindMap:
    var m = {};
    var keys = $keys(v);
    for (var i = 0; i < keys.length; i++) {
      var entry = v[keys[i]];
      m[$externalize(entry.k, t.key)] = $externalize(entry.v, t.elem);
    }
    return m;
  case $kindPtr:
    if (v === t.nil) {
      return null;
    }
    return $externalize(v.$get(), t.elem);
  case $kindSlice:
    if ($needsExternalization(t.elem)) {
      return $mapArray($sliceToArray(v), function(e) { return $externalize(e, t.elem); });
    }
    return $sliceToArray(v);
  case $kindString:
    if ($isASCII(v)) {
      return v;
    }
    var s = "", r;
    for (var i = 0; i < v.length; i += r[1]) {
      r = $decodeRune(v, i);
      var c = r[0];
      if (c > 0xFFFF) {
        var h = Math.floor((c - 0x10000) / 0x400) + 0xD800;
        var l = (c - 0x10000) % 0x400 + 0xDC00;
        s += String.fromCharCode(h, l);
        continue;
      }
      s += String.fromCharCode(c);
    }
    return s;
  case $kindStruct:
    var timePkg = $packages["time"];
    if (timePkg !== undefined && v.constructor === timePkg.Time.ptr) {
      var milli = $div64(v.UnixNano(), new $Int64(0, 1000000));
      return new Date($flatten64(milli));
    }

    var noJsObject = {};
    var searchJsObject = function(v, t) {
      if (t === $jsObjectPtr) {
        return v;
      }
      switch (t.kind) {
      case $kindPtr:
        if (v === t.nil) {
          return noJsObject;
        }
        return searchJsObject(v.$get(), t.elem);
      case $kindStruct:
        var f = t.fields[0];
        return searchJsObject(v[f.prop], f.typ);
      case $kindInterface:
        return searchJsObject(v.$val, v.constructor);
      default:
        return noJsObject;
      }
    };
    var o = searchJsObject(v, t);
    if (o !== noJsObject) {
      return o;
    }

    o = {};
    for (var i = 0; i < t.fields.length; i++) {
      var f = t.fields[i];
      if (!f.exported) {
        continue;
      }
      o[f.name] = $externalize(v[f.prop], f.typ);
    }
    return o;
  }
  $throwRuntimeError("cannot externalize " + t.string);
};

var $externalizeFunction = function(v, t, passThis) {
  if (v === $throwNilPointerError) {
    return null;
  }
  if (v.$externalizeWrapper === undefined) {
    $checkForDeadlock = false;
    v.$externalizeWrapper = function() {
      var args = [];
      for (var i = 0; i < t.params.length; i++) {
        if (t.variadic && i === t.params.length - 1) {
          var vt = t.params[i].elem, varargs = [];
          for (var j = i; j < arguments.length; j++) {
            varargs.push($internalize(arguments[j], vt));
          }
          args.push(new (t.params[i])(varargs));
          break;
        }
        args.push($internalize(arguments[i], t.params[i]));
      }
      var result = v.apply(passThis ? this : undefined, args);
      switch (t.results.length) {
      case 0:
        return;
      case 1:
        return $externalize(result, t.results[0]);
      default:
        for (var i = 0; i < t.results.length; i++) {
          result[i] = $externalize(result[i], t.results[i]);
        }
        return result;
      }
    };
  }
  return v.$externalizeWrapper;
};

var $internalize = function(v, t, recv) {
  if (t === $jsObjectPtr) {
    return v;
  }
  if (t === $jsObjectPtr.elem) {
    $throwRuntimeError("cannot internalize js.Object, use *js.Object instead");
  }
  if (v && v.__internal_object__ !== undefined) {
    return $assertType(v.__internal_object__, t, false);
  }
  var timePkg = $packages["time"];
  if (timePkg !== undefined && t === timePkg.Time) {
    if (!(v !== null && v !== undefined && v.constructor === Date)) {
      $throwRuntimeError("cannot internalize time.Time from " + typeof v + ", must be Date");
    }
    return timePkg.Unix(new $Int64(0, 0), new $Int64(0, v.getTime() * 1000000));
  }
  switch (t.kind) {
  case $kindBool:
    return !!v;
  case $kindInt:
    return parseInt(v);
  case $kindInt8:
    return parseInt(v) << 24 >> 24;
  case $kindInt16:
    return parseInt(v) << 16 >> 16;
  case $kindInt32:
    return parseInt(v) >> 0;
  case $kindUint:
    return parseInt(v);
  case $kindUint8:
    return parseInt(v) << 24 >>> 24;
  case $kindUint16:
    return parseInt(v) << 16 >>> 16;
  case $kindUint32:
  case $kindUintptr:
    return parseInt(v) >>> 0;
  case $kindInt64:
  case $kindUint64:
    return new t(0, v);
  case $kindFloat32:
  case $kindFloat64:
    return parseFloat(v);
  case $kindArray:
    if (v.length !== t.len) {
      $throwRuntimeError("got array with wrong size from JavaScript native");
    }
    return $mapArray(v, function(e) { return $internalize(e, t.elem); });
  case $kindFunc:
    return function() {
      var args = [];
      for (var i = 0; i < t.params.length; i++) {
        if (t.variadic && i === t.params.length - 1) {
          var vt = t.params[i].elem, varargs = arguments[i];
          for (var j = 0; j < varargs.$length; j++) {
            args.push($externalize(varargs.$array[varargs.$offset + j], vt));
          }
          break;
        }
        args.push($externalize(arguments[i], t.params[i]));
      }
      var result = v.apply(recv, args);
      switch (t.results.length) {
      case 0:
        return;
      case 1:
        return $internalize(result, t.results[0]);
      default:
        for (var i = 0; i < t.results.length; i++) {
          result[i] = $internalize(result[i], t.results[i]);
        }
        return result;
      }
    };
  case $kindInterface:
    if (t.methods.length !== 0) {
      $throwRuntimeError("cannot internalize " + t.string);
    }
    if (v === null) {
      return $ifaceNil;
    }
    if (v === undefined) {
      return new $jsObjectPtr(undefined);
    }
    switch (v.constructor) {
    case Int8Array:
      return new ($sliceType($Int8))(v);
    case Int16Array:
      return new ($sliceType($Int16))(v);
    case Int32Array:
      return new ($sliceType($Int))(v);
    case Uint8Array:
      return new ($sliceType($Uint8))(v);
    case Uint16Array:
      return new ($sliceType($Uint16))(v);
    case Uint32Array:
      return new ($sliceType($Uint))(v);
    case Float32Array:
      return new ($sliceType($Float32))(v);
    case Float64Array:
      return new ($sliceType($Float64))(v);
    case Array:
      return $internalize(v, $sliceType($emptyInterface));
    case Boolean:
      return new $Bool(!!v);
    case Date:
      if (timePkg === undefined) {
        /* time package is not present, internalize as &js.Object{Date} so it can be externalized into original Date. */
        return new $jsObjectPtr(v);
      }
      return new timePkg.Time($internalize(v, timePkg.Time));
    case Function:
      var funcType = $funcType([$sliceType($emptyInterface)], [$jsObjectPtr], true);
      return new funcType($internalize(v, funcType));
    case Number:
      return new $Float64(parseFloat(v));
    case String:
      return new $String($internalize(v, $String));
    default:
      if ($global.Node && v instanceof $global.Node) {
        return new $jsObjectPtr(v);
      }
      var mapType = $mapType($String, $emptyInterface);
      return new mapType($internalize(v, mapType));
    }
  case $kindMap:
    var m = {};
    var keys = $keys(v);
    for (var i = 0; i < keys.length; i++) {
      var k = $internalize(keys[i], t.key);
      m[t.key.keyFor(k)] = { k: k, v: $internalize(v[keys[i]], t.elem) };
    }
    return m;
  case $kindPtr:
    if (t.elem.kind === $kindStruct) {
      return $internalize(v, t.elem);
    }
  case $kindSlice:
    return new t($mapArray(v, function(e) { return $internalize(e, t.elem); }));
  case $kindString:
    v = String(v);
    if ($isASCII(v)) {
      return v;
    }
    var s = "";
    var i = 0;
    while (i < v.length) {
      var h = v.charCodeAt(i);
      if (0xD800 <= h && h <= 0xDBFF) {
        var l = v.charCodeAt(i + 1);
        var c = (h - 0xD800) * 0x400 + l - 0xDC00 + 0x10000;
        s += $encodeRune(c);
        i += 2;
        continue;
      }
      s += $encodeRune(h);
      i++;
    }
    return s;
  case $kindStruct:
    var noJsObject = {};
    var searchJsObject = function(t) {
      if (t === $jsObjectPtr) {
        return v;
      }
      if (t === $jsObjectPtr.elem) {
        $throwRuntimeError("cannot internalize js.Object, use *js.Object instead");
      }
      switch (t.kind) {
      case $kindPtr:
        return searchJsObject(t.elem);
      case $kindStruct:
        var f = t.fields[0];
        var o = searchJsObject(f.typ);
        if (o !== noJsObject) {
          var n = new t.ptr();
          n[f.prop] = o;
          return n;
        }
        return noJsObject;
      default:
        return noJsObject;
      }
    };
    var o = searchJsObject(t);
    if (o !== noJsObject) {
      return o;
    }
  }
  $throwRuntimeError("cannot internalize " + t.string);
};

/* $isASCII reports whether string s contains only ASCII characters. */
var $isASCII = function(s) {
  for (var i = 0; i < s.length; i++) {
    if (s.charCodeAt(i) >= 128) {
      return false;
    }
  }
  return true;
};

$packages["github.com/gopherjs/gopherjs/js"] = (function() {
	var $pkg = {}, $init, Object, Error, sliceType, ptrType, sliceType$2, funcType, ptrType$1, MakeWrapper, init;
	Object = $pkg.Object = $newType(0, $kindStruct, "js.Object", true, "github.com/gopherjs/gopherjs/js", true, function(object_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.object = null;
			return;
		}
		this.object = object_;
	});
	Error = $pkg.Error = $newType(0, $kindStruct, "js.Error", true, "github.com/gopherjs/gopherjs/js", true, function(Object_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Object = null;
			return;
		}
		this.Object = Object_;
	});
	sliceType = $sliceType($emptyInterface);
	ptrType = $ptrType(Object);
	sliceType$2 = $sliceType(ptrType);
	funcType = $funcType([sliceType$2], [ptrType], true);
	ptrType$1 = $ptrType(Error);
	Object.ptr.prototype.Get = function(key) {
		var key, o;
		o = this;
		return o.object[$externalize(key, $String)];
	};
	Object.prototype.Get = function(key) { return this.$val.Get(key); };
	Object.ptr.prototype.Set = function(key, value) {
		var key, o, value;
		o = this;
		o.object[$externalize(key, $String)] = $externalize(value, $emptyInterface);
	};
	Object.prototype.Set = function(key, value) { return this.$val.Set(key, value); };
	Object.ptr.prototype.Delete = function(key) {
		var key, o;
		o = this;
		delete o.object[$externalize(key, $String)];
	};
	Object.prototype.Delete = function(key) { return this.$val.Delete(key); };
	Object.ptr.prototype.Length = function() {
		var o;
		o = this;
		return $parseInt(o.object.length);
	};
	Object.prototype.Length = function() { return this.$val.Length(); };
	Object.ptr.prototype.Index = function(i) {
		var i, o;
		o = this;
		return o.object[i];
	};
	Object.prototype.Index = function(i) { return this.$val.Index(i); };
	Object.ptr.prototype.SetIndex = function(i, value) {
		var i, o, value;
		o = this;
		o.object[i] = $externalize(value, $emptyInterface);
	};
	Object.prototype.SetIndex = function(i, value) { return this.$val.SetIndex(i, value); };
	Object.ptr.prototype.Call = function(name, args) {
		var args, name, o, obj;
		o = this;
		return (obj = o.object, obj[$externalize(name, $String)].apply(obj, $externalize(args, sliceType)));
	};
	Object.prototype.Call = function(name, args) { return this.$val.Call(name, args); };
	Object.ptr.prototype.Invoke = function(args) {
		var args, o;
		o = this;
		return o.object.apply(undefined, $externalize(args, sliceType));
	};
	Object.prototype.Invoke = function(args) { return this.$val.Invoke(args); };
	Object.ptr.prototype.New = function(args) {
		var args, o;
		o = this;
		return new ($global.Function.prototype.bind.apply(o.object, [undefined].concat($externalize(args, sliceType))));
	};
	Object.prototype.New = function(args) { return this.$val.New(args); };
	Object.ptr.prototype.Bool = function() {
		var o;
		o = this;
		return !!(o.object);
	};
	Object.prototype.Bool = function() { return this.$val.Bool(); };
	Object.ptr.prototype.String = function() {
		var o;
		o = this;
		return $internalize(o.object, $String);
	};
	Object.prototype.String = function() { return this.$val.String(); };
	Object.ptr.prototype.Int = function() {
		var o;
		o = this;
		return $parseInt(o.object) >> 0;
	};
	Object.prototype.Int = function() { return this.$val.Int(); };
	Object.ptr.prototype.Int64 = function() {
		var o;
		o = this;
		return $internalize(o.object, $Int64);
	};
	Object.prototype.Int64 = function() { return this.$val.Int64(); };
	Object.ptr.prototype.Uint64 = function() {
		var o;
		o = this;
		return $internalize(o.object, $Uint64);
	};
	Object.prototype.Uint64 = function() { return this.$val.Uint64(); };
	Object.ptr.prototype.Float = function() {
		var o;
		o = this;
		return $parseFloat(o.object);
	};
	Object.prototype.Float = function() { return this.$val.Float(); };
	Object.ptr.prototype.Interface = function() {
		var o;
		o = this;
		return $internalize(o.object, $emptyInterface);
	};
	Object.prototype.Interface = function() { return this.$val.Interface(); };
	Object.ptr.prototype.Unsafe = function() {
		var o;
		o = this;
		return o.object;
	};
	Object.prototype.Unsafe = function() { return this.$val.Unsafe(); };
	Error.ptr.prototype.Error = function() {
		var err;
		err = this;
		return "JavaScript error: " + $internalize(err.Object.message, $String);
	};
	Error.prototype.Error = function() { return this.$val.Error(); };
	Error.ptr.prototype.Stack = function() {
		var err;
		err = this;
		return $internalize(err.Object.stack, $String);
	};
	Error.prototype.Stack = function() { return this.$val.Stack(); };
	MakeWrapper = function(i) {
		var i, i$1, m, methods, o, v;
		v = i;
		o = new ($global.Object)();
		o.__internal_object__ = v;
		methods = v.constructor.methods;
		i$1 = 0;
		while (true) {
			if (!(i$1 < $parseInt(methods.length))) { break; }
			m = [m];
			m[0] = methods[i$1];
			if (!($internalize(m[0].pkg, $String) === "")) {
				i$1 = i$1 + (1) >> 0;
				continue;
			}
			o[$externalize($internalize(m[0].name, $String), $String)] = $externalize((function(m) { return function(args) {
				var args;
				return $externalizeFunction(v[$externalize($internalize(m[0].prop, $String), $String)], m[0].typ, $externalize(true, $Bool)).apply(v, $externalize(args, sliceType$2));
			}; })(m), funcType);
			i$1 = i$1 + (1) >> 0;
		}
		return o;
	};
	$pkg.MakeWrapper = MakeWrapper;
	init = function() {
		var e;
		e = new Error.ptr(null);
		$unused(e);
	};
	ptrType.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([$String], [ptrType], false)}, {prop: "Set", name: "Set", pkg: "", typ: $funcType([$String, $emptyInterface], [], false)}, {prop: "Delete", name: "Delete", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Length", name: "Length", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Index", name: "Index", pkg: "", typ: $funcType([$Int], [ptrType], false)}, {prop: "SetIndex", name: "SetIndex", pkg: "", typ: $funcType([$Int, $emptyInterface], [], false)}, {prop: "Call", name: "Call", pkg: "", typ: $funcType([$String, sliceType], [ptrType], true)}, {prop: "Invoke", name: "Invoke", pkg: "", typ: $funcType([sliceType], [ptrType], true)}, {prop: "New", name: "New", pkg: "", typ: $funcType([sliceType], [ptrType], true)}, {prop: "Bool", name: "Bool", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Int", name: "Int", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Int64", name: "Int64", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Uint64", name: "Uint64", pkg: "", typ: $funcType([], [$Uint64], false)}, {prop: "Float", name: "Float", pkg: "", typ: $funcType([], [$Float64], false)}, {prop: "Interface", name: "Interface", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Unsafe", name: "Unsafe", pkg: "", typ: $funcType([], [$Uintptr], false)}];
	ptrType$1.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Stack", name: "Stack", pkg: "", typ: $funcType([], [$String], false)}];
	Object.init("github.com/gopherjs/gopherjs/js", [{prop: "object", name: "object", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	Error.init("", [{prop: "Object", name: "Object", embedded: true, exported: true, typ: ptrType, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/cpu"] = (function() {
	var $pkg = {}, $init;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/bytealg"] = (function() {
	var $pkg = {}, $init, cpu, Count, Index, Cutover;
	cpu = $packages["internal/cpu"];
	Count = function(b, c) {
		var _i, _ref, b, c, n, x;
		n = 0;
		_ref = b;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			x = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (x === c) {
				n = n + (1) >> 0;
			}
			_i++;
		}
		return n;
	};
	$pkg.Count = Count;
	Index = function(a, b) {
		var a, b;
		$panic(new $String("unimplemented"));
	};
	$pkg.Index = Index;
	Cutover = function(n) {
		var n;
		$panic(new $String("unimplemented"));
	};
	$pkg.Cutover = Cutover;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = cpu.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.MaxLen = 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["runtime/internal/sys"] = (function() {
	var $pkg = {}, $init;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["runtime"] = (function() {
	var $pkg = {}, $init, js, bytealg, sys, _type, TypeAssertionError, errorString, ptrType, ptrType$4, init, throw$1;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bytealg = $packages["internal/bytealg"];
	sys = $packages["runtime/internal/sys"];
	_type = $pkg._type = $newType(0, $kindStruct, "runtime._type", true, "runtime", false, function(str_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.str = "";
			return;
		}
		this.str = str_;
	});
	TypeAssertionError = $pkg.TypeAssertionError = $newType(0, $kindStruct, "runtime.TypeAssertionError", true, "runtime", true, function(_interface_, concrete_, asserted_, missingMethod_) {
		this.$val = this;
		if (arguments.length === 0) {
			this._interface = ptrType.nil;
			this.concrete = ptrType.nil;
			this.asserted = ptrType.nil;
			this.missingMethod = "";
			return;
		}
		this._interface = _interface_;
		this.concrete = concrete_;
		this.asserted = asserted_;
		this.missingMethod = missingMethod_;
	});
	errorString = $pkg.errorString = $newType(8, $kindString, "runtime.errorString", true, "runtime", false, null);
	ptrType = $ptrType(_type);
	ptrType$4 = $ptrType(TypeAssertionError);
	_type.ptr.prototype.string = function() {
		var t;
		t = this;
		return t.str;
	};
	_type.prototype.string = function() { return this.$val.string(); };
	_type.ptr.prototype.pkgpath = function() {
		var t;
		t = this;
		return "";
	};
	_type.prototype.pkgpath = function() { return this.$val.pkgpath(); };
	init = function() {
		var e, jsPkg;
		jsPkg = $packages[$externalize("github.com/gopherjs/gopherjs/js", $String)];
		$jsObjectPtr = jsPkg.Object.ptr;
		$jsErrorPtr = jsPkg.Error.ptr;
		$throwRuntimeError = throw$1;
		e = $ifaceNil;
		e = new TypeAssertionError.ptr(ptrType.nil, ptrType.nil, ptrType.nil, "");
		$unused(e);
	};
	throw$1 = function(s) {
		var s;
		$panic(new errorString((s)));
	};
	TypeAssertionError.ptr.prototype.RuntimeError = function() {
	};
	TypeAssertionError.prototype.RuntimeError = function() { return this.$val.RuntimeError(); };
	TypeAssertionError.ptr.prototype.Error = function() {
		var as, cs, e, inter, msg;
		e = this;
		inter = "interface";
		if (!(e._interface === ptrType.nil)) {
			inter = e._interface.string();
		}
		as = e.asserted.string();
		if (e.concrete === ptrType.nil) {
			return "interface conversion: " + inter + " is nil, not " + as;
		}
		cs = e.concrete.string();
		if (e.missingMethod === "") {
			msg = "interface conversion: " + inter + " is " + cs + ", not " + as;
			if (cs === as) {
				if (!(e.concrete.pkgpath() === e.asserted.pkgpath())) {
					msg = msg + (" (types from different packages)");
				} else {
					msg = msg + (" (types from different scopes)");
				}
			}
			return msg;
		}
		return "interface conversion: " + cs + " is not " + as + ": missing method " + e.missingMethod;
	};
	TypeAssertionError.prototype.Error = function() { return this.$val.Error(); };
	errorString.prototype.RuntimeError = function() {
		var e;
		e = this.$val;
	};
	$ptrType(errorString).prototype.RuntimeError = function() { return new errorString(this.$get()).RuntimeError(); };
	errorString.prototype.Error = function() {
		var e;
		e = this.$val;
		return "runtime error: " + (e);
	};
	$ptrType(errorString).prototype.Error = function() { return new errorString(this.$get()).Error(); };
	ptrType.methods = [{prop: "string", name: "string", pkg: "runtime", typ: $funcType([], [$String], false)}, {prop: "pkgpath", name: "pkgpath", pkg: "runtime", typ: $funcType([], [$String], false)}];
	ptrType$4.methods = [{prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	errorString.methods = [{prop: "RuntimeError", name: "RuntimeError", pkg: "", typ: $funcType([], [], false)}, {prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	_type.init("runtime", [{prop: "str", name: "str", embedded: false, exported: false, typ: $String, tag: ""}]);
	TypeAssertionError.init("runtime", [{prop: "_interface", name: "_interface", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "concrete", name: "concrete", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "asserted", name: "asserted", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "missingMethod", name: "missingMethod", embedded: false, exported: false, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sys.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["errors"] = (function() {
	var $pkg = {}, $init, errorString, ptrType, New;
	errorString = $pkg.errorString = $newType(0, $kindStruct, "errors.errorString", true, "errors", false, function(s_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = "";
			return;
		}
		this.s = s_;
	});
	ptrType = $ptrType(errorString);
	New = function(text) {
		var text;
		return new errorString.ptr(text);
	};
	$pkg.New = New;
	errorString.ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.s;
	};
	errorString.prototype.Error = function() { return this.$val.Error(); };
	ptrType.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	errorString.init("errors", [{prop: "s", name: "s", embedded: false, exported: false, typ: $String, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["internal/race"] = (function() {
	var $pkg = {}, $init, Acquire, Release;
	Acquire = function(addr) {
		var addr;
	};
	$pkg.Acquire = Acquire;
	Release = function(addr) {
		var addr;
	};
	$pkg.Release = Release;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sync/atomic"] = (function() {
	var $pkg = {}, $init, js, CompareAndSwapInt32, AddInt32;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	CompareAndSwapInt32 = function(addr, old, new$1) {
		var addr, new$1, old;
		if (addr.$get() === old) {
			addr.$set(new$1);
			return true;
		}
		return false;
	};
	$pkg.CompareAndSwapInt32 = CompareAndSwapInt32;
	AddInt32 = function(addr, delta) {
		var addr, delta, new$1;
		new$1 = addr.$get() + delta >> 0;
		addr.$set(new$1);
		return new$1;
	};
	$pkg.AddInt32 = AddInt32;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["sync"] = (function() {
	var $pkg = {}, $init, js, race, runtime, atomic, Pool, Mutex, poolLocalInternal, poolLocal, notifyList, ptrType, sliceType, ptrType$1, chanType, sliceType$1, ptrType$6, ptrType$7, sliceType$4, funcType, ptrType$16, arrayType$2, semWaiters, semAwoken, expunged, allPools, runtime_registerPoolCleanup, runtime_SemacquireMutex, runtime_Semrelease, runtime_notifyListCheck, runtime_canSpin, runtime_nanotime, throw$1, poolCleanup, init, indexLocal, init$1, runtime_doSpin;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	race = $packages["internal/race"];
	runtime = $packages["runtime"];
	atomic = $packages["sync/atomic"];
	Pool = $pkg.Pool = $newType(0, $kindStruct, "sync.Pool", true, "sync", true, function(local_, localSize_, store_, New_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.local = 0;
			this.localSize = 0;
			this.store = sliceType$4.nil;
			this.New = $throwNilPointerError;
			return;
		}
		this.local = local_;
		this.localSize = localSize_;
		this.store = store_;
		this.New = New_;
	});
	Mutex = $pkg.Mutex = $newType(0, $kindStruct, "sync.Mutex", true, "sync", true, function(state_, sema_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.state = 0;
			this.sema = 0;
			return;
		}
		this.state = state_;
		this.sema = sema_;
	});
	poolLocalInternal = $pkg.poolLocalInternal = $newType(0, $kindStruct, "sync.poolLocalInternal", true, "sync", false, function(private$0_, shared_, Mutex_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.private$0 = $ifaceNil;
			this.shared = sliceType$4.nil;
			this.Mutex = new Mutex.ptr(0, 0);
			return;
		}
		this.private$0 = private$0_;
		this.shared = shared_;
		this.Mutex = Mutex_;
	});
	poolLocal = $pkg.poolLocal = $newType(0, $kindStruct, "sync.poolLocal", true, "sync", false, function(poolLocalInternal_, pad_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.poolLocalInternal = new poolLocalInternal.ptr($ifaceNil, sliceType$4.nil, new Mutex.ptr(0, 0));
			this.pad = arrayType$2.zero();
			return;
		}
		this.poolLocalInternal = poolLocalInternal_;
		this.pad = pad_;
	});
	notifyList = $pkg.notifyList = $newType(0, $kindStruct, "sync.notifyList", true, "sync", false, function(wait_, notify_, lock_, head_, tail_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.wait = 0;
			this.notify = 0;
			this.lock = 0;
			this.head = 0;
			this.tail = 0;
			return;
		}
		this.wait = wait_;
		this.notify = notify_;
		this.lock = lock_;
		this.head = head_;
		this.tail = tail_;
	});
	ptrType = $ptrType(Pool);
	sliceType = $sliceType(ptrType);
	ptrType$1 = $ptrType($Uint32);
	chanType = $chanType($Bool, false, false);
	sliceType$1 = $sliceType(chanType);
	ptrType$6 = $ptrType($Int32);
	ptrType$7 = $ptrType(poolLocal);
	sliceType$4 = $sliceType($emptyInterface);
	funcType = $funcType([], [$emptyInterface], false);
	ptrType$16 = $ptrType(Mutex);
	arrayType$2 = $arrayType($Uint8, 100);
	Pool.ptr.prototype.Get = function() {
		var _r, p, x, x$1, x$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		/* */ if (p.store.$length === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (p.store.$length === 0) { */ case 1:
			/* */ if (!(p.New === $throwNilPointerError)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(p.New === $throwNilPointerError)) { */ case 3:
				_r = p.New(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } */ case 4:
			$s = -1; return $ifaceNil;
		/* } */ case 2:
		x$2 = (x = p.store, x$1 = p.store.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		p.store = $subslice(p.store, 0, (p.store.$length - 1 >> 0));
		$s = -1; return x$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Pool.ptr.prototype.Get }; } $f._r = _r; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	Pool.prototype.Get = function() { return this.$val.Get(); };
	Pool.ptr.prototype.Put = function(x) {
		var p, x;
		p = this;
		if ($interfaceIsEqual(x, $ifaceNil)) {
			return;
		}
		p.store = $append(p.store, x);
	};
	Pool.prototype.Put = function(x) { return this.$val.Put(x); };
	runtime_registerPoolCleanup = function(cleanup) {
		var cleanup;
	};
	runtime_SemacquireMutex = function(s, lifo) {
		var _entry, _entry$1, _entry$2, _entry$3, _entry$4, _key, _key$1, _key$2, _r, ch, lifo, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _entry$2 = $f._entry$2; _entry$3 = $f._entry$3; _entry$4 = $f._entry$4; _key = $f._key; _key$1 = $f._key$1; _key$2 = $f._key$2; _r = $f._r; ch = $f.ch; lifo = $f.lifo; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		/* */ if (((s.$get() - (_entry = semAwoken[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : 0) >>> 0)) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (((s.$get() - (_entry = semAwoken[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : 0) >>> 0)) === 0) { */ case 1:
			ch = new $Chan($Bool, 0);
			if (lifo) {
				_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: $appendSlice(new sliceType$1([ch]), (_entry$1 = semWaiters[ptrType$1.keyFor(s)], _entry$1 !== undefined ? _entry$1.v : sliceType$1.nil)) };
			} else {
				_key$1 = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$1)] = { k: _key$1, v: $append((_entry$2 = semWaiters[ptrType$1.keyFor(s)], _entry$2 !== undefined ? _entry$2.v : sliceType$1.nil), ch) };
			}
			_r = $recv(ch); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r[0];
			_key$2 = s; (semAwoken || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$2)] = { k: _key$2, v: (_entry$3 = semAwoken[ptrType$1.keyFor(s)], _entry$3 !== undefined ? _entry$3.v : 0) - (1) >>> 0 };
			if ((_entry$4 = semAwoken[ptrType$1.keyFor(s)], _entry$4 !== undefined ? _entry$4.v : 0) === 0) {
				delete semAwoken[ptrType$1.keyFor(s)];
			}
		/* } */ case 2:
		s.$set(s.$get() - (1) >>> 0);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_SemacquireMutex }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._entry$2 = _entry$2; $f._entry$3 = _entry$3; $f._entry$4 = _entry$4; $f._key = _key; $f._key$1 = _key$1; $f._key$2 = _key$2; $f._r = _r; $f.ch = ch; $f.lifo = lifo; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_Semrelease = function(s, handoff) {
		var _entry, _entry$1, _key, _key$1, ch, handoff, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _key = $f._key; _key$1 = $f._key$1; ch = $f.ch; handoff = $f.handoff; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		s.$set(s.$get() + (1) >>> 0);
		w = (_entry = semWaiters[ptrType$1.keyFor(s)], _entry !== undefined ? _entry.v : sliceType$1.nil);
		if (w.$length === 0) {
			$s = -1; return;
		}
		ch = (0 >= w.$length ? ($throwRuntimeError("index out of range"), undefined) : w.$array[w.$offset + 0]);
		w = $subslice(w, 1);
		_key = s; (semWaiters || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key)] = { k: _key, v: w };
		if (w.$length === 0) {
			delete semWaiters[ptrType$1.keyFor(s)];
		}
		_key$1 = s; (semAwoken || $throwRuntimeError("assignment to entry in nil map"))[ptrType$1.keyFor(_key$1)] = { k: _key$1, v: (_entry$1 = semAwoken[ptrType$1.keyFor(s)], _entry$1 !== undefined ? _entry$1.v : 0) + (1) >>> 0 };
		$r = $send(ch, true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: runtime_Semrelease }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._key = _key; $f._key$1 = _key$1; $f.ch = ch; $f.handoff = handoff; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	runtime_notifyListCheck = function(size) {
		var size;
	};
	runtime_canSpin = function(i) {
		var i;
		return false;
	};
	runtime_nanotime = function() {
		return $mul64($internalize(new ($global.Date)().getTime(), $Int64), new $Int64(0, 1000000));
	};
	throw$1 = function(s) {
		var s;
		$throwRuntimeError($externalize(s, $String));
	};
	Mutex.ptr.prototype.Lock = function() {
		var awoke, delta, iter, m, new$1, old, queueLifo, starving, waitStartTime, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; awoke = $f.awoke; delta = $f.delta; iter = $f.iter; m = $f.m; new$1 = $f.new$1; old = $f.old; queueLifo = $f.queueLifo; starving = $f.starving; waitStartTime = $f.waitStartTime; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), 0, 1)) {
			if (false) {
				race.Acquire((m));
			}
			$s = -1; return;
		}
		waitStartTime = new $Int64(0, 0);
		starving = false;
		awoke = false;
		iter = 0;
		old = m.state;
		/* while (true) { */ case 1:
			/* */ if (((old & 5) === 1) && runtime_canSpin(iter)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (((old & 5) === 1) && runtime_canSpin(iter)) { */ case 3:
				if (!awoke && ((old & 2) === 0) && !(((old >> 3 >> 0) === 0)) && atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, old | 2)) {
					awoke = true;
				}
				runtime_doSpin();
				iter = iter + (1) >> 0;
				old = m.state;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			new$1 = old;
			if ((old & 4) === 0) {
				new$1 = new$1 | (1);
			}
			if (!(((old & 5) === 0))) {
				new$1 = new$1 + (8) >> 0;
			}
			if (starving && !(((old & 1) === 0))) {
				new$1 = new$1 | (4);
			}
			if (awoke) {
				if ((new$1 & 2) === 0) {
					throw$1("sync: inconsistent mutex state");
				}
				new$1 = (new$1 & ~(2)) >> 0;
			}
			/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 5:
				if ((old & 5) === 0) {
					/* break; */ $s = 2; continue;
				}
				queueLifo = !((waitStartTime.$high === 0 && waitStartTime.$low === 0));
				if ((waitStartTime.$high === 0 && waitStartTime.$low === 0)) {
					waitStartTime = runtime_nanotime();
				}
				$r = runtime_SemacquireMutex((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), queueLifo); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				starving = starving || (x = (x$1 = runtime_nanotime(), new $Int64(x$1.$high - waitStartTime.$high, x$1.$low - waitStartTime.$low)), (x.$high > 0 || (x.$high === 0 && x.$low > 1000000)));
				old = m.state;
				if (!(((old & 4) === 0))) {
					if (!(((old & 3) === 0)) || ((old >> 3 >> 0) === 0)) {
						throw$1("sync: inconsistent mutex state");
					}
					delta = -7;
					if (!starving || ((old >> 3 >> 0) === 1)) {
						delta = delta - (4) >> 0;
					}
					atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), delta);
					/* break; */ $s = 2; continue;
				}
				awoke = true;
				iter = 0;
				$s = 7; continue;
			/* } else { */ case 6:
				old = m.state;
			/* } */ case 7:
		/* } */ $s = 1; continue; case 2:
		if (false) {
			race.Acquire((m));
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Lock }; } $f.awoke = awoke; $f.delta = delta; $f.iter = iter; $f.m = m; $f.new$1 = new$1; $f.old = old; $f.queueLifo = queueLifo; $f.starving = starving; $f.waitStartTime = waitStartTime; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Mutex.prototype.Lock = function() { return this.$val.Lock(); };
	Mutex.ptr.prototype.Unlock = function() {
		var m, new$1, old, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; m = $f.m; new$1 = $f.new$1; old = $f.old; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		m = this;
		if (false) {
			$unused(m.state);
			race.Release((m));
		}
		new$1 = atomic.AddInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), -1);
		if ((((new$1 + 1 >> 0)) & 1) === 0) {
			throw$1("sync: unlock of unlocked mutex");
		}
		/* */ if ((new$1 & 4) === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((new$1 & 4) === 0) { */ case 1:
			old = new$1;
			/* while (true) { */ case 4:
				if (((old >> 3 >> 0) === 0) || !(((old & 7) === 0))) {
					$s = -1; return;
				}
				new$1 = ((old - 8 >> 0)) | 2;
				/* */ if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if (atomic.CompareAndSwapInt32((m.$ptr_state || (m.$ptr_state = new ptrType$6(function() { return this.$target.state; }, function($v) { this.$target.state = $v; }, m))), old, new$1)) { */ case 6:
					$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), false); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					$s = -1; return;
				/* } */ case 7:
				old = m.state;
			/* } */ $s = 4; continue; case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			$r = runtime_Semrelease((m.$ptr_sema || (m.$ptr_sema = new ptrType$1(function() { return this.$target.sema; }, function($v) { this.$target.sema = $v; }, m))), true); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 3:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Mutex.ptr.prototype.Unlock }; } $f.m = m; $f.new$1 = new$1; $f.old = old; $f.$s = $s; $f.$r = $r; return $f;
	};
	Mutex.prototype.Unlock = function() { return this.$val.Unlock(); };
	poolCleanup = function() {
		var _i, _i$1, _ref, _ref$1, i, i$1, j, l, p, x;
		_ref = allPools;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			p = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			((i < 0 || i >= allPools.$length) ? ($throwRuntimeError("index out of range"), undefined) : allPools.$array[allPools.$offset + i] = ptrType.nil);
			i$1 = 0;
			while (true) {
				if (!(i$1 < ((p.localSize >> 0)))) { break; }
				l = indexLocal(p.local, i$1);
				l.poolLocalInternal.private$0 = $ifaceNil;
				_ref$1 = l.poolLocalInternal.shared;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					j = _i$1;
					(x = l.poolLocalInternal.shared, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j] = $ifaceNil));
					_i$1++;
				}
				l.poolLocalInternal.shared = sliceType$4.nil;
				i$1 = i$1 + (1) >> 0;
			}
			p.local = 0;
			p.localSize = 0;
			_i++;
		}
		allPools = new sliceType([]);
	};
	init = function() {
		runtime_registerPoolCleanup(poolCleanup);
	};
	indexLocal = function(l, i) {
		var i, l, lp;
		lp = (((l) + ($imul(((i >>> 0)), 128) >>> 0) >>> 0));
		return ($pointerOfStructConversion(lp, ptrType$7));
	};
	init$1 = function() {
		var n;
		n = new notifyList.ptr(0, 0, 0, 0, 0);
		runtime_notifyListCheck(20);
	};
	runtime_doSpin = function() {
		$throwRuntimeError("native function not implemented: sync.runtime_doSpin");
	};
	ptrType.methods = [{prop: "Get", name: "Get", pkg: "", typ: $funcType([], [$emptyInterface], false)}, {prop: "Put", name: "Put", pkg: "", typ: $funcType([$emptyInterface], [], false)}, {prop: "getSlow", name: "getSlow", pkg: "sync", typ: $funcType([], [$emptyInterface], false)}, {prop: "pin", name: "pin", pkg: "sync", typ: $funcType([], [ptrType$7], false)}, {prop: "pinSlow", name: "pinSlow", pkg: "sync", typ: $funcType([], [ptrType$7], false)}];
	ptrType$16.methods = [{prop: "Lock", name: "Lock", pkg: "", typ: $funcType([], [], false)}, {prop: "Unlock", name: "Unlock", pkg: "", typ: $funcType([], [], false)}];
	Pool.init("sync", [{prop: "local", name: "local", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "localSize", name: "localSize", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "store", name: "store", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "New", name: "New", embedded: false, exported: true, typ: funcType, tag: ""}]);
	Mutex.init("sync", [{prop: "state", name: "state", embedded: false, exported: false, typ: $Int32, tag: ""}, {prop: "sema", name: "sema", embedded: false, exported: false, typ: $Uint32, tag: ""}]);
	poolLocalInternal.init("sync", [{prop: "private$0", name: "private", embedded: false, exported: false, typ: $emptyInterface, tag: ""}, {prop: "shared", name: "shared", embedded: false, exported: false, typ: sliceType$4, tag: ""}, {prop: "Mutex", name: "Mutex", embedded: true, exported: true, typ: Mutex, tag: ""}]);
	poolLocal.init("sync", [{prop: "poolLocalInternal", name: "poolLocalInternal", embedded: true, exported: false, typ: poolLocalInternal, tag: ""}, {prop: "pad", name: "pad", embedded: false, exported: false, typ: arrayType$2, tag: ""}]);
	notifyList.init("sync", [{prop: "wait", name: "wait", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "notify", name: "notify", embedded: false, exported: false, typ: $Uint32, tag: ""}, {prop: "lock", name: "lock", embedded: false, exported: false, typ: $Uintptr, tag: ""}, {prop: "head", name: "head", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}, {prop: "tail", name: "tail", embedded: false, exported: false, typ: $UnsafePointer, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = race.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = runtime.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		allPools = sliceType.nil;
		semWaiters = {};
		semAwoken = {};
		expunged = (new Uint8Array(8));
		init();
		init$1();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["io"] = (function() {
	var $pkg = {}, $init, errors, sync, atomic, Reader, Writer, ReaderFrom, StringWriter, sliceType, errWhence, errOffset, WriteString;
	errors = $packages["errors"];
	sync = $packages["sync"];
	atomic = $packages["sync/atomic"];
	Reader = $pkg.Reader = $newType(8, $kindInterface, "io.Reader", true, "io", true, null);
	Writer = $pkg.Writer = $newType(8, $kindInterface, "io.Writer", true, "io", true, null);
	ReaderFrom = $pkg.ReaderFrom = $newType(8, $kindInterface, "io.ReaderFrom", true, "io", true, null);
	StringWriter = $pkg.StringWriter = $newType(8, $kindInterface, "io.StringWriter", true, "io", true, null);
	sliceType = $sliceType($Uint8);
	WriteString = function(w, s) {
		var _r, _r$1, _tuple, _tuple$1, _tuple$2, err, n, ok, s, sw, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; err = $f.err; n = $f.n; ok = $f.ok; s = $f.s; sw = $f.sw; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = 0;
		err = $ifaceNil;
		_tuple = $assertType(w, StringWriter, true);
		sw = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			_r = sw.WriteString(s); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple$1 = _r;
			n = _tuple$1[0];
			err = _tuple$1[1];
			$s = -1; return [n, err];
		/* } */ case 2:
		_r$1 = w.Write((new sliceType($stringToBytes(s)))); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple$2 = _r$1;
		n = _tuple$2[0];
		err = _tuple$2[1];
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: WriteString }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.err = err; $f.n = n; $f.ok = ok; $f.s = s; $f.sw = sw; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.WriteString = WriteString;
	Reader.init([{prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	Writer.init([{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}]);
	ReaderFrom.init([{prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([Reader], [$Int64, $error], false)}]);
	StringWriter.init([{prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atomic.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrShortWrite = errors.New("short write");
		$pkg.ErrShortBuffer = errors.New("short buffer");
		$pkg.EOF = errors.New("EOF");
		$pkg.ErrUnexpectedEOF = errors.New("unexpected EOF");
		$pkg.ErrNoProgress = errors.New("multiple Read calls return no data or error");
		errWhence = errors.New("Seek: invalid whence");
		errOffset = errors.New("Seek: invalid offset");
		$pkg.ErrClosedPipe = errors.New("io: read/write on closed pipe");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode"] = (function() {
	var $pkg = {}, $init, RangeTable, Range16, Range32, CaseRange, d, foldPair, arrayType, sliceType, sliceType$1, ptrType, sliceType$2, sliceType$3, sliceType$4, _L, _M, _N, _Nd, _P, _S, _Zs, _Han, _White_Space, _CaseRanges, properties, asciiFold, caseOrbit, to, IsDigit, IsPrint, In, IsControl, IsLetter, IsPunct, IsSpace, IsSymbol, is16, is32, Is, isExcludingLatin, To, ToUpper, ToLower, SimpleFold;
	RangeTable = $pkg.RangeTable = $newType(0, $kindStruct, "unicode.RangeTable", true, "unicode", true, function(R16_, R32_, LatinOffset_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.R16 = sliceType.nil;
			this.R32 = sliceType$1.nil;
			this.LatinOffset = 0;
			return;
		}
		this.R16 = R16_;
		this.R32 = R32_;
		this.LatinOffset = LatinOffset_;
	});
	Range16 = $pkg.Range16 = $newType(0, $kindStruct, "unicode.Range16", true, "unicode", true, function(Lo_, Hi_, Stride_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Stride = 0;
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Stride = Stride_;
	});
	Range32 = $pkg.Range32 = $newType(0, $kindStruct, "unicode.Range32", true, "unicode", true, function(Lo_, Hi_, Stride_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Stride = 0;
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Stride = Stride_;
	});
	CaseRange = $pkg.CaseRange = $newType(0, $kindStruct, "unicode.CaseRange", true, "unicode", true, function(Lo_, Hi_, Delta_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Lo = 0;
			this.Hi = 0;
			this.Delta = arrayType.zero();
			return;
		}
		this.Lo = Lo_;
		this.Hi = Hi_;
		this.Delta = Delta_;
	});
	d = $pkg.d = $newType(12, $kindArray, "unicode.d", true, "unicode", false, null);
	foldPair = $pkg.foldPair = $newType(0, $kindStruct, "unicode.foldPair", true, "unicode", false, function(From_, To_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.From = 0;
			this.To = 0;
			return;
		}
		this.From = From_;
		this.To = To_;
	});
	arrayType = $arrayType($Int32, 3);
	sliceType = $sliceType(Range16);
	sliceType$1 = $sliceType(Range32);
	ptrType = $ptrType(RangeTable);
	sliceType$2 = $sliceType(ptrType);
	sliceType$3 = $sliceType(CaseRange);
	sliceType$4 = $sliceType(foldPair);
	to = function(_case, r, caseRange) {
		var _case, _q, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, caseRange, cr, delta, foundMapping, hi, lo, m, mappedRune, r, x;
		mappedRune = 0;
		foundMapping = false;
		if (_case < 0 || 3 <= _case) {
			_tmp = 65533;
			_tmp$1 = false;
			mappedRune = _tmp;
			foundMapping = _tmp$1;
			return [mappedRune, foundMapping];
		}
		lo = 0;
		hi = caseRange.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			cr = ((m < 0 || m >= caseRange.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseRange.$array[caseRange.$offset + m]);
			if (((cr.Lo >> 0)) <= r && r <= ((cr.Hi >> 0))) {
				delta = ((x = cr.Delta, ((_case < 0 || _case >= x.length) ? ($throwRuntimeError("index out of range"), undefined) : x[_case])));
				if (delta > 1114111) {
					_tmp$2 = ((cr.Lo >> 0)) + ((((((r - ((cr.Lo >> 0)) >> 0)) & ~1) >> 0) | (((_case & 1) >> 0)))) >> 0;
					_tmp$3 = true;
					mappedRune = _tmp$2;
					foundMapping = _tmp$3;
					return [mappedRune, foundMapping];
				}
				_tmp$4 = r + delta >> 0;
				_tmp$5 = true;
				mappedRune = _tmp$4;
				foundMapping = _tmp$5;
				return [mappedRune, foundMapping];
			}
			if (r < ((cr.Lo >> 0))) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		_tmp$6 = r;
		_tmp$7 = false;
		mappedRune = _tmp$6;
		foundMapping = _tmp$7;
		return [mappedRune, foundMapping];
	};
	IsDigit = function(r) {
		var r;
		if (r <= 255) {
			return 48 <= r && r <= 57;
		}
		return isExcludingLatin($pkg.Digit, r);
	};
	$pkg.IsDigit = IsDigit;
	IsPrint = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 128) >>> 0) === 0));
		}
		return In(r, $pkg.PrintRanges);
	};
	$pkg.IsPrint = IsPrint;
	In = function(r, ranges) {
		var _i, _ref, inside, r, ranges;
		_ref = ranges;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			inside = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (Is(inside, r)) {
				return true;
			}
			_i++;
		}
		return false;
	};
	$pkg.In = In;
	IsControl = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 1) >>> 0) === 0));
		}
		return false;
	};
	$pkg.IsControl = IsControl;
	IsLetter = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 96) >>> 0) === 0));
		}
		return isExcludingLatin($pkg.Letter, r);
	};
	$pkg.IsLetter = IsLetter;
	IsPunct = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 2) >>> 0) === 0));
		}
		return Is($pkg.Punct, r);
	};
	$pkg.IsPunct = IsPunct;
	IsSpace = function(r) {
		var _1, r;
		if (((r >>> 0)) <= 255) {
			_1 = r;
			if ((_1 === (9)) || (_1 === (10)) || (_1 === (11)) || (_1 === (12)) || (_1 === (13)) || (_1 === (32)) || (_1 === (133)) || (_1 === (160))) {
				return true;
			}
			return false;
		}
		return isExcludingLatin($pkg.White_Space, r);
	};
	$pkg.IsSpace = IsSpace;
	IsSymbol = function(r) {
		var r, x;
		if (((r >>> 0)) <= 255) {
			return !(((((x = ((r << 24 >>> 24)), ((x < 0 || x >= properties.length) ? ($throwRuntimeError("index out of range"), undefined) : properties[x])) & 8) >>> 0) === 0));
		}
		return isExcludingLatin($pkg.Symbol, r);
	};
	$pkg.IsSymbol = IsSymbol;
	is16 = function(ranges, r) {
		var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
		if (ranges.$length <= 18 || r <= 255) {
			_ref = ranges;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				range_ = ((i < 0 || i >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + i]);
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (range_.Stride === 1) || ((_r = ((r - range_.Lo << 16 >>> 16)) % range_.Stride, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0);
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = ((m < 0 || m >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + m]);
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (range_$1.Stride === 1) || ((_r$1 = ((r - range_$1.Lo << 16 >>> 16)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0);
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	is32 = function(ranges, r) {
		var _i, _q, _r, _r$1, _ref, hi, i, lo, m, r, range_, range_$1, ranges;
		if (ranges.$length <= 18) {
			_ref = ranges;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				i = _i;
				range_ = ((i < 0 || i >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + i]);
				if (r < range_.Lo) {
					return false;
				}
				if (r <= range_.Hi) {
					return (range_.Stride === 1) || ((_r = ((r - range_.Lo >>> 0)) % range_.Stride, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0);
				}
				_i++;
			}
			return false;
		}
		lo = 0;
		hi = ranges.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			range_$1 = $clone(((m < 0 || m >= ranges.$length) ? ($throwRuntimeError("index out of range"), undefined) : ranges.$array[ranges.$offset + m]), Range32);
			if (range_$1.Lo <= r && r <= range_$1.Hi) {
				return (range_$1.Stride === 1) || ((_r$1 = ((r - range_$1.Lo >>> 0)) % range_$1.Stride, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0);
			}
			if (r < range_$1.Lo) {
				hi = m;
			} else {
				lo = m + 1 >> 0;
			}
		}
		return false;
	};
	Is = function(rangeTab, r) {
		var r, r16, r32, rangeTab, x;
		r16 = rangeTab.R16;
		if (r16.$length > 0 && r <= (((x = r16.$length - 1 >> 0, ((x < 0 || x >= r16.$length) ? ($throwRuntimeError("index out of range"), undefined) : r16.$array[r16.$offset + x])).Hi >> 0))) {
			return is16(r16, ((r << 16 >>> 16)));
		}
		r32 = rangeTab.R32;
		if (r32.$length > 0 && r >= (((0 >= r32.$length ? ($throwRuntimeError("index out of range"), undefined) : r32.$array[r32.$offset + 0]).Lo >> 0))) {
			return is32(r32, ((r >>> 0)));
		}
		return false;
	};
	$pkg.Is = Is;
	isExcludingLatin = function(rangeTab, r) {
		var off, r, r16, r32, rangeTab, x;
		r16 = rangeTab.R16;
		off = rangeTab.LatinOffset;
		if (r16.$length > off && r <= (((x = r16.$length - 1 >> 0, ((x < 0 || x >= r16.$length) ? ($throwRuntimeError("index out of range"), undefined) : r16.$array[r16.$offset + x])).Hi >> 0))) {
			return is16($subslice(r16, off), ((r << 16 >>> 16)));
		}
		r32 = rangeTab.R32;
		if (r32.$length > 0 && r >= (((0 >= r32.$length ? ($throwRuntimeError("index out of range"), undefined) : r32.$array[r32.$offset + 0]).Lo >> 0))) {
			return is32(r32, ((r >>> 0)));
		}
		return false;
	};
	To = function(_case, r) {
		var _case, _tuple, r;
		_tuple = to(_case, r, $pkg.CaseRanges);
		r = _tuple[0];
		return r;
	};
	$pkg.To = To;
	ToUpper = function(r) {
		var r;
		if (r <= 127) {
			if (97 <= r && r <= 122) {
				r = r - (32) >> 0;
			}
			return r;
		}
		return To(0, r);
	};
	$pkg.ToUpper = ToUpper;
	ToLower = function(r) {
		var r;
		if (r <= 127) {
			if (65 <= r && r <= 90) {
				r = r + (32) >> 0;
			}
			return r;
		}
		return To(1, r);
	};
	$pkg.ToLower = ToLower;
	SimpleFold = function(r) {
		var _q, hi, l, lo, m, r;
		if (r < 0 || r > 1114111) {
			return r;
		}
		if (((r >> 0)) < 128) {
			return ((((r < 0 || r >= asciiFold.length) ? ($throwRuntimeError("index out of range"), undefined) : asciiFold[r]) >> 0));
		}
		lo = 0;
		hi = caseOrbit.$length;
		while (true) {
			if (!(lo < hi)) { break; }
			m = lo + (_q = ((hi - lo >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((((m < 0 || m >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + m]).From >> 0)) < r) {
				lo = m + 1 >> 0;
			} else {
				hi = m;
			}
		}
		if (lo < caseOrbit.$length && (((((lo < 0 || lo >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + lo]).From >> 0)) === r)) {
			return ((((lo < 0 || lo >= caseOrbit.$length) ? ($throwRuntimeError("index out of range"), undefined) : caseOrbit.$array[caseOrbit.$offset + lo]).To >> 0));
		}
		l = ToLower(r);
		if (!((l === r))) {
			return l;
		}
		return ToUpper(r);
	};
	$pkg.SimpleFold = SimpleFold;
	RangeTable.init("", [{prop: "R16", name: "R16", embedded: false, exported: true, typ: sliceType, tag: ""}, {prop: "R32", name: "R32", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "LatinOffset", name: "LatinOffset", embedded: false, exported: true, typ: $Int, tag: ""}]);
	Range16.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	Range32.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Stride", name: "Stride", embedded: false, exported: true, typ: $Uint32, tag: ""}]);
	CaseRange.init("", [{prop: "Lo", name: "Lo", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Hi", name: "Hi", embedded: false, exported: true, typ: $Uint32, tag: ""}, {prop: "Delta", name: "Delta", embedded: false, exported: true, typ: d, tag: ""}]);
	d.init($Int32, 3);
	foldPair.init("", [{prop: "From", name: "From", embedded: false, exported: true, typ: $Uint16, tag: ""}, {prop: "To", name: "To", embedded: false, exported: true, typ: $Uint16, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_L = new RangeTable.ptr(new sliceType([new Range16.ptr(65, 90, 1), new Range16.ptr(97, 122, 1), new Range16.ptr(170, 181, 11), new Range16.ptr(186, 192, 6), new Range16.ptr(193, 214, 1), new Range16.ptr(216, 246, 1), new Range16.ptr(248, 705, 1), new Range16.ptr(710, 721, 1), new Range16.ptr(736, 740, 1), new Range16.ptr(748, 750, 2), new Range16.ptr(880, 884, 1), new Range16.ptr(886, 887, 1), new Range16.ptr(890, 893, 1), new Range16.ptr(895, 902, 7), new Range16.ptr(904, 906, 1), new Range16.ptr(908, 910, 2), new Range16.ptr(911, 929, 1), new Range16.ptr(931, 1013, 1), new Range16.ptr(1015, 1153, 1), new Range16.ptr(1162, 1327, 1), new Range16.ptr(1329, 1366, 1), new Range16.ptr(1369, 1377, 8), new Range16.ptr(1378, 1415, 1), new Range16.ptr(1488, 1514, 1), new Range16.ptr(1520, 1522, 1), new Range16.ptr(1568, 1610, 1), new Range16.ptr(1646, 1647, 1), new Range16.ptr(1649, 1747, 1), new Range16.ptr(1749, 1765, 16), new Range16.ptr(1766, 1774, 8), new Range16.ptr(1775, 1786, 11), new Range16.ptr(1787, 1788, 1), new Range16.ptr(1791, 1808, 17), new Range16.ptr(1810, 1839, 1), new Range16.ptr(1869, 1957, 1), new Range16.ptr(1969, 1994, 25), new Range16.ptr(1995, 2026, 1), new Range16.ptr(2036, 2037, 1), new Range16.ptr(2042, 2048, 6), new Range16.ptr(2049, 2069, 1), new Range16.ptr(2074, 2084, 10), new Range16.ptr(2088, 2112, 24), new Range16.ptr(2113, 2136, 1), new Range16.ptr(2144, 2154, 1), new Range16.ptr(2208, 2228, 1), new Range16.ptr(2230, 2237, 1), new Range16.ptr(2308, 2361, 1), new Range16.ptr(2365, 2384, 19), new Range16.ptr(2392, 2401, 1), new Range16.ptr(2417, 2432, 1), new Range16.ptr(2437, 2444, 1), new Range16.ptr(2447, 2448, 1), new Range16.ptr(2451, 2472, 1), new Range16.ptr(2474, 2480, 1), new Range16.ptr(2482, 2486, 4), new Range16.ptr(2487, 2489, 1), new Range16.ptr(2493, 2510, 17), new Range16.ptr(2524, 2525, 1), new Range16.ptr(2527, 2529, 1), new Range16.ptr(2544, 2545, 1), new Range16.ptr(2556, 2565, 9), new Range16.ptr(2566, 2570, 1), new Range16.ptr(2575, 2576, 1), new Range16.ptr(2579, 2600, 1), new Range16.ptr(2602, 2608, 1), new Range16.ptr(2610, 2611, 1), new Range16.ptr(2613, 2614, 1), new Range16.ptr(2616, 2617, 1), new Range16.ptr(2649, 2652, 1), new Range16.ptr(2654, 2674, 20), new Range16.ptr(2675, 2676, 1), new Range16.ptr(2693, 2701, 1), new Range16.ptr(2703, 2705, 1), new Range16.ptr(2707, 2728, 1), new Range16.ptr(2730, 2736, 1), new Range16.ptr(2738, 2739, 1), new Range16.ptr(2741, 2745, 1), new Range16.ptr(2749, 2768, 19), new Range16.ptr(2784, 2785, 1), new Range16.ptr(2809, 2821, 12), new Range16.ptr(2822, 2828, 1), new Range16.ptr(2831, 2832, 1), new Range16.ptr(2835, 2856, 1), new Range16.ptr(2858, 2864, 1), new Range16.ptr(2866, 2867, 1), new Range16.ptr(2869, 2873, 1), new Range16.ptr(2877, 2908, 31), new Range16.ptr(2909, 2911, 2), new Range16.ptr(2912, 2913, 1), new Range16.ptr(2929, 2947, 18), new Range16.ptr(2949, 2954, 1), new Range16.ptr(2958, 2960, 1), new Range16.ptr(2962, 2965, 1), new Range16.ptr(2969, 2970, 1), new Range16.ptr(2972, 2974, 2), new Range16.ptr(2975, 2979, 4), new Range16.ptr(2980, 2984, 4), new Range16.ptr(2985, 2986, 1), new Range16.ptr(2990, 3001, 1), new Range16.ptr(3024, 3077, 53), new Range16.ptr(3078, 3084, 1), new Range16.ptr(3086, 3088, 1), new Range16.ptr(3090, 3112, 1), new Range16.ptr(3114, 3129, 1), new Range16.ptr(3133, 3160, 27), new Range16.ptr(3161, 3162, 1), new Range16.ptr(3168, 3169, 1), new Range16.ptr(3200, 3205, 5), new Range16.ptr(3206, 3212, 1), new Range16.ptr(3214, 3216, 1), new Range16.ptr(3218, 3240, 1), new Range16.ptr(3242, 3251, 1), new Range16.ptr(3253, 3257, 1), new Range16.ptr(3261, 3294, 33), new Range16.ptr(3296, 3297, 1), new Range16.ptr(3313, 3314, 1), new Range16.ptr(3333, 3340, 1), new Range16.ptr(3342, 3344, 1), new Range16.ptr(3346, 3386, 1), new Range16.ptr(3389, 3406, 17), new Range16.ptr(3412, 3414, 1), new Range16.ptr(3423, 3425, 1), new Range16.ptr(3450, 3455, 1), new Range16.ptr(3461, 3478, 1), new Range16.ptr(3482, 3505, 1), new Range16.ptr(3507, 3515, 1), new Range16.ptr(3517, 3520, 3), new Range16.ptr(3521, 3526, 1), new Range16.ptr(3585, 3632, 1), new Range16.ptr(3634, 3635, 1), new Range16.ptr(3648, 3654, 1), new Range16.ptr(3713, 3714, 1), new Range16.ptr(3716, 3719, 3), new Range16.ptr(3720, 3722, 2), new Range16.ptr(3725, 3732, 7), new Range16.ptr(3733, 3735, 1), new Range16.ptr(3737, 3743, 1), new Range16.ptr(3745, 3747, 1), new Range16.ptr(3749, 3751, 2), new Range16.ptr(3754, 3755, 1), new Range16.ptr(3757, 3760, 1), new Range16.ptr(3762, 3763, 1), new Range16.ptr(3773, 3776, 3), new Range16.ptr(3777, 3780, 1), new Range16.ptr(3782, 3804, 22), new Range16.ptr(3805, 3807, 1), new Range16.ptr(3840, 3904, 64), new Range16.ptr(3905, 3911, 1), new Range16.ptr(3913, 3948, 1), new Range16.ptr(3976, 3980, 1), new Range16.ptr(4096, 4138, 1), new Range16.ptr(4159, 4176, 17), new Range16.ptr(4177, 4181, 1), new Range16.ptr(4186, 4189, 1), new Range16.ptr(4193, 4197, 4), new Range16.ptr(4198, 4206, 8), new Range16.ptr(4207, 4208, 1), new Range16.ptr(4213, 4225, 1), new Range16.ptr(4238, 4256, 18), new Range16.ptr(4257, 4293, 1), new Range16.ptr(4295, 4301, 6), new Range16.ptr(4304, 4346, 1), new Range16.ptr(4348, 4680, 1), new Range16.ptr(4682, 4685, 1), new Range16.ptr(4688, 4694, 1), new Range16.ptr(4696, 4698, 2), new Range16.ptr(4699, 4701, 1), new Range16.ptr(4704, 4744, 1), new Range16.ptr(4746, 4749, 1), new Range16.ptr(4752, 4784, 1), new Range16.ptr(4786, 4789, 1), new Range16.ptr(4792, 4798, 1), new Range16.ptr(4800, 4802, 2), new Range16.ptr(4803, 4805, 1), new Range16.ptr(4808, 4822, 1), new Range16.ptr(4824, 4880, 1), new Range16.ptr(4882, 4885, 1), new Range16.ptr(4888, 4954, 1), new Range16.ptr(4992, 5007, 1), new Range16.ptr(5024, 5109, 1), new Range16.ptr(5112, 5117, 1), new Range16.ptr(5121, 5740, 1), new Range16.ptr(5743, 5759, 1), new Range16.ptr(5761, 5786, 1), new Range16.ptr(5792, 5866, 1), new Range16.ptr(5873, 5880, 1), new Range16.ptr(5888, 5900, 1), new Range16.ptr(5902, 5905, 1), new Range16.ptr(5920, 5937, 1), new Range16.ptr(5952, 5969, 1), new Range16.ptr(5984, 5996, 1), new Range16.ptr(5998, 6000, 1), new Range16.ptr(6016, 6067, 1), new Range16.ptr(6103, 6108, 5), new Range16.ptr(6176, 6263, 1), new Range16.ptr(6272, 6276, 1), new Range16.ptr(6279, 6312, 1), new Range16.ptr(6314, 6320, 6), new Range16.ptr(6321, 6389, 1), new Range16.ptr(6400, 6430, 1), new Range16.ptr(6480, 6509, 1), new Range16.ptr(6512, 6516, 1), new Range16.ptr(6528, 6571, 1), new Range16.ptr(6576, 6601, 1), new Range16.ptr(6656, 6678, 1), new Range16.ptr(6688, 6740, 1), new Range16.ptr(6823, 6917, 94), new Range16.ptr(6918, 6963, 1), new Range16.ptr(6981, 6987, 1), new Range16.ptr(7043, 7072, 1), new Range16.ptr(7086, 7087, 1), new Range16.ptr(7098, 7141, 1), new Range16.ptr(7168, 7203, 1), new Range16.ptr(7245, 7247, 1), new Range16.ptr(7258, 7293, 1), new Range16.ptr(7296, 7304, 1), new Range16.ptr(7401, 7404, 1), new Range16.ptr(7406, 7409, 1), new Range16.ptr(7413, 7414, 1), new Range16.ptr(7424, 7615, 1), new Range16.ptr(7680, 7957, 1), new Range16.ptr(7960, 7965, 1), new Range16.ptr(7968, 8005, 1), new Range16.ptr(8008, 8013, 1), new Range16.ptr(8016, 8023, 1), new Range16.ptr(8025, 8031, 2), new Range16.ptr(8032, 8061, 1), new Range16.ptr(8064, 8116, 1), new Range16.ptr(8118, 8124, 1), new Range16.ptr(8126, 8130, 4), new Range16.ptr(8131, 8132, 1), new Range16.ptr(8134, 8140, 1), new Range16.ptr(8144, 8147, 1), new Range16.ptr(8150, 8155, 1), new Range16.ptr(8160, 8172, 1), new Range16.ptr(8178, 8180, 1), new Range16.ptr(8182, 8188, 1), new Range16.ptr(8305, 8319, 14), new Range16.ptr(8336, 8348, 1), new Range16.ptr(8450, 8455, 5), new Range16.ptr(8458, 8467, 1), new Range16.ptr(8469, 8473, 4), new Range16.ptr(8474, 8477, 1), new Range16.ptr(8484, 8490, 2), new Range16.ptr(8491, 8493, 1), new Range16.ptr(8495, 8505, 1), new Range16.ptr(8508, 8511, 1), new Range16.ptr(8517, 8521, 1), new Range16.ptr(8526, 8579, 53), new Range16.ptr(8580, 11264, 2684), new Range16.ptr(11265, 11310, 1), new Range16.ptr(11312, 11358, 1), new Range16.ptr(11360, 11492, 1), new Range16.ptr(11499, 11502, 1), new Range16.ptr(11506, 11507, 1), new Range16.ptr(11520, 11557, 1), new Range16.ptr(11559, 11565, 6), new Range16.ptr(11568, 11623, 1), new Range16.ptr(11631, 11648, 17), new Range16.ptr(11649, 11670, 1), new Range16.ptr(11680, 11686, 1), new Range16.ptr(11688, 11694, 1), new Range16.ptr(11696, 11702, 1), new Range16.ptr(11704, 11710, 1), new Range16.ptr(11712, 11718, 1), new Range16.ptr(11720, 11726, 1), new Range16.ptr(11728, 11734, 1), new Range16.ptr(11736, 11742, 1), new Range16.ptr(11823, 12293, 470), new Range16.ptr(12294, 12337, 43), new Range16.ptr(12338, 12341, 1), new Range16.ptr(12347, 12348, 1), new Range16.ptr(12353, 12438, 1), new Range16.ptr(12445, 12447, 1), new Range16.ptr(12449, 12538, 1), new Range16.ptr(12540, 12543, 1), new Range16.ptr(12549, 12590, 1), new Range16.ptr(12593, 12686, 1), new Range16.ptr(12704, 12730, 1), new Range16.ptr(12784, 12799, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40938, 1), new Range16.ptr(40960, 42124, 1), new Range16.ptr(42192, 42237, 1), new Range16.ptr(42240, 42508, 1), new Range16.ptr(42512, 42527, 1), new Range16.ptr(42538, 42539, 1), new Range16.ptr(42560, 42606, 1), new Range16.ptr(42623, 42653, 1), new Range16.ptr(42656, 42725, 1), new Range16.ptr(42775, 42783, 1), new Range16.ptr(42786, 42888, 1), new Range16.ptr(42891, 42926, 1), new Range16.ptr(42928, 42935, 1), new Range16.ptr(42999, 43009, 1), new Range16.ptr(43011, 43013, 1), new Range16.ptr(43015, 43018, 1), new Range16.ptr(43020, 43042, 1), new Range16.ptr(43072, 43123, 1), new Range16.ptr(43138, 43187, 1), new Range16.ptr(43250, 43255, 1), new Range16.ptr(43259, 43261, 2), new Range16.ptr(43274, 43301, 1), new Range16.ptr(43312, 43334, 1), new Range16.ptr(43360, 43388, 1), new Range16.ptr(43396, 43442, 1), new Range16.ptr(43471, 43488, 17), new Range16.ptr(43489, 43492, 1), new Range16.ptr(43494, 43503, 1), new Range16.ptr(43514, 43518, 1), new Range16.ptr(43520, 43560, 1), new Range16.ptr(43584, 43586, 1), new Range16.ptr(43588, 43595, 1), new Range16.ptr(43616, 43638, 1), new Range16.ptr(43642, 43646, 4), new Range16.ptr(43647, 43695, 1), new Range16.ptr(43697, 43701, 4), new Range16.ptr(43702, 43705, 3), new Range16.ptr(43706, 43709, 1), new Range16.ptr(43712, 43714, 2), new Range16.ptr(43739, 43741, 1), new Range16.ptr(43744, 43754, 1), new Range16.ptr(43762, 43764, 1), new Range16.ptr(43777, 43782, 1), new Range16.ptr(43785, 43790, 1), new Range16.ptr(43793, 43798, 1), new Range16.ptr(43808, 43814, 1), new Range16.ptr(43816, 43822, 1), new Range16.ptr(43824, 43866, 1), new Range16.ptr(43868, 43877, 1), new Range16.ptr(43888, 44002, 1), new Range16.ptr(44032, 55203, 1), new Range16.ptr(55216, 55238, 1), new Range16.ptr(55243, 55291, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1), new Range16.ptr(64256, 64262, 1), new Range16.ptr(64275, 64279, 1), new Range16.ptr(64285, 64287, 2), new Range16.ptr(64288, 64296, 1), new Range16.ptr(64298, 64310, 1), new Range16.ptr(64312, 64316, 1), new Range16.ptr(64318, 64320, 2), new Range16.ptr(64321, 64323, 2), new Range16.ptr(64324, 64326, 2), new Range16.ptr(64327, 64433, 1), new Range16.ptr(64467, 64829, 1), new Range16.ptr(64848, 64911, 1), new Range16.ptr(64914, 64967, 1), new Range16.ptr(65008, 65019, 1), new Range16.ptr(65136, 65140, 1), new Range16.ptr(65142, 65276, 1), new Range16.ptr(65313, 65338, 1), new Range16.ptr(65345, 65370, 1), new Range16.ptr(65382, 65470, 1), new Range16.ptr(65474, 65479, 1), new Range16.ptr(65482, 65487, 1), new Range16.ptr(65490, 65495, 1), new Range16.ptr(65498, 65500, 1)]), new sliceType$1([new Range32.ptr(65536, 65547, 1), new Range32.ptr(65549, 65574, 1), new Range32.ptr(65576, 65594, 1), new Range32.ptr(65596, 65597, 1), new Range32.ptr(65599, 65613, 1), new Range32.ptr(65616, 65629, 1), new Range32.ptr(65664, 65786, 1), new Range32.ptr(66176, 66204, 1), new Range32.ptr(66208, 66256, 1), new Range32.ptr(66304, 66335, 1), new Range32.ptr(66349, 66368, 1), new Range32.ptr(66370, 66377, 1), new Range32.ptr(66384, 66421, 1), new Range32.ptr(66432, 66461, 1), new Range32.ptr(66464, 66499, 1), new Range32.ptr(66504, 66511, 1), new Range32.ptr(66560, 66717, 1), new Range32.ptr(66736, 66771, 1), new Range32.ptr(66776, 66811, 1), new Range32.ptr(66816, 66855, 1), new Range32.ptr(66864, 66915, 1), new Range32.ptr(67072, 67382, 1), new Range32.ptr(67392, 67413, 1), new Range32.ptr(67424, 67431, 1), new Range32.ptr(67584, 67589, 1), new Range32.ptr(67592, 67594, 2), new Range32.ptr(67595, 67637, 1), new Range32.ptr(67639, 67640, 1), new Range32.ptr(67644, 67647, 3), new Range32.ptr(67648, 67669, 1), new Range32.ptr(67680, 67702, 1), new Range32.ptr(67712, 67742, 1), new Range32.ptr(67808, 67826, 1), new Range32.ptr(67828, 67829, 1), new Range32.ptr(67840, 67861, 1), new Range32.ptr(67872, 67897, 1), new Range32.ptr(67968, 68023, 1), new Range32.ptr(68030, 68031, 1), new Range32.ptr(68096, 68112, 16), new Range32.ptr(68113, 68115, 1), new Range32.ptr(68117, 68119, 1), new Range32.ptr(68121, 68147, 1), new Range32.ptr(68192, 68220, 1), new Range32.ptr(68224, 68252, 1), new Range32.ptr(68288, 68295, 1), new Range32.ptr(68297, 68324, 1), new Range32.ptr(68352, 68405, 1), new Range32.ptr(68416, 68437, 1), new Range32.ptr(68448, 68466, 1), new Range32.ptr(68480, 68497, 1), new Range32.ptr(68608, 68680, 1), new Range32.ptr(68736, 68786, 1), new Range32.ptr(68800, 68850, 1), new Range32.ptr(69635, 69687, 1), new Range32.ptr(69763, 69807, 1), new Range32.ptr(69840, 69864, 1), new Range32.ptr(69891, 69926, 1), new Range32.ptr(69968, 70002, 1), new Range32.ptr(70006, 70019, 13), new Range32.ptr(70020, 70066, 1), new Range32.ptr(70081, 70084, 1), new Range32.ptr(70106, 70108, 2), new Range32.ptr(70144, 70161, 1), new Range32.ptr(70163, 70187, 1), new Range32.ptr(70272, 70278, 1), new Range32.ptr(70280, 70282, 2), new Range32.ptr(70283, 70285, 1), new Range32.ptr(70287, 70301, 1), new Range32.ptr(70303, 70312, 1), new Range32.ptr(70320, 70366, 1), new Range32.ptr(70405, 70412, 1), new Range32.ptr(70415, 70416, 1), new Range32.ptr(70419, 70440, 1), new Range32.ptr(70442, 70448, 1), new Range32.ptr(70450, 70451, 1), new Range32.ptr(70453, 70457, 1), new Range32.ptr(70461, 70480, 19), new Range32.ptr(70493, 70497, 1), new Range32.ptr(70656, 70708, 1), new Range32.ptr(70727, 70730, 1), new Range32.ptr(70784, 70831, 1), new Range32.ptr(70852, 70853, 1), new Range32.ptr(70855, 71040, 185), new Range32.ptr(71041, 71086, 1), new Range32.ptr(71128, 71131, 1), new Range32.ptr(71168, 71215, 1), new Range32.ptr(71236, 71296, 60), new Range32.ptr(71297, 71338, 1), new Range32.ptr(71424, 71449, 1), new Range32.ptr(71840, 71903, 1), new Range32.ptr(71935, 72192, 257), new Range32.ptr(72203, 72242, 1), new Range32.ptr(72250, 72272, 22), new Range32.ptr(72284, 72323, 1), new Range32.ptr(72326, 72329, 1), new Range32.ptr(72384, 72440, 1), new Range32.ptr(72704, 72712, 1), new Range32.ptr(72714, 72750, 1), new Range32.ptr(72768, 72818, 50), new Range32.ptr(72819, 72847, 1), new Range32.ptr(72960, 72966, 1), new Range32.ptr(72968, 72969, 1), new Range32.ptr(72971, 73008, 1), new Range32.ptr(73030, 73728, 698), new Range32.ptr(73729, 74649, 1), new Range32.ptr(74880, 75075, 1), new Range32.ptr(77824, 78894, 1), new Range32.ptr(82944, 83526, 1), new Range32.ptr(92160, 92728, 1), new Range32.ptr(92736, 92766, 1), new Range32.ptr(92880, 92909, 1), new Range32.ptr(92928, 92975, 1), new Range32.ptr(92992, 92995, 1), new Range32.ptr(93027, 93047, 1), new Range32.ptr(93053, 93071, 1), new Range32.ptr(93952, 94020, 1), new Range32.ptr(94032, 94099, 67), new Range32.ptr(94100, 94111, 1), new Range32.ptr(94176, 94177, 1), new Range32.ptr(94208, 100332, 1), new Range32.ptr(100352, 101106, 1), new Range32.ptr(110592, 110878, 1), new Range32.ptr(110960, 111355, 1), new Range32.ptr(113664, 113770, 1), new Range32.ptr(113776, 113788, 1), new Range32.ptr(113792, 113800, 1), new Range32.ptr(113808, 113817, 1), new Range32.ptr(119808, 119892, 1), new Range32.ptr(119894, 119964, 1), new Range32.ptr(119966, 119967, 1), new Range32.ptr(119970, 119973, 3), new Range32.ptr(119974, 119977, 3), new Range32.ptr(119978, 119980, 1), new Range32.ptr(119982, 119993, 1), new Range32.ptr(119995, 119997, 2), new Range32.ptr(119998, 120003, 1), new Range32.ptr(120005, 120069, 1), new Range32.ptr(120071, 120074, 1), new Range32.ptr(120077, 120084, 1), new Range32.ptr(120086, 120092, 1), new Range32.ptr(120094, 120121, 1), new Range32.ptr(120123, 120126, 1), new Range32.ptr(120128, 120132, 1), new Range32.ptr(120134, 120138, 4), new Range32.ptr(120139, 120144, 1), new Range32.ptr(120146, 120485, 1), new Range32.ptr(120488, 120512, 1), new Range32.ptr(120514, 120538, 1), new Range32.ptr(120540, 120570, 1), new Range32.ptr(120572, 120596, 1), new Range32.ptr(120598, 120628, 1), new Range32.ptr(120630, 120654, 1), new Range32.ptr(120656, 120686, 1), new Range32.ptr(120688, 120712, 1), new Range32.ptr(120714, 120744, 1), new Range32.ptr(120746, 120770, 1), new Range32.ptr(120772, 120779, 1), new Range32.ptr(124928, 125124, 1), new Range32.ptr(125184, 125251, 1), new Range32.ptr(126464, 126467, 1), new Range32.ptr(126469, 126495, 1), new Range32.ptr(126497, 126498, 1), new Range32.ptr(126500, 126503, 3), new Range32.ptr(126505, 126514, 1), new Range32.ptr(126516, 126519, 1), new Range32.ptr(126521, 126523, 2), new Range32.ptr(126530, 126535, 5), new Range32.ptr(126537, 126541, 2), new Range32.ptr(126542, 126543, 1), new Range32.ptr(126545, 126546, 1), new Range32.ptr(126548, 126551, 3), new Range32.ptr(126553, 126561, 2), new Range32.ptr(126562, 126564, 2), new Range32.ptr(126567, 126570, 1), new Range32.ptr(126572, 126578, 1), new Range32.ptr(126580, 126583, 1), new Range32.ptr(126585, 126588, 1), new Range32.ptr(126590, 126592, 2), new Range32.ptr(126593, 126601, 1), new Range32.ptr(126603, 126619, 1), new Range32.ptr(126625, 126627, 1), new Range32.ptr(126629, 126633, 1), new Range32.ptr(126635, 126651, 1), new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(183984, 191456, 1), new Range32.ptr(194560, 195101, 1)]), 6);
		_M = new RangeTable.ptr(new sliceType([new Range16.ptr(768, 879, 1), new Range16.ptr(1155, 1161, 1), new Range16.ptr(1425, 1469, 1), new Range16.ptr(1471, 1473, 2), new Range16.ptr(1474, 1476, 2), new Range16.ptr(1477, 1479, 2), new Range16.ptr(1552, 1562, 1), new Range16.ptr(1611, 1631, 1), new Range16.ptr(1648, 1750, 102), new Range16.ptr(1751, 1756, 1), new Range16.ptr(1759, 1764, 1), new Range16.ptr(1767, 1768, 1), new Range16.ptr(1770, 1773, 1), new Range16.ptr(1809, 1840, 31), new Range16.ptr(1841, 1866, 1), new Range16.ptr(1958, 1968, 1), new Range16.ptr(2027, 2035, 1), new Range16.ptr(2070, 2073, 1), new Range16.ptr(2075, 2083, 1), new Range16.ptr(2085, 2087, 1), new Range16.ptr(2089, 2093, 1), new Range16.ptr(2137, 2139, 1), new Range16.ptr(2260, 2273, 1), new Range16.ptr(2275, 2307, 1), new Range16.ptr(2362, 2364, 1), new Range16.ptr(2366, 2383, 1), new Range16.ptr(2385, 2391, 1), new Range16.ptr(2402, 2403, 1), new Range16.ptr(2433, 2435, 1), new Range16.ptr(2492, 2494, 2), new Range16.ptr(2495, 2500, 1), new Range16.ptr(2503, 2504, 1), new Range16.ptr(2507, 2509, 1), new Range16.ptr(2519, 2530, 11), new Range16.ptr(2531, 2561, 30), new Range16.ptr(2562, 2563, 1), new Range16.ptr(2620, 2622, 2), new Range16.ptr(2623, 2626, 1), new Range16.ptr(2631, 2632, 1), new Range16.ptr(2635, 2637, 1), new Range16.ptr(2641, 2672, 31), new Range16.ptr(2673, 2677, 4), new Range16.ptr(2689, 2691, 1), new Range16.ptr(2748, 2750, 2), new Range16.ptr(2751, 2757, 1), new Range16.ptr(2759, 2761, 1), new Range16.ptr(2763, 2765, 1), new Range16.ptr(2786, 2787, 1), new Range16.ptr(2810, 2815, 1), new Range16.ptr(2817, 2819, 1), new Range16.ptr(2876, 2878, 2), new Range16.ptr(2879, 2884, 1), new Range16.ptr(2887, 2888, 1), new Range16.ptr(2891, 2893, 1), new Range16.ptr(2902, 2903, 1), new Range16.ptr(2914, 2915, 1), new Range16.ptr(2946, 3006, 60), new Range16.ptr(3007, 3010, 1), new Range16.ptr(3014, 3016, 1), new Range16.ptr(3018, 3021, 1), new Range16.ptr(3031, 3072, 41), new Range16.ptr(3073, 3075, 1), new Range16.ptr(3134, 3140, 1), new Range16.ptr(3142, 3144, 1), new Range16.ptr(3146, 3149, 1), new Range16.ptr(3157, 3158, 1), new Range16.ptr(3170, 3171, 1), new Range16.ptr(3201, 3203, 1), new Range16.ptr(3260, 3262, 2), new Range16.ptr(3263, 3268, 1), new Range16.ptr(3270, 3272, 1), new Range16.ptr(3274, 3277, 1), new Range16.ptr(3285, 3286, 1), new Range16.ptr(3298, 3299, 1), new Range16.ptr(3328, 3331, 1), new Range16.ptr(3387, 3388, 1), new Range16.ptr(3390, 3396, 1), new Range16.ptr(3398, 3400, 1), new Range16.ptr(3402, 3405, 1), new Range16.ptr(3415, 3426, 11), new Range16.ptr(3427, 3458, 31), new Range16.ptr(3459, 3530, 71), new Range16.ptr(3535, 3540, 1), new Range16.ptr(3542, 3544, 2), new Range16.ptr(3545, 3551, 1), new Range16.ptr(3570, 3571, 1), new Range16.ptr(3633, 3636, 3), new Range16.ptr(3637, 3642, 1), new Range16.ptr(3655, 3662, 1), new Range16.ptr(3761, 3764, 3), new Range16.ptr(3765, 3769, 1), new Range16.ptr(3771, 3772, 1), new Range16.ptr(3784, 3789, 1), new Range16.ptr(3864, 3865, 1), new Range16.ptr(3893, 3897, 2), new Range16.ptr(3902, 3903, 1), new Range16.ptr(3953, 3972, 1), new Range16.ptr(3974, 3975, 1), new Range16.ptr(3981, 3991, 1), new Range16.ptr(3993, 4028, 1), new Range16.ptr(4038, 4139, 101), new Range16.ptr(4140, 4158, 1), new Range16.ptr(4182, 4185, 1), new Range16.ptr(4190, 4192, 1), new Range16.ptr(4194, 4196, 1), new Range16.ptr(4199, 4205, 1), new Range16.ptr(4209, 4212, 1), new Range16.ptr(4226, 4237, 1), new Range16.ptr(4239, 4250, 11), new Range16.ptr(4251, 4253, 1), new Range16.ptr(4957, 4959, 1), new Range16.ptr(5906, 5908, 1), new Range16.ptr(5938, 5940, 1), new Range16.ptr(5970, 5971, 1), new Range16.ptr(6002, 6003, 1), new Range16.ptr(6068, 6099, 1), new Range16.ptr(6109, 6155, 46), new Range16.ptr(6156, 6157, 1), new Range16.ptr(6277, 6278, 1), new Range16.ptr(6313, 6432, 119), new Range16.ptr(6433, 6443, 1), new Range16.ptr(6448, 6459, 1), new Range16.ptr(6679, 6683, 1), new Range16.ptr(6741, 6750, 1), new Range16.ptr(6752, 6780, 1), new Range16.ptr(6783, 6832, 49), new Range16.ptr(6833, 6846, 1), new Range16.ptr(6912, 6916, 1), new Range16.ptr(6964, 6980, 1), new Range16.ptr(7019, 7027, 1), new Range16.ptr(7040, 7042, 1), new Range16.ptr(7073, 7085, 1), new Range16.ptr(7142, 7155, 1), new Range16.ptr(7204, 7223, 1), new Range16.ptr(7376, 7378, 1), new Range16.ptr(7380, 7400, 1), new Range16.ptr(7405, 7410, 5), new Range16.ptr(7411, 7412, 1), new Range16.ptr(7415, 7417, 1), new Range16.ptr(7616, 7673, 1), new Range16.ptr(7675, 7679, 1), new Range16.ptr(8400, 8432, 1), new Range16.ptr(11503, 11505, 1), new Range16.ptr(11647, 11744, 97), new Range16.ptr(11745, 11775, 1), new Range16.ptr(12330, 12335, 1), new Range16.ptr(12441, 12442, 1), new Range16.ptr(42607, 42610, 1), new Range16.ptr(42612, 42621, 1), new Range16.ptr(42654, 42655, 1), new Range16.ptr(42736, 42737, 1), new Range16.ptr(43010, 43014, 4), new Range16.ptr(43019, 43043, 24), new Range16.ptr(43044, 43047, 1), new Range16.ptr(43136, 43137, 1), new Range16.ptr(43188, 43205, 1), new Range16.ptr(43232, 43249, 1), new Range16.ptr(43302, 43309, 1), new Range16.ptr(43335, 43347, 1), new Range16.ptr(43392, 43395, 1), new Range16.ptr(43443, 43456, 1), new Range16.ptr(43493, 43561, 68), new Range16.ptr(43562, 43574, 1), new Range16.ptr(43587, 43596, 9), new Range16.ptr(43597, 43643, 46), new Range16.ptr(43644, 43645, 1), new Range16.ptr(43696, 43698, 2), new Range16.ptr(43699, 43700, 1), new Range16.ptr(43703, 43704, 1), new Range16.ptr(43710, 43711, 1), new Range16.ptr(43713, 43755, 42), new Range16.ptr(43756, 43759, 1), new Range16.ptr(43765, 43766, 1), new Range16.ptr(44003, 44010, 1), new Range16.ptr(44012, 44013, 1), new Range16.ptr(64286, 65024, 738), new Range16.ptr(65025, 65039, 1), new Range16.ptr(65056, 65071, 1)]), new sliceType$1([new Range32.ptr(66045, 66272, 227), new Range32.ptr(66422, 66426, 1), new Range32.ptr(68097, 68099, 1), new Range32.ptr(68101, 68102, 1), new Range32.ptr(68108, 68111, 1), new Range32.ptr(68152, 68154, 1), new Range32.ptr(68159, 68325, 166), new Range32.ptr(68326, 69632, 1306), new Range32.ptr(69633, 69634, 1), new Range32.ptr(69688, 69702, 1), new Range32.ptr(69759, 69762, 1), new Range32.ptr(69808, 69818, 1), new Range32.ptr(69888, 69890, 1), new Range32.ptr(69927, 69940, 1), new Range32.ptr(70003, 70016, 13), new Range32.ptr(70017, 70018, 1), new Range32.ptr(70067, 70080, 1), new Range32.ptr(70090, 70092, 1), new Range32.ptr(70188, 70199, 1), new Range32.ptr(70206, 70367, 161), new Range32.ptr(70368, 70378, 1), new Range32.ptr(70400, 70403, 1), new Range32.ptr(70460, 70462, 2), new Range32.ptr(70463, 70468, 1), new Range32.ptr(70471, 70472, 1), new Range32.ptr(70475, 70477, 1), new Range32.ptr(70487, 70498, 11), new Range32.ptr(70499, 70502, 3), new Range32.ptr(70503, 70508, 1), new Range32.ptr(70512, 70516, 1), new Range32.ptr(70709, 70726, 1), new Range32.ptr(70832, 70851, 1), new Range32.ptr(71087, 71093, 1), new Range32.ptr(71096, 71104, 1), new Range32.ptr(71132, 71133, 1), new Range32.ptr(71216, 71232, 1), new Range32.ptr(71339, 71351, 1), new Range32.ptr(71453, 71467, 1), new Range32.ptr(72193, 72202, 1), new Range32.ptr(72243, 72249, 1), new Range32.ptr(72251, 72254, 1), new Range32.ptr(72263, 72273, 10), new Range32.ptr(72274, 72283, 1), new Range32.ptr(72330, 72345, 1), new Range32.ptr(72751, 72758, 1), new Range32.ptr(72760, 72767, 1), new Range32.ptr(72850, 72871, 1), new Range32.ptr(72873, 72886, 1), new Range32.ptr(73009, 73014, 1), new Range32.ptr(73018, 73020, 2), new Range32.ptr(73021, 73023, 2), new Range32.ptr(73024, 73029, 1), new Range32.ptr(73031, 92912, 19881), new Range32.ptr(92913, 92916, 1), new Range32.ptr(92976, 92982, 1), new Range32.ptr(94033, 94078, 1), new Range32.ptr(94095, 94098, 1), new Range32.ptr(113821, 113822, 1), new Range32.ptr(119141, 119145, 1), new Range32.ptr(119149, 119154, 1), new Range32.ptr(119163, 119170, 1), new Range32.ptr(119173, 119179, 1), new Range32.ptr(119210, 119213, 1), new Range32.ptr(119362, 119364, 1), new Range32.ptr(121344, 121398, 1), new Range32.ptr(121403, 121452, 1), new Range32.ptr(121461, 121476, 15), new Range32.ptr(121499, 121503, 1), new Range32.ptr(121505, 121519, 1), new Range32.ptr(122880, 122886, 1), new Range32.ptr(122888, 122904, 1), new Range32.ptr(122907, 122913, 1), new Range32.ptr(122915, 122916, 1), new Range32.ptr(122918, 122922, 1), new Range32.ptr(125136, 125142, 1), new Range32.ptr(125252, 125258, 1), new Range32.ptr(917760, 917999, 1)]), 0);
		_N = new RangeTable.ptr(new sliceType([new Range16.ptr(48, 57, 1), new Range16.ptr(178, 179, 1), new Range16.ptr(185, 188, 3), new Range16.ptr(189, 190, 1), new Range16.ptr(1632, 1641, 1), new Range16.ptr(1776, 1785, 1), new Range16.ptr(1984, 1993, 1), new Range16.ptr(2406, 2415, 1), new Range16.ptr(2534, 2543, 1), new Range16.ptr(2548, 2553, 1), new Range16.ptr(2662, 2671, 1), new Range16.ptr(2790, 2799, 1), new Range16.ptr(2918, 2927, 1), new Range16.ptr(2930, 2935, 1), new Range16.ptr(3046, 3058, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3192, 3198, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3416, 3422, 1), new Range16.ptr(3430, 3448, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3664, 3673, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3872, 3891, 1), new Range16.ptr(4160, 4169, 1), new Range16.ptr(4240, 4249, 1), new Range16.ptr(4969, 4988, 1), new Range16.ptr(5870, 5872, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6128, 6137, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6470, 6479, 1), new Range16.ptr(6608, 6618, 1), new Range16.ptr(6784, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6992, 7001, 1), new Range16.ptr(7088, 7097, 1), new Range16.ptr(7232, 7241, 1), new Range16.ptr(7248, 7257, 1), new Range16.ptr(8304, 8308, 4), new Range16.ptr(8309, 8313, 1), new Range16.ptr(8320, 8329, 1), new Range16.ptr(8528, 8578, 1), new Range16.ptr(8581, 8585, 1), new Range16.ptr(9312, 9371, 1), new Range16.ptr(9450, 9471, 1), new Range16.ptr(10102, 10131, 1), new Range16.ptr(11517, 12295, 778), new Range16.ptr(12321, 12329, 1), new Range16.ptr(12344, 12346, 1), new Range16.ptr(12690, 12693, 1), new Range16.ptr(12832, 12841, 1), new Range16.ptr(12872, 12879, 1), new Range16.ptr(12881, 12895, 1), new Range16.ptr(12928, 12937, 1), new Range16.ptr(12977, 12991, 1), new Range16.ptr(42528, 42537, 1), new Range16.ptr(42726, 42735, 1), new Range16.ptr(43056, 43061, 1), new Range16.ptr(43216, 43225, 1), new Range16.ptr(43264, 43273, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43504, 43513, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(44016, 44025, 1), new Range16.ptr(65296, 65305, 1)]), new sliceType$1([new Range32.ptr(65799, 65843, 1), new Range32.ptr(65856, 65912, 1), new Range32.ptr(65930, 65931, 1), new Range32.ptr(66273, 66299, 1), new Range32.ptr(66336, 66339, 1), new Range32.ptr(66369, 66378, 9), new Range32.ptr(66513, 66517, 1), new Range32.ptr(66720, 66729, 1), new Range32.ptr(67672, 67679, 1), new Range32.ptr(67705, 67711, 1), new Range32.ptr(67751, 67759, 1), new Range32.ptr(67835, 67839, 1), new Range32.ptr(67862, 67867, 1), new Range32.ptr(68028, 68029, 1), new Range32.ptr(68032, 68047, 1), new Range32.ptr(68050, 68095, 1), new Range32.ptr(68160, 68167, 1), new Range32.ptr(68221, 68222, 1), new Range32.ptr(68253, 68255, 1), new Range32.ptr(68331, 68335, 1), new Range32.ptr(68440, 68447, 1), new Range32.ptr(68472, 68479, 1), new Range32.ptr(68521, 68527, 1), new Range32.ptr(68858, 68863, 1), new Range32.ptr(69216, 69246, 1), new Range32.ptr(69714, 69743, 1), new Range32.ptr(69872, 69881, 1), new Range32.ptr(69942, 69951, 1), new Range32.ptr(70096, 70105, 1), new Range32.ptr(70113, 70132, 1), new Range32.ptr(70384, 70393, 1), new Range32.ptr(70736, 70745, 1), new Range32.ptr(70864, 70873, 1), new Range32.ptr(71248, 71257, 1), new Range32.ptr(71360, 71369, 1), new Range32.ptr(71472, 71483, 1), new Range32.ptr(71904, 71922, 1), new Range32.ptr(72784, 72812, 1), new Range32.ptr(73040, 73049, 1), new Range32.ptr(74752, 74862, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(93019, 93025, 1), new Range32.ptr(119648, 119665, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(125127, 125135, 1), new Range32.ptr(125264, 125273, 1), new Range32.ptr(127232, 127244, 1)]), 4);
		_Nd = new RangeTable.ptr(new sliceType([new Range16.ptr(48, 57, 1), new Range16.ptr(1632, 1641, 1), new Range16.ptr(1776, 1785, 1), new Range16.ptr(1984, 1993, 1), new Range16.ptr(2406, 2415, 1), new Range16.ptr(2534, 2543, 1), new Range16.ptr(2662, 2671, 1), new Range16.ptr(2790, 2799, 1), new Range16.ptr(2918, 2927, 1), new Range16.ptr(3046, 3055, 1), new Range16.ptr(3174, 3183, 1), new Range16.ptr(3302, 3311, 1), new Range16.ptr(3430, 3439, 1), new Range16.ptr(3558, 3567, 1), new Range16.ptr(3664, 3673, 1), new Range16.ptr(3792, 3801, 1), new Range16.ptr(3872, 3881, 1), new Range16.ptr(4160, 4169, 1), new Range16.ptr(4240, 4249, 1), new Range16.ptr(6112, 6121, 1), new Range16.ptr(6160, 6169, 1), new Range16.ptr(6470, 6479, 1), new Range16.ptr(6608, 6617, 1), new Range16.ptr(6784, 6793, 1), new Range16.ptr(6800, 6809, 1), new Range16.ptr(6992, 7001, 1), new Range16.ptr(7088, 7097, 1), new Range16.ptr(7232, 7241, 1), new Range16.ptr(7248, 7257, 1), new Range16.ptr(42528, 42537, 1), new Range16.ptr(43216, 43225, 1), new Range16.ptr(43264, 43273, 1), new Range16.ptr(43472, 43481, 1), new Range16.ptr(43504, 43513, 1), new Range16.ptr(43600, 43609, 1), new Range16.ptr(44016, 44025, 1), new Range16.ptr(65296, 65305, 1)]), new sliceType$1([new Range32.ptr(66720, 66729, 1), new Range32.ptr(69734, 69743, 1), new Range32.ptr(69872, 69881, 1), new Range32.ptr(69942, 69951, 1), new Range32.ptr(70096, 70105, 1), new Range32.ptr(70384, 70393, 1), new Range32.ptr(70736, 70745, 1), new Range32.ptr(70864, 70873, 1), new Range32.ptr(71248, 71257, 1), new Range32.ptr(71360, 71369, 1), new Range32.ptr(71472, 71481, 1), new Range32.ptr(71904, 71913, 1), new Range32.ptr(72784, 72793, 1), new Range32.ptr(73040, 73049, 1), new Range32.ptr(92768, 92777, 1), new Range32.ptr(93008, 93017, 1), new Range32.ptr(120782, 120831, 1), new Range32.ptr(125264, 125273, 1)]), 1);
		_P = new RangeTable.ptr(new sliceType([new Range16.ptr(33, 35, 1), new Range16.ptr(37, 42, 1), new Range16.ptr(44, 47, 1), new Range16.ptr(58, 59, 1), new Range16.ptr(63, 64, 1), new Range16.ptr(91, 93, 1), new Range16.ptr(95, 123, 28), new Range16.ptr(125, 161, 36), new Range16.ptr(167, 171, 4), new Range16.ptr(182, 183, 1), new Range16.ptr(187, 191, 4), new Range16.ptr(894, 903, 9), new Range16.ptr(1370, 1375, 1), new Range16.ptr(1417, 1418, 1), new Range16.ptr(1470, 1472, 2), new Range16.ptr(1475, 1478, 3), new Range16.ptr(1523, 1524, 1), new Range16.ptr(1545, 1546, 1), new Range16.ptr(1548, 1549, 1), new Range16.ptr(1563, 1566, 3), new Range16.ptr(1567, 1642, 75), new Range16.ptr(1643, 1645, 1), new Range16.ptr(1748, 1792, 44), new Range16.ptr(1793, 1805, 1), new Range16.ptr(2039, 2041, 1), new Range16.ptr(2096, 2110, 1), new Range16.ptr(2142, 2404, 262), new Range16.ptr(2405, 2416, 11), new Range16.ptr(2557, 2800, 243), new Range16.ptr(3572, 3663, 91), new Range16.ptr(3674, 3675, 1), new Range16.ptr(3844, 3858, 1), new Range16.ptr(3860, 3898, 38), new Range16.ptr(3899, 3901, 1), new Range16.ptr(3973, 4048, 75), new Range16.ptr(4049, 4052, 1), new Range16.ptr(4057, 4058, 1), new Range16.ptr(4170, 4175, 1), new Range16.ptr(4347, 4960, 613), new Range16.ptr(4961, 4968, 1), new Range16.ptr(5120, 5741, 621), new Range16.ptr(5742, 5787, 45), new Range16.ptr(5788, 5867, 79), new Range16.ptr(5868, 5869, 1), new Range16.ptr(5941, 5942, 1), new Range16.ptr(6100, 6102, 1), new Range16.ptr(6104, 6106, 1), new Range16.ptr(6144, 6154, 1), new Range16.ptr(6468, 6469, 1), new Range16.ptr(6686, 6687, 1), new Range16.ptr(6816, 6822, 1), new Range16.ptr(6824, 6829, 1), new Range16.ptr(7002, 7008, 1), new Range16.ptr(7164, 7167, 1), new Range16.ptr(7227, 7231, 1), new Range16.ptr(7294, 7295, 1), new Range16.ptr(7360, 7367, 1), new Range16.ptr(7379, 8208, 829), new Range16.ptr(8209, 8231, 1), new Range16.ptr(8240, 8259, 1), new Range16.ptr(8261, 8273, 1), new Range16.ptr(8275, 8286, 1), new Range16.ptr(8317, 8318, 1), new Range16.ptr(8333, 8334, 1), new Range16.ptr(8968, 8971, 1), new Range16.ptr(9001, 9002, 1), new Range16.ptr(10088, 10101, 1), new Range16.ptr(10181, 10182, 1), new Range16.ptr(10214, 10223, 1), new Range16.ptr(10627, 10648, 1), new Range16.ptr(10712, 10715, 1), new Range16.ptr(10748, 10749, 1), new Range16.ptr(11513, 11516, 1), new Range16.ptr(11518, 11519, 1), new Range16.ptr(11632, 11776, 144), new Range16.ptr(11777, 11822, 1), new Range16.ptr(11824, 11849, 1), new Range16.ptr(12289, 12291, 1), new Range16.ptr(12296, 12305, 1), new Range16.ptr(12308, 12319, 1), new Range16.ptr(12336, 12349, 13), new Range16.ptr(12448, 12539, 91), new Range16.ptr(42238, 42239, 1), new Range16.ptr(42509, 42511, 1), new Range16.ptr(42611, 42622, 11), new Range16.ptr(42738, 42743, 1), new Range16.ptr(43124, 43127, 1), new Range16.ptr(43214, 43215, 1), new Range16.ptr(43256, 43258, 1), new Range16.ptr(43260, 43310, 50), new Range16.ptr(43311, 43359, 48), new Range16.ptr(43457, 43469, 1), new Range16.ptr(43486, 43487, 1), new Range16.ptr(43612, 43615, 1), new Range16.ptr(43742, 43743, 1), new Range16.ptr(43760, 43761, 1), new Range16.ptr(44011, 64830, 20819), new Range16.ptr(64831, 65040, 209), new Range16.ptr(65041, 65049, 1), new Range16.ptr(65072, 65106, 1), new Range16.ptr(65108, 65121, 1), new Range16.ptr(65123, 65128, 5), new Range16.ptr(65130, 65131, 1), new Range16.ptr(65281, 65283, 1), new Range16.ptr(65285, 65290, 1), new Range16.ptr(65292, 65295, 1), new Range16.ptr(65306, 65307, 1), new Range16.ptr(65311, 65312, 1), new Range16.ptr(65339, 65341, 1), new Range16.ptr(65343, 65371, 28), new Range16.ptr(65373, 65375, 2), new Range16.ptr(65376, 65381, 1)]), new sliceType$1([new Range32.ptr(65792, 65794, 1), new Range32.ptr(66463, 66512, 49), new Range32.ptr(66927, 67671, 744), new Range32.ptr(67871, 67903, 32), new Range32.ptr(68176, 68184, 1), new Range32.ptr(68223, 68336, 113), new Range32.ptr(68337, 68342, 1), new Range32.ptr(68409, 68415, 1), new Range32.ptr(68505, 68508, 1), new Range32.ptr(69703, 69709, 1), new Range32.ptr(69819, 69820, 1), new Range32.ptr(69822, 69825, 1), new Range32.ptr(69952, 69955, 1), new Range32.ptr(70004, 70005, 1), new Range32.ptr(70085, 70089, 1), new Range32.ptr(70093, 70107, 14), new Range32.ptr(70109, 70111, 1), new Range32.ptr(70200, 70205, 1), new Range32.ptr(70313, 70731, 418), new Range32.ptr(70732, 70735, 1), new Range32.ptr(70747, 70749, 2), new Range32.ptr(70854, 71105, 251), new Range32.ptr(71106, 71127, 1), new Range32.ptr(71233, 71235, 1), new Range32.ptr(71264, 71276, 1), new Range32.ptr(71484, 71486, 1), new Range32.ptr(72255, 72262, 1), new Range32.ptr(72346, 72348, 1), new Range32.ptr(72350, 72354, 1), new Range32.ptr(72769, 72773, 1), new Range32.ptr(72816, 72817, 1), new Range32.ptr(74864, 74868, 1), new Range32.ptr(92782, 92783, 1), new Range32.ptr(92917, 92983, 66), new Range32.ptr(92984, 92987, 1), new Range32.ptr(92996, 113823, 20827), new Range32.ptr(121479, 121483, 1), new Range32.ptr(125278, 125279, 1)]), 11);
		_S = new RangeTable.ptr(new sliceType([new Range16.ptr(36, 43, 7), new Range16.ptr(60, 62, 1), new Range16.ptr(94, 96, 2), new Range16.ptr(124, 126, 2), new Range16.ptr(162, 166, 1), new Range16.ptr(168, 169, 1), new Range16.ptr(172, 174, 2), new Range16.ptr(175, 177, 1), new Range16.ptr(180, 184, 4), new Range16.ptr(215, 247, 32), new Range16.ptr(706, 709, 1), new Range16.ptr(722, 735, 1), new Range16.ptr(741, 747, 1), new Range16.ptr(749, 751, 2), new Range16.ptr(752, 767, 1), new Range16.ptr(885, 900, 15), new Range16.ptr(901, 1014, 113), new Range16.ptr(1154, 1421, 267), new Range16.ptr(1422, 1423, 1), new Range16.ptr(1542, 1544, 1), new Range16.ptr(1547, 1550, 3), new Range16.ptr(1551, 1758, 207), new Range16.ptr(1769, 1789, 20), new Range16.ptr(1790, 2038, 248), new Range16.ptr(2546, 2547, 1), new Range16.ptr(2554, 2555, 1), new Range16.ptr(2801, 2928, 127), new Range16.ptr(3059, 3066, 1), new Range16.ptr(3199, 3407, 208), new Range16.ptr(3449, 3647, 198), new Range16.ptr(3841, 3843, 1), new Range16.ptr(3859, 3861, 2), new Range16.ptr(3862, 3863, 1), new Range16.ptr(3866, 3871, 1), new Range16.ptr(3892, 3896, 2), new Range16.ptr(4030, 4037, 1), new Range16.ptr(4039, 4044, 1), new Range16.ptr(4046, 4047, 1), new Range16.ptr(4053, 4056, 1), new Range16.ptr(4254, 4255, 1), new Range16.ptr(5008, 5017, 1), new Range16.ptr(6107, 6464, 357), new Range16.ptr(6622, 6655, 1), new Range16.ptr(7009, 7018, 1), new Range16.ptr(7028, 7036, 1), new Range16.ptr(8125, 8127, 2), new Range16.ptr(8128, 8129, 1), new Range16.ptr(8141, 8143, 1), new Range16.ptr(8157, 8159, 1), new Range16.ptr(8173, 8175, 1), new Range16.ptr(8189, 8190, 1), new Range16.ptr(8260, 8274, 14), new Range16.ptr(8314, 8316, 1), new Range16.ptr(8330, 8332, 1), new Range16.ptr(8352, 8383, 1), new Range16.ptr(8448, 8449, 1), new Range16.ptr(8451, 8454, 1), new Range16.ptr(8456, 8457, 1), new Range16.ptr(8468, 8470, 2), new Range16.ptr(8471, 8472, 1), new Range16.ptr(8478, 8483, 1), new Range16.ptr(8485, 8489, 2), new Range16.ptr(8494, 8506, 12), new Range16.ptr(8507, 8512, 5), new Range16.ptr(8513, 8516, 1), new Range16.ptr(8522, 8525, 1), new Range16.ptr(8527, 8586, 59), new Range16.ptr(8587, 8592, 5), new Range16.ptr(8593, 8967, 1), new Range16.ptr(8972, 9000, 1), new Range16.ptr(9003, 9254, 1), new Range16.ptr(9280, 9290, 1), new Range16.ptr(9372, 9449, 1), new Range16.ptr(9472, 10087, 1), new Range16.ptr(10132, 10180, 1), new Range16.ptr(10183, 10213, 1), new Range16.ptr(10224, 10626, 1), new Range16.ptr(10649, 10711, 1), new Range16.ptr(10716, 10747, 1), new Range16.ptr(10750, 11123, 1), new Range16.ptr(11126, 11157, 1), new Range16.ptr(11160, 11193, 1), new Range16.ptr(11197, 11208, 1), new Range16.ptr(11210, 11218, 1), new Range16.ptr(11244, 11247, 1), new Range16.ptr(11493, 11498, 1), new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12272, 12283, 1), new Range16.ptr(12292, 12306, 14), new Range16.ptr(12307, 12320, 13), new Range16.ptr(12342, 12343, 1), new Range16.ptr(12350, 12351, 1), new Range16.ptr(12443, 12444, 1), new Range16.ptr(12688, 12689, 1), new Range16.ptr(12694, 12703, 1), new Range16.ptr(12736, 12771, 1), new Range16.ptr(12800, 12830, 1), new Range16.ptr(12842, 12871, 1), new Range16.ptr(12880, 12896, 16), new Range16.ptr(12897, 12927, 1), new Range16.ptr(12938, 12976, 1), new Range16.ptr(12992, 13054, 1), new Range16.ptr(13056, 13311, 1), new Range16.ptr(19904, 19967, 1), new Range16.ptr(42128, 42182, 1), new Range16.ptr(42752, 42774, 1), new Range16.ptr(42784, 42785, 1), new Range16.ptr(42889, 42890, 1), new Range16.ptr(43048, 43051, 1), new Range16.ptr(43062, 43065, 1), new Range16.ptr(43639, 43641, 1), new Range16.ptr(43867, 64297, 20430), new Range16.ptr(64434, 64449, 1), new Range16.ptr(65020, 65021, 1), new Range16.ptr(65122, 65124, 2), new Range16.ptr(65125, 65126, 1), new Range16.ptr(65129, 65284, 155), new Range16.ptr(65291, 65308, 17), new Range16.ptr(65309, 65310, 1), new Range16.ptr(65342, 65344, 2), new Range16.ptr(65372, 65374, 2), new Range16.ptr(65504, 65510, 1), new Range16.ptr(65512, 65518, 1), new Range16.ptr(65532, 65533, 1)]), new sliceType$1([new Range32.ptr(65847, 65855, 1), new Range32.ptr(65913, 65929, 1), new Range32.ptr(65932, 65934, 1), new Range32.ptr(65936, 65947, 1), new Range32.ptr(65952, 66000, 48), new Range32.ptr(66001, 66044, 1), new Range32.ptr(67703, 67704, 1), new Range32.ptr(68296, 71487, 3191), new Range32.ptr(92988, 92991, 1), new Range32.ptr(92997, 113820, 20823), new Range32.ptr(118784, 119029, 1), new Range32.ptr(119040, 119078, 1), new Range32.ptr(119081, 119140, 1), new Range32.ptr(119146, 119148, 1), new Range32.ptr(119171, 119172, 1), new Range32.ptr(119180, 119209, 1), new Range32.ptr(119214, 119272, 1), new Range32.ptr(119296, 119361, 1), new Range32.ptr(119365, 119552, 187), new Range32.ptr(119553, 119638, 1), new Range32.ptr(120513, 120539, 26), new Range32.ptr(120571, 120597, 26), new Range32.ptr(120629, 120655, 26), new Range32.ptr(120687, 120713, 26), new Range32.ptr(120745, 120771, 26), new Range32.ptr(120832, 121343, 1), new Range32.ptr(121399, 121402, 1), new Range32.ptr(121453, 121460, 1), new Range32.ptr(121462, 121475, 1), new Range32.ptr(121477, 121478, 1), new Range32.ptr(126704, 126705, 1), new Range32.ptr(126976, 127019, 1), new Range32.ptr(127024, 127123, 1), new Range32.ptr(127136, 127150, 1), new Range32.ptr(127153, 127167, 1), new Range32.ptr(127169, 127183, 1), new Range32.ptr(127185, 127221, 1), new Range32.ptr(127248, 127278, 1), new Range32.ptr(127280, 127339, 1), new Range32.ptr(127344, 127404, 1), new Range32.ptr(127462, 127490, 1), new Range32.ptr(127504, 127547, 1), new Range32.ptr(127552, 127560, 1), new Range32.ptr(127568, 127569, 1), new Range32.ptr(127584, 127589, 1), new Range32.ptr(127744, 128724, 1), new Range32.ptr(128736, 128748, 1), new Range32.ptr(128752, 128760, 1), new Range32.ptr(128768, 128883, 1), new Range32.ptr(128896, 128980, 1), new Range32.ptr(129024, 129035, 1), new Range32.ptr(129040, 129095, 1), new Range32.ptr(129104, 129113, 1), new Range32.ptr(129120, 129159, 1), new Range32.ptr(129168, 129197, 1), new Range32.ptr(129280, 129291, 1), new Range32.ptr(129296, 129342, 1), new Range32.ptr(129344, 129356, 1), new Range32.ptr(129360, 129387, 1), new Range32.ptr(129408, 129431, 1), new Range32.ptr(129472, 129488, 16), new Range32.ptr(129489, 129510, 1)]), 10);
		_Zs = new RangeTable.ptr(new sliceType([new Range16.ptr(32, 160, 128), new Range16.ptr(5760, 8192, 2432), new Range16.ptr(8193, 8202, 1), new Range16.ptr(8239, 8287, 48), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 1);
		$pkg.Digit = _Nd;
		$pkg.Letter = _L;
		$pkg.L = _L;
		$pkg.M = _M;
		$pkg.N = _N;
		$pkg.Punct = _P;
		$pkg.P = _P;
		$pkg.Symbol = _S;
		$pkg.S = _S;
		$pkg.PrintRanges = new sliceType$2([$pkg.L, $pkg.M, $pkg.N, $pkg.P, $pkg.S]);
		$pkg.Zs = _Zs;
		_Han = new RangeTable.ptr(new sliceType([new Range16.ptr(11904, 11929, 1), new Range16.ptr(11931, 12019, 1), new Range16.ptr(12032, 12245, 1), new Range16.ptr(12293, 12293, 1), new Range16.ptr(12295, 12295, 1), new Range16.ptr(12321, 12329, 1), new Range16.ptr(12344, 12347, 1), new Range16.ptr(13312, 19893, 1), new Range16.ptr(19968, 40938, 1), new Range16.ptr(63744, 64109, 1), new Range16.ptr(64112, 64217, 1)]), new sliceType$1([new Range32.ptr(131072, 173782, 1), new Range32.ptr(173824, 177972, 1), new Range32.ptr(177984, 178205, 1), new Range32.ptr(178208, 183969, 1), new Range32.ptr(183984, 191456, 1), new Range32.ptr(194560, 195101, 1)]), 0);
		$pkg.Han = _Han;
		_White_Space = new RangeTable.ptr(new sliceType([new Range16.ptr(9, 13, 1), new Range16.ptr(32, 32, 1), new Range16.ptr(133, 133, 1), new Range16.ptr(160, 160, 1), new Range16.ptr(5760, 5760, 1), new Range16.ptr(8192, 8202, 1), new Range16.ptr(8232, 8233, 1), new Range16.ptr(8239, 8239, 1), new Range16.ptr(8287, 8287, 1), new Range16.ptr(12288, 12288, 1)]), sliceType$1.nil, 4);
		$pkg.White_Space = _White_Space;
		_CaseRanges = new sliceType$3([new CaseRange.ptr(65, 90, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(97, 122, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(181, 181, $toNativeArray($kindInt32, [743, 0, 743])), new CaseRange.ptr(192, 214, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(216, 222, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(224, 246, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(248, 254, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(255, 255, $toNativeArray($kindInt32, [121, 0, 121])), new CaseRange.ptr(256, 303, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(304, 304, $toNativeArray($kindInt32, [0, -199, 0])), new CaseRange.ptr(305, 305, $toNativeArray($kindInt32, [-232, 0, -232])), new CaseRange.ptr(306, 311, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(313, 328, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(330, 375, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(376, 376, $toNativeArray($kindInt32, [0, -121, 0])), new CaseRange.ptr(377, 382, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(383, 383, $toNativeArray($kindInt32, [-300, 0, -300])), new CaseRange.ptr(384, 384, $toNativeArray($kindInt32, [195, 0, 195])), new CaseRange.ptr(385, 385, $toNativeArray($kindInt32, [0, 210, 0])), new CaseRange.ptr(386, 389, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(390, 390, $toNativeArray($kindInt32, [0, 206, 0])), new CaseRange.ptr(391, 392, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(393, 394, $toNativeArray($kindInt32, [0, 205, 0])), new CaseRange.ptr(395, 396, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(398, 398, $toNativeArray($kindInt32, [0, 79, 0])), new CaseRange.ptr(399, 399, $toNativeArray($kindInt32, [0, 202, 0])), new CaseRange.ptr(400, 400, $toNativeArray($kindInt32, [0, 203, 0])), new CaseRange.ptr(401, 402, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(403, 403, $toNativeArray($kindInt32, [0, 205, 0])), new CaseRange.ptr(404, 404, $toNativeArray($kindInt32, [0, 207, 0])), new CaseRange.ptr(405, 405, $toNativeArray($kindInt32, [97, 0, 97])), new CaseRange.ptr(406, 406, $toNativeArray($kindInt32, [0, 211, 0])), new CaseRange.ptr(407, 407, $toNativeArray($kindInt32, [0, 209, 0])), new CaseRange.ptr(408, 409, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(410, 410, $toNativeArray($kindInt32, [163, 0, 163])), new CaseRange.ptr(412, 412, $toNativeArray($kindInt32, [0, 211, 0])), new CaseRange.ptr(413, 413, $toNativeArray($kindInt32, [0, 213, 0])), new CaseRange.ptr(414, 414, $toNativeArray($kindInt32, [130, 0, 130])), new CaseRange.ptr(415, 415, $toNativeArray($kindInt32, [0, 214, 0])), new CaseRange.ptr(416, 421, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(422, 422, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(423, 424, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(425, 425, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(428, 429, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(430, 430, $toNativeArray($kindInt32, [0, 218, 0])), new CaseRange.ptr(431, 432, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(433, 434, $toNativeArray($kindInt32, [0, 217, 0])), new CaseRange.ptr(435, 438, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(439, 439, $toNativeArray($kindInt32, [0, 219, 0])), new CaseRange.ptr(440, 441, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(444, 445, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(447, 447, $toNativeArray($kindInt32, [56, 0, 56])), new CaseRange.ptr(452, 452, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(453, 453, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(454, 454, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(455, 455, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(456, 456, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(457, 457, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(458, 458, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(459, 459, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(460, 460, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(461, 476, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(477, 477, $toNativeArray($kindInt32, [-79, 0, -79])), new CaseRange.ptr(478, 495, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(497, 497, $toNativeArray($kindInt32, [0, 2, 1])), new CaseRange.ptr(498, 498, $toNativeArray($kindInt32, [-1, 1, 0])), new CaseRange.ptr(499, 499, $toNativeArray($kindInt32, [-2, 0, -1])), new CaseRange.ptr(500, 501, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(502, 502, $toNativeArray($kindInt32, [0, -97, 0])), new CaseRange.ptr(503, 503, $toNativeArray($kindInt32, [0, -56, 0])), new CaseRange.ptr(504, 543, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(544, 544, $toNativeArray($kindInt32, [0, -130, 0])), new CaseRange.ptr(546, 563, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(570, 570, $toNativeArray($kindInt32, [0, 10795, 0])), new CaseRange.ptr(571, 572, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(573, 573, $toNativeArray($kindInt32, [0, -163, 0])), new CaseRange.ptr(574, 574, $toNativeArray($kindInt32, [0, 10792, 0])), new CaseRange.ptr(575, 576, $toNativeArray($kindInt32, [10815, 0, 10815])), new CaseRange.ptr(577, 578, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(579, 579, $toNativeArray($kindInt32, [0, -195, 0])), new CaseRange.ptr(580, 580, $toNativeArray($kindInt32, [0, 69, 0])), new CaseRange.ptr(581, 581, $toNativeArray($kindInt32, [0, 71, 0])), new CaseRange.ptr(582, 591, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(592, 592, $toNativeArray($kindInt32, [10783, 0, 10783])), new CaseRange.ptr(593, 593, $toNativeArray($kindInt32, [10780, 0, 10780])), new CaseRange.ptr(594, 594, $toNativeArray($kindInt32, [10782, 0, 10782])), new CaseRange.ptr(595, 595, $toNativeArray($kindInt32, [-210, 0, -210])), new CaseRange.ptr(596, 596, $toNativeArray($kindInt32, [-206, 0, -206])), new CaseRange.ptr(598, 599, $toNativeArray($kindInt32, [-205, 0, -205])), new CaseRange.ptr(601, 601, $toNativeArray($kindInt32, [-202, 0, -202])), new CaseRange.ptr(603, 603, $toNativeArray($kindInt32, [-203, 0, -203])), new CaseRange.ptr(604, 604, $toNativeArray($kindInt32, [42319, 0, 42319])), new CaseRange.ptr(608, 608, $toNativeArray($kindInt32, [-205, 0, -205])), new CaseRange.ptr(609, 609, $toNativeArray($kindInt32, [42315, 0, 42315])), new CaseRange.ptr(611, 611, $toNativeArray($kindInt32, [-207, 0, -207])), new CaseRange.ptr(613, 613, $toNativeArray($kindInt32, [42280, 0, 42280])), new CaseRange.ptr(614, 614, $toNativeArray($kindInt32, [42308, 0, 42308])), new CaseRange.ptr(616, 616, $toNativeArray($kindInt32, [-209, 0, -209])), new CaseRange.ptr(617, 617, $toNativeArray($kindInt32, [-211, 0, -211])), new CaseRange.ptr(618, 618, $toNativeArray($kindInt32, [42308, 0, 42308])), new CaseRange.ptr(619, 619, $toNativeArray($kindInt32, [10743, 0, 10743])), new CaseRange.ptr(620, 620, $toNativeArray($kindInt32, [42305, 0, 42305])), new CaseRange.ptr(623, 623, $toNativeArray($kindInt32, [-211, 0, -211])), new CaseRange.ptr(625, 625, $toNativeArray($kindInt32, [10749, 0, 10749])), new CaseRange.ptr(626, 626, $toNativeArray($kindInt32, [-213, 0, -213])), new CaseRange.ptr(629, 629, $toNativeArray($kindInt32, [-214, 0, -214])), new CaseRange.ptr(637, 637, $toNativeArray($kindInt32, [10727, 0, 10727])), new CaseRange.ptr(640, 640, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(643, 643, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(647, 647, $toNativeArray($kindInt32, [42282, 0, 42282])), new CaseRange.ptr(648, 648, $toNativeArray($kindInt32, [-218, 0, -218])), new CaseRange.ptr(649, 649, $toNativeArray($kindInt32, [-69, 0, -69])), new CaseRange.ptr(650, 651, $toNativeArray($kindInt32, [-217, 0, -217])), new CaseRange.ptr(652, 652, $toNativeArray($kindInt32, [-71, 0, -71])), new CaseRange.ptr(658, 658, $toNativeArray($kindInt32, [-219, 0, -219])), new CaseRange.ptr(669, 669, $toNativeArray($kindInt32, [42261, 0, 42261])), new CaseRange.ptr(670, 670, $toNativeArray($kindInt32, [42258, 0, 42258])), new CaseRange.ptr(837, 837, $toNativeArray($kindInt32, [84, 0, 84])), new CaseRange.ptr(880, 883, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(886, 887, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(891, 893, $toNativeArray($kindInt32, [130, 0, 130])), new CaseRange.ptr(895, 895, $toNativeArray($kindInt32, [0, 116, 0])), new CaseRange.ptr(902, 902, $toNativeArray($kindInt32, [0, 38, 0])), new CaseRange.ptr(904, 906, $toNativeArray($kindInt32, [0, 37, 0])), new CaseRange.ptr(908, 908, $toNativeArray($kindInt32, [0, 64, 0])), new CaseRange.ptr(910, 911, $toNativeArray($kindInt32, [0, 63, 0])), new CaseRange.ptr(913, 929, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(931, 939, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(940, 940, $toNativeArray($kindInt32, [-38, 0, -38])), new CaseRange.ptr(941, 943, $toNativeArray($kindInt32, [-37, 0, -37])), new CaseRange.ptr(945, 961, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(962, 962, $toNativeArray($kindInt32, [-31, 0, -31])), new CaseRange.ptr(963, 971, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(972, 972, $toNativeArray($kindInt32, [-64, 0, -64])), new CaseRange.ptr(973, 974, $toNativeArray($kindInt32, [-63, 0, -63])), new CaseRange.ptr(975, 975, $toNativeArray($kindInt32, [0, 8, 0])), new CaseRange.ptr(976, 976, $toNativeArray($kindInt32, [-62, 0, -62])), new CaseRange.ptr(977, 977, $toNativeArray($kindInt32, [-57, 0, -57])), new CaseRange.ptr(981, 981, $toNativeArray($kindInt32, [-47, 0, -47])), new CaseRange.ptr(982, 982, $toNativeArray($kindInt32, [-54, 0, -54])), new CaseRange.ptr(983, 983, $toNativeArray($kindInt32, [-8, 0, -8])), new CaseRange.ptr(984, 1007, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1008, 1008, $toNativeArray($kindInt32, [-86, 0, -86])), new CaseRange.ptr(1009, 1009, $toNativeArray($kindInt32, [-80, 0, -80])), new CaseRange.ptr(1010, 1010, $toNativeArray($kindInt32, [7, 0, 7])), new CaseRange.ptr(1011, 1011, $toNativeArray($kindInt32, [-116, 0, -116])), new CaseRange.ptr(1012, 1012, $toNativeArray($kindInt32, [0, -60, 0])), new CaseRange.ptr(1013, 1013, $toNativeArray($kindInt32, [-96, 0, -96])), new CaseRange.ptr(1015, 1016, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1017, 1017, $toNativeArray($kindInt32, [0, -7, 0])), new CaseRange.ptr(1018, 1019, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1021, 1023, $toNativeArray($kindInt32, [0, -130, 0])), new CaseRange.ptr(1024, 1039, $toNativeArray($kindInt32, [0, 80, 0])), new CaseRange.ptr(1040, 1071, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(1072, 1103, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(1104, 1119, $toNativeArray($kindInt32, [-80, 0, -80])), new CaseRange.ptr(1120, 1153, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1162, 1215, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1216, 1216, $toNativeArray($kindInt32, [0, 15, 0])), new CaseRange.ptr(1217, 1230, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1231, 1231, $toNativeArray($kindInt32, [-15, 0, -15])), new CaseRange.ptr(1232, 1327, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(1329, 1366, $toNativeArray($kindInt32, [0, 48, 0])), new CaseRange.ptr(1377, 1414, $toNativeArray($kindInt32, [-48, 0, -48])), new CaseRange.ptr(4256, 4293, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(4295, 4295, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(4301, 4301, $toNativeArray($kindInt32, [0, 7264, 0])), new CaseRange.ptr(5024, 5103, $toNativeArray($kindInt32, [0, 38864, 0])), new CaseRange.ptr(5104, 5109, $toNativeArray($kindInt32, [0, 8, 0])), new CaseRange.ptr(5112, 5117, $toNativeArray($kindInt32, [-8, 0, -8])), new CaseRange.ptr(7296, 7296, $toNativeArray($kindInt32, [-6254, 0, -6254])), new CaseRange.ptr(7297, 7297, $toNativeArray($kindInt32, [-6253, 0, -6253])), new CaseRange.ptr(7298, 7298, $toNativeArray($kindInt32, [-6244, 0, -6244])), new CaseRange.ptr(7299, 7300, $toNativeArray($kindInt32, [-6242, 0, -6242])), new CaseRange.ptr(7301, 7301, $toNativeArray($kindInt32, [-6243, 0, -6243])), new CaseRange.ptr(7302, 7302, $toNativeArray($kindInt32, [-6236, 0, -6236])), new CaseRange.ptr(7303, 7303, $toNativeArray($kindInt32, [-6181, 0, -6181])), new CaseRange.ptr(7304, 7304, $toNativeArray($kindInt32, [35266, 0, 35266])), new CaseRange.ptr(7545, 7545, $toNativeArray($kindInt32, [35332, 0, 35332])), new CaseRange.ptr(7549, 7549, $toNativeArray($kindInt32, [3814, 0, 3814])), new CaseRange.ptr(7680, 7829, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(7835, 7835, $toNativeArray($kindInt32, [-59, 0, -59])), new CaseRange.ptr(7838, 7838, $toNativeArray($kindInt32, [0, -7615, 0])), new CaseRange.ptr(7840, 7935, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(7936, 7943, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7944, 7951, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7952, 7957, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7960, 7965, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7968, 7975, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7976, 7983, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(7984, 7991, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(7992, 7999, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8000, 8005, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8008, 8013, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8017, 8017, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8019, 8019, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8021, 8021, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8023, 8023, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8025, 8025, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8027, 8027, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8029, 8029, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8031, 8031, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8032, 8039, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8040, 8047, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8048, 8049, $toNativeArray($kindInt32, [74, 0, 74])), new CaseRange.ptr(8050, 8053, $toNativeArray($kindInt32, [86, 0, 86])), new CaseRange.ptr(8054, 8055, $toNativeArray($kindInt32, [100, 0, 100])), new CaseRange.ptr(8056, 8057, $toNativeArray($kindInt32, [128, 0, 128])), new CaseRange.ptr(8058, 8059, $toNativeArray($kindInt32, [112, 0, 112])), new CaseRange.ptr(8060, 8061, $toNativeArray($kindInt32, [126, 0, 126])), new CaseRange.ptr(8064, 8071, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8072, 8079, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8080, 8087, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8088, 8095, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8096, 8103, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8104, 8111, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8112, 8113, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8115, 8115, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8120, 8121, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8122, 8123, $toNativeArray($kindInt32, [0, -74, 0])), new CaseRange.ptr(8124, 8124, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8126, 8126, $toNativeArray($kindInt32, [-7205, 0, -7205])), new CaseRange.ptr(8131, 8131, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8136, 8139, $toNativeArray($kindInt32, [0, -86, 0])), new CaseRange.ptr(8140, 8140, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8144, 8145, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8152, 8153, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8154, 8155, $toNativeArray($kindInt32, [0, -100, 0])), new CaseRange.ptr(8160, 8161, $toNativeArray($kindInt32, [8, 0, 8])), new CaseRange.ptr(8165, 8165, $toNativeArray($kindInt32, [7, 0, 7])), new CaseRange.ptr(8168, 8169, $toNativeArray($kindInt32, [0, -8, 0])), new CaseRange.ptr(8170, 8171, $toNativeArray($kindInt32, [0, -112, 0])), new CaseRange.ptr(8172, 8172, $toNativeArray($kindInt32, [0, -7, 0])), new CaseRange.ptr(8179, 8179, $toNativeArray($kindInt32, [9, 0, 9])), new CaseRange.ptr(8184, 8185, $toNativeArray($kindInt32, [0, -128, 0])), new CaseRange.ptr(8186, 8187, $toNativeArray($kindInt32, [0, -126, 0])), new CaseRange.ptr(8188, 8188, $toNativeArray($kindInt32, [0, -9, 0])), new CaseRange.ptr(8486, 8486, $toNativeArray($kindInt32, [0, -7517, 0])), new CaseRange.ptr(8490, 8490, $toNativeArray($kindInt32, [0, -8383, 0])), new CaseRange.ptr(8491, 8491, $toNativeArray($kindInt32, [0, -8262, 0])), new CaseRange.ptr(8498, 8498, $toNativeArray($kindInt32, [0, 28, 0])), new CaseRange.ptr(8526, 8526, $toNativeArray($kindInt32, [-28, 0, -28])), new CaseRange.ptr(8544, 8559, $toNativeArray($kindInt32, [0, 16, 0])), new CaseRange.ptr(8560, 8575, $toNativeArray($kindInt32, [-16, 0, -16])), new CaseRange.ptr(8579, 8580, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(9398, 9423, $toNativeArray($kindInt32, [0, 26, 0])), new CaseRange.ptr(9424, 9449, $toNativeArray($kindInt32, [-26, 0, -26])), new CaseRange.ptr(11264, 11310, $toNativeArray($kindInt32, [0, 48, 0])), new CaseRange.ptr(11312, 11358, $toNativeArray($kindInt32, [-48, 0, -48])), new CaseRange.ptr(11360, 11361, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11362, 11362, $toNativeArray($kindInt32, [0, -10743, 0])), new CaseRange.ptr(11363, 11363, $toNativeArray($kindInt32, [0, -3814, 0])), new CaseRange.ptr(11364, 11364, $toNativeArray($kindInt32, [0, -10727, 0])), new CaseRange.ptr(11365, 11365, $toNativeArray($kindInt32, [-10795, 0, -10795])), new CaseRange.ptr(11366, 11366, $toNativeArray($kindInt32, [-10792, 0, -10792])), new CaseRange.ptr(11367, 11372, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11373, 11373, $toNativeArray($kindInt32, [0, -10780, 0])), new CaseRange.ptr(11374, 11374, $toNativeArray($kindInt32, [0, -10749, 0])), new CaseRange.ptr(11375, 11375, $toNativeArray($kindInt32, [0, -10783, 0])), new CaseRange.ptr(11376, 11376, $toNativeArray($kindInt32, [0, -10782, 0])), new CaseRange.ptr(11378, 11379, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11381, 11382, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11390, 11391, $toNativeArray($kindInt32, [0, -10815, 0])), new CaseRange.ptr(11392, 11491, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11499, 11502, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11506, 11507, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(11520, 11557, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(11559, 11559, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(11565, 11565, $toNativeArray($kindInt32, [-7264, 0, -7264])), new CaseRange.ptr(42560, 42605, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42624, 42651, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42786, 42799, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42802, 42863, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42873, 42876, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42877, 42877, $toNativeArray($kindInt32, [0, -35332, 0])), new CaseRange.ptr(42878, 42887, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42891, 42892, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42893, 42893, $toNativeArray($kindInt32, [0, -42280, 0])), new CaseRange.ptr(42896, 42899, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42902, 42921, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(42922, 42922, $toNativeArray($kindInt32, [0, -42308, 0])), new CaseRange.ptr(42923, 42923, $toNativeArray($kindInt32, [0, -42319, 0])), new CaseRange.ptr(42924, 42924, $toNativeArray($kindInt32, [0, -42315, 0])), new CaseRange.ptr(42925, 42925, $toNativeArray($kindInt32, [0, -42305, 0])), new CaseRange.ptr(42926, 42926, $toNativeArray($kindInt32, [0, -42308, 0])), new CaseRange.ptr(42928, 42928, $toNativeArray($kindInt32, [0, -42258, 0])), new CaseRange.ptr(42929, 42929, $toNativeArray($kindInt32, [0, -42282, 0])), new CaseRange.ptr(42930, 42930, $toNativeArray($kindInt32, [0, -42261, 0])), new CaseRange.ptr(42931, 42931, $toNativeArray($kindInt32, [0, 928, 0])), new CaseRange.ptr(42932, 42935, $toNativeArray($kindInt32, [1114112, 1114112, 1114112])), new CaseRange.ptr(43859, 43859, $toNativeArray($kindInt32, [-928, 0, -928])), new CaseRange.ptr(43888, 43967, $toNativeArray($kindInt32, [-38864, 0, -38864])), new CaseRange.ptr(65313, 65338, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(65345, 65370, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(66560, 66599, $toNativeArray($kindInt32, [0, 40, 0])), new CaseRange.ptr(66600, 66639, $toNativeArray($kindInt32, [-40, 0, -40])), new CaseRange.ptr(66736, 66771, $toNativeArray($kindInt32, [0, 40, 0])), new CaseRange.ptr(66776, 66811, $toNativeArray($kindInt32, [-40, 0, -40])), new CaseRange.ptr(68736, 68786, $toNativeArray($kindInt32, [0, 64, 0])), new CaseRange.ptr(68800, 68850, $toNativeArray($kindInt32, [-64, 0, -64])), new CaseRange.ptr(71840, 71871, $toNativeArray($kindInt32, [0, 32, 0])), new CaseRange.ptr(71872, 71903, $toNativeArray($kindInt32, [-32, 0, -32])), new CaseRange.ptr(125184, 125217, $toNativeArray($kindInt32, [0, 34, 0])), new CaseRange.ptr(125218, 125251, $toNativeArray($kindInt32, [-34, 0, -34]))]);
		$pkg.CaseRanges = _CaseRanges;
		properties = $toNativeArray($kindUint8, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 144, 130, 130, 130, 136, 130, 130, 130, 130, 130, 130, 136, 130, 130, 130, 130, 132, 132, 132, 132, 132, 132, 132, 132, 132, 132, 130, 130, 136, 136, 136, 130, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 130, 130, 130, 136, 130, 136, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 130, 136, 130, 136, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 16, 130, 136, 136, 136, 136, 136, 130, 136, 136, 224, 130, 136, 0, 136, 136, 136, 136, 132, 132, 136, 192, 130, 130, 136, 132, 224, 130, 132, 132, 132, 130, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 136, 160, 160, 160, 160, 160, 160, 160, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 192, 136, 192, 192, 192, 192, 192, 192, 192, 192]);
		asciiFold = $toNativeArray($kindUint16, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 91, 92, 93, 94, 95, 96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 8490, 76, 77, 78, 79, 80, 81, 82, 383, 84, 85, 86, 87, 88, 89, 90, 123, 124, 125, 126, 127]);
		caseOrbit = new sliceType$4([new foldPair.ptr(75, 107), new foldPair.ptr(83, 115), new foldPair.ptr(107, 8490), new foldPair.ptr(115, 383), new foldPair.ptr(181, 924), new foldPair.ptr(197, 229), new foldPair.ptr(223, 7838), new foldPair.ptr(229, 8491), new foldPair.ptr(304, 304), new foldPair.ptr(305, 305), new foldPair.ptr(383, 83), new foldPair.ptr(452, 453), new foldPair.ptr(453, 454), new foldPair.ptr(454, 452), new foldPair.ptr(455, 456), new foldPair.ptr(456, 457), new foldPair.ptr(457, 455), new foldPair.ptr(458, 459), new foldPair.ptr(459, 460), new foldPair.ptr(460, 458), new foldPair.ptr(497, 498), new foldPair.ptr(498, 499), new foldPair.ptr(499, 497), new foldPair.ptr(837, 921), new foldPair.ptr(914, 946), new foldPair.ptr(917, 949), new foldPair.ptr(920, 952), new foldPair.ptr(921, 953), new foldPair.ptr(922, 954), new foldPair.ptr(924, 956), new foldPair.ptr(928, 960), new foldPair.ptr(929, 961), new foldPair.ptr(931, 962), new foldPair.ptr(934, 966), new foldPair.ptr(937, 969), new foldPair.ptr(946, 976), new foldPair.ptr(949, 1013), new foldPair.ptr(952, 977), new foldPair.ptr(953, 8126), new foldPair.ptr(954, 1008), new foldPair.ptr(956, 181), new foldPair.ptr(960, 982), new foldPair.ptr(961, 1009), new foldPair.ptr(962, 963), new foldPair.ptr(963, 931), new foldPair.ptr(966, 981), new foldPair.ptr(969, 8486), new foldPair.ptr(976, 914), new foldPair.ptr(977, 1012), new foldPair.ptr(981, 934), new foldPair.ptr(982, 928), new foldPair.ptr(1008, 922), new foldPair.ptr(1009, 929), new foldPair.ptr(1012, 920), new foldPair.ptr(1013, 917), new foldPair.ptr(1042, 1074), new foldPair.ptr(1044, 1076), new foldPair.ptr(1054, 1086), new foldPair.ptr(1057, 1089), new foldPair.ptr(1058, 1090), new foldPair.ptr(1066, 1098), new foldPair.ptr(1074, 7296), new foldPair.ptr(1076, 7297), new foldPair.ptr(1086, 7298), new foldPair.ptr(1089, 7299), new foldPair.ptr(1090, 7300), new foldPair.ptr(1098, 7302), new foldPair.ptr(1122, 1123), new foldPair.ptr(1123, 7303), new foldPair.ptr(7296, 1042), new foldPair.ptr(7297, 1044), new foldPair.ptr(7298, 1054), new foldPair.ptr(7299, 1057), new foldPair.ptr(7300, 7301), new foldPair.ptr(7301, 1058), new foldPair.ptr(7302, 1066), new foldPair.ptr(7303, 1122), new foldPair.ptr(7304, 42570), new foldPair.ptr(7776, 7777), new foldPair.ptr(7777, 7835), new foldPair.ptr(7835, 7776), new foldPair.ptr(7838, 223), new foldPair.ptr(8126, 837), new foldPair.ptr(8486, 937), new foldPair.ptr(8490, 75), new foldPair.ptr(8491, 197), new foldPair.ptr(42570, 42571), new foldPair.ptr(42571, 7304)]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["unicode/utf8"] = (function() {
	var $pkg = {}, $init, acceptRange, first, acceptRanges, DecodeRune, DecodeRuneInString, DecodeLastRune, DecodeLastRuneInString, RuneLen, EncodeRune, RuneCount, RuneCountInString, RuneStart, ValidRune;
	acceptRange = $pkg.acceptRange = $newType(0, $kindStruct, "utf8.acceptRange", true, "unicode/utf8", false, function(lo_, hi_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.lo = 0;
			this.hi = 0;
			return;
		}
		this.lo = lo_;
		this.hi = hi_;
	});
	DecodeRune = function(p) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, b1, b2, b3, mask, n, p, p0, r, size, sz, x, x$1;
		r = 0;
		size = 0;
		n = p.$length;
		if (n < 1) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		p0 = (0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]);
		x = ((p0 < 0 || p0 >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[p0]);
		if (x >= 240) {
			mask = (((x >> 0)) << 31 >> 0) >> 31 >> 0;
			_tmp$2 = (((((0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0]) >> 0)) & ~mask) >> 0) | (65533 & mask);
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		sz = (x & 7) >>> 0;
		accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
		if (n < ((sz >> 0))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		b1 = (1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]);
		if (b1 < accept.lo || accept.hi < b1) {
			_tmp$6 = 65533;
			_tmp$7 = 1;
			r = _tmp$6;
			size = _tmp$7;
			return [r, size];
		}
		if (sz === 2) {
			_tmp$8 = (((((p0 & 31) >>> 0) >> 0)) << 6 >> 0) | ((((b1 & 63) >>> 0) >> 0));
			_tmp$9 = 2;
			r = _tmp$8;
			size = _tmp$9;
			return [r, size];
		}
		b2 = (2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]);
		if (b2 < 128 || 191 < b2) {
			_tmp$10 = 65533;
			_tmp$11 = 1;
			r = _tmp$10;
			size = _tmp$11;
			return [r, size];
		}
		if (sz === 3) {
			_tmp$12 = ((((((p0 & 15) >>> 0) >> 0)) << 12 >> 0) | (((((b1 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((b2 & 63) >>> 0) >> 0));
			_tmp$13 = 3;
			r = _tmp$12;
			size = _tmp$13;
			return [r, size];
		}
		b3 = (3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]);
		if (b3 < 128 || 191 < b3) {
			_tmp$14 = 65533;
			_tmp$15 = 1;
			r = _tmp$14;
			size = _tmp$15;
			return [r, size];
		}
		_tmp$16 = (((((((p0 & 7) >>> 0) >> 0)) << 18 >> 0) | (((((b1 & 63) >>> 0) >> 0)) << 12 >> 0)) | (((((b2 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((b3 & 63) >>> 0) >> 0));
		_tmp$17 = 4;
		r = _tmp$16;
		size = _tmp$17;
		return [r, size];
	};
	$pkg.DecodeRune = DecodeRune;
	DecodeRuneInString = function(s) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, accept, mask, n, r, s, s0, s1, s2, s3, size, sz, x, x$1;
		r = 0;
		size = 0;
		n = s.length;
		if (n < 1) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		s0 = s.charCodeAt(0);
		x = ((s0 < 0 || s0 >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[s0]);
		if (x >= 240) {
			mask = (((x >> 0)) << 31 >> 0) >> 31 >> 0;
			_tmp$2 = ((((s.charCodeAt(0) >> 0)) & ~mask) >> 0) | (65533 & mask);
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		sz = (x & 7) >>> 0;
		accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
		if (n < ((sz >> 0))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		s1 = s.charCodeAt(1);
		if (s1 < accept.lo || accept.hi < s1) {
			_tmp$6 = 65533;
			_tmp$7 = 1;
			r = _tmp$6;
			size = _tmp$7;
			return [r, size];
		}
		if (sz === 2) {
			_tmp$8 = (((((s0 & 31) >>> 0) >> 0)) << 6 >> 0) | ((((s1 & 63) >>> 0) >> 0));
			_tmp$9 = 2;
			r = _tmp$8;
			size = _tmp$9;
			return [r, size];
		}
		s2 = s.charCodeAt(2);
		if (s2 < 128 || 191 < s2) {
			_tmp$10 = 65533;
			_tmp$11 = 1;
			r = _tmp$10;
			size = _tmp$11;
			return [r, size];
		}
		if (sz === 3) {
			_tmp$12 = ((((((s0 & 15) >>> 0) >> 0)) << 12 >> 0) | (((((s1 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((s2 & 63) >>> 0) >> 0));
			_tmp$13 = 3;
			r = _tmp$12;
			size = _tmp$13;
			return [r, size];
		}
		s3 = s.charCodeAt(3);
		if (s3 < 128 || 191 < s3) {
			_tmp$14 = 65533;
			_tmp$15 = 1;
			r = _tmp$14;
			size = _tmp$15;
			return [r, size];
		}
		_tmp$16 = (((((((s0 & 7) >>> 0) >> 0)) << 18 >> 0) | (((((s1 & 63) >>> 0) >> 0)) << 12 >> 0)) | (((((s2 & 63) >>> 0) >> 0)) << 6 >> 0)) | ((((s3 & 63) >>> 0) >> 0));
		_tmp$17 = 4;
		r = _tmp$16;
		size = _tmp$17;
		return [r, size];
	};
	$pkg.DecodeRuneInString = DecodeRuneInString;
	DecodeLastRune = function(p) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, end, lim, p, r, size, start;
		r = 0;
		size = 0;
		end = p.$length;
		if (end === 0) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((((start < 0 || start >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + start]) >> 0));
		if (r < 128) {
			_tmp$2 = r;
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - (1) >> 0;
		while (true) {
			if (!(start >= lim)) { break; }
			if (RuneStart(((start < 0 || start >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + start]))) {
				break;
			}
			start = start - (1) >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple = DecodeRune($subslice(p, start, end));
		r = _tuple[0];
		size = _tuple[1];
		if (!(((start + size >> 0) === end))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		_tmp$6 = r;
		_tmp$7 = size;
		r = _tmp$6;
		size = _tmp$7;
		return [r, size];
	};
	$pkg.DecodeLastRune = DecodeLastRune;
	DecodeLastRuneInString = function(s) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, end, lim, r, s, size, start;
		r = 0;
		size = 0;
		end = s.length;
		if (end === 0) {
			_tmp = 65533;
			_tmp$1 = 0;
			r = _tmp;
			size = _tmp$1;
			return [r, size];
		}
		start = end - 1 >> 0;
		r = ((s.charCodeAt(start) >> 0));
		if (r < 128) {
			_tmp$2 = r;
			_tmp$3 = 1;
			r = _tmp$2;
			size = _tmp$3;
			return [r, size];
		}
		lim = end - 4 >> 0;
		if (lim < 0) {
			lim = 0;
		}
		start = start - (1) >> 0;
		while (true) {
			if (!(start >= lim)) { break; }
			if (RuneStart(s.charCodeAt(start))) {
				break;
			}
			start = start - (1) >> 0;
		}
		if (start < 0) {
			start = 0;
		}
		_tuple = DecodeRuneInString($substring(s, start, end));
		r = _tuple[0];
		size = _tuple[1];
		if (!(((start + size >> 0) === end))) {
			_tmp$4 = 65533;
			_tmp$5 = 1;
			r = _tmp$4;
			size = _tmp$5;
			return [r, size];
		}
		_tmp$6 = r;
		_tmp$7 = size;
		r = _tmp$6;
		size = _tmp$7;
		return [r, size];
	};
	$pkg.DecodeLastRuneInString = DecodeLastRuneInString;
	RuneLen = function(r) {
		var r;
		if (r < 0) {
			return -1;
		} else if (r <= 127) {
			return 1;
		} else if (r <= 2047) {
			return 2;
		} else if (55296 <= r && r <= 57343) {
			return -1;
		} else if (r <= 65535) {
			return 3;
		} else if (r <= 1114111) {
			return 4;
		}
		return -1;
	};
	$pkg.RuneLen = RuneLen;
	EncodeRune = function(p, r) {
		var i, p, r;
		i = ((r >>> 0));
		if (i <= 127) {
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((r << 24 >>> 24)));
			return 1;
		} else if (i <= 2047) {
			$unused((1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((192 | (((r >> 6 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 2;
		} else if ((i > 1114111) || (55296 <= i && i <= 57343)) {
			r = 65533;
			$unused((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((224 | (((r >> 12 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 3;
		} else if (i <= 65535) {
			$unused((2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((224 | (((r >> 12 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 3;
		} else {
			$unused((3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3]));
			(0 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 0] = ((240 | (((r >> 18 >> 0) << 24 >>> 24))) >>> 0));
			(1 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 1] = ((128 | (((((r >> 12 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(2 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 2] = ((128 | (((((r >> 6 >> 0) << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			(3 >= p.$length ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + 3] = ((128 | ((((r << 24 >>> 24)) & 63) >>> 0)) >>> 0));
			return 4;
		}
	};
	$pkg.EncodeRune = EncodeRune;
	RuneCount = function(p) {
		var accept, c, c$1, c$2, c$3, i, n, np, p, size, x, x$1, x$2, x$3, x$4;
		np = p.$length;
		n = 0;
		i = 0;
		while (true) {
			if (!(i < np)) { break; }
			n = n + (1) >> 0;
			c = ((i < 0 || i >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + i]);
			if (c < 128) {
				i = i + (1) >> 0;
				continue;
			}
			x = ((c < 0 || c >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[c]);
			if (x === 241) {
				i = i + (1) >> 0;
				continue;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > np) {
				i = i + (1) >> 0;
				continue;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c$1 = (x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$2]));
			if (c$1 < accept.lo || accept.hi < c$1) {
				size = 1;
			} else if (size === 2) {
			} else {
				c$2 = (x$3 = i + 2 >> 0, ((x$3 < 0 || x$3 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$3]));
				if (c$2 < 128 || 191 < c$2) {
					size = 1;
				} else if (size === 3) {
				} else {
					c$3 = (x$4 = i + 3 >> 0, ((x$4 < 0 || x$4 >= p.$length) ? ($throwRuntimeError("index out of range"), undefined) : p.$array[p.$offset + x$4]));
					if (c$3 < 128 || 191 < c$3) {
						size = 1;
					}
				}
			}
			i = i + (size) >> 0;
		}
		return n;
	};
	$pkg.RuneCount = RuneCount;
	RuneCountInString = function(s) {
		var accept, c, c$1, c$2, c$3, i, n, ns, s, size, x, x$1;
		n = 0;
		ns = s.length;
		i = 0;
		while (true) {
			if (!(i < ns)) { break; }
			c = s.charCodeAt(i);
			if (c < 128) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			x = ((c < 0 || c >= first.length) ? ($throwRuntimeError("index out of range"), undefined) : first[c]);
			if (x === 241) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			size = ((((x & 7) >>> 0) >> 0));
			if ((i + size >> 0) > ns) {
				i = i + (1) >> 0;
				n = n + (1) >> 0;
				continue;
			}
			accept = $clone((x$1 = x >>> 4 << 24 >>> 24, ((x$1 < 0 || x$1 >= acceptRanges.length) ? ($throwRuntimeError("index out of range"), undefined) : acceptRanges[x$1])), acceptRange);
			c$1 = s.charCodeAt((i + 1 >> 0));
			if (c$1 < accept.lo || accept.hi < c$1) {
				size = 1;
			} else if (size === 2) {
			} else {
				c$2 = s.charCodeAt((i + 2 >> 0));
				if (c$2 < 128 || 191 < c$2) {
					size = 1;
				} else if (size === 3) {
				} else {
					c$3 = s.charCodeAt((i + 3 >> 0));
					if (c$3 < 128 || 191 < c$3) {
						size = 1;
					}
				}
			}
			i = i + (size) >> 0;
			n = n + (1) >> 0;
		}
		n = n;
		return n;
	};
	$pkg.RuneCountInString = RuneCountInString;
	RuneStart = function(b) {
		var b;
		return !((((b & 192) >>> 0) === 128));
	};
	$pkg.RuneStart = RuneStart;
	ValidRune = function(r) {
		var r;
		if (0 <= r && r < 55296) {
			return true;
		} else if (57343 < r && r <= 1114111) {
			return true;
		}
		return false;
	};
	$pkg.ValidRune = ValidRune;
	acceptRange.init("unicode/utf8", [{prop: "lo", name: "lo", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "hi", name: "hi", embedded: false, exported: false, typ: $Uint8, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		first = $toNativeArray($kindUint8, [240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 19, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 35, 3, 3, 52, 4, 4, 4, 68, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241, 241]);
		acceptRanges = $toNativeArray($kindStruct, [new acceptRange.ptr(128, 191), new acceptRange.ptr(160, 191), new acceptRange.ptr(128, 159), new acceptRange.ptr(144, 191), new acceptRange.ptr(128, 143)]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["bytes"] = (function() {
	var $pkg = {}, $init, errors, bytealg, io, unicode, utf8, Buffer, readOp, asciiSet, Reader, ptrType, sliceType, sliceType$1, ptrType$1, arrayType$1, ptrType$2, errNegativeRead, IndexByte, Equal, makeSlice, NewBufferString, explode, Count, Contains, ContainsAny, LastIndex, IndexAny, genSplit, Split, SplitAfter, HasPrefix, HasSuffix, Map, Repeat, ToLower, TrimLeftFunc, TrimRightFunc, TrimFunc, TrimSuffix, indexFunc, lastIndexFunc, makeASCIISet, makeCutsetFunc, Trim, TrimRight, TrimSpace, Replace, ReplaceAll, EqualFold, Index, indexRabinKarp, hashStr, NewReader;
	errors = $packages["errors"];
	bytealg = $packages["internal/bytealg"];
	io = $packages["io"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Buffer = $pkg.Buffer = $newType(0, $kindStruct, "bytes.Buffer", true, "bytes", true, function(buf_, off_, lastRead_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.buf = sliceType.nil;
			this.off = 0;
			this.lastRead = 0;
			return;
		}
		this.buf = buf_;
		this.off = off_;
		this.lastRead = lastRead_;
	});
	readOp = $pkg.readOp = $newType(1, $kindInt8, "bytes.readOp", true, "bytes", false, null);
	asciiSet = $pkg.asciiSet = $newType(32, $kindArray, "bytes.asciiSet", true, "bytes", false, null);
	Reader = $pkg.Reader = $newType(0, $kindStruct, "bytes.Reader", true, "bytes", true, function(s_, i_, prevRune_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = sliceType.nil;
			this.i = new $Int64(0, 0);
			this.prevRune = 0;
			return;
		}
		this.s = s_;
		this.i = i_;
		this.prevRune = prevRune_;
	});
	ptrType = $ptrType(Buffer);
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType(sliceType);
	ptrType$1 = $ptrType(asciiSet);
	arrayType$1 = $arrayType($Uint32, 8);
	ptrType$2 = $ptrType(Reader);
	IndexByte = function(s, c) {
		var _i, _ref, b, c, i, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			b = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (b === c) {
				return i;
			}
			_i++;
		}
		return -1;
	};
	$pkg.IndexByte = IndexByte;
	Equal = function(a, b) {
		var _i, _ref, a, b, c, i;
		if (!((a.$length === b.$length))) {
			return false;
		}
		_ref = a;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((c === ((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i])))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	$pkg.Equal = Equal;
	Buffer.ptr.prototype.Bytes = function() {
		var b;
		b = this;
		return $subslice(b.buf, b.off);
	};
	Buffer.prototype.Bytes = function() { return this.$val.Bytes(); };
	Buffer.ptr.prototype.String = function() {
		var b;
		b = this;
		if (b === ptrType.nil) {
			return "<nil>";
		}
		return ($bytesToString($subslice(b.buf, b.off)));
	};
	Buffer.prototype.String = function() { return this.$val.String(); };
	Buffer.ptr.prototype.empty = function() {
		var b;
		b = this;
		return b.buf.$length <= b.off;
	};
	Buffer.prototype.empty = function() { return this.$val.empty(); };
	Buffer.ptr.prototype.Len = function() {
		var b;
		b = this;
		return b.buf.$length - b.off >> 0;
	};
	Buffer.prototype.Len = function() { return this.$val.Len(); };
	Buffer.ptr.prototype.Cap = function() {
		var b;
		b = this;
		return b.buf.$capacity;
	};
	Buffer.prototype.Cap = function() { return this.$val.Cap(); };
	Buffer.ptr.prototype.Truncate = function(n) {
		var b, n;
		b = this;
		if (n === 0) {
			b.Reset();
			return;
		}
		b.lastRead = 0;
		if (n < 0 || n > b.Len()) {
			$panic(new $String("bytes.Buffer: truncation out of range"));
		}
		b.buf = $subslice(b.buf, 0, (b.off + n >> 0));
	};
	Buffer.prototype.Truncate = function(n) { return this.$val.Truncate(n); };
	Buffer.ptr.prototype.Reset = function() {
		var b;
		b = this;
		b.buf = $subslice(b.buf, 0, 0);
		b.off = 0;
		b.lastRead = 0;
	};
	Buffer.prototype.Reset = function() { return this.$val.Reset(); };
	Buffer.ptr.prototype.tryGrowByReslice = function(n) {
		var b, l, n;
		b = this;
		l = b.buf.$length;
		if (n <= (b.buf.$capacity - l >> 0)) {
			b.buf = $subslice(b.buf, 0, (l + n >> 0));
			return [l, true];
		}
		return [0, false];
	};
	Buffer.prototype.tryGrowByReslice = function(n) { return this.$val.tryGrowByReslice(n); };
	Buffer.ptr.prototype.grow = function(n) {
		var _q, _tuple, b, buf, c, i, m, n, ok;
		b = this;
		m = b.Len();
		if ((m === 0) && !((b.off === 0))) {
			b.Reset();
		}
		_tuple = b.tryGrowByReslice(n);
		i = _tuple[0];
		ok = _tuple[1];
		if (ok) {
			return i;
		}
		if (b.buf === sliceType.nil && n <= 64) {
			b.buf = $makeSlice(sliceType, n, 64);
			return 0;
		}
		c = b.buf.$capacity;
		if (n <= ((_q = c / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) - m >> 0)) {
			$copySlice(b.buf, $subslice(b.buf, b.off));
		} else if (c > ((2147483647 - c >> 0) - n >> 0)) {
			$panic($pkg.ErrTooLarge);
		} else {
			buf = makeSlice(($imul(2, c)) + n >> 0);
			$copySlice(buf, $subslice(b.buf, b.off));
			b.buf = buf;
		}
		b.off = 0;
		b.buf = $subslice(b.buf, 0, (m + n >> 0));
		return m;
	};
	Buffer.prototype.grow = function(n) { return this.$val.grow(n); };
	Buffer.ptr.prototype.Grow = function(n) {
		var b, m, n;
		b = this;
		if (n < 0) {
			$panic(new $String("bytes.Buffer.Grow: negative count"));
		}
		m = b.grow(n);
		b.buf = $subslice(b.buf, 0, m);
	};
	Buffer.prototype.Grow = function(n) { return this.$val.Grow(n); };
	Buffer.ptr.prototype.Write = function(p) {
		var _tmp, _tmp$1, _tuple, b, err, m, n, ok, p;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(p.$length);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(p.$length);
		}
		_tmp = $copySlice($subslice(b.buf, m), p);
		_tmp$1 = $ifaceNil;
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	Buffer.prototype.Write = function(p) { return this.$val.Write(p); };
	Buffer.ptr.prototype.WriteString = function(s) {
		var _tmp, _tmp$1, _tuple, b, err, m, n, ok, s;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(s.length);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(s.length);
		}
		_tmp = $copyString($subslice(b.buf, m), s);
		_tmp$1 = $ifaceNil;
		n = _tmp;
		err = _tmp$1;
		return [n, err];
	};
	Buffer.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Buffer.ptr.prototype.ReadFrom = function(r) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, e, err, i, m, n, r, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; i = $f.i; m = $f.m; n = $f.n; r = $f.r; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		/* while (true) { */ case 1:
			i = b.grow(512);
			b.buf = $subslice(b.buf, 0, i);
			_r = r.Read($subslice(b.buf, i, b.buf.$capacity)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (m < 0) {
				$panic(errNegativeRead);
			}
			b.buf = $subslice(b.buf, 0, (i + m >> 0));
			n = (x = (new $Int64(0, m)), new $Int64(n.$high + x.$high, n.$low + x.$low));
			if ($interfaceIsEqual(e, io.EOF)) {
				_tmp = n;
				_tmp$1 = $ifaceNil;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tmp$2 = n;
				_tmp$3 = e;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Buffer.ptr.prototype.ReadFrom }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.i = i; $f.m = m; $f.n = n; $f.r = r; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Buffer.prototype.ReadFrom = function(r) { return this.$val.ReadFrom(r); };
	makeSlice = function(n) {
		var n, $deferred;
		/* */ var $err = null; try { $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		$deferred.push([(function() {
			if (!($interfaceIsEqual($recover(), $ifaceNil))) {
				$panic($pkg.ErrTooLarge);
			}
		}), []]);
		return $makeSlice(sliceType, n);
		/* */ } catch(err) { $err = err; return sliceType.nil; } finally { $callDeferred($deferred, $err); }
	};
	Buffer.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, b, e, err, m, n, nBytes, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; b = $f.b; e = $f.e; err = $f.err; m = $f.m; n = $f.n; nBytes = $f.nBytes; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		nBytes = b.Len();
		/* */ if (nBytes > 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (nBytes > 0) { */ case 1:
			_r = w.Write($subslice(b.buf, b.off)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			m = _tuple[0];
			e = _tuple[1];
			if (m > nBytes) {
				$panic(new $String("bytes.Buffer.WriteTo: invalid Write count"));
			}
			b.off = b.off + (m) >> 0;
			n = (new $Int64(0, m));
			if (!($interfaceIsEqual(e, $ifaceNil))) {
				_tmp = n;
				_tmp$1 = e;
				n = _tmp;
				err = _tmp$1;
				$s = -1; return [n, err];
			}
			if (!((m === nBytes))) {
				_tmp$2 = n;
				_tmp$3 = io.ErrShortWrite;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
		/* } */ case 2:
		b.Reset();
		_tmp$4 = n;
		_tmp$5 = $ifaceNil;
		n = _tmp$4;
		err = _tmp$5;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Buffer.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.b = b; $f.e = e; $f.err = err; $f.m = m; $f.n = n; $f.nBytes = nBytes; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	Buffer.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Buffer.ptr.prototype.WriteByte = function(c) {
		var _tuple, b, c, m, ok, x;
		b = this;
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(1);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(1);
		}
		(x = b.buf, ((m < 0 || m >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + m] = c));
		return $ifaceNil;
	};
	Buffer.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Buffer.ptr.prototype.WriteRune = function(r) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, err, m, n, ok, r;
		n = 0;
		err = $ifaceNil;
		b = this;
		if (r < 128) {
			b.WriteByte(((r << 24 >>> 24)));
			_tmp = 1;
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		b.lastRead = 0;
		_tuple = b.tryGrowByReslice(4);
		m = _tuple[0];
		ok = _tuple[1];
		if (!ok) {
			m = b.grow(4);
		}
		n = utf8.EncodeRune($subslice(b.buf, m, (m + 4 >> 0)), r);
		b.buf = $subslice(b.buf, 0, (m + n >> 0));
		_tmp$2 = n;
		_tmp$3 = $ifaceNil;
		n = _tmp$2;
		err = _tmp$3;
		return [n, err];
	};
	Buffer.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Buffer.ptr.prototype.Read = function(p) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, b, err, n, p;
		n = 0;
		err = $ifaceNil;
		b = this;
		b.lastRead = 0;
		if (b.empty()) {
			b.Reset();
			if (p.$length === 0) {
				_tmp = 0;
				_tmp$1 = $ifaceNil;
				n = _tmp;
				err = _tmp$1;
				return [n, err];
			}
			_tmp$2 = 0;
			_tmp$3 = io.EOF;
			n = _tmp$2;
			err = _tmp$3;
			return [n, err];
		}
		n = $copySlice(p, $subslice(b.buf, b.off));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = -1;
		}
		_tmp$4 = n;
		_tmp$5 = $ifaceNil;
		n = _tmp$4;
		err = _tmp$5;
		return [n, err];
	};
	Buffer.prototype.Read = function(p) { return this.$val.Read(p); };
	Buffer.ptr.prototype.Next = function(n) {
		var b, data, m, n;
		b = this;
		b.lastRead = 0;
		m = b.Len();
		if (n > m) {
			n = m;
		}
		data = $subslice(b.buf, b.off, (b.off + n >> 0));
		b.off = b.off + (n) >> 0;
		if (n > 0) {
			b.lastRead = -1;
		}
		return data;
	};
	Buffer.prototype.Next = function(n) { return this.$val.Next(n); };
	Buffer.ptr.prototype.ReadByte = function() {
		var b, c, x, x$1;
		b = this;
		if (b.empty()) {
			b.Reset();
			return [0, io.EOF];
		}
		c = (x = b.buf, x$1 = b.off, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		b.off = b.off + (1) >> 0;
		b.lastRead = -1;
		return [c, $ifaceNil];
	};
	Buffer.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Buffer.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tuple, b, c, err, n, r, size, x, x$1;
		r = 0;
		size = 0;
		err = $ifaceNil;
		b = this;
		if (b.empty()) {
			b.Reset();
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			r = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [r, size, err];
		}
		c = (x = b.buf, x$1 = b.off, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (c < 128) {
			b.off = b.off + (1) >> 0;
			b.lastRead = 1;
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			r = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [r, size, err];
		}
		_tuple = utf8.DecodeRune($subslice(b.buf, b.off));
		r = _tuple[0];
		n = _tuple[1];
		b.off = b.off + (n) >> 0;
		b.lastRead = ((n << 24 >> 24));
		_tmp$6 = r;
		_tmp$7 = n;
		_tmp$8 = $ifaceNil;
		r = _tmp$6;
		size = _tmp$7;
		err = _tmp$8;
		return [r, size, err];
	};
	Buffer.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Buffer.ptr.prototype.UnreadRune = function() {
		var b;
		b = this;
		if (b.lastRead <= 0) {
			return errors.New("bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune");
		}
		if (b.off >= ((b.lastRead >> 0))) {
			b.off = b.off - (((b.lastRead >> 0))) >> 0;
		}
		b.lastRead = 0;
		return $ifaceNil;
	};
	Buffer.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Buffer.ptr.prototype.UnreadByte = function() {
		var b;
		b = this;
		if (b.lastRead === 0) {
			return errors.New("bytes.Buffer: UnreadByte: previous operation was not a successful read");
		}
		b.lastRead = 0;
		if (b.off > 0) {
			b.off = b.off - (1) >> 0;
		}
		return $ifaceNil;
	};
	Buffer.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Buffer.ptr.prototype.ReadBytes = function(delim) {
		var _tmp, _tmp$1, _tuple, b, delim, err, line, slice;
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		_tuple = b.readSlice(delim);
		slice = _tuple[0];
		err = _tuple[1];
		line = $appendSlice(line, slice);
		_tmp = line;
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.ReadBytes = function(delim) { return this.$val.ReadBytes(delim); };
	Buffer.ptr.prototype.readSlice = function(delim) {
		var _tmp, _tmp$1, b, delim, end, err, i, line;
		line = sliceType.nil;
		err = $ifaceNil;
		b = this;
		i = IndexByte($subslice(b.buf, b.off), delim);
		end = (b.off + i >> 0) + 1 >> 0;
		if (i < 0) {
			end = b.buf.$length;
			err = io.EOF;
		}
		line = $subslice(b.buf, b.off, end);
		b.off = end;
		b.lastRead = -1;
		_tmp = line;
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.readSlice = function(delim) { return this.$val.readSlice(delim); };
	Buffer.ptr.prototype.ReadString = function(delim) {
		var _tmp, _tmp$1, _tuple, b, delim, err, line, slice;
		line = "";
		err = $ifaceNil;
		b = this;
		_tuple = b.readSlice(delim);
		slice = _tuple[0];
		err = _tuple[1];
		_tmp = ($bytesToString(slice));
		_tmp$1 = err;
		line = _tmp;
		err = _tmp$1;
		return [line, err];
	};
	Buffer.prototype.ReadString = function(delim) { return this.$val.ReadString(delim); };
	NewBufferString = function(s) {
		var s;
		return new Buffer.ptr((new sliceType($stringToBytes(s))), 0, 0);
	};
	$pkg.NewBufferString = NewBufferString;
	explode = function(s, n) {
		var _tuple, a, n, na, s, size;
		if (n <= 0) {
			n = s.$length;
		}
		a = $makeSlice(sliceType$1, n);
		size = 0;
		na = 0;
		while (true) {
			if (!(s.$length > 0)) { break; }
			if ((na + 1 >> 0) >= n) {
				((na < 0 || na >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + na] = s);
				na = na + (1) >> 0;
				break;
			}
			_tuple = utf8.DecodeRune(s);
			size = _tuple[1];
			((na < 0 || na >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + na] = $subslice(s, 0, size, size));
			s = $subslice(s, size);
			na = na + (1) >> 0;
		}
		return $subslice(a, 0, na);
	};
	Count = function(s, sep) {
		var i, n, s, sep;
		if (sep.$length === 0) {
			return utf8.RuneCount(s) + 1 >> 0;
		}
		if (sep.$length === 1) {
			return bytealg.Count(s, (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]));
		}
		n = 0;
		while (true) {
			i = Index(s, sep);
			if (i === -1) {
				return n;
			}
			n = n + (1) >> 0;
			s = $subslice(s, (i + sep.$length >> 0));
		}
	};
	$pkg.Count = Count;
	Contains = function(b, subslice) {
		var b, subslice;
		return !((Index(b, subslice) === -1));
	};
	$pkg.Contains = Contains;
	ContainsAny = function(b, chars) {
		var b, chars;
		return IndexAny(b, chars) >= 0;
	};
	$pkg.ContainsAny = ContainsAny;
	LastIndex = function(s, sep) {
		var c, i, n, s, sep;
		n = sep.$length;
		if (n === 0) {
			return s.$length;
		}
		c = (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]);
		i = s.$length - n >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if ((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === c) && ((n === 1) || Equal($subslice(s, i, (i + n >> 0)), sep))) {
				return i;
			}
			i = i - (1) >> 0;
		}
		return -1;
	};
	$pkg.LastIndex = LastIndex;
	IndexAny = function(s, chars) {
		var _i, _i$1, _ref, _ref$1, _rune, _tuple, _tuple$1, as, c, ch, chars, i, i$1, isASCII, r, s, width;
		if (chars === "") {
			return -1;
		}
		if (s.$length > 8) {
			_tuple = makeASCIISet(chars);
			as = $clone(_tuple[0], asciiSet);
			isASCII = _tuple[1];
			if (isASCII) {
				_ref = s;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					i = _i;
					c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					if (new ptrType$1(as).contains(c)) {
						return i;
					}
					_i++;
				}
				return -1;
			}
		}
		width = 0;
		i$1 = 0;
		while (true) {
			if (!(i$1 < s.$length)) { break; }
			r = ((((i$1 < 0 || i$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i$1]) >> 0));
			if (r < 128) {
				width = 1;
			} else {
				_tuple$1 = utf8.DecodeRune($subslice(s, i$1));
				r = _tuple$1[0];
				width = _tuple$1[1];
			}
			_ref$1 = chars;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.length)) { break; }
				_rune = $decodeRune(_ref$1, _i$1);
				ch = _rune[0];
				if (r === ch) {
					return i$1;
				}
				_i$1 += _rune[1];
			}
			i$1 = i$1 + (width) >> 0;
		}
		return -1;
	};
	$pkg.IndexAny = IndexAny;
	genSplit = function(s, sep, sepSave, n) {
		var a, i, m, n, s, sep, sepSave;
		if (n === 0) {
			return sliceType$1.nil;
		}
		if (sep.$length === 0) {
			return explode(s, n);
		}
		if (n < 0) {
			n = Count(s, sep) + 1 >> 0;
		}
		a = $makeSlice(sliceType$1, n);
		n = n - (1) >> 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			m = Index(s, sep);
			if (m < 0) {
				break;
			}
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = $subslice(s, 0, (m + sepSave >> 0), (m + sepSave >> 0)));
			s = $subslice(s, (m + sep.$length >> 0));
			i = i + (1) >> 0;
		}
		((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = s);
		return $subslice(a, 0, (i + 1 >> 0));
	};
	Split = function(s, sep) {
		var s, sep;
		return genSplit(s, sep, 0, -1);
	};
	$pkg.Split = Split;
	SplitAfter = function(s, sep) {
		var s, sep;
		return genSplit(s, sep, sep.$length, -1);
	};
	$pkg.SplitAfter = SplitAfter;
	HasPrefix = function(s, prefix) {
		var prefix, s;
		return s.$length >= prefix.$length && Equal($subslice(s, 0, prefix.$length), prefix);
	};
	$pkg.HasPrefix = HasPrefix;
	HasSuffix = function(s, suffix) {
		var s, suffix;
		return s.$length >= suffix.$length && Equal($subslice(s, (s.$length - suffix.$length >> 0)), suffix);
	};
	$pkg.HasSuffix = HasSuffix;
	Map = function(mapping, s) {
		var _r, _tuple, b, i, mapping, maxbytes, nb, nbytes, r, rl, s, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; i = $f.i; mapping = $f.mapping; maxbytes = $f.maxbytes; nb = $f.nb; nbytes = $f.nbytes; r = $f.r; rl = $f.rl; s = $f.s; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		maxbytes = s.$length;
		nbytes = 0;
		b = $makeSlice(sliceType, maxbytes);
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < s.$length)) { break; } */ if(!(i < s.$length)) { $s = 2; continue; }
			wid = 1;
			r = ((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >> 0));
			if (r >= 128) {
				_tuple = utf8.DecodeRune($subslice(s, i));
				r = _tuple[0];
				wid = _tuple[1];
			}
			_r = mapping(r); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if (r >= 0) {
				rl = utf8.RuneLen(r);
				if (rl < 0) {
					rl = 3;
				}
				if ((nbytes + rl >> 0) > maxbytes) {
					maxbytes = ($imul(maxbytes, 2)) + 4 >> 0;
					nb = $makeSlice(sliceType, maxbytes);
					$copySlice(nb, $subslice(b, 0, nbytes));
					b = nb;
				}
				nbytes = nbytes + (utf8.EncodeRune($subslice(b, nbytes, maxbytes), r)) >> 0;
			}
			i = i + (wid) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $subslice(b, 0, nbytes);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.i = i; $f.mapping = mapping; $f.maxbytes = maxbytes; $f.nb = nb; $f.nbytes = nbytes; $f.r = r; $f.rl = rl; $f.s = s; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Map = Map;
	Repeat = function(b, count) {
		var _q, b, bp, count, nb;
		if (count < 0) {
			$panic(new $String("bytes: negative Repeat count"));
		} else if (count > 0 && !(((_q = ($imul(b.$length, count)) / count, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) === b.$length))) {
			$panic(new $String("bytes: Repeat count causes overflow"));
		}
		nb = $makeSlice(sliceType, ($imul(b.$length, count)));
		bp = $copySlice(nb, b);
		while (true) {
			if (!(bp < nb.$length)) { break; }
			$copySlice($subslice(nb, bp), $subslice(nb, 0, bp));
			bp = $imul(bp, (2));
		}
		return nb;
	};
	$pkg.Repeat = Repeat;
	ToLower = function(s) {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = Map(unicode.ToLower, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ToLower }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ToLower = ToLower;
	TrimLeftFunc = function(s, f) {
		var _r, f, i, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; i = $f.i; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = indexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i === -1) {
			$s = -1; return sliceType.nil;
		}
		$s = -1; return $subslice(s, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimLeftFunc }; } $f._r = _r; $f.f = f; $f.i = i; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimLeftFunc = TrimLeftFunc;
	TrimRightFunc = function(s, f) {
		var _r, _tuple, f, i, s, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; i = $f.i; s = $f.s; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = lastIndexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i >= 0 && ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >= 128) {
			_tuple = utf8.DecodeRune($subslice(s, i));
			wid = _tuple[1];
			i = i + (wid) >> 0;
		} else {
			i = i + (1) >> 0;
		}
		$s = -1; return $subslice(s, 0, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimRightFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.s = s; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimRightFunc = TrimRightFunc;
	TrimFunc = function(s, f) {
		var _r, _r$1, f, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; f = $f.f; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimLeftFunc(s, f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = TrimRightFunc(_r, f); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimFunc }; } $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimFunc = TrimFunc;
	TrimSuffix = function(s, suffix) {
		var s, suffix;
		if (HasSuffix(s, suffix)) {
			return $subslice(s, 0, (s.$length - suffix.$length >> 0));
		}
		return s;
	};
	$pkg.TrimSuffix = TrimSuffix;
	indexFunc = function(s, f, truth) {
		var _r, _tuple, f, r, s, start, truth, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; r = $f.r; s = $f.s; start = $f.start; truth = $f.truth; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		start = 0;
		/* while (true) { */ case 1:
			/* if (!(start < s.$length)) { break; } */ if(!(start < s.$length)) { $s = 2; continue; }
			wid = 1;
			r = ((((start < 0 || start >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + start]) >> 0));
			if (r >= 128) {
				_tuple = utf8.DecodeRune($subslice(s, start));
				r = _tuple[0];
				wid = _tuple[1];
			}
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return start;
			/* } */ case 4:
			start = start + (wid) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: indexFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.r = r; $f.s = s; $f.start = start; $f.truth = truth; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	lastIndexFunc = function(s, f, truth) {
		var _r, _tmp, _tmp$1, _tuple, f, i, r, s, size, truth, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; f = $f.f; i = $f.i; r = $f.r; s = $f.s; size = $f.size; truth = $f.truth; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = s.$length;
		/* while (true) { */ case 1:
			/* if (!(i > 0)) { break; } */ if(!(i > 0)) { $s = 2; continue; }
			_tmp = (((x = i - 1 >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) >> 0));
			_tmp$1 = 1;
			r = _tmp;
			size = _tmp$1;
			if (r >= 128) {
				_tuple = utf8.DecodeLastRune($subslice(s, 0, i));
				r = _tuple[0];
				size = _tuple[1];
			}
			i = i - (size) >> 0;
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return i;
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lastIndexFunc }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.r = r; $f.s = s; $f.size = size; $f.truth = truth; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeASCIISet = function(chars) {
		var _index, _tmp, _tmp$1, _tmp$2, _tmp$3, as, c, chars, i, ok, y;
		as = arrayType$1.zero();
		ok = false;
		i = 0;
		while (true) {
			if (!(i < chars.length)) { break; }
			c = chars.charCodeAt(i);
			if (c >= 128) {
				_tmp = $clone(as, asciiSet);
				_tmp$1 = false;
				asciiSet.copy(as, _tmp);
				ok = _tmp$1;
				return [as, ok];
			}
			_index = c >>> 5 << 24 >>> 24;
			((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index] = ((((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index]) | (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0));
			i = i + (1) >> 0;
		}
		_tmp$2 = $clone(as, asciiSet);
		_tmp$3 = true;
		asciiSet.copy(as, _tmp$2);
		ok = _tmp$3;
		return [as, ok];
	};
	asciiSet.prototype.contains = function(c) {
		var as, c, x, y;
		as = this.$val;
		return !((((((x = c >>> 5 << 24 >>> 24, (as.nilCheck, ((x < 0 || x >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[x]))) & (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0)) === 0));
	};
	$ptrType(asciiSet).prototype.contains = function(c) { return (new asciiSet(this.$get())).contains(c); };
	makeCutsetFunc = function(cutset) {
		var _tuple, as, cutset, isASCII;
		if ((cutset.length === 1) && cutset.charCodeAt(0) < 128) {
			return (function(r) {
				var r;
				return r === ((cutset.charCodeAt(0) >> 0));
			});
		}
		_tuple = makeASCIISet(cutset);
		as = $clone(_tuple[0], asciiSet);
		isASCII = _tuple[1];
		if (isASCII) {
			return (function(r) {
				var r;
				return r < 128 && new ptrType$1(as).contains(((r << 24 >>> 24)));
			});
		}
		return (function(r) {
			var _i, _ref, _rune, c, r;
			_ref = cutset;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				c = _rune[0];
				if (c === r) {
					return true;
				}
				_i += _rune[1];
			}
			return false;
		});
	};
	Trim = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Trim }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Trim = Trim;
	TrimRight = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimRightFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimRight }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimRight = TrimRight;
	TrimSpace = function(s) {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimFunc(s, unicode.IsSpace); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimSpace }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimSpace = TrimSpace;
	Replace = function(s, old, new$1, n) {
		var _tuple, i, j, m, n, new$1, old, s, start, t, w, wid;
		m = 0;
		if (!((n === 0))) {
			m = Count(s, old);
		}
		if (m === 0) {
			return $appendSlice((sliceType.nil), s);
		}
		if (n < 0 || m < n) {
			n = m;
		}
		t = $makeSlice(sliceType, (s.$length + ($imul(n, ((new$1.$length - old.$length >> 0)))) >> 0));
		w = 0;
		start = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			j = start;
			if (old.$length === 0) {
				if (i > 0) {
					_tuple = utf8.DecodeRune($subslice(s, start));
					wid = _tuple[1];
					j = j + (wid) >> 0;
				}
			} else {
				j = j + (Index($subslice(s, start), old)) >> 0;
			}
			w = w + ($copySlice($subslice(t, w), $subslice(s, start, j))) >> 0;
			w = w + ($copySlice($subslice(t, w), new$1)) >> 0;
			start = j + old.$length >> 0;
			i = i + (1) >> 0;
		}
		w = w + ($copySlice($subslice(t, w), $subslice(s, start))) >> 0;
		return $subslice(t, 0, w);
	};
	$pkg.Replace = Replace;
	ReplaceAll = function(s, old, new$1) {
		var new$1, old, s;
		return Replace(s, old, new$1, -1);
	};
	$pkg.ReplaceAll = ReplaceAll;
	EqualFold = function(s, t) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, r, r$1, r$2, s, size, size$1, sr, t, tr;
		while (true) {
			if (!(!((s.$length === 0)) && !((t.$length === 0)))) { break; }
			_tmp = 0;
			_tmp$1 = 0;
			sr = _tmp;
			tr = _tmp$1;
			if ((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]) < 128) {
				_tmp$2 = (((0 >= s.$length ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + 0]) >> 0));
				_tmp$3 = $subslice(s, 1);
				sr = _tmp$2;
				s = _tmp$3;
			} else {
				_tuple = utf8.DecodeRune(s);
				r = _tuple[0];
				size = _tuple[1];
				_tmp$4 = r;
				_tmp$5 = $subslice(s, size);
				sr = _tmp$4;
				s = _tmp$5;
			}
			if ((0 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 0]) < 128) {
				_tmp$6 = (((0 >= t.$length ? ($throwRuntimeError("index out of range"), undefined) : t.$array[t.$offset + 0]) >> 0));
				_tmp$7 = $subslice(t, 1);
				tr = _tmp$6;
				t = _tmp$7;
			} else {
				_tuple$1 = utf8.DecodeRune(t);
				r$1 = _tuple$1[0];
				size$1 = _tuple$1[1];
				_tmp$8 = r$1;
				_tmp$9 = $subslice(t, size$1);
				tr = _tmp$8;
				t = _tmp$9;
			}
			if (tr === sr) {
				continue;
			}
			if (tr < sr) {
				_tmp$10 = sr;
				_tmp$11 = tr;
				tr = _tmp$10;
				sr = _tmp$11;
			}
			if (tr < 128) {
				if (65 <= sr && sr <= 90 && (tr === ((sr + 97 >> 0) - 65 >> 0))) {
					continue;
				}
				return false;
			}
			r$2 = unicode.SimpleFold(sr);
			while (true) {
				if (!(!((r$2 === sr)) && r$2 < tr)) { break; }
				r$2 = unicode.SimpleFold(r$2);
			}
			if (r$2 === tr) {
				continue;
			}
			return false;
		}
		return s.$length === t.$length;
	};
	$pkg.EqualFold = EqualFold;
	Index = function(s, sep) {
		var c0, c0$1, c1, c1$1, fails, fails$1, i, i$1, j, n, o, o$1, r, s, sep, t, t$1, x, x$1;
		n = sep.$length;
		if ((n === 0)) {
			return 0;
		} else if ((n === 1)) {
			return IndexByte(s, (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]));
		} else if ((n === s.$length)) {
			if (Equal(sep, s)) {
				return 0;
			}
			return -1;
		} else if (n > s.$length) {
			return -1;
		} else if (n <= bytealg.MaxLen) {
			if (s.$length <= 0) {
				return bytealg.Index(s, sep);
			}
			c0 = (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]);
			c1 = (1 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 1]);
			i = 0;
			t = (s.$length - n >> 0) + 1 >> 0;
			fails = 0;
			while (true) {
				if (!(i < t)) { break; }
				if (!((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === c0))) {
					o = IndexByte($subslice(s, i, t), c0);
					if (o < 0) {
						return -1;
					}
					i = i + (o) >> 0;
				}
				if (((x = i + 1 >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) === c1) && Equal($subslice(s, i, (i + n >> 0)), sep)) {
					return i;
				}
				fails = fails + (1) >> 0;
				i = i + (1) >> 0;
				if (fails > bytealg.Cutover(i)) {
					r = bytealg.Index($subslice(s, i), sep);
					if (r >= 0) {
						return r + i >> 0;
					}
					return -1;
				}
			}
			return -1;
		}
		c0$1 = (0 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 0]);
		c1$1 = (1 >= sep.$length ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + 1]);
		i$1 = 0;
		fails$1 = 0;
		t$1 = (s.$length - n >> 0) + 1 >> 0;
		while (true) {
			if (!(i$1 < t$1)) { break; }
			if (!((((i$1 < 0 || i$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i$1]) === c0$1))) {
				o$1 = IndexByte($subslice(s, i$1, t$1), c0$1);
				if (o$1 < 0) {
					break;
				}
				i$1 = i$1 + (o$1) >> 0;
			}
			if (((x$1 = i$1 + 1 >> 0, ((x$1 < 0 || x$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x$1])) === c1$1) && Equal($subslice(s, i$1, (i$1 + n >> 0)), sep)) {
				return i$1;
			}
			i$1 = i$1 + (1) >> 0;
			fails$1 = fails$1 + (1) >> 0;
			if (fails$1 >= (4 + (i$1 >> 4 >> 0) >> 0) && i$1 < t$1) {
				j = indexRabinKarp($subslice(s, i$1), sep);
				if (j < 0) {
					return -1;
				}
				return i$1 + j >> 0;
			}
		}
		return -1;
	};
	$pkg.Index = Index;
	indexRabinKarp = function(s, sep) {
		var _tuple, h, hashsep, i, i$1, n, pow, s, sep, x;
		_tuple = hashStr(sep);
		hashsep = _tuple[0];
		pow = _tuple[1];
		n = sep.$length;
		h = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			h = ($imul(h, 16777619) >>> 0) + ((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >>> 0)) >>> 0;
			i = i + (1) >> 0;
		}
		if ((h === hashsep) && Equal($subslice(s, 0, n), sep)) {
			return 0;
		}
		i$1 = n;
		while (true) {
			if (!(i$1 < s.$length)) { break; }
			h = $imul(h, (16777619)) >>> 0;
			h = h + (((((i$1 < 0 || i$1 >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i$1]) >>> 0))) >>> 0;
			h = h - (($imul(pow, (((x = i$1 - n >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) >>> 0))) >>> 0)) >>> 0;
			i$1 = i$1 + (1) >> 0;
			if ((h === hashsep) && Equal($subslice(s, (i$1 - n >> 0), i$1), sep)) {
				return i$1 - n >> 0;
			}
		}
		return -1;
	};
	hashStr = function(sep) {
		var _tmp, _tmp$1, hash, i, i$1, pow, sep, sq;
		hash = 0;
		i = 0;
		while (true) {
			if (!(i < sep.$length)) { break; }
			hash = ($imul(hash, 16777619) >>> 0) + ((((i < 0 || i >= sep.$length) ? ($throwRuntimeError("index out of range"), undefined) : sep.$array[sep.$offset + i]) >>> 0)) >>> 0;
			i = i + (1) >> 0;
		}
		_tmp = 1;
		_tmp$1 = 16777619;
		pow = _tmp;
		sq = _tmp$1;
		i$1 = sep.$length;
		while (true) {
			if (!(i$1 > 0)) { break; }
			if (!(((i$1 & 1) === 0))) {
				pow = $imul(pow, (sq)) >>> 0;
			}
			sq = $imul(sq, (sq)) >>> 0;
			i$1 = (i$1 >> $min((1), 31)) >> 0;
		}
		return [hash, pow];
	};
	Reader.ptr.prototype.Len = function() {
		var r, x, x$1, x$2, x$3, x$4;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return 0;
		}
		return (((x$2 = (x$3 = (new $Int64(0, r.s.$length)), x$4 = r.i, new $Int64(x$3.$high - x$4.$high, x$3.$low - x$4.$low)), x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
	};
	Reader.prototype.Len = function() { return this.$val.Len(); };
	Reader.ptr.prototype.Size = function() {
		var r;
		r = this;
		return (new $Int64(0, r.s.$length));
	};
	Reader.prototype.Size = function() { return this.$val.Size(); };
	Reader.ptr.prototype.Read = function(b) {
		var _tmp, _tmp$1, b, err, n, r, x, x$1, x$2, x$3;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = 0;
			_tmp$1 = io.EOF;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		r.prevRune = -1;
		n = $copySlice(b, $subslice(r.s, $flatten64(r.i)));
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, n)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		return [n, err];
	};
	Reader.prototype.Read = function(b) { return this.$val.Read(b); };
	Reader.ptr.prototype.ReadAt = function(b, off) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, b, err, n, off, r, x;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp = 0;
			_tmp$1 = errors.New("bytes.Reader.ReadAt: negative offset");
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		if ((x = (new $Int64(0, r.s.$length)), (off.$high > x.$high || (off.$high === x.$high && off.$low >= x.$low)))) {
			_tmp$2 = 0;
			_tmp$3 = io.EOF;
			n = _tmp$2;
			err = _tmp$3;
			return [n, err];
		}
		n = $copySlice(b, $subslice(r.s, $flatten64(off)));
		if (n < b.$length) {
			err = io.EOF;
		}
		return [n, err];
	};
	Reader.prototype.ReadAt = function(b, off) { return this.$val.ReadAt(b, off); };
	Reader.ptr.prototype.ReadByte = function() {
		var b, r, x, x$1, x$2, x$3, x$4, x$5;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return [0, io.EOF];
		}
		b = (x$2 = r.s, x$3 = r.i, (($flatten64(x$3) < 0 || $flatten64(x$3) >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + $flatten64(x$3)]));
		r.i = (x$4 = r.i, x$5 = new $Int64(0, 1), new $Int64(x$4.$high + x$5.$high, x$4.$low + x$5.$low));
		return [b, $ifaceNil];
	};
	Reader.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Reader.ptr.prototype.UnreadByte = function() {
		var r, x, x$1, x$2;
		r = this;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("bytes.Reader.UnreadByte: at beginning of slice");
		}
		r.prevRune = -1;
		r.i = (x$1 = r.i, x$2 = new $Int64(0, 1), new $Int64(x$1.$high - x$2.$high, x$1.$low - x$2.$low));
		return $ifaceNil;
	};
	Reader.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Reader.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, c, ch, err, r, size, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8;
		ch = 0;
		size = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			r.prevRune = -1;
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			ch = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [ch, size, err];
		}
		r.prevRune = (((x$2 = r.i, x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
		c = (x$3 = r.s, x$4 = r.i, (($flatten64(x$4) < 0 || $flatten64(x$4) >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + $flatten64(x$4)]));
		if (c < 128) {
			r.i = (x$5 = r.i, x$6 = new $Int64(0, 1), new $Int64(x$5.$high + x$6.$high, x$5.$low + x$6.$low));
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			ch = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [ch, size, err];
		}
		_tuple = utf8.DecodeRune($subslice(r.s, $flatten64(r.i)));
		ch = _tuple[0];
		size = _tuple[1];
		r.i = (x$7 = r.i, x$8 = (new $Int64(0, size)), new $Int64(x$7.$high + x$8.$high, x$7.$low + x$8.$low));
		return [ch, size, err];
	};
	Reader.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Reader.ptr.prototype.UnreadRune = function() {
		var r, x;
		r = this;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("bytes.Reader.UnreadRune: at beginning of slice");
		}
		if (r.prevRune < 0) {
			return errors.New("bytes.Reader.UnreadRune: previous operation was not ReadRune");
		}
		r.i = (new $Int64(0, r.prevRune));
		r.prevRune = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Reader.ptr.prototype.Seek = function(offset, whence) {
		var _1, abs, offset, r, whence, x, x$1;
		r = this;
		r.prevRune = -1;
		abs = new $Int64(0, 0);
		_1 = whence;
		if (_1 === (0)) {
			abs = offset;
		} else if (_1 === (1)) {
			abs = (x = r.i, new $Int64(x.$high + offset.$high, x.$low + offset.$low));
		} else if (_1 === (2)) {
			abs = (x$1 = (new $Int64(0, r.s.$length)), new $Int64(x$1.$high + offset.$high, x$1.$low + offset.$low));
		} else {
			return [new $Int64(0, 0), errors.New("bytes.Reader.Seek: invalid whence")];
		}
		if ((abs.$high < 0 || (abs.$high === 0 && abs.$low < 0))) {
			return [new $Int64(0, 0), errors.New("bytes.Reader.Seek: negative position")];
		}
		r.i = abs;
		return [abs, $ifaceNil];
	};
	Reader.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	Reader.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tuple, b, err, m, n, r, w, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; b = $f.b; err = $f.err; m = $f.m; n = $f.n; r = $f.r; w = $f.w; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.$length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		b = $subslice(r.s, $flatten64(r.i));
		_r = w.Write(b); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		m = _tuple[0];
		err = _tuple[1];
		if (m > b.$length) {
			$panic(new $String("bytes.Reader.WriteTo: invalid Write count"));
		}
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, m)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		n = (new $Int64(0, m));
		if (!((m === b.$length)) && $interfaceIsEqual(err, $ifaceNil)) {
			err = io.ErrShortWrite;
		}
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.m = m; $f.n = n; $f.r = r; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Reader.ptr.prototype.Reset = function(b) {
		var b, r;
		r = this;
		Reader.copy(r, new Reader.ptr(b, new $Int64(0, 0), -1));
	};
	Reader.prototype.Reset = function(b) { return this.$val.Reset(b); };
	NewReader = function(b) {
		var b;
		return new Reader.ptr(b, new $Int64(0, 0), -1);
	};
	$pkg.NewReader = NewReader;
	ptrType.methods = [{prop: "Bytes", name: "Bytes", pkg: "", typ: $funcType([], [sliceType], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "empty", name: "empty", pkg: "bytes", typ: $funcType([], [$Bool], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Truncate", name: "Truncate", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "tryGrowByReslice", name: "tryGrowByReslice", pkg: "bytes", typ: $funcType([$Int], [$Int, $Bool], false)}, {prop: "grow", name: "grow", pkg: "bytes", typ: $funcType([$Int], [$Int], false)}, {prop: "Grow", name: "Grow", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([io.Reader], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "Next", name: "Next", pkg: "", typ: $funcType([$Int], [sliceType], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadBytes", name: "ReadBytes", pkg: "", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "readSlice", name: "readSlice", pkg: "bytes", typ: $funcType([$Uint8], [sliceType, $error], false)}, {prop: "ReadString", name: "ReadString", pkg: "", typ: $funcType([$Uint8], [$String, $error], false)}];
	ptrType$1.methods = [{prop: "contains", name: "contains", pkg: "bytes", typ: $funcType([$Uint8], [$Bool], false)}];
	ptrType$2.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "ReadAt", name: "ReadAt", pkg: "", typ: $funcType([sliceType, $Int64], [$Int, $error], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([sliceType], [], false)}];
	Buffer.init("bytes", [{prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "off", name: "off", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lastRead", name: "lastRead", embedded: false, exported: false, typ: readOp, tag: ""}]);
	asciiSet.init($Uint32, 8);
	Reader.init("bytes", [{prop: "s", name: "s", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "i", name: "i", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "prevRune", name: "prevRune", embedded: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrTooLarge = errors.New("bytes.Buffer: too large");
		errNegativeRead = errors.New("bytes.Buffer: reader returned negative count from Read");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["bufio"] = (function() {
	var $pkg = {}, $init, bytes, errors, io, utf8, Writer, sliceType, ptrType$1, errNegativeRead, errNegativeWrite, NewWriterSize, NewWriter;
	bytes = $packages["bytes"];
	errors = $packages["errors"];
	io = $packages["io"];
	utf8 = $packages["unicode/utf8"];
	Writer = $pkg.Writer = $newType(0, $kindStruct, "bufio.Writer", true, "bufio", true, function(err_, buf_, n_, wr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.err = $ifaceNil;
			this.buf = sliceType.nil;
			this.n = 0;
			this.wr = $ifaceNil;
			return;
		}
		this.err = err_;
		this.buf = buf_;
		this.n = n_;
		this.wr = wr_;
	});
	sliceType = $sliceType($Uint8);
	ptrType$1 = $ptrType(Writer);
	NewWriterSize = function(w, size) {
		var _tuple, b, ok, size, w;
		_tuple = $assertType(w, ptrType$1, true);
		b = _tuple[0];
		ok = _tuple[1];
		if (ok && b.buf.$length >= size) {
			return b;
		}
		if (size <= 0) {
			size = 4096;
		}
		return new Writer.ptr($ifaceNil, $makeSlice(sliceType, size), 0, w);
	};
	$pkg.NewWriterSize = NewWriterSize;
	NewWriter = function(w) {
		var w;
		return NewWriterSize(w, 4096);
	};
	$pkg.NewWriter = NewWriter;
	Writer.ptr.prototype.Size = function() {
		var b;
		b = this;
		return b.buf.$length;
	};
	Writer.prototype.Size = function() { return this.$val.Size(); };
	Writer.ptr.prototype.Reset = function(w) {
		var b, w;
		b = this;
		b.err = $ifaceNil;
		b.n = 0;
		b.wr = w;
	};
	Writer.prototype.Reset = function(w) { return this.$val.Reset(w); };
	Writer.ptr.prototype.Flush = function() {
		var _r, _tuple, b, err, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; err = $f.err; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			$s = -1; return b.err;
		}
		if (b.n === 0) {
			$s = -1; return $ifaceNil;
		}
		_r = b.wr.Write($subslice(b.buf, 0, b.n)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		n = _tuple[0];
		err = _tuple[1];
		if (n < b.n && $interfaceIsEqual(err, $ifaceNil)) {
			err = io.ErrShortWrite;
		}
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			if (n > 0 && n < b.n) {
				$copySlice($subslice(b.buf, 0, (b.n - n >> 0)), $subslice(b.buf, n, b.n));
			}
			b.n = b.n - (n) >> 0;
			b.err = err;
			$s = -1; return err;
		}
		b.n = 0;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.Flush }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.Flush = function() { return this.$val.Flush(); };
	Writer.ptr.prototype.Available = function() {
		var b;
		b = this;
		return b.buf.$length - b.n >> 0;
	};
	Writer.prototype.Available = function() { return this.$val.Available(); };
	Writer.ptr.prototype.Buffered = function() {
		var b;
		b = this;
		return b.n;
	};
	Writer.prototype.Buffered = function() { return this.$val.Buffered(); };
	Writer.ptr.prototype.Write = function(p) {
		var _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, b, err, n, n$1, nn, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tuple = $f._tuple; b = $f.b; err = $f.err; n = $f.n; n$1 = $f.n$1; nn = $f.nn; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		nn = 0;
		err = $ifaceNil;
		b = this;
		/* while (true) { */ case 1:
			/* if (!(p.$length > b.Available() && $interfaceIsEqual(b.err, $ifaceNil))) { break; } */ if(!(p.$length > b.Available() && $interfaceIsEqual(b.err, $ifaceNil))) { $s = 2; continue; }
			n = 0;
			/* */ if (b.Buffered() === 0) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (b.Buffered() === 0) { */ case 3:
				_r = b.wr.Write(p); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				n = _tuple[0];
				b.err = _tuple[1];
				$s = 5; continue;
			/* } else { */ case 4:
				n = $copySlice($subslice(b.buf, b.n), p);
				b.n = b.n + (n) >> 0;
				_r$1 = b.Flush(); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				_r$1;
			/* } */ case 5:
			nn = nn + (n) >> 0;
			p = $subslice(p, n);
		/* } */ $s = 1; continue; case 2:
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			_tmp = nn;
			_tmp$1 = b.err;
			nn = _tmp;
			err = _tmp$1;
			$s = -1; return [nn, err];
		}
		n$1 = $copySlice($subslice(b.buf, b.n), p);
		b.n = b.n + (n$1) >> 0;
		nn = nn + (n$1) >> 0;
		_tmp$2 = nn;
		_tmp$3 = $ifaceNil;
		nn = _tmp$2;
		err = _tmp$3;
		$s = -1; return [nn, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.Write }; } $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.n = n; $f.n$1 = n$1; $f.nn = nn; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.Write = function(p) { return this.$val.Write(p); };
	Writer.ptr.prototype.WriteByte = function(c) {
		var _r, _v, b, c, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _v = $f._v; b = $f.b; c = $f.c; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			$s = -1; return b.err;
		}
		if (!(b.Available() <= 0)) { _v = false; $s = 3; continue s; }
		_r = b.Flush(); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_v = !($interfaceIsEqual(_r, $ifaceNil)); case 3:
		/* */ if (_v) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_v) { */ case 1:
			$s = -1; return b.err;
		/* } */ case 2:
		(x = b.buf, x$1 = b.n, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1] = c));
		b.n = b.n + (1) >> 0;
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.WriteByte }; } $f._r = _r; $f._v = _v; $f.b = b; $f.c = c; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Writer.ptr.prototype.WriteRune = function(r) {
		var _r, _r$1, _r$2, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, b, err, n, r, size, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tmp$9 = $f._tmp$9; _tuple = $f._tuple; b = $f.b; err = $f.err; n = $f.n; r = $f.r; size = $f.size; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		size = 0;
		err = $ifaceNil;
		b = this;
		/* */ if (r < 128) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r < 128) { */ case 1:
			_r = b.WriteByte(((r << 24 >>> 24))); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			err = _r;
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				_tmp = 0;
				_tmp$1 = err;
				size = _tmp;
				err = _tmp$1;
				$s = -1; return [size, err];
			}
			_tmp$2 = 1;
			_tmp$3 = $ifaceNil;
			size = _tmp$2;
			err = _tmp$3;
			$s = -1; return [size, err];
		/* } */ case 2:
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			_tmp$4 = 0;
			_tmp$5 = b.err;
			size = _tmp$4;
			err = _tmp$5;
			$s = -1; return [size, err];
		}
		n = b.Available();
		/* */ if (n < 4) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (n < 4) { */ case 4:
			_r$1 = b.Flush(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_r$1;
			if (!($interfaceIsEqual(b.err, $ifaceNil))) {
				_tmp$6 = 0;
				_tmp$7 = b.err;
				size = _tmp$6;
				err = _tmp$7;
				$s = -1; return [size, err];
			}
			n = b.Available();
			/* */ if (n < 4) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (n < 4) { */ case 7:
				_r$2 = b.WriteString(($encodeRune(r))); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_tuple = _r$2;
				size = _tuple[0];
				err = _tuple[1];
				$s = -1; return [size, err];
			/* } */ case 8:
		/* } */ case 5:
		size = utf8.EncodeRune($subslice(b.buf, b.n), r);
		b.n = b.n + (size) >> 0;
		_tmp$8 = size;
		_tmp$9 = $ifaceNil;
		size = _tmp$8;
		err = _tmp$9;
		$s = -1; return [size, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.WriteRune }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tmp$9 = _tmp$9; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.n = n; $f.r = r; $f.size = size; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Writer.ptr.prototype.WriteString = function(s) {
		var _r, b, n, n$1, nn, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; b = $f.b; n = $f.n; n$1 = $f.n$1; nn = $f.nn; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = this;
		nn = 0;
		/* while (true) { */ case 1:
			/* if (!(s.length > b.Available() && $interfaceIsEqual(b.err, $ifaceNil))) { break; } */ if(!(s.length > b.Available() && $interfaceIsEqual(b.err, $ifaceNil))) { $s = 2; continue; }
			n = $copyString($subslice(b.buf, b.n), s);
			b.n = b.n + (n) >> 0;
			nn = nn + (n) >> 0;
			s = $substring(s, n);
			_r = b.Flush(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
		/* } */ $s = 1; continue; case 2:
		if (!($interfaceIsEqual(b.err, $ifaceNil))) {
			$s = -1; return [nn, b.err];
		}
		n$1 = $copyString($subslice(b.buf, b.n), s);
		b.n = b.n + (n$1) >> 0;
		nn = nn + (n$1) >> 0;
		$s = -1; return [nn, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.WriteString }; } $f._r = _r; $f.b = b; $f.n = n; $f.n$1 = n$1; $f.nn = nn; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Writer.ptr.prototype.ReadFrom = function(r) {
		var _r, _r$1, _r$2, _r$3, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, _tuple$2, b, err, err1, m, n, nr, ok, r, w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; b = $f.b; err = $f.err; err1 = $f.err1; m = $f.m; n = $f.n; nr = $f.nr; ok = $f.ok; r = $f.r; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		b = this;
		/* */ if (b.Buffered() === 0) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (b.Buffered() === 0) { */ case 1:
			_tuple = $assertType(b.wr, io.ReaderFrom, true);
			w = _tuple[0];
			ok = _tuple[1];
			/* */ if (ok) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (ok) { */ case 3:
				_r = w.ReadFrom(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple$1 = _r;
				n = _tuple$1[0];
				err = _tuple$1[1];
				$s = -1; return [n, err];
			/* } */ case 4:
		/* } */ case 2:
		m = 0;
		/* while (true) { */ case 6:
			/* */ if (b.Available() === 0) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (b.Available() === 0) { */ case 8:
				_r$1 = b.Flush(); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				err1 = _r$1;
				if (!($interfaceIsEqual(err1, $ifaceNil))) {
					_tmp = n;
					_tmp$1 = err1;
					n = _tmp;
					err = _tmp$1;
					$s = -1; return [n, err];
				}
			/* } */ case 9:
			nr = 0;
			/* while (true) { */ case 11:
				/* if (!(nr < 100)) { break; } */ if(!(nr < 100)) { $s = 12; continue; }
				_r$2 = r.Read($subslice(b.buf, b.n)); /* */ $s = 13; case 13: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_tuple$2 = _r$2;
				m = _tuple$2[0];
				err = _tuple$2[1];
				if (!((m === 0)) || !($interfaceIsEqual(err, $ifaceNil))) {
					/* break; */ $s = 12; continue;
				}
				nr = nr + (1) >> 0;
			/* } */ $s = 11; continue; case 12:
			if (nr === 100) {
				_tmp$2 = n;
				_tmp$3 = io.ErrNoProgress;
				n = _tmp$2;
				err = _tmp$3;
				$s = -1; return [n, err];
			}
			b.n = b.n + (m) >> 0;
			n = (x = (new $Int64(0, m)), new $Int64(n.$high + x.$high, n.$low + x.$low));
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				/* break; */ $s = 7; continue;
			}
		/* } */ $s = 6; continue; case 7:
		/* */ if ($interfaceIsEqual(err, io.EOF)) { $s = 14; continue; }
		/* */ $s = 15; continue;
		/* if ($interfaceIsEqual(err, io.EOF)) { */ case 14:
			/* */ if (b.Available() === 0) { $s = 16; continue; }
			/* */ $s = 17; continue;
			/* if (b.Available() === 0) { */ case 16:
				_r$3 = b.Flush(); /* */ $s = 19; case 19: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				err = _r$3;
				$s = 18; continue;
			/* } else { */ case 17:
				err = $ifaceNil;
			/* } */ case 18:
		/* } */ case 15:
		_tmp$4 = n;
		_tmp$5 = err;
		n = _tmp$4;
		err = _tmp$5;
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Writer.ptr.prototype.ReadFrom }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.b = b; $f.err = err; $f.err1 = err1; $f.m = m; $f.n = n; $f.nr = nr; $f.ok = ok; $f.r = r; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Writer.prototype.ReadFrom = function(r) { return this.$val.ReadFrom(r); };
	ptrType$1.methods = [{prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([io.Writer], [], false)}, {prop: "Flush", name: "Flush", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Available", name: "Available", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Buffered", name: "Buffered", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}, {prop: "ReadFrom", name: "ReadFrom", pkg: "", typ: $funcType([io.Reader], [$Int64, $error], false)}];
	Writer.init("bufio", [{prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "n", name: "n", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "wr", name: "wr", embedded: false, exported: false, typ: io.Writer, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte");
		$pkg.ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune");
		$pkg.ErrBufferFull = errors.New("bufio: buffer full");
		$pkg.ErrNegativeCount = errors.New("bufio: negative count");
		errNegativeRead = errors.New("bufio: reader returned negative count from Read");
		errNegativeWrite = errors.New("bufio: writer returned negative count from Write");
		$pkg.ErrTooLong = errors.New("bufio.Scanner: token too long");
		$pkg.ErrNegativeAdvance = errors.New("bufio.Scanner: SplitFunc returns negative advance count");
		$pkg.ErrAdvanceTooFar = errors.New("bufio.Scanner: SplitFunc returns advance count beyond input");
		$pkg.ErrFinalToken = errors.New("final token");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute/html/atom"] = (function() {
	var $pkg = {}, $init, Atom, table, fnv, match, Lookup, String;
	Atom = $pkg.Atom = $newType(4, $kindUint32, "atom.Atom", true, "lute/html/atom", true, null);
	Atom.prototype.String = function() {
		var a, n, start;
		a = this.$val;
		start = (((a >>> 8 >>> 0) >>> 0));
		n = ((((a & 255) >>> 0) >>> 0));
		if ((start + n >>> 0) > 1834) {
			return "";
		}
		return $substring("abbradiogrouparamainavalueaccept-charsetbodyaccesskeygenobrbasefontimeupdateviacacheightmlabelooptgroupatternoembedetailsampictureversedfnoframesetdirnameterowspanomoduleacronymalignmarkbdialogallowpaymentrequestrikeytypeallowusermediagroupingaltfooterubyasyncanvasidefaultitleaudioncancelautofocusandboxmplaceholderautoplaysinlinebdoncanplaythrough1bgsoundisabledivarbigblinkindraggablegendblockquotebuttonabortcitempropenoncecolgrouplaintextrackcolorcolspannotation-xmlcommandcontrolshapecoordslotranslatecrossoriginsmallowfullscreenoscriptfacenterfieldsetfigcaptionafterprintegrityfigurequiredforeignObjectforeignobjectformactionautocompleteerrorformenctypemustmatchallengeformmethodformnovalidatetimeformtargethgrouposterhiddenhigh2hreflanghttp-equivideonclickiframeimageimglyph3isindexismappletitemtypemarqueematheadersortedmaxlength4minlength5mtextareadonlymultiplemutedoncloseamlessourceoncontextmenuitemidoncopyoncuechangeoncutondblclickondragendondragenterondragexitemreferrerpolicyondragleaveondragoverondragstarticleondropzonemptiedondurationchangeonendedonerroronfocuspaceronhashchangeoninputmodeloninvalidonkeydownloadonkeypresspellcheckedonkeyupreloadonlanguagechangeonloadeddatalistingonloadedmetadatabindexonloadendonloadstartonmessageerroronmousedownonmouseenteronmouseleaveonmousemoveonmouseoutputonmouseoveronmouseupromptonmousewheelonofflineononlineonpagehidesclassectionbluronpageshowbronpastepublicontenteditableonpausemaponplayingonpopstateonprogressrcdocodeferonratechangeonrejectionhandledonresetonresizesrclangonscrollonsecuritypolicyviolationauxclickonseekedonseekingonselectedonshowidth6onsortableonstalledonstorageonsubmitemscopedonsuspendontoggleonunhandledrejectionbeforeprintonunloadonvolumechangeonwaitingonwheeloptimumanifestrongoptionbeforeunloaddressrcsetstylesummarysupsvgsystemplateworkertypewrap", start, (start + n >>> 0));
	};
	$ptrType(Atom).prototype.String = function() { return new Atom(this.$get()).String(); };
	Atom.prototype.string = function() {
		var a;
		a = this.$val;
		return $substring("abbradiogrouparamainavalueaccept-charsetbodyaccesskeygenobrbasefontimeupdateviacacheightmlabelooptgroupatternoembedetailsampictureversedfnoframesetdirnameterowspanomoduleacronymalignmarkbdialogallowpaymentrequestrikeytypeallowusermediagroupingaltfooterubyasyncanvasidefaultitleaudioncancelautofocusandboxmplaceholderautoplaysinlinebdoncanplaythrough1bgsoundisabledivarbigblinkindraggablegendblockquotebuttonabortcitempropenoncecolgrouplaintextrackcolorcolspannotation-xmlcommandcontrolshapecoordslotranslatecrossoriginsmallowfullscreenoscriptfacenterfieldsetfigcaptionafterprintegrityfigurequiredforeignObjectforeignobjectformactionautocompleteerrorformenctypemustmatchallengeformmethodformnovalidatetimeformtargethgrouposterhiddenhigh2hreflanghttp-equivideonclickiframeimageimglyph3isindexismappletitemtypemarqueematheadersortedmaxlength4minlength5mtextareadonlymultiplemutedoncloseamlessourceoncontextmenuitemidoncopyoncuechangeoncutondblclickondragendondragenterondragexitemreferrerpolicyondragleaveondragoverondragstarticleondropzonemptiedondurationchangeonendedonerroronfocuspaceronhashchangeoninputmodeloninvalidonkeydownloadonkeypresspellcheckedonkeyupreloadonlanguagechangeonloadeddatalistingonloadedmetadatabindexonloadendonloadstartonmessageerroronmousedownonmouseenteronmouseleaveonmousemoveonmouseoutputonmouseoveronmouseupromptonmousewheelonofflineononlineonpagehidesclassectionbluronpageshowbronpastepublicontenteditableonpausemaponplayingonpopstateonprogressrcdocodeferonratechangeonrejectionhandledonresetonresizesrclangonscrollonsecuritypolicyviolationauxclickonseekedonseekingonselectedonshowidth6onsortableonstalledonstorageonsubmitemscopedonsuspendontoggleonunhandledrejectionbeforeprintonunloadonvolumechangeonwaitingonwheeloptimumanifestrongoptionbeforeunloaddressrcsetstylesummarysupsvgsystemplateworkertypewrap", (a >>> 8 >>> 0), ((a >>> 8 >>> 0) + ((a & 255) >>> 0) >>> 0));
	};
	$ptrType(Atom).prototype.string = function() { return new Atom(this.$get()).string(); };
	fnv = function(h, s) {
		var _i, _ref, h, i, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			h = (h ^ (((((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) >>> 0)))) >>> 0;
			h = $imul(h, (16777619)) >>> 0;
			_i++;
		}
		return h;
	};
	match = function(s, t) {
		var _i, _ref, c, i, s, t;
		_ref = t;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((s.charCodeAt(i) === c))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	Lookup = function(s) {
		var a, a$1, h, s, x, x$1;
		if ((s.$length === 0) || s.$length > 25) {
			return 0;
		}
		h = fnv(2177757454, s);
		a = (x = (h & 511) >>> 0, ((x < 0 || x >= table.length) ? ($throwRuntimeError("index out of range"), undefined) : table[x]));
		if ((((((a & 255) >>> 0) >> 0)) === s.$length) && match(new Atom(a).string(), s)) {
			return a;
		}
		a$1 = (x$1 = (((h >>> 16 >>> 0)) & 511) >>> 0, ((x$1 < 0 || x$1 >= table.length) ? ($throwRuntimeError("index out of range"), undefined) : table[x$1]));
		if ((((((a$1 & 255) >>> 0) >> 0)) === s.$length) && match(new Atom(a$1).string(), s)) {
			return a$1;
		}
		return 0;
	};
	$pkg.Lookup = Lookup;
	String = function(s) {
		var a, s;
		a = Lookup(s);
		if (!((a === 0))) {
			return new Atom(a).String();
		}
		return ($bytesToString(s));
	};
	$pkg.String = String;
	Atom.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "string", name: "string", pkg: "lute/html/atom", typ: $funcType([], [$String], false)}];
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		table = $toNativeArray($kindUint32, [0, 58890, 189444, 0, 11273, 35592, 0, 408072, 463110, 0, 411909, 0, 166155, 79618, 235275, 0, 84739, 70917, 96777, 0, 192773, 176386, 231172, 184070, 0, 62982, 174086, 178184, 103687, 17934, 65285, 302342, 0, 71944, 403720, 197125, 382994, 0, 95236, 335110, 209156, 327436, 360199, 369673, 115719, 0, 0, 114437, 390404, 190474, 0, 1537, 350474, 429076, 0, 272903, 0, 0, 15112, 0, 0, 0, 0, 4867, 96004, 218888, 198662, 0, 45570, 0, 185606, 462339, 361220, 147209, 361990, 0, 109315, 100106, 216834, 0, 375048, 390405, 214274, 0, 0, 0, 208901, 54791, 374538, 281353, 241929, 0, 0, 238085, 276230, 109320, 0, 0, 91394, 0, 0, 15362, 346121, 210694, 0, 298256, 0, 0, 277772, 38404, 62725, 352516, 212227, 0, 125446, 199938, 452366, 39940, 408582, 38917, 232198, 343052, 376838, 0, 0, 113157, 0, 204552, 0, 0, 41986, 269064, 209159, 379916, 395289, 0, 304392, 321547, 126724, 307216, 6662, 157702, 0, 0, 0, 439054, 8455, 161299, 49427, 10244, 68103, 408584, 138756, 124165, 0, 427016, 0, 0, 412418, 46596, 0, 2817, 0, 0, 437000, 23812, 91144, 0, 0, 0, 271111, 45066, 0, 424713, 217349, 413446, 105736, 0, 0, 422153, 94981, 0, 241926, 42754, 159236, 76039, 35589, 5381, 418313, 0, 0, 43527, 104962, 0, 514, 140808, 167949, 41480, 27655, 433677, 102662, 193799, 459783, 0, 0, 64260, 353285, 259083, 143623, 0, 0, 0, 56590, 315147, 0, 0, 0, 92931, 305412, 208388, 281349, 0, 0, 256522, 187906, 0, 111113, 0, 324364, 0, 0, 293127, 290819, 0, 220936, 47619, 212233, 52993, 401162, 0, 359427, 0, 15108, 451334, 0, 267024, 0, 35080, 0, 263432, 0, 423173, 32776, 244235, 260613, 77571, 391431, 198403, 0, 0, 257, 152579, 67333, 280839, 218628, 173066, 468484, 0, 146434, 289546, 26626, 0, 214786, 222981, 62211, 378116, 28162, 247050, 0, 40708, 0, 448264, 231176, 363271, 0, 442633, 0, 312841, 0, 228877, 0, 355590, 261127, 37635, 61188, 150536, 283913, 45317, 0, 363012, 412930, 115716, 142858, 286217, 420616, 85257, 461571, 3073, 0, 264713, 233734, 105476, 239370, 0, 330507, 0, 421123, 296707, 24328, 0, 0, 0, 39943, 227334, 136712, 107268, 132099, 152589, 371978, 0, 167175, 161294, 217608, 0, 161804, 87810, 122376, 67842, 0, 144908, 0, 155917, 206599, 367111, 386562, 20998, 214787, 37639, 127497, 22020, 214793, 296455, 463880, 253707, 14850, 0, 376835, 449798, 0, 30724, 455431, 348424, 0, 78091, 181254, 132613, 444935, 117002, 291850, 29191, 66310, 73993, 3077, 0, 287496, 283139, 224263, 47363, 203014, 188420, 389384, 0, 302348, 0, 52226, 180234, 69637, 458501, 53766, 368134, 195590, 4100, 0, 31495, 0, 0, 202245, 0, 304388, 22789, 0, 250126, 87554, 0, 341510, 354311, 0, 446727, 187140, 89090, 416009, 93443, 16900, 0, 422914, 209158, 317961, 108037, 159242, 139270, 14084, 365829, 305415, 98566, 0, 170761, 149510, 58885, 0, 0, 55556, 16132, 317966, 225544, 34563, 378629, 49923, 104963, 336651, 176650, 465930, 0, 249095, 0, 0, 1, 202755, 16396, 89607, 12806, 9989, 0, 0, 410630, 0, 9473, 26119, 0, 0, 0, 85264, 0, 186114, 456966, 94211, 0, 413960, 294919, 0, 369670, 0, 309252, 262918, 0, 393224, 129803, 357130, 4, 37378, 363279, 160262, 81931, 274695, 188424, 0, 333322, 387591, 80904, 405769, 0, 423174, 0, 778, 0, 229387, 339465, 0, 182790, 133135, 310792, 0, 0, 200455, 6670, 175630, 0, 0, 117006, 28165, 137222, 47878, 120583]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math/bits"] = (function() {
	var $pkg = {}, $init, deBruijn32tab, deBruijn64tab, TrailingZeros, TrailingZeros32, TrailingZeros64;
	TrailingZeros = function(x) {
		var x;
		if (true) {
			return TrailingZeros32(((x >>> 0)));
		}
		return TrailingZeros64((new $Uint64(0, x)));
	};
	$pkg.TrailingZeros = TrailingZeros;
	TrailingZeros32 = function(x) {
		var x, x$1;
		if (x === 0) {
			return 32;
		}
		return (((x$1 = ($imul((((x & (-x >>> 0)) >>> 0)), 125613361) >>> 0) >>> 27 >>> 0, ((x$1 < 0 || x$1 >= deBruijn32tab.length) ? ($throwRuntimeError("index out of range"), undefined) : deBruijn32tab[x$1])) >> 0));
	};
	$pkg.TrailingZeros32 = TrailingZeros32;
	TrailingZeros64 = function(x) {
		var x, x$1, x$2;
		if ((x.$high === 0 && x.$low === 0)) {
			return 64;
		}
		return (((x$1 = $shiftRightUint64($mul64(((x$2 = new $Uint64(-x.$high, -x.$low), new $Uint64(x.$high & x$2.$high, (x.$low & x$2.$low) >>> 0))), new $Uint64(66559345, 3033172745)), 58), (($flatten64(x$1) < 0 || $flatten64(x$1) >= deBruijn64tab.length) ? ($throwRuntimeError("index out of range"), undefined) : deBruijn64tab[$flatten64(x$1)])) >> 0));
	};
	$pkg.TrailingZeros64 = TrailingZeros64;
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		deBruijn32tab = $toNativeArray($kindUint8, [0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9]);
		deBruijn64tab = $toNativeArray($kindUint8, [0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4, 62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5, 63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11, 54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["math"] = (function() {
	var $pkg = {}, $init, js, bits, arrayType, arrayType$1, arrayType$2, structType, math, buf, init;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bits = $packages["math/bits"];
	arrayType = $arrayType($Uint32, 2);
	arrayType$1 = $arrayType($Float32, 2);
	arrayType$2 = $arrayType($Float64, 1);
	structType = $structType("math", [{prop: "uint32array", name: "uint32array", embedded: false, exported: false, typ: arrayType, tag: ""}, {prop: "float32array", name: "float32array", embedded: false, exported: false, typ: arrayType$1, tag: ""}, {prop: "float64array", name: "float64array", embedded: false, exported: false, typ: arrayType$2, tag: ""}]);
	init = function() {
		var ab;
		ab = new ($global.ArrayBuffer)(8);
		buf.uint32array = new ($global.Uint32Array)(ab);
		buf.float32array = new ($global.Float32Array)(ab);
		buf.float64array = new ($global.Float64Array)(ab);
	};
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bits.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		buf = new structType.ptr(arrayType.zero(), arrayType$1.zero(), arrayType$2.zero());
		math = $global.Math;
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["strconv"] = (function() {
	var $pkg = {}, $init, errors, bytealg, math, bits, utf8, NumError, sliceType$4, sliceType$5, sliceType$6, ptrType, arrayType$3, arrayType$4, isPrint16, isNotPrint16, isPrint32, isNotPrint32, isGraphic, syntaxError, rangeError, baseError, bitSizeError, ParseUint, ParseInt, Atoi, FormatInt, Itoa, small, formatBits, isPowerOfTwo, quoteWith, appendQuotedWith, appendEscapedRune, Quote, bsearch16, bsearch32, IsPrint, isInGraphicList;
	errors = $packages["errors"];
	bytealg = $packages["internal/bytealg"];
	math = $packages["math"];
	bits = $packages["math/bits"];
	utf8 = $packages["unicode/utf8"];
	NumError = $pkg.NumError = $newType(0, $kindStruct, "strconv.NumError", true, "strconv", true, function(Func_, Num_, Err_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Func = "";
			this.Num = "";
			this.Err = $ifaceNil;
			return;
		}
		this.Func = Func_;
		this.Num = Num_;
		this.Err = Err_;
	});
	sliceType$4 = $sliceType($Uint16);
	sliceType$5 = $sliceType($Uint32);
	sliceType$6 = $sliceType($Uint8);
	ptrType = $ptrType(NumError);
	arrayType$3 = $arrayType($Uint8, 65);
	arrayType$4 = $arrayType($Uint8, 4);
	NumError.ptr.prototype.Error = function() {
		var _r, e, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; e = $f.e; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		e = this;
		_r = e.Err.Error(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return "strconv." + e.Func + ": " + "parsing " + Quote(e.Num) + ": " + _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NumError.ptr.prototype.Error }; } $f._r = _r; $f.e = e; $f.$s = $s; $f.$r = $r; return $f;
	};
	NumError.prototype.Error = function() { return this.$val.Error(); };
	syntaxError = function(fn, str) {
		var fn, str;
		return new NumError.ptr(fn, str, $pkg.ErrSyntax);
	};
	rangeError = function(fn, str) {
		var fn, str;
		return new NumError.ptr(fn, str, $pkg.ErrRange);
	};
	baseError = function(fn, str, base) {
		var base, fn, str;
		return new NumError.ptr(fn, str, errors.New("invalid base " + Itoa(base)));
	};
	bitSizeError = function(fn, str, bitSize) {
		var bitSize, fn, str;
		return new NumError.ptr(fn, str, errors.New("invalid bit size " + Itoa(bitSize)));
	};
	ParseUint = function(s, base, bitSize) {
		var _1, _i, _ref, base, bitSize, c, cutoff, d, maxVal, n, n1, s, s0, x, x$1, x$2;
		if (s.length === 0) {
			return [new $Uint64(0, 0), syntaxError("ParseUint", s)];
		}
		s0 = s;
		if (2 <= base && base <= 36) {
		} else if ((base === 0)) {
			if ((s.charCodeAt(0) === 48) && s.length > 1 && ((s.charCodeAt(1) === 120) || (s.charCodeAt(1) === 88))) {
				if (s.length < 3) {
					return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
				}
				base = 16;
				s = $substring(s, 2);
			} else if ((s.charCodeAt(0) === 48)) {
				base = 8;
				s = $substring(s, 1);
			} else {
				base = 10;
			}
		} else {
			return [new $Uint64(0, 0), baseError("ParseUint", s0, base)];
		}
		if (bitSize === 0) {
			bitSize = 32;
		} else if (bitSize < 0 || bitSize > 64) {
			return [new $Uint64(0, 0), bitSizeError("ParseUint", s0, bitSize)];
		}
		cutoff = new $Uint64(0, 0);
		_1 = base;
		if (_1 === (10)) {
			cutoff = new $Uint64(429496729, 2576980378);
		} else if (_1 === (16)) {
			cutoff = new $Uint64(268435456, 0);
		} else {
			cutoff = (x = $div64(new $Uint64(4294967295, 4294967295), (new $Uint64(0, base)), false), new $Uint64(x.$high + 0, x.$low + 1));
		}
		maxVal = (x$1 = $shiftLeft64(new $Uint64(0, 1), ((bitSize >>> 0))), new $Uint64(x$1.$high - 0, x$1.$low - 1));
		n = new $Uint64(0, 0);
		_ref = (new sliceType$6($stringToBytes(s)));
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			d = 0;
			if (48 <= c && c <= 57) {
				d = c - 48 << 24 >>> 24;
			} else if (97 <= c && c <= 122) {
				d = (c - 97 << 24 >>> 24) + 10 << 24 >>> 24;
			} else if (65 <= c && c <= 90) {
				d = (c - 65 << 24 >>> 24) + 10 << 24 >>> 24;
			} else {
				return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
			}
			if (d >= ((base << 24 >>> 24))) {
				return [new $Uint64(0, 0), syntaxError("ParseUint", s0)];
			}
			if ((n.$high > cutoff.$high || (n.$high === cutoff.$high && n.$low >= cutoff.$low))) {
				return [maxVal, rangeError("ParseUint", s0)];
			}
			n = $mul64(n, ((new $Uint64(0, base))));
			n1 = (x$2 = (new $Uint64(0, d)), new $Uint64(n.$high + x$2.$high, n.$low + x$2.$low));
			if ((n1.$high < n.$high || (n1.$high === n.$high && n1.$low < n.$low)) || (n1.$high > maxVal.$high || (n1.$high === maxVal.$high && n1.$low > maxVal.$low))) {
				return [maxVal, rangeError("ParseUint", s0)];
			}
			n = n1;
			_i++;
		}
		return [n, $ifaceNil];
	};
	$pkg.ParseUint = ParseUint;
	ParseInt = function(s, base, bitSize) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, base, bitSize, cutoff, err, i, n, neg, s, s0, un, x, x$1;
		i = new $Int64(0, 0);
		err = $ifaceNil;
		if (s.length === 0) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = syntaxError("ParseInt", s);
			i = _tmp;
			err = _tmp$1;
			return [i, err];
		}
		s0 = s;
		neg = false;
		if (s.charCodeAt(0) === 43) {
			s = $substring(s, 1);
		} else if (s.charCodeAt(0) === 45) {
			neg = true;
			s = $substring(s, 1);
		}
		un = new $Uint64(0, 0);
		_tuple = ParseUint(s, base, bitSize);
		un = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual(err, $ifaceNil)) && !($interfaceIsEqual($assertType(err, ptrType).Err, $pkg.ErrRange))) {
			$assertType(err, ptrType).Func = "ParseInt";
			$assertType(err, ptrType).Num = s0;
			_tmp$2 = new $Int64(0, 0);
			_tmp$3 = err;
			i = _tmp$2;
			err = _tmp$3;
			return [i, err];
		}
		if (bitSize === 0) {
			bitSize = 32;
		}
		cutoff = ($shiftLeft64(new $Uint64(0, 1), (((bitSize - 1 >> 0) >>> 0))));
		if (!neg && (un.$high > cutoff.$high || (un.$high === cutoff.$high && un.$low >= cutoff.$low))) {
			_tmp$4 = ((x = new $Uint64(cutoff.$high - 0, cutoff.$low - 1), new $Int64(x.$high, x.$low)));
			_tmp$5 = rangeError("ParseInt", s0);
			i = _tmp$4;
			err = _tmp$5;
			return [i, err];
		}
		if (neg && (un.$high > cutoff.$high || (un.$high === cutoff.$high && un.$low > cutoff.$low))) {
			_tmp$6 = (x$1 = (new $Int64(cutoff.$high, cutoff.$low)), new $Int64(-x$1.$high, -x$1.$low));
			_tmp$7 = rangeError("ParseInt", s0);
			i = _tmp$6;
			err = _tmp$7;
			return [i, err];
		}
		n = (new $Int64(un.$high, un.$low));
		if (neg) {
			n = new $Int64(-n.$high, -n.$low);
		}
		_tmp$8 = n;
		_tmp$9 = $ifaceNil;
		i = _tmp$8;
		err = _tmp$9;
		return [i, err];
	};
	$pkg.ParseInt = ParseInt;
	Atoi = function(s) {
		var _i, _ref, _tuple, _tuple$1, ch, err, i64, n, nerr, ok, s, s0, sLen;
		sLen = s.length;
		if (true && (0 < sLen && sLen < 10) || false && (0 < sLen && sLen < 19)) {
			s0 = s;
			if ((s.charCodeAt(0) === 45) || (s.charCodeAt(0) === 43)) {
				s = $substring(s, 1);
				if (s.length < 1) {
					return [0, new NumError.ptr("Atoi", s0, $pkg.ErrSyntax)];
				}
			}
			n = 0;
			_ref = (new sliceType$6($stringToBytes(s)));
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				ch = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				ch = ch - (48) << 24 >>> 24;
				if (ch > 9) {
					return [0, new NumError.ptr("Atoi", s0, $pkg.ErrSyntax)];
				}
				n = ($imul(n, 10)) + ((ch >> 0)) >> 0;
				_i++;
			}
			if (s0.charCodeAt(0) === 45) {
				n = -n;
			}
			return [n, $ifaceNil];
		}
		_tuple = ParseInt(s, 10, 0);
		i64 = _tuple[0];
		err = _tuple[1];
		_tuple$1 = $assertType(err, ptrType, true);
		nerr = _tuple$1[0];
		ok = _tuple$1[1];
		if (ok) {
			nerr.Func = "Atoi";
		}
		return [(((i64.$low + ((i64.$high >> 31) * 4294967296)) >> 0)), err];
	};
	$pkg.Atoi = Atoi;
	FormatInt = function(i, base) {
		var _tuple, base, i, s;
		if (true && (0 < i.$high || (0 === i.$high && 0 <= i.$low)) && (i.$high < 0 || (i.$high === 0 && i.$low < 100)) && (base === 10)) {
			return small((((i.$low + ((i.$high >> 31) * 4294967296)) >> 0)));
		}
		_tuple = formatBits(sliceType$6.nil, (new $Uint64(i.$high, i.$low)), base, (i.$high < 0 || (i.$high === 0 && i.$low < 0)), false);
		s = _tuple[1];
		return s;
	};
	$pkg.FormatInt = FormatInt;
	Itoa = function(i) {
		var i;
		return FormatInt((new $Int64(0, i)), 10);
	};
	$pkg.Itoa = Itoa;
	small = function(i) {
		var i;
		if (i < 10) {
			return $substring("0123456789abcdefghijklmnopqrstuvwxyz", i, (i + 1 >> 0));
		}
		return $substring("00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899", ($imul(i, 2)), (($imul(i, 2)) + 2 >> 0));
	};
	formatBits = function(dst, u, base, neg, append_) {
		var _q, _q$1, _r, _r$1, a, append_, b, b$1, base, d, dst, i, is, is$1, is$2, j, m, neg, q, q$1, s, shift, u, us, us$1, x, x$1, x$2, x$3, x$4, x$5;
		d = sliceType$6.nil;
		s = "";
		if (base < 2 || base > 36) {
			$panic(new $String("strconv: illegal AppendInt/FormatInt base"));
		}
		a = arrayType$3.zero();
		i = 65;
		if (neg) {
			u = new $Uint64(-u.$high, -u.$low);
		}
		if (base === 10) {
			if (true) {
				while (true) {
					if (!((u.$high > 0 || (u.$high === 0 && u.$low >= 1000000000)))) { break; }
					q = $div64(u, new $Uint64(0, 1000000000), false);
					us = (((x = $mul64(q, new $Uint64(0, 1000000000)), new $Uint64(u.$high - x.$high, u.$low - x.$low)).$low >>> 0));
					j = 4;
					while (true) {
						if (!(j > 0)) { break; }
						is = (_r = us % 100, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) * 2 >>> 0;
						us = (_q = us / (100), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : $throwRuntimeError("integer divide by zero"));
						i = i - (2) >> 0;
						(x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$1] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is + 1 >>> 0))));
						(x$2 = i + 0 >> 0, ((x$2 < 0 || x$2 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$2] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is + 0 >>> 0))));
						j = j - (1) >> 0;
					}
					i = i - (1) >> 0;
					((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(((us * 2 >>> 0) + 1 >>> 0)));
					u = q;
				}
			}
			us$1 = ((u.$low >>> 0));
			while (true) {
				if (!(us$1 >= 100)) { break; }
				is$1 = (_r$1 = us$1 % 100, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) * 2 >>> 0;
				us$1 = (_q$1 = us$1 / (100), (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : $throwRuntimeError("integer divide by zero"));
				i = i - (2) >> 0;
				(x$3 = i + 1 >> 0, ((x$3 < 0 || x$3 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$3] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$1 + 1 >>> 0))));
				(x$4 = i + 0 >> 0, ((x$4 < 0 || x$4 >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[x$4] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$1 + 0 >>> 0))));
			}
			is$2 = us$1 * 2 >>> 0;
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt((is$2 + 1 >>> 0)));
			if (us$1 >= 10) {
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "00010203040506070809101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899".charCodeAt(is$2));
			}
		} else if (isPowerOfTwo(base)) {
			shift = (((bits.TrailingZeros(((base >>> 0))) >>> 0)) & 7) >>> 0;
			b = (new $Uint64(0, base));
			m = ((base >>> 0)) - 1 >>> 0;
			while (true) {
				if (!((u.$high > b.$high || (u.$high === b.$high && u.$low >= b.$low)))) { break; }
				i = i - (1) >> 0;
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((((u.$low >>> 0)) & m) >>> 0)));
				u = $shiftRightUint64(u, (shift));
			}
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((u.$low >>> 0))));
		} else {
			b$1 = (new $Uint64(0, base));
			while (true) {
				if (!((u.$high > b$1.$high || (u.$high === b$1.$high && u.$low >= b$1.$low)))) { break; }
				i = i - (1) >> 0;
				q$1 = $div64(u, b$1, false);
				((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt((((x$5 = $mul64(q$1, b$1), new $Uint64(u.$high - x$5.$high, u.$low - x$5.$low)).$low >>> 0))));
				u = q$1;
			}
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = "0123456789abcdefghijklmnopqrstuvwxyz".charCodeAt(((u.$low >>> 0))));
		}
		if (neg) {
			i = i - (1) >> 0;
			((i < 0 || i >= a.length) ? ($throwRuntimeError("index out of range"), undefined) : a[i] = 45);
		}
		if (append_) {
			d = $appendSlice(dst, $subslice(new sliceType$6(a), i));
			return [d, s];
		}
		s = ($bytesToString($subslice(new sliceType$6(a), i)));
		return [d, s];
	};
	isPowerOfTwo = function(x) {
		var x;
		return (x & ((x - 1 >> 0))) === 0;
	};
	quoteWith = function(s, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _q, graphicOnly, quote, s;
		return ($bytesToString(appendQuotedWith($makeSlice(sliceType$6, 0, (_q = ($imul(3, s.length)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))), s, quote, ASCIIonly, graphicOnly)));
	};
	appendQuotedWith = function(buf, s, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _tuple, buf, graphicOnly, quote, r, s, width;
		buf = $append(buf, quote);
		width = 0;
		while (true) {
			if (!(s.length > 0)) { break; }
			r = ((s.charCodeAt(0) >> 0));
			width = 1;
			if (r >= 128) {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				width = _tuple[1];
			}
			if ((width === 1) && (r === 65533)) {
				buf = $appendSlice(buf, "\\x");
				buf = $append(buf, "0123456789abcdef".charCodeAt((s.charCodeAt(0) >>> 4 << 24 >>> 24)));
				buf = $append(buf, "0123456789abcdef".charCodeAt(((s.charCodeAt(0) & 15) >>> 0)));
				s = $substring(s, width);
				continue;
			}
			buf = appendEscapedRune(buf, r, quote, ASCIIonly, graphicOnly);
			s = $substring(s, width);
		}
		buf = $append(buf, quote);
		return buf;
	};
	appendEscapedRune = function(buf, r, quote, ASCIIonly, graphicOnly) {
		var ASCIIonly, _1, buf, graphicOnly, n, quote, r, runeTmp, s, s$1;
		runeTmp = arrayType$4.zero();
		if ((r === ((quote >> 0))) || (r === 92)) {
			buf = $append(buf, 92);
			buf = $append(buf, ((r << 24 >>> 24)));
			return buf;
		}
		if (ASCIIonly) {
			if (r < 128 && IsPrint(r)) {
				buf = $append(buf, ((r << 24 >>> 24)));
				return buf;
			}
		} else if (IsPrint(r) || graphicOnly && isInGraphicList(r)) {
			n = utf8.EncodeRune(new sliceType$6(runeTmp), r);
			buf = $appendSlice(buf, $subslice(new sliceType$6(runeTmp), 0, n));
			return buf;
		}
		_1 = r;
		if (_1 === (7)) {
			buf = $appendSlice(buf, "\\a");
		} else if (_1 === (8)) {
			buf = $appendSlice(buf, "\\b");
		} else if (_1 === (12)) {
			buf = $appendSlice(buf, "\\f");
		} else if (_1 === (10)) {
			buf = $appendSlice(buf, "\\n");
		} else if (_1 === (13)) {
			buf = $appendSlice(buf, "\\r");
		} else if (_1 === (9)) {
			buf = $appendSlice(buf, "\\t");
		} else if (_1 === (11)) {
			buf = $appendSlice(buf, "\\v");
		} else {
			if (r < 32) {
				buf = $appendSlice(buf, "\\x");
				buf = $append(buf, "0123456789abcdef".charCodeAt((((r << 24 >>> 24)) >>> 4 << 24 >>> 24)));
				buf = $append(buf, "0123456789abcdef".charCodeAt(((((r << 24 >>> 24)) & 15) >>> 0)));
			} else if (r > 1114111) {
				r = 65533;
				buf = $appendSlice(buf, "\\u");
				s = 12;
				while (true) {
					if (!(s >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s >>> 0)), 31)) >> 0) & 15)));
					s = s - (4) >> 0;
				}
			} else if (r < 65536) {
				buf = $appendSlice(buf, "\\u");
				s = 12;
				while (true) {
					if (!(s >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s >>> 0)), 31)) >> 0) & 15)));
					s = s - (4) >> 0;
				}
			} else {
				buf = $appendSlice(buf, "\\U");
				s$1 = 28;
				while (true) {
					if (!(s$1 >= 0)) { break; }
					buf = $append(buf, "0123456789abcdef".charCodeAt((((r >> $min(((s$1 >>> 0)), 31)) >> 0) & 15)));
					s$1 = s$1 - (4) >> 0;
				}
			}
		}
		return buf;
	};
	Quote = function(s) {
		var s;
		return quoteWith(s, 34, false, false);
	};
	$pkg.Quote = Quote;
	bsearch16 = function(a, x) {
		var _q, _tmp, _tmp$1, a, h, i, j, x;
		_tmp = 0;
		_tmp$1 = a.$length;
		i = _tmp;
		j = _tmp$1;
		while (true) {
			if (!(i < j)) { break; }
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((h < 0 || h >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + h]) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	bsearch32 = function(a, x) {
		var _q, _tmp, _tmp$1, a, h, i, j, x;
		_tmp = 0;
		_tmp$1 = a.$length;
		i = _tmp;
		j = _tmp$1;
		while (true) {
			if (!(i < j)) { break; }
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) >> 0;
			if (((h < 0 || h >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + h]) < x) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		return i;
	};
	IsPrint = function(r) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, i, i$1, isNotPrint, isNotPrint$1, isPrint, isPrint$1, j, j$1, r, rr, rr$1, x, x$1, x$2, x$3;
		if (r <= 255) {
			if (32 <= r && r <= 126) {
				return true;
			}
			if (161 <= r && r <= 255) {
				return !((r === 173));
			}
			return false;
		}
		if (0 <= r && r < 65536) {
			_tmp = ((r << 16 >>> 16));
			_tmp$1 = isPrint16;
			_tmp$2 = isNotPrint16;
			rr = _tmp;
			isPrint = _tmp$1;
			isNotPrint = _tmp$2;
			i = bsearch16(isPrint, rr);
			if (i >= isPrint.$length || rr < (x = (i & ~1) >> 0, ((x < 0 || x >= isPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint.$array[isPrint.$offset + x])) || (x$1 = i | 1, ((x$1 < 0 || x$1 >= isPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint.$array[isPrint.$offset + x$1])) < rr) {
				return false;
			}
			j = bsearch16(isNotPrint, rr);
			return j >= isNotPrint.$length || !((((j < 0 || j >= isNotPrint.$length) ? ($throwRuntimeError("index out of range"), undefined) : isNotPrint.$array[isNotPrint.$offset + j]) === rr));
		}
		_tmp$3 = ((r >>> 0));
		_tmp$4 = isPrint32;
		_tmp$5 = isNotPrint32;
		rr$1 = _tmp$3;
		isPrint$1 = _tmp$4;
		isNotPrint$1 = _tmp$5;
		i$1 = bsearch32(isPrint$1, rr$1);
		if (i$1 >= isPrint$1.$length || rr$1 < (x$2 = (i$1 & ~1) >> 0, ((x$2 < 0 || x$2 >= isPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint$1.$array[isPrint$1.$offset + x$2])) || (x$3 = i$1 | 1, ((x$3 < 0 || x$3 >= isPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isPrint$1.$array[isPrint$1.$offset + x$3])) < rr$1) {
			return false;
		}
		if (r >= 131072) {
			return true;
		}
		r = r - (65536) >> 0;
		j$1 = bsearch16(isNotPrint$1, ((r << 16 >>> 16)));
		return j$1 >= isNotPrint$1.$length || !((((j$1 < 0 || j$1 >= isNotPrint$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : isNotPrint$1.$array[isNotPrint$1.$offset + j$1]) === ((r << 16 >>> 16))));
	};
	$pkg.IsPrint = IsPrint;
	isInGraphicList = function(r) {
		var i, r, rr;
		if (r > 65535) {
			return false;
		}
		rr = ((r << 16 >>> 16));
		i = bsearch16(isGraphic, rr);
		return i < isGraphic.$length && (rr === ((i < 0 || i >= isGraphic.$length) ? ($throwRuntimeError("index out of range"), undefined) : isGraphic.$array[isGraphic.$offset + i]));
	};
	ptrType.methods = [{prop: "Error", name: "Error", pkg: "", typ: $funcType([], [$String], false)}];
	NumError.init("", [{prop: "Func", name: "Func", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Num", name: "Num", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Err", name: "Err", embedded: false, exported: true, typ: $error, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = math.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bits.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$pkg.ErrRange = errors.New("value out of range");
		$pkg.ErrSyntax = errors.New("invalid syntax");
		isPrint16 = new sliceType$4([32, 126, 161, 887, 890, 895, 900, 1366, 1369, 1418, 1421, 1479, 1488, 1514, 1520, 1524, 1542, 1563, 1566, 1805, 1808, 1866, 1869, 1969, 1984, 2042, 2048, 2093, 2096, 2139, 2142, 2154, 2208, 2237, 2260, 2444, 2447, 2448, 2451, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2531, 2534, 2557, 2561, 2570, 2575, 2576, 2579, 2617, 2620, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2654, 2662, 2677, 2689, 2745, 2748, 2765, 2768, 2768, 2784, 2787, 2790, 2801, 2809, 2828, 2831, 2832, 2835, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2915, 2918, 2935, 2946, 2954, 2958, 2965, 2969, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3021, 3024, 3024, 3031, 3031, 3046, 3066, 3072, 3129, 3133, 3149, 3157, 3162, 3168, 3171, 3174, 3183, 3192, 3257, 3260, 3277, 3285, 3286, 3294, 3299, 3302, 3314, 3328, 3407, 3412, 3427, 3430, 3455, 3458, 3478, 3482, 3517, 3520, 3526, 3530, 3530, 3535, 3551, 3558, 3567, 3570, 3572, 3585, 3642, 3647, 3675, 3713, 3716, 3719, 3722, 3725, 3725, 3732, 3751, 3754, 3773, 3776, 3789, 3792, 3801, 3804, 3807, 3840, 3948, 3953, 4058, 4096, 4295, 4301, 4301, 4304, 4685, 4688, 4701, 4704, 4749, 4752, 4789, 4792, 4805, 4808, 4885, 4888, 4954, 4957, 4988, 4992, 5017, 5024, 5109, 5112, 5117, 5120, 5788, 5792, 5880, 5888, 5908, 5920, 5942, 5952, 5971, 5984, 6003, 6016, 6109, 6112, 6121, 6128, 6137, 6144, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6443, 6448, 6459, 6464, 6464, 6468, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6622, 6683, 6686, 6780, 6783, 6793, 6800, 6809, 6816, 6829, 6832, 6846, 6912, 6987, 6992, 7036, 7040, 7155, 7164, 7223, 7227, 7241, 7245, 7304, 7360, 7367, 7376, 7417, 7424, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8061, 8064, 8147, 8150, 8175, 8178, 8190, 8208, 8231, 8240, 8286, 8304, 8305, 8308, 8348, 8352, 8383, 8400, 8432, 8448, 8587, 8592, 9254, 9280, 9290, 9312, 11123, 11126, 11157, 11160, 11193, 11197, 11218, 11244, 11247, 11264, 11507, 11513, 11559, 11565, 11565, 11568, 11623, 11631, 11632, 11647, 11670, 11680, 11849, 11904, 12019, 12032, 12245, 12272, 12283, 12289, 12438, 12441, 12543, 12549, 12590, 12593, 12730, 12736, 12771, 12784, 19893, 19904, 40938, 40960, 42124, 42128, 42182, 42192, 42539, 42560, 42743, 42752, 42935, 42999, 43051, 43056, 43065, 43072, 43127, 43136, 43205, 43214, 43225, 43232, 43261, 43264, 43347, 43359, 43388, 43392, 43481, 43486, 43574, 43584, 43597, 43600, 43609, 43612, 43714, 43739, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43877, 43888, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64449, 64467, 64831, 64848, 64911, 64914, 64967, 65008, 65021, 65024, 65049, 65056, 65131, 65136, 65276, 65281, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65504, 65518, 65532, 65533]);
		isNotPrint16 = new sliceType$4([173, 907, 909, 930, 1328, 1376, 1416, 1424, 1757, 2111, 2143, 2229, 2274, 2436, 2473, 2481, 2526, 2564, 2601, 2609, 2612, 2615, 2621, 2653, 2692, 2702, 2706, 2729, 2737, 2740, 2758, 2762, 2816, 2820, 2857, 2865, 2868, 2910, 2948, 2961, 2971, 2973, 3017, 3076, 3085, 3089, 3113, 3141, 3145, 3159, 3204, 3213, 3217, 3241, 3252, 3269, 3273, 3295, 3312, 3332, 3341, 3345, 3397, 3401, 3460, 3506, 3516, 3541, 3543, 3715, 3721, 3736, 3744, 3748, 3750, 3756, 3770, 3781, 3783, 3912, 3992, 4029, 4045, 4294, 4681, 4695, 4697, 4745, 4785, 4799, 4801, 4823, 4881, 5760, 5901, 5997, 6001, 6431, 6751, 7674, 8024, 8026, 8028, 8030, 8117, 8133, 8156, 8181, 8335, 11209, 11311, 11359, 11558, 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, 11930, 12352, 12687, 12831, 13055, 42927, 43470, 43519, 43815, 43823, 64311, 64317, 64319, 64322, 64325, 65107, 65127, 65141, 65511]);
		isPrint32 = new sliceType$5([65536, 65613, 65616, 65629, 65664, 65786, 65792, 65794, 65799, 65843, 65847, 65947, 65952, 65952, 66000, 66045, 66176, 66204, 66208, 66256, 66272, 66299, 66304, 66339, 66349, 66378, 66384, 66426, 66432, 66499, 66504, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66927, 66927, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67640, 67644, 67644, 67647, 67742, 67751, 67759, 67808, 67829, 67835, 67867, 67871, 67897, 67903, 67903, 67968, 68023, 68028, 68047, 68050, 68102, 68108, 68147, 68152, 68154, 68159, 68167, 68176, 68184, 68192, 68255, 68288, 68326, 68331, 68342, 68352, 68405, 68409, 68437, 68440, 68466, 68472, 68497, 68505, 68508, 68521, 68527, 68608, 68680, 68736, 68786, 68800, 68850, 68858, 68863, 69216, 69246, 69632, 69709, 69714, 69743, 69759, 69825, 69840, 69864, 69872, 69881, 69888, 69955, 69968, 70006, 70016, 70093, 70096, 70132, 70144, 70206, 70272, 70313, 70320, 70378, 70384, 70393, 70400, 70412, 70415, 70416, 70419, 70457, 70460, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70749, 70784, 70855, 70864, 70873, 71040, 71093, 71096, 71133, 71168, 71236, 71248, 71257, 71264, 71276, 71296, 71351, 71360, 71369, 71424, 71449, 71453, 71467, 71472, 71487, 71840, 71922, 71935, 71935, 72192, 72263, 72272, 72323, 72326, 72354, 72384, 72440, 72704, 72773, 72784, 72812, 72816, 72847, 72850, 72886, 72960, 73014, 73018, 73031, 73040, 73049, 73728, 74649, 74752, 74868, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92777, 92782, 92783, 92880, 92909, 92912, 92917, 92928, 92997, 93008, 93047, 93053, 93071, 93952, 94020, 94032, 94078, 94095, 94111, 94176, 94177, 94208, 100332, 100352, 101106, 110592, 110878, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113820, 113823, 118784, 119029, 119040, 119078, 119081, 119154, 119163, 119272, 119296, 119365, 119552, 119638, 119648, 119665, 119808, 119967, 119970, 119970, 119973, 119974, 119977, 120074, 120077, 120134, 120138, 120485, 120488, 120779, 120782, 121483, 121499, 121519, 122880, 122904, 122907, 122922, 124928, 125124, 125127, 125142, 125184, 125258, 125264, 125273, 125278, 125279, 126464, 126500, 126503, 126523, 126530, 126530, 126535, 126548, 126551, 126564, 126567, 126619, 126625, 126651, 126704, 126705, 126976, 127019, 127024, 127123, 127136, 127150, 127153, 127221, 127232, 127244, 127248, 127339, 127344, 127404, 127462, 127490, 127504, 127547, 127552, 127560, 127568, 127569, 127584, 127589, 127744, 128724, 128736, 128748, 128752, 128760, 128768, 128883, 128896, 128980, 129024, 129035, 129040, 129095, 129104, 129113, 129120, 129159, 129168, 129197, 129280, 129291, 129296, 129356, 129360, 129387, 129408, 129431, 129472, 129472, 129488, 129510, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 917760, 917999]);
		isNotPrint32 = new sliceType$4([12, 39, 59, 62, 399, 926, 2057, 2102, 2134, 2291, 2564, 2580, 2584, 4285, 4405, 4576, 4626, 4743, 4745, 4750, 4766, 4868, 4905, 4913, 4916, 5210, 5212, 6813, 7177, 7223, 7336, 7431, 7434, 7483, 7486, 9327, 27231, 27482, 27490, 54357, 54429, 54445, 54458, 54460, 54468, 54534, 54549, 54557, 54586, 54591, 54597, 54609, 55968, 57351, 57378, 57381, 60932, 60960, 60963, 60968, 60979, 60984, 60986, 61000, 61002, 61004, 61008, 61011, 61016, 61018, 61020, 61022, 61024, 61027, 61035, 61043, 61048, 61053, 61055, 61066, 61092, 61098, 61632, 61648, 61743, 63807]);
		isGraphic = new sliceType$4([160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["strings"] = (function() {
	var $pkg = {}, $init, errors, js, bytealg, io, sync, unicode, utf8, Builder, Reader, asciiSet, ptrType, sliceType, sliceType$1, ptrType$5, arrayType$3, ptrType$6, IndexByte, Index, LastIndex, Count, NewReader, explode, Contains, IndexRune, IndexAny, genSplit, Split, HasPrefix, HasSuffix, Map, Repeat, ToLower, TrimLeftFunc, TrimRightFunc, TrimFunc, indexFunc, lastIndexFunc, makeASCIISet, makeCutsetFunc, Trim, TrimLeft, TrimRight, TrimSpace, Replace, ReplaceAll, EqualFold;
	errors = $packages["errors"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	bytealg = $packages["internal/bytealg"];
	io = $packages["io"];
	sync = $packages["sync"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Builder = $pkg.Builder = $newType(0, $kindStruct, "strings.Builder", true, "strings", true, function(addr_, buf_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.addr = ptrType.nil;
			this.buf = sliceType.nil;
			return;
		}
		this.addr = addr_;
		this.buf = buf_;
	});
	Reader = $pkg.Reader = $newType(0, $kindStruct, "strings.Reader", true, "strings", true, function(s_, i_, prevRune_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.s = "";
			this.i = new $Int64(0, 0);
			this.prevRune = 0;
			return;
		}
		this.s = s_;
		this.i = i_;
		this.prevRune = prevRune_;
	});
	asciiSet = $pkg.asciiSet = $newType(32, $kindArray, "strings.asciiSet", true, "strings", false, null);
	ptrType = $ptrType(Builder);
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType($String);
	ptrType$5 = $ptrType(asciiSet);
	arrayType$3 = $arrayType($Uint32, 8);
	ptrType$6 = $ptrType(Reader);
	IndexByte = function(s, c) {
		var c, s;
		return $parseInt(s.indexOf($global.String.fromCharCode(c))) >> 0;
	};
	$pkg.IndexByte = IndexByte;
	Index = function(s, sep) {
		var s, sep;
		return $parseInt(s.indexOf(sep)) >> 0;
	};
	$pkg.Index = Index;
	LastIndex = function(s, sep) {
		var s, sep;
		return $parseInt(s.lastIndexOf(sep)) >> 0;
	};
	$pkg.LastIndex = LastIndex;
	Count = function(s, sep) {
		var n, pos, s, sep;
		n = 0;
		if ((sep.length === 0)) {
			return utf8.RuneCountInString(s) + 1 >> 0;
		} else if (sep.length > s.length) {
			return 0;
		} else if ((sep.length === s.length)) {
			if (sep === s) {
				return 1;
			}
			return 0;
		}
		while (true) {
			pos = Index(s, sep);
			if (pos === -1) {
				break;
			}
			n = n + (1) >> 0;
			s = $substring(s, (pos + sep.length >> 0));
		}
		return n;
	};
	$pkg.Count = Count;
	Builder.ptr.prototype.String = function() {
		var b;
		b = this;
		return ($bytesToString(b.buf));
	};
	Builder.prototype.String = function() { return this.$val.String(); };
	Builder.ptr.prototype.copyCheck = function() {
		var b;
		b = this;
		if (b.addr === ptrType.nil) {
			b.addr = b;
		} else if (!(b.addr === b)) {
			$panic(new $String("strings: illegal use of non-zero Builder copied by value"));
		}
	};
	Builder.prototype.copyCheck = function() { return this.$val.copyCheck(); };
	Builder.ptr.prototype.Len = function() {
		var b;
		b = this;
		return b.buf.$length;
	};
	Builder.prototype.Len = function() { return this.$val.Len(); };
	Builder.ptr.prototype.Cap = function() {
		var b;
		b = this;
		return b.buf.$capacity;
	};
	Builder.prototype.Cap = function() { return this.$val.Cap(); };
	Builder.ptr.prototype.Reset = function() {
		var b;
		b = this;
		b.addr = ptrType.nil;
		b.buf = sliceType.nil;
	};
	Builder.prototype.Reset = function() { return this.$val.Reset(); };
	Builder.ptr.prototype.grow = function(n) {
		var b, buf, n;
		b = this;
		buf = $makeSlice(sliceType, b.buf.$length, (($imul(2, b.buf.$capacity)) + n >> 0));
		$copySlice(buf, b.buf);
		b.buf = buf;
	};
	Builder.prototype.grow = function(n) { return this.$val.grow(n); };
	Builder.ptr.prototype.Grow = function(n) {
		var b, n;
		b = this;
		b.copyCheck();
		if (n < 0) {
			$panic(new $String("strings.Builder.Grow: negative count"));
		}
		if ((b.buf.$capacity - b.buf.$length >> 0) < n) {
			b.grow(n);
		}
	};
	Builder.prototype.Grow = function(n) { return this.$val.Grow(n); };
	Builder.ptr.prototype.Write = function(p) {
		var b, p;
		b = this;
		b.copyCheck();
		b.buf = $appendSlice(b.buf, p);
		return [p.$length, $ifaceNil];
	};
	Builder.prototype.Write = function(p) { return this.$val.Write(p); };
	Builder.ptr.prototype.WriteByte = function(c) {
		var b, c;
		b = this;
		b.copyCheck();
		b.buf = $append(b.buf, c);
		return $ifaceNil;
	};
	Builder.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	Builder.ptr.prototype.WriteRune = function(r) {
		var b, l, n, r;
		b = this;
		b.copyCheck();
		if (r < 128) {
			b.buf = $append(b.buf, ((r << 24 >>> 24)));
			return [1, $ifaceNil];
		}
		l = b.buf.$length;
		if ((b.buf.$capacity - l >> 0) < 4) {
			b.grow(4);
		}
		n = utf8.EncodeRune($subslice(b.buf, l, (l + 4 >> 0)), r);
		b.buf = $subslice(b.buf, 0, (l + n >> 0));
		return [n, $ifaceNil];
	};
	Builder.prototype.WriteRune = function(r) { return this.$val.WriteRune(r); };
	Builder.ptr.prototype.WriteString = function(s) {
		var b, s;
		b = this;
		b.copyCheck();
		b.buf = $appendSlice(b.buf, s);
		return [s.length, $ifaceNil];
	};
	Builder.prototype.WriteString = function(s) { return this.$val.WriteString(s); };
	Reader.ptr.prototype.Len = function() {
		var r, x, x$1, x$2, x$3, x$4;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return 0;
		}
		return (((x$2 = (x$3 = (new $Int64(0, r.s.length)), x$4 = r.i, new $Int64(x$3.$high - x$4.$high, x$3.$low - x$4.$low)), x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
	};
	Reader.prototype.Len = function() { return this.$val.Len(); };
	Reader.ptr.prototype.Size = function() {
		var r;
		r = this;
		return (new $Int64(0, r.s.length));
	};
	Reader.prototype.Size = function() { return this.$val.Size(); };
	Reader.ptr.prototype.Read = function(b) {
		var _tmp, _tmp$1, b, err, n, r, x, x$1, x$2, x$3;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = 0;
			_tmp$1 = io.EOF;
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		r.prevRune = -1;
		n = $copyString(b, $substring(r.s, $flatten64(r.i)));
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, n)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		return [n, err];
	};
	Reader.prototype.Read = function(b) { return this.$val.Read(b); };
	Reader.ptr.prototype.ReadAt = function(b, off) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, b, err, n, off, r, x;
		n = 0;
		err = $ifaceNil;
		r = this;
		if ((off.$high < 0 || (off.$high === 0 && off.$low < 0))) {
			_tmp = 0;
			_tmp$1 = errors.New("strings.Reader.ReadAt: negative offset");
			n = _tmp;
			err = _tmp$1;
			return [n, err];
		}
		if ((x = (new $Int64(0, r.s.length)), (off.$high > x.$high || (off.$high === x.$high && off.$low >= x.$low)))) {
			_tmp$2 = 0;
			_tmp$3 = io.EOF;
			n = _tmp$2;
			err = _tmp$3;
			return [n, err];
		}
		n = $copyString(b, $substring(r.s, $flatten64(off)));
		if (n < b.$length) {
			err = io.EOF;
		}
		return [n, err];
	};
	Reader.prototype.ReadAt = function(b, off) { return this.$val.ReadAt(b, off); };
	Reader.ptr.prototype.ReadByte = function() {
		var b, r, x, x$1, x$2, x$3;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			return [0, io.EOF];
		}
		b = r.s.charCodeAt($flatten64(r.i));
		r.i = (x$2 = r.i, x$3 = new $Int64(0, 1), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		return [b, $ifaceNil];
	};
	Reader.prototype.ReadByte = function() { return this.$val.ReadByte(); };
	Reader.ptr.prototype.UnreadByte = function() {
		var r, x, x$1, x$2;
		r = this;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("strings.Reader.UnreadByte: at beginning of string");
		}
		r.prevRune = -1;
		r.i = (x$1 = r.i, x$2 = new $Int64(0, 1), new $Int64(x$1.$high - x$2.$high, x$1.$low - x$2.$low));
		return $ifaceNil;
	};
	Reader.prototype.UnreadByte = function() { return this.$val.UnreadByte(); };
	Reader.ptr.prototype.ReadRune = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, c, ch, err, r, size, x, x$1, x$2, x$3, x$4, x$5, x$6;
		ch = 0;
		size = 0;
		err = $ifaceNil;
		r = this;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			r.prevRune = -1;
			_tmp = 0;
			_tmp$1 = 0;
			_tmp$2 = io.EOF;
			ch = _tmp;
			size = _tmp$1;
			err = _tmp$2;
			return [ch, size, err];
		}
		r.prevRune = (((x$2 = r.i, x$2.$low + ((x$2.$high >> 31) * 4294967296)) >> 0));
		c = r.s.charCodeAt($flatten64(r.i));
		if (c < 128) {
			r.i = (x$3 = r.i, x$4 = new $Int64(0, 1), new $Int64(x$3.$high + x$4.$high, x$3.$low + x$4.$low));
			_tmp$3 = ((c >> 0));
			_tmp$4 = 1;
			_tmp$5 = $ifaceNil;
			ch = _tmp$3;
			size = _tmp$4;
			err = _tmp$5;
			return [ch, size, err];
		}
		_tuple = utf8.DecodeRuneInString($substring(r.s, $flatten64(r.i)));
		ch = _tuple[0];
		size = _tuple[1];
		r.i = (x$5 = r.i, x$6 = (new $Int64(0, size)), new $Int64(x$5.$high + x$6.$high, x$5.$low + x$6.$low));
		return [ch, size, err];
	};
	Reader.prototype.ReadRune = function() { return this.$val.ReadRune(); };
	Reader.ptr.prototype.UnreadRune = function() {
		var r, x;
		r = this;
		if ((x = r.i, (x.$high < 0 || (x.$high === 0 && x.$low <= 0)))) {
			return errors.New("strings.Reader.UnreadRune: at beginning of string");
		}
		if (r.prevRune < 0) {
			return errors.New("strings.Reader.UnreadRune: previous operation was not ReadRune");
		}
		r.i = (new $Int64(0, r.prevRune));
		r.prevRune = -1;
		return $ifaceNil;
	};
	Reader.prototype.UnreadRune = function() { return this.$val.UnreadRune(); };
	Reader.ptr.prototype.Seek = function(offset, whence) {
		var _1, abs, offset, r, whence, x, x$1;
		r = this;
		r.prevRune = -1;
		abs = new $Int64(0, 0);
		_1 = whence;
		if (_1 === (0)) {
			abs = offset;
		} else if (_1 === (1)) {
			abs = (x = r.i, new $Int64(x.$high + offset.$high, x.$low + offset.$low));
		} else if (_1 === (2)) {
			abs = (x$1 = (new $Int64(0, r.s.length)), new $Int64(x$1.$high + offset.$high, x$1.$low + offset.$low));
		} else {
			return [new $Int64(0, 0), errors.New("strings.Reader.Seek: invalid whence")];
		}
		if ((abs.$high < 0 || (abs.$high === 0 && abs.$low < 0))) {
			return [new $Int64(0, 0), errors.New("strings.Reader.Seek: negative position")];
		}
		r.i = abs;
		return [abs, $ifaceNil];
	};
	Reader.prototype.Seek = function(offset, whence) { return this.$val.Seek(offset, whence); };
	Reader.ptr.prototype.WriteTo = function(w) {
		var _r, _tmp, _tmp$1, _tuple, err, m, n, r, s, w, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; err = $f.err; m = $f.m; n = $f.n; r = $f.r; s = $f.s; w = $f.w; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = new $Int64(0, 0);
		err = $ifaceNil;
		r = this;
		r.prevRune = -1;
		if ((x = r.i, x$1 = (new $Int64(0, r.s.length)), (x.$high > x$1.$high || (x.$high === x$1.$high && x.$low >= x$1.$low)))) {
			_tmp = new $Int64(0, 0);
			_tmp$1 = $ifaceNil;
			n = _tmp;
			err = _tmp$1;
			$s = -1; return [n, err];
		}
		s = $substring(r.s, $flatten64(r.i));
		_r = io.WriteString(w, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		m = _tuple[0];
		err = _tuple[1];
		if (m > s.length) {
			$panic(new $String("strings.Reader.WriteTo: invalid WriteString count"));
		}
		r.i = (x$2 = r.i, x$3 = (new $Int64(0, m)), new $Int64(x$2.$high + x$3.$high, x$2.$low + x$3.$low));
		n = (new $Int64(0, m));
		if (!((m === s.length)) && $interfaceIsEqual(err, $ifaceNil)) {
			err = io.ErrShortWrite;
		}
		$s = -1; return [n, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Reader.ptr.prototype.WriteTo }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f.err = err; $f.m = m; $f.n = n; $f.r = r; $f.s = s; $f.w = w; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	Reader.prototype.WriteTo = function(w) { return this.$val.WriteTo(w); };
	Reader.ptr.prototype.Reset = function(s) {
		var r, s;
		r = this;
		Reader.copy(r, new Reader.ptr(s, new $Int64(0, 0), -1));
	};
	Reader.prototype.Reset = function(s) { return this.$val.Reset(s); };
	NewReader = function(s) {
		var s;
		return new Reader.ptr(s, new $Int64(0, 0), -1);
	};
	$pkg.NewReader = NewReader;
	explode = function(s, n) {
		var _tuple, a, ch, i, l, n, s, size, x;
		l = utf8.RuneCountInString(s);
		if (n < 0 || n > l) {
			n = l;
		}
		a = $makeSlice(sliceType$1, n);
		i = 0;
		while (true) {
			if (!(i < (n - 1 >> 0))) { break; }
			_tuple = utf8.DecodeRuneInString(s);
			ch = _tuple[0];
			size = _tuple[1];
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = $substring(s, 0, size));
			s = $substring(s, size);
			if (ch === 65533) {
				((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = "\xEF\xBF\xBD");
			}
			i = i + (1) >> 0;
		}
		if (n > 0) {
			(x = n - 1 >> 0, ((x < 0 || x >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + x] = s));
		}
		return a;
	};
	Contains = function(s, substr) {
		var s, substr;
		return Index(s, substr) >= 0;
	};
	$pkg.Contains = Contains;
	IndexRune = function(s, r) {
		var _i, _ref, _rune, i, r, r$1, s;
		if (0 <= r && r < 128) {
			return IndexByte(s, ((r << 24 >>> 24)));
		} else if ((r === 65533)) {
			_ref = s;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				i = _i;
				r$1 = _rune[0];
				if (r$1 === 65533) {
					return i;
				}
				_i += _rune[1];
			}
			return -1;
		} else if (!utf8.ValidRune(r)) {
			return -1;
		} else {
			return Index(s, ($encodeRune(r)));
		}
	};
	$pkg.IndexRune = IndexRune;
	IndexAny = function(s, chars) {
		var _i, _i$1, _ref, _ref$1, _rune, _rune$1, _tuple, as, c, chars, i, i$1, isASCII, m, s;
		if (chars === "") {
			return -1;
		}
		if (s.length > 8) {
			_tuple = makeASCIISet(chars);
			as = $clone(_tuple[0], asciiSet);
			isASCII = _tuple[1];
			if (isASCII) {
				i = 0;
				while (true) {
					if (!(i < s.length)) { break; }
					if (new ptrType$5(as).contains(s.charCodeAt(i))) {
						return i;
					}
					i = i + (1) >> 0;
				}
				return -1;
			}
		}
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			i$1 = _i;
			c = _rune[0];
			_ref$1 = chars;
			_i$1 = 0;
			while (true) {
				if (!(_i$1 < _ref$1.length)) { break; }
				_rune$1 = $decodeRune(_ref$1, _i$1);
				m = _rune$1[0];
				if (c === m) {
					return i$1;
				}
				_i$1 += _rune$1[1];
			}
			_i += _rune[1];
		}
		return -1;
	};
	$pkg.IndexAny = IndexAny;
	genSplit = function(s, sep, sepSave, n) {
		var a, i, m, n, s, sep, sepSave;
		if (n === 0) {
			return sliceType$1.nil;
		}
		if (sep === "") {
			return explode(s, n);
		}
		if (n < 0) {
			n = Count(s, sep) + 1 >> 0;
		}
		a = $makeSlice(sliceType$1, n);
		n = n - (1) >> 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			m = Index(s, sep);
			if (m < 0) {
				break;
			}
			((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = $substring(s, 0, (m + sepSave >> 0)));
			s = $substring(s, (m + sep.length >> 0));
			i = i + (1) >> 0;
		}
		((i < 0 || i >= a.$length) ? ($throwRuntimeError("index out of range"), undefined) : a.$array[a.$offset + i] = s);
		return $subslice(a, 0, (i + 1 >> 0));
	};
	Split = function(s, sep) {
		var s, sep;
		return genSplit(s, sep, 0, -1);
	};
	$pkg.Split = Split;
	HasPrefix = function(s, prefix) {
		var prefix, s;
		return s.length >= prefix.length && $substring(s, 0, prefix.length) === prefix;
	};
	$pkg.HasPrefix = HasPrefix;
	HasSuffix = function(s, suffix) {
		var s, suffix;
		return s.length >= suffix.length && $substring(s, (s.length - suffix.length >> 0)) === suffix;
	};
	$pkg.HasSuffix = HasSuffix;
	Map = function(mapping, s) {
		var _i, _i$1, _r, _r$1, _ref, _ref$1, _rune, _rune$1, _tuple, b, c, c$1, i, mapping, r, r$1, s, width, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _rune = $f._rune; _rune$1 = $f._rune$1; _tuple = $f._tuple; b = $f.b; c = $f.c; c$1 = $f.c$1; i = $f.i; mapping = $f.mapping; r = $f.r; r$1 = $f.r$1; s = $f.s; width = $f.width; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		b = new Builder.ptr(ptrType.nil, sliceType.nil);
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			c = _rune[0];
			_r = mapping(c); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			r = _r;
			if ((r === c) && !((c === 65533))) {
				_i += _rune[1];
				/* continue; */ $s = 1; continue;
			}
			width = 0;
			if (c === 65533) {
				_tuple = utf8.DecodeRuneInString($substring(s, i));
				c = _tuple[0];
				width = _tuple[1];
				if (!((width === 1)) && (r === c)) {
					_i += _rune[1];
					/* continue; */ $s = 1; continue;
				}
			} else {
				width = utf8.RuneLen(c);
			}
			b.Grow(s.length + 4 >> 0);
			b.WriteString($substring(s, 0, i));
			if (r >= 0) {
				b.WriteRune(r);
			}
			s = $substring(s, (i + width >> 0));
			/* break; */ $s = 2; continue;
		/* } */ $s = 1; continue; case 2:
		if (b.Cap() === 0) {
			$s = -1; return s;
		}
		_ref$1 = s;
		_i$1 = 0;
		/* while (true) { */ case 4:
			/* if (!(_i$1 < _ref$1.length)) { break; } */ if(!(_i$1 < _ref$1.length)) { $s = 5; continue; }
			_rune$1 = $decodeRune(_ref$1, _i$1);
			c$1 = _rune$1[0];
			_r$1 = mapping(c$1); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			r$1 = _r$1;
			if (r$1 >= 0) {
				if (r$1 < 128) {
					b.WriteByte(((r$1 << 24 >>> 24)));
				} else {
					b.WriteRune(r$1);
				}
			}
			_i$1 += _rune$1[1];
		/* } */ $s = 4; continue; case 5:
		$s = -1; return b.String();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Map }; } $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._rune = _rune; $f._rune$1 = _rune$1; $f._tuple = _tuple; $f.b = b; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.mapping = mapping; $f.r = r; $f.r$1 = r$1; $f.s = s; $f.width = width; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Map = Map;
	Repeat = function(s, count) {
		var _q, _q$1, b, count, n, s;
		if (count === 0) {
			return "";
		}
		if (count < 0) {
			$panic(new $String("strings: negative Repeat count"));
		} else if (!(((_q = ($imul(s.length, count)) / count, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero")) === s.length))) {
			$panic(new $String("strings: Repeat count causes overflow"));
		}
		n = $imul(s.length, count);
		b = new Builder.ptr(ptrType.nil, sliceType.nil);
		b.Grow(n);
		b.WriteString(s);
		while (true) {
			if (!(b.Len() < n)) { break; }
			if (b.Len() <= (_q$1 = n / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))) {
				b.WriteString(b.String());
			} else {
				b.WriteString($substring(b.String(), 0, (n - b.Len() >> 0)));
				break;
			}
		}
		return b.String();
	};
	$pkg.Repeat = Repeat;
	ToLower = function(s) {
		var _r, _tmp, _tmp$1, b, c, c$1, hasUpper, i, i$1, isASCII, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; b = $f.b; c = $f.c; c$1 = $f.c$1; hasUpper = $f.hasUpper; i = $f.i; i$1 = $f.i$1; isASCII = $f.isASCII; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tmp = true;
		_tmp$1 = false;
		isASCII = _tmp;
		hasUpper = _tmp$1;
		i = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			c = s.charCodeAt(i);
			if (c >= 128) {
				isASCII = false;
				break;
			}
			hasUpper = hasUpper || (c >= 65 && c <= 90);
			i = i + (1) >> 0;
		}
		if (isASCII) {
			if (!hasUpper) {
				$s = -1; return s;
			}
			b = new Builder.ptr(ptrType.nil, sliceType.nil);
			b.Grow(s.length);
			i$1 = 0;
			while (true) {
				if (!(i$1 < s.length)) { break; }
				c$1 = s.charCodeAt(i$1);
				if (c$1 >= 65 && c$1 <= 90) {
					c$1 = c$1 + (32) << 24 >>> 24;
				}
				b.WriteByte(c$1);
				i$1 = i$1 + (1) >> 0;
			}
			$s = -1; return b.String();
		}
		_r = Map(unicode.ToLower, s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ToLower }; } $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.b = b; $f.c = c; $f.c$1 = c$1; $f.hasUpper = hasUpper; $f.i = i; $f.i$1 = i$1; $f.isASCII = isASCII; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ToLower = ToLower;
	TrimLeftFunc = function(s, f) {
		var _r, f, i, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; f = $f.f; i = $f.i; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = indexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i === -1) {
			$s = -1; return "";
		}
		$s = -1; return $substring(s, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimLeftFunc }; } $f._r = _r; $f.f = f; $f.i = i; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimLeftFunc = TrimLeftFunc;
	TrimRightFunc = function(s, f) {
		var _r, _tuple, f, i, s, wid, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; i = $f.i; s = $f.s; wid = $f.wid; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = lastIndexFunc(s, f, false); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		i = _r;
		if (i >= 0 && s.charCodeAt(i) >= 128) {
			_tuple = utf8.DecodeRuneInString($substring(s, i));
			wid = _tuple[1];
			i = i + (wid) >> 0;
		} else {
			i = i + (1) >> 0;
		}
		$s = -1; return $substring(s, 0, i);
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimRightFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.s = s; $f.wid = wid; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimRightFunc = TrimRightFunc;
	TrimFunc = function(s, f) {
		var _r, _r$1, f, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; f = $f.f; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimLeftFunc(s, f); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r$1 = TrimRightFunc(_r, f); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		$s = -1; return _r$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimFunc }; } $f._r = _r; $f._r$1 = _r$1; $f.f = f; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimFunc = TrimFunc;
	indexFunc = function(s, f, truth) {
		var _i, _r, _ref, _rune, f, i, r, s, truth, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _rune = $f._rune; f = $f.f; i = $f.i; r = $f.r; s = $f.s; truth = $f.truth; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_ref = s;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.length)) { break; } */ if(!(_i < _ref.length)) { $s = 2; continue; }
			_rune = $decodeRune(_ref, _i);
			i = _i;
			r = _rune[0];
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return i;
			/* } */ case 4:
			_i += _rune[1];
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: indexFunc }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._rune = _rune; $f.f = f; $f.i = i; $f.r = r; $f.s = s; $f.truth = truth; $f.$s = $s; $f.$r = $r; return $f;
	};
	lastIndexFunc = function(s, f, truth) {
		var _r, _tuple, f, i, r, s, size, truth, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; f = $f.f; i = $f.i; r = $f.r; s = $f.s; size = $f.size; truth = $f.truth; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = s.length;
		/* while (true) { */ case 1:
			/* if (!(i > 0)) { break; } */ if(!(i > 0)) { $s = 2; continue; }
			_tuple = utf8.DecodeLastRuneInString($substring(s, 0, i));
			r = _tuple[0];
			size = _tuple[1];
			i = i - (size) >> 0;
			_r = f(r); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r === truth) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r === truth) { */ case 3:
				$s = -1; return i;
			/* } */ case 4:
		/* } */ $s = 1; continue; case 2:
		$s = -1; return -1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: lastIndexFunc }; } $f._r = _r; $f._tuple = _tuple; $f.f = f; $f.i = i; $f.r = r; $f.s = s; $f.size = size; $f.truth = truth; $f.$s = $s; $f.$r = $r; return $f;
	};
	makeASCIISet = function(chars) {
		var _index, _tmp, _tmp$1, _tmp$2, _tmp$3, as, c, chars, i, ok, y;
		as = arrayType$3.zero();
		ok = false;
		i = 0;
		while (true) {
			if (!(i < chars.length)) { break; }
			c = chars.charCodeAt(i);
			if (c >= 128) {
				_tmp = $clone(as, asciiSet);
				_tmp$1 = false;
				asciiSet.copy(as, _tmp);
				ok = _tmp$1;
				return [as, ok];
			}
			_index = c >>> 5 << 24 >>> 24;
			((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index] = ((((_index < 0 || _index >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[_index]) | (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0));
			i = i + (1) >> 0;
		}
		_tmp$2 = $clone(as, asciiSet);
		_tmp$3 = true;
		asciiSet.copy(as, _tmp$2);
		ok = _tmp$3;
		return [as, ok];
	};
	asciiSet.prototype.contains = function(c) {
		var as, c, x, y;
		as = this.$val;
		return !((((((x = c >>> 5 << 24 >>> 24, (as.nilCheck, ((x < 0 || x >= as.length) ? ($throwRuntimeError("index out of range"), undefined) : as[x]))) & (((y = ((((c & 31) >>> 0) >>> 0)), y < 32 ? (1 << y) : 0) >>> 0))) >>> 0)) === 0));
	};
	$ptrType(asciiSet).prototype.contains = function(c) { return (new asciiSet(this.$get())).contains(c); };
	makeCutsetFunc = function(cutset) {
		var _tuple, as, cutset, isASCII;
		if ((cutset.length === 1) && cutset.charCodeAt(0) < 128) {
			return (function(r) {
				var r;
				return r === ((cutset.charCodeAt(0) >> 0));
			});
		}
		_tuple = makeASCIISet(cutset);
		as = $clone(_tuple[0], asciiSet);
		isASCII = _tuple[1];
		if (isASCII) {
			return (function(r) {
				var r;
				return r < 128 && new ptrType$5(as).contains(((r << 24 >>> 24)));
			});
		}
		return (function(r) {
			var r;
			return IndexRune(cutset, r) >= 0;
		});
	};
	Trim = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (s === "" || cutset === "") {
			$s = -1; return s;
		}
		_r = TrimFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Trim }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Trim = Trim;
	TrimLeft = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (s === "" || cutset === "") {
			$s = -1; return s;
		}
		_r = TrimLeftFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimLeft }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimLeft = TrimLeft;
	TrimRight = function(s, cutset) {
		var _r, cutset, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; cutset = $f.cutset; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (s === "" || cutset === "") {
			$s = -1; return s;
		}
		_r = TrimRightFunc(s, makeCutsetFunc(cutset)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimRight }; } $f._r = _r; $f.cutset = cutset; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimRight = TrimRight;
	TrimSpace = function(s) {
		var _r, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = TrimFunc(s, unicode.IsSpace); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: TrimSpace }; } $f._r = _r; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.TrimSpace = TrimSpace;
	Replace = function(s, old, new$1, n) {
		var _tuple, i, j, m, n, new$1, old, s, start, t, w, wid;
		if (old === new$1 || (n === 0)) {
			return s;
		}
		m = Count(s, old);
		if (m === 0) {
			return s;
		} else if (n < 0 || m < n) {
			n = m;
		}
		t = $makeSlice(sliceType, (s.length + ($imul(n, ((new$1.length - old.length >> 0)))) >> 0));
		w = 0;
		start = 0;
		i = 0;
		while (true) {
			if (!(i < n)) { break; }
			j = start;
			if (old.length === 0) {
				if (i > 0) {
					_tuple = utf8.DecodeRuneInString($substring(s, start));
					wid = _tuple[1];
					j = j + (wid) >> 0;
				}
			} else {
				j = j + (Index($substring(s, start), old)) >> 0;
			}
			w = w + ($copyString($subslice(t, w), $substring(s, start, j))) >> 0;
			w = w + ($copyString($subslice(t, w), new$1)) >> 0;
			start = j + old.length >> 0;
			i = i + (1) >> 0;
		}
		w = w + ($copyString($subslice(t, w), $substring(s, start))) >> 0;
		return ($bytesToString($subslice(t, 0, w)));
	};
	$pkg.Replace = Replace;
	ReplaceAll = function(s, old, new$1) {
		var new$1, old, s;
		return Replace(s, old, new$1, -1);
	};
	$pkg.ReplaceAll = ReplaceAll;
	EqualFold = function(s, t) {
		var _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, _tuple, _tuple$1, r, r$1, r$2, s, size, size$1, sr, t, tr;
		while (true) {
			if (!(!(s === "") && !(t === ""))) { break; }
			_tmp = 0;
			_tmp$1 = 0;
			sr = _tmp;
			tr = _tmp$1;
			if (s.charCodeAt(0) < 128) {
				_tmp$2 = ((s.charCodeAt(0) >> 0));
				_tmp$3 = $substring(s, 1);
				sr = _tmp$2;
				s = _tmp$3;
			} else {
				_tuple = utf8.DecodeRuneInString(s);
				r = _tuple[0];
				size = _tuple[1];
				_tmp$4 = r;
				_tmp$5 = $substring(s, size);
				sr = _tmp$4;
				s = _tmp$5;
			}
			if (t.charCodeAt(0) < 128) {
				_tmp$6 = ((t.charCodeAt(0) >> 0));
				_tmp$7 = $substring(t, 1);
				tr = _tmp$6;
				t = _tmp$7;
			} else {
				_tuple$1 = utf8.DecodeRuneInString(t);
				r$1 = _tuple$1[0];
				size$1 = _tuple$1[1];
				_tmp$8 = r$1;
				_tmp$9 = $substring(t, size$1);
				tr = _tmp$8;
				t = _tmp$9;
			}
			if (tr === sr) {
				continue;
			}
			if (tr < sr) {
				_tmp$10 = sr;
				_tmp$11 = tr;
				tr = _tmp$10;
				sr = _tmp$11;
			}
			if (tr < 128) {
				if (65 <= sr && sr <= 90 && (tr === ((sr + 97 >> 0) - 65 >> 0))) {
					continue;
				}
				return false;
			}
			r$2 = unicode.SimpleFold(sr);
			while (true) {
				if (!(!((r$2 === sr)) && r$2 < tr)) { break; }
				r$2 = unicode.SimpleFold(r$2);
			}
			if (r$2 === tr) {
				continue;
			}
			return false;
		}
		return s === t;
	};
	$pkg.EqualFold = EqualFold;
	ptrType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}, {prop: "copyCheck", name: "copyCheck", pkg: "strings", typ: $funcType([], [], false)}, {prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Cap", name: "Cap", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([], [], false)}, {prop: "grow", name: "grow", pkg: "strings", typ: $funcType([$Int], [], false)}, {prop: "Grow", name: "Grow", pkg: "", typ: $funcType([$Int], [], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteRune", name: "WriteRune", pkg: "", typ: $funcType([$Int32], [$Int, $error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}];
	ptrType$6.methods = [{prop: "Len", name: "Len", pkg: "", typ: $funcType([], [$Int], false)}, {prop: "Size", name: "Size", pkg: "", typ: $funcType([], [$Int64], false)}, {prop: "Read", name: "Read", pkg: "", typ: $funcType([sliceType], [$Int, $error], false)}, {prop: "ReadAt", name: "ReadAt", pkg: "", typ: $funcType([sliceType, $Int64], [$Int, $error], false)}, {prop: "ReadByte", name: "ReadByte", pkg: "", typ: $funcType([], [$Uint8, $error], false)}, {prop: "UnreadByte", name: "UnreadByte", pkg: "", typ: $funcType([], [$error], false)}, {prop: "ReadRune", name: "ReadRune", pkg: "", typ: $funcType([], [$Int32, $Int, $error], false)}, {prop: "UnreadRune", name: "UnreadRune", pkg: "", typ: $funcType([], [$error], false)}, {prop: "Seek", name: "Seek", pkg: "", typ: $funcType([$Int64, $Int], [$Int64, $error], false)}, {prop: "WriteTo", name: "WriteTo", pkg: "", typ: $funcType([io.Writer], [$Int64, $error], false)}, {prop: "Reset", name: "Reset", pkg: "", typ: $funcType([$String], [], false)}];
	ptrType$5.methods = [{prop: "contains", name: "contains", pkg: "strings", typ: $funcType([$Uint8], [$Bool], false)}];
	Builder.init("strings", [{prop: "addr", name: "addr", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType, tag: ""}]);
	Reader.init("strings", [{prop: "s", name: "s", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "i", name: "i", embedded: false, exported: false, typ: $Int64, tag: ""}, {prop: "prevRune", name: "prevRune", embedded: false, exported: false, typ: $Int, tag: ""}]);
	asciiSet.init($Uint32, 8);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = errors.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytealg.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = sync.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute/html"] = (function() {
	var $pkg = {}, $init, bufio, bytes, errors, io, atom, strconv, strings, utf8, NodeType, Node, nodeStack, insertionModeStack, parser, scope, insertionMode, ParseOption, writer, TokenType, Attribute, Token, span, Tokenizer, sliceType, ptrType, sliceType$1, sliceType$2, sliceType$3, sliceType$4, ptrType$1, ptrType$2, sliceType$5, ptrType$3, sliceType$6, arrayType, arrayType$1, sliceType$7, ptrType$4, isSpecialElementMap, replacementTable, breakout, svgTagNameAdjustments, mathMLAttributeAdjustments, svgAttributeAdjustments, scopeMarker, scopeMarker$24ptr, defaultScopeStopTags, plaintextAbort, voidElements, nul, replacement, isSpecialElement, unescapeEntity, unescape, lower, escape, EscapeString, UnescapeString, adjustAttributeNames, adjustForeignAttributes, htmlIntegrationPoint, mathMLTextIntegrationPoint, reparentChildren, beforeHeadIM, inHeadIM, inHeadNoscriptIM, afterHeadIM, copyAttributes, inBodyIM, textIM, inTableIM, inCaptionIM, inColumnGroupIM, inTableBodyIM, inRowIM, inCellIM, inSelectIM, inSelectInTableIM, inTemplateIM, afterBodyIM, inFramesetIM, afterFramesetIM, afterAfterBodyIM, afterAfterFramesetIM, parseForeignContent, ParseFragment, ParseFragmentWithOptions, Render, render, render1, writeQuoted, readAtLeastOneByte, convertNewlines, NewTokenizer, NewTokenizerFragment;
	bufio = $packages["bufio"];
	bytes = $packages["bytes"];
	errors = $packages["errors"];
	io = $packages["io"];
	atom = $packages["lute/html/atom"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	utf8 = $packages["unicode/utf8"];
	NodeType = $pkg.NodeType = $newType(4, $kindUint32, "html.NodeType", true, "lute/html", true, null);
	Node = $pkg.Node = $newType(0, $kindStruct, "html.Node", true, "lute/html", true, function(Parent_, FirstChild_, LastChild_, PrevSibling_, NextSibling_, Type_, DataAtom_, Data_, Namespace_, Attr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Parent = ptrType.nil;
			this.FirstChild = ptrType.nil;
			this.LastChild = ptrType.nil;
			this.PrevSibling = ptrType.nil;
			this.NextSibling = ptrType.nil;
			this.Type = 0;
			this.DataAtom = 0;
			this.Data = "";
			this.Namespace = "";
			this.Attr = sliceType$1.nil;
			return;
		}
		this.Parent = Parent_;
		this.FirstChild = FirstChild_;
		this.LastChild = LastChild_;
		this.PrevSibling = PrevSibling_;
		this.NextSibling = NextSibling_;
		this.Type = Type_;
		this.DataAtom = DataAtom_;
		this.Data = Data_;
		this.Namespace = Namespace_;
		this.Attr = Attr_;
	});
	nodeStack = $pkg.nodeStack = $newType(12, $kindSlice, "html.nodeStack", true, "lute/html", false, null);
	insertionModeStack = $pkg.insertionModeStack = $newType(12, $kindSlice, "html.insertionModeStack", true, "lute/html", false, null);
	parser = $pkg.parser = $newType(0, $kindStruct, "html.parser", true, "lute/html", false, function(tokenizer_, tok_, hasSelfClosingToken_, doc_, oe_, afe_, head_, form_, scripting_, framesetOK_, templateStack_, im_, originalIM_, fosterParenting_, quirks_, fragment_, context_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.tokenizer = ptrType$3.nil;
			this.tok = new Token.ptr(0, 0, "", sliceType$1.nil);
			this.hasSelfClosingToken = false;
			this.doc = ptrType.nil;
			this.oe = nodeStack.nil;
			this.afe = nodeStack.nil;
			this.head = ptrType.nil;
			this.form = ptrType.nil;
			this.scripting = false;
			this.framesetOK = false;
			this.templateStack = insertionModeStack.nil;
			this.im = $throwNilPointerError;
			this.originalIM = $throwNilPointerError;
			this.fosterParenting = false;
			this.quirks = false;
			this.fragment = false;
			this.context = ptrType.nil;
			return;
		}
		this.tokenizer = tokenizer_;
		this.tok = tok_;
		this.hasSelfClosingToken = hasSelfClosingToken_;
		this.doc = doc_;
		this.oe = oe_;
		this.afe = afe_;
		this.head = head_;
		this.form = form_;
		this.scripting = scripting_;
		this.framesetOK = framesetOK_;
		this.templateStack = templateStack_;
		this.im = im_;
		this.originalIM = originalIM_;
		this.fosterParenting = fosterParenting_;
		this.quirks = quirks_;
		this.fragment = fragment_;
		this.context = context_;
	});
	scope = $pkg.scope = $newType(4, $kindInt, "html.scope", true, "lute/html", false, null);
	insertionMode = $pkg.insertionMode = $newType(4, $kindFunc, "html.insertionMode", true, "lute/html", false, null);
	ParseOption = $pkg.ParseOption = $newType(4, $kindFunc, "html.ParseOption", true, "lute/html", true, null);
	writer = $pkg.writer = $newType(8, $kindInterface, "html.writer", true, "lute/html", false, null);
	TokenType = $pkg.TokenType = $newType(4, $kindUint32, "html.TokenType", true, "lute/html", true, null);
	Attribute = $pkg.Attribute = $newType(0, $kindStruct, "html.Attribute", true, "lute/html", true, function(Namespace_, Key_, Val_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Namespace = "";
			this.Key = "";
			this.Val = "";
			return;
		}
		this.Namespace = Namespace_;
		this.Key = Key_;
		this.Val = Val_;
	});
	Token = $pkg.Token = $newType(0, $kindStruct, "html.Token", true, "lute/html", true, function(Type_, DataAtom_, Data_, Attr_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Type = 0;
			this.DataAtom = 0;
			this.Data = "";
			this.Attr = sliceType$1.nil;
			return;
		}
		this.Type = Type_;
		this.DataAtom = DataAtom_;
		this.Data = Data_;
		this.Attr = Attr_;
	});
	span = $pkg.span = $newType(0, $kindStruct, "html.span", true, "lute/html", false, function(start_, end_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.start = 0;
			this.end = 0;
			return;
		}
		this.start = start_;
		this.end = end_;
	});
	Tokenizer = $pkg.Tokenizer = $newType(0, $kindStruct, "html.Tokenizer", true, "lute/html", true, function(r_, tt_, err_, readErr_, raw_, buf_, maxBuf_, data_, pendingAttr_, attr_, nAttrReturned_, rawTag_, textIsRaw_, convertNUL_, allowCDATA_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.r = $ifaceNil;
			this.tt = 0;
			this.err = $ifaceNil;
			this.readErr = $ifaceNil;
			this.raw = new span.ptr(0, 0);
			this.buf = sliceType$3.nil;
			this.maxBuf = 0;
			this.data = new span.ptr(0, 0);
			this.pendingAttr = arrayType$1.zero();
			this.attr = sliceType$7.nil;
			this.nAttrReturned = 0;
			this.rawTag = "";
			this.textIsRaw = false;
			this.convertNUL = false;
			this.allowCDATA = false;
			return;
		}
		this.r = r_;
		this.tt = tt_;
		this.err = err_;
		this.readErr = readErr_;
		this.raw = raw_;
		this.buf = buf_;
		this.maxBuf = maxBuf_;
		this.data = data_;
		this.pendingAttr = pendingAttr_;
		this.attr = attr_;
		this.nAttrReturned = nAttrReturned_;
		this.rawTag = rawTag_;
		this.textIsRaw = textIsRaw_;
		this.convertNUL = convertNUL_;
		this.allowCDATA = allowCDATA_;
	});
	sliceType = $sliceType($String);
	ptrType = $ptrType(Node);
	sliceType$1 = $sliceType(Attribute);
	sliceType$2 = $sliceType(atom.Atom);
	sliceType$3 = $sliceType($Uint8);
	sliceType$4 = $sliceType($Int32);
	ptrType$1 = $ptrType(nodeStack);
	ptrType$2 = $ptrType(insertionModeStack);
	sliceType$5 = $sliceType(ParseOption);
	ptrType$3 = $ptrType(Tokenizer);
	sliceType$6 = $sliceType(ptrType);
	arrayType = $arrayType($Uint8, 2);
	arrayType$1 = $arrayType(span, 2);
	sliceType$7 = $sliceType(arrayType$1);
	ptrType$4 = $ptrType(parser);
	isSpecialElement = function(element) {
		var _1, _2, _3, _entry, element;
		_1 = element.Namespace;
		if (_1 === ("") || _1 === ("html")) {
			return (_entry = isSpecialElementMap[$String.keyFor(element.Data)], _entry !== undefined ? _entry.v : false);
		} else if (_1 === ("math")) {
			_2 = element.Data;
			if (_2 === ("mi") || _2 === ("mo") || _2 === ("mn") || _2 === ("ms") || _2 === ("mtext") || _2 === ("annotation-xml")) {
				return true;
			}
		} else if (_1 === ("svg")) {
			_3 = element.Data;
			if (_3 === ("foreignObject") || _3 === ("desc") || _3 === ("title")) {
				return true;
			}
		}
		return false;
	};
	unescapeEntity = function(b, dst, src, attribute) {
		var _entry, _entry$1, _tmp, _tmp$1, _tmp$10, _tmp$11, _tmp$12, _tmp$13, _tmp$14, _tmp$15, _tmp$16, _tmp$17, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tmp$9, attribute, b, c, c$1, dst, dst1, entityName, hex, i, j, max, maxLen, s, src, src1, x, x$1, x$2, x$3, x$4, x$5;
		dst1 = 0;
		src1 = 0;
		_tmp = 1;
		_tmp$1 = $subslice(b, src);
		i = _tmp;
		s = _tmp$1;
		if (s.$length <= 1) {
			((dst < 0 || dst >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + dst] = ((src < 0 || src >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + src]));
			_tmp$2 = dst + 1 >> 0;
			_tmp$3 = src + 1 >> 0;
			dst1 = _tmp$2;
			src1 = _tmp$3;
			return [dst1, src1];
		}
		if (((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === 35) {
			if (s.$length <= 3) {
				((dst < 0 || dst >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + dst] = ((src < 0 || src >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + src]));
				_tmp$4 = dst + 1 >> 0;
				_tmp$5 = src + 1 >> 0;
				dst1 = _tmp$4;
				src1 = _tmp$5;
				return [dst1, src1];
			}
			i = i + (1) >> 0;
			c = ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]);
			hex = false;
			if ((c === 120) || (c === 88)) {
				hex = true;
				i = i + (1) >> 0;
			}
			x = 0;
			while (true) {
				if (!(i < s.$length)) { break; }
				c = ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]);
				i = i + (1) >> 0;
				if (hex) {
					if (48 <= c && c <= 57) {
						x = (($imul(16, x)) + ((c >> 0)) >> 0) - 48 >> 0;
						continue;
					} else if (97 <= c && c <= 102) {
						x = ((($imul(16, x)) + ((c >> 0)) >> 0) - 97 >> 0) + 10 >> 0;
						continue;
					} else if (65 <= c && c <= 70) {
						x = ((($imul(16, x)) + ((c >> 0)) >> 0) - 65 >> 0) + 10 >> 0;
						continue;
					}
				} else if (48 <= c && c <= 57) {
					x = (($imul(10, x)) + ((c >> 0)) >> 0) - 48 >> 0;
					continue;
				}
				if (!((c === 59))) {
					i = i - (1) >> 0;
				}
				break;
			}
			if (i <= 3) {
				((dst < 0 || dst >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + dst] = ((src < 0 || src >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + src]));
				_tmp$6 = dst + 1 >> 0;
				_tmp$7 = src + 1 >> 0;
				dst1 = _tmp$6;
				src1 = _tmp$7;
				return [dst1, src1];
			}
			if (128 <= x && x <= 159) {
				x = (x$1 = x - 128 >> 0, ((x$1 < 0 || x$1 >= replacementTable.length) ? ($throwRuntimeError("index out of range"), undefined) : replacementTable[x$1]));
			} else if ((x === 0) || (55296 <= x && x <= 57343) || x > 1114111) {
				x = 65533;
			}
			_tmp$8 = dst + utf8.EncodeRune($subslice(b, dst), x) >> 0;
			_tmp$9 = src + i >> 0;
			dst1 = _tmp$8;
			src1 = _tmp$9;
			return [dst1, src1];
		}
		while (true) {
			if (!(i < s.$length)) { break; }
			c$1 = ((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]);
			i = i + (1) >> 0;
			if (97 <= c$1 && c$1 <= 122 || 65 <= c$1 && c$1 <= 90 || 48 <= c$1 && c$1 <= 57) {
				continue;
			}
			if (!((c$1 === 59))) {
				i = i - (1) >> 0;
			}
			break;
		}
		max = i;
		if (max < 1) {
			max = 1;
		}
		entityName = ($bytesToString($subslice(s, 1, max)));
		if (entityName === "") {
		} else if (attribute && !((entityName.charCodeAt((entityName.length - 1 >> 0)) === 59)) && s.$length > i && (((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i]) === 61)) {
		} else {
			x$2 = (_entry = $pkg.Entities[$String.keyFor(entityName)], _entry !== undefined ? _entry.v : "");
			if (!(x$2 === "")) {
				_tmp$10 = dst + utf8.EncodeRune($subslice(b, dst), (x$3 = (new sliceType$4($stringToRunes(x$2))), (0 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 0]))) >> 0;
				_tmp$11 = src + i >> 0;
				dst1 = _tmp$10;
				src1 = _tmp$11;
				return [dst1, src1];
			} else if (!attribute) {
				maxLen = entityName.length - 1 >> 0;
				if (maxLen > 6) {
					maxLen = 6;
				}
				j = maxLen;
				while (true) {
					if (!(j > 1)) { break; }
					x$4 = (_entry$1 = $pkg.Entities[$String.keyFor($substring(entityName, 0, j))], _entry$1 !== undefined ? _entry$1.v : "");
					if (!(x$4 === "")) {
						_tmp$12 = dst + utf8.EncodeRune($subslice(b, dst), (x$5 = (new sliceType$4($stringToRunes(x$4))), (0 >= x$5.$length ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + 0]))) >> 0;
						_tmp$13 = (src + j >> 0) + 1 >> 0;
						dst1 = _tmp$12;
						src1 = _tmp$13;
						return [dst1, src1];
					}
					j = j - (1) >> 0;
				}
			}
		}
		_tmp$14 = dst + i >> 0;
		_tmp$15 = src + i >> 0;
		dst1 = _tmp$14;
		src1 = _tmp$15;
		$copySlice($subslice(b, dst, dst1), $subslice(b, src, src1));
		_tmp$16 = dst1;
		_tmp$17 = src1;
		dst1 = _tmp$16;
		src1 = _tmp$17;
		return [dst1, src1];
	};
	unescape = function(b, attribute) {
		var _i, _ref, _tmp, _tmp$1, _tuple, _tuple$1, attribute, b, c, c$1, dst, i, src;
		_ref = b;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (c === 38) {
				_tuple = unescapeEntity(b, i, i, attribute);
				dst = _tuple[0];
				src = _tuple[1];
				while (true) {
					if (!(src < b.$length)) { break; }
					c$1 = ((src < 0 || src >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + src]);
					if (c$1 === 38) {
						_tuple$1 = unescapeEntity(b, dst, src, attribute);
						dst = _tuple$1[0];
						src = _tuple$1[1];
					} else {
						((dst < 0 || dst >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + dst] = c$1);
						_tmp = dst + 1 >> 0;
						_tmp$1 = src + 1 >> 0;
						dst = _tmp;
						src = _tmp$1;
					}
				}
				return $subslice(b, 0, dst);
			}
			_i++;
		}
		return b;
	};
	lower = function(b) {
		var _i, _ref, b, c, i;
		_ref = b;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (65 <= c && c <= 90) {
				((i < 0 || i >= b.$length) ? ($throwRuntimeError("index out of range"), undefined) : b.$array[b.$offset + i] = ((c + 97 << 24 >>> 24) - 65 << 24 >>> 24));
			}
			_i++;
		}
		return b;
	};
	escape = function(w, s) {
		var _1, _r, _r$1, _r$2, _tuple, _tuple$1, _tuple$2, err, err$1, err$2, esc, i, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; esc = $f.esc; i = $f.i; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = strings.IndexAny(s, "&'<>\"\r");
		/* while (true) { */ case 1:
			/* if (!(!((i === -1)))) { break; } */ if(!(!((i === -1)))) { $s = 2; continue; }
			_r = w.WriteString($substring(s, 0, i)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			err = _tuple[1];
			if (!($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return err;
			}
			esc = "";
			_1 = s.charCodeAt(i);
			if (_1 === (38)) {
				esc = "&amp;";
			} else if (_1 === (39)) {
				esc = "&#39;";
			} else if (_1 === (60)) {
				esc = "&lt;";
			} else if (_1 === (62)) {
				esc = "&gt;";
			} else if (_1 === (34)) {
				esc = "&#34;";
			} else if (_1 === (13)) {
				esc = "&#13;";
			} else {
				$panic(new $String("unrecognized escape character"));
			}
			s = $substring(s, (i + 1 >> 0));
			_r$1 = w.WriteString(esc); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			_tuple$1 = _r$1;
			err$1 = _tuple$1[1];
			if (!($interfaceIsEqual(err$1, $ifaceNil))) {
				$s = -1; return err$1;
			}
			i = strings.IndexAny(s, "&'<>\"\r");
		/* } */ $s = 1; continue; case 2:
		_r$2 = w.WriteString(s); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_tuple$2 = _r$2;
		err$2 = _tuple$2[1];
		$s = -1; return err$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: escape }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.esc = esc; $f.i = i; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	EscapeString = function(s) {
		var _r, buf, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; buf = $f.buf; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		buf = [buf];
		if (strings.IndexAny(s, "&'<>\"\r") === -1) {
			$s = -1; return s;
		}
		buf[0] = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
		_r = escape(buf[0], s); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return buf[0].String();
		/* */ } return; } if ($f === undefined) { $f = { $blk: EscapeString }; } $f._r = _r; $f.buf = buf; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.EscapeString = EscapeString;
	UnescapeString = function(s) {
		var _i, _ref, _rune, c, s;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			c = _rune[0];
			if (c === 38) {
				return ($bytesToString(unescape((new sliceType$3($stringToBytes(s))), false)));
			}
			_i += _rune[1];
		}
		return s;
	};
	$pkg.UnescapeString = UnescapeString;
	adjustAttributeNames = function(aa, nameMap) {
		var _entry, _i, _ref, _tuple, aa, i, nameMap, newName, ok;
		_ref = aa;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			_tuple = (_entry = nameMap[$String.keyFor(((i < 0 || i >= aa.$length) ? ($throwRuntimeError("index out of range"), undefined) : aa.$array[aa.$offset + i]).Key)], _entry !== undefined ? [_entry.v, true] : ["", false]);
			newName = _tuple[0];
			ok = _tuple[1];
			if (ok) {
				((i < 0 || i >= aa.$length) ? ($throwRuntimeError("index out of range"), undefined) : aa.$array[aa.$offset + i]).Key = newName;
			}
			_i++;
		}
	};
	adjustForeignAttributes = function(aa) {
		var _1, _i, _ref, a, aa, i, j;
		_ref = aa;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			a = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
			if (a.Key === "" || !((a.Key.charCodeAt(0) === 120))) {
				_i++;
				continue;
			}
			_1 = a.Key;
			if (_1 === ("xlink:actuate") || _1 === ("xlink:arcrole") || _1 === ("xlink:href") || _1 === ("xlink:role") || _1 === ("xlink:show") || _1 === ("xlink:title") || _1 === ("xlink:type") || _1 === ("xml:base") || _1 === ("xml:lang") || _1 === ("xml:space") || _1 === ("xmlns:xlink")) {
				j = strings.Index(a.Key, ":");
				((i < 0 || i >= aa.$length) ? ($throwRuntimeError("index out of range"), undefined) : aa.$array[aa.$offset + i]).Namespace = $substring(a.Key, 0, j);
				((i < 0 || i >= aa.$length) ? ($throwRuntimeError("index out of range"), undefined) : aa.$array[aa.$offset + i]).Key = $substring(a.Key, (j + 1 >> 0));
			}
			_i++;
		}
	};
	htmlIntegrationPoint = function(n) {
		var _1, _2, _i, _r, _ref, a, n, val, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; n = $f.n; val = $f.val; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		if (!((n.Type === 3))) {
			$s = -1; return false;
		}
			_1 = n.Namespace;
			/* */ if (_1 === ("math")) { $s = 2; continue; }
			/* */ if (_1 === ("svg")) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_1 === ("math")) { */ case 2:
				/* */ if (n.Data === "annotation-xml") { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (n.Data === "annotation-xml") { */ case 5:
					_ref = n.Attr;
					_i = 0;
					/* while (true) { */ case 7:
						/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 8; continue; }
						a = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
						/* */ if (a.Key === "encoding") { $s = 9; continue; }
						/* */ $s = 10; continue;
						/* if (a.Key === "encoding") { */ case 9:
							_r = strings.ToLower(a.Val); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
							val = _r;
							if (val === "text/html" || val === "application/xhtml+xml") {
								$s = -1; return true;
							}
						/* } */ case 10:
						_i++;
					/* } */ $s = 7; continue; case 8:
				/* } */ case 6:
				$s = 4; continue;
			/* } else if (_1 === ("svg")) { */ case 3:
				_2 = n.Data;
				if (_2 === ("desc") || _2 === ("foreignObject") || _2 === ("title")) {
					$s = -1; return true;
				}
			/* } */ case 4:
		case 1:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: htmlIntegrationPoint }; } $f._1 = _1; $f._2 = _2; $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.n = n; $f.val = val; $f.$s = $s; $f.$r = $r; return $f;
	};
	mathMLTextIntegrationPoint = function(n) {
		var _1, n;
		if (!(n.Namespace === "math")) {
			return false;
		}
		_1 = n.Data;
		if (_1 === ("mi") || _1 === ("mo") || _1 === ("mn") || _1 === ("ms") || _1 === ("mtext")) {
			return true;
		}
		return false;
	};
	Node.ptr.prototype.Unlink = function() {
		var n;
		n = this;
		if (!(ptrType.nil === n.PrevSibling)) {
			n.PrevSibling.NextSibling = n.NextSibling;
		} else if (!(ptrType.nil === n.Parent)) {
			n.Parent.FirstChild = n.NextSibling;
		}
		if (!(ptrType.nil === n.NextSibling)) {
			n.NextSibling.PrevSibling = n.PrevSibling;
		} else if (!(ptrType.nil === n.Parent)) {
			n.Parent.LastChild = n.PrevSibling;
		}
		n.Parent = ptrType.nil;
		n.NextSibling = ptrType.nil;
		n.PrevSibling = ptrType.nil;
	};
	Node.prototype.Unlink = function() { return this.$val.Unlink(); };
	Node.ptr.prototype.InsertBefore = function(sibling) {
		var n, sibling;
		n = this;
		sibling.Unlink();
		sibling.PrevSibling = n.PrevSibling;
		if (!(ptrType.nil === sibling.PrevSibling)) {
			sibling.PrevSibling.NextSibling = sibling;
		}
		sibling.NextSibling = n;
		n.PrevSibling = sibling;
		sibling.Parent = n.Parent;
		if (ptrType.nil === sibling.PrevSibling) {
			sibling.Parent.FirstChild = sibling;
		}
	};
	Node.prototype.InsertBefore = function(sibling) { return this.$val.InsertBefore(sibling); };
	Node.ptr.prototype.InsertAfter = function(sibling) {
		var n, sibling;
		n = this;
		sibling.Unlink();
		sibling.NextSibling = n.NextSibling;
		if (!(ptrType.nil === sibling.NextSibling)) {
			sibling.NextSibling.PrevSibling = sibling;
		}
		sibling.PrevSibling = n;
		n.NextSibling = sibling;
		sibling.Parent = n.Parent;
		if (ptrType.nil === sibling.NextSibling && !(ptrType.nil === sibling.Parent)) {
			sibling.Parent.LastChild = sibling;
		}
	};
	Node.prototype.InsertAfter = function(sibling) { return this.$val.InsertAfter(sibling); };
	Node.ptr.prototype.InsertChildBefore = function(newChild, oldChild) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, n, newChild, next, oldChild, prev;
		n = this;
		if (!(newChild.Parent === ptrType.nil) || !(newChild.PrevSibling === ptrType.nil) || !(newChild.NextSibling === ptrType.nil)) {
			$panic(new $String("html: InsertChildBefore called for an attached child Node"));
		}
		_tmp = ptrType.nil;
		_tmp$1 = ptrType.nil;
		prev = _tmp;
		next = _tmp$1;
		if (!(oldChild === ptrType.nil)) {
			_tmp$2 = oldChild.PrevSibling;
			_tmp$3 = oldChild;
			prev = _tmp$2;
			next = _tmp$3;
		} else {
			prev = n.LastChild;
		}
		if (!(prev === ptrType.nil)) {
			prev.NextSibling = newChild;
		} else {
			n.FirstChild = newChild;
		}
		if (!(next === ptrType.nil)) {
			next.PrevSibling = newChild;
		} else {
			n.LastChild = newChild;
		}
		newChild.Parent = n;
		newChild.PrevSibling = prev;
		newChild.NextSibling = next;
	};
	Node.prototype.InsertChildBefore = function(newChild, oldChild) { return this.$val.InsertChildBefore(newChild, oldChild); };
	Node.ptr.prototype.AppendChild = function(c) {
		var c, last, n;
		n = this;
		if (!(c.Parent === ptrType.nil) || !(c.PrevSibling === ptrType.nil) || !(c.NextSibling === ptrType.nil)) {
			$panic(new $String("html: AppendChild called for an attached child Node"));
		}
		last = n.LastChild;
		if (!(last === ptrType.nil)) {
			last.NextSibling = c;
		} else {
			n.FirstChild = c;
		}
		n.LastChild = c;
		c.Parent = n;
		c.PrevSibling = last;
	};
	Node.prototype.AppendChild = function(c) { return this.$val.AppendChild(c); };
	Node.ptr.prototype.RemoveChild = function(c) {
		var c, n;
		n = this;
		if (!(c.Parent === n)) {
			$panic(new $String("html: RemoveChild called for a non-child Node"));
		}
		if (n.FirstChild === c) {
			n.FirstChild = c.NextSibling;
		}
		if (!(c.NextSibling === ptrType.nil)) {
			c.NextSibling.PrevSibling = c.PrevSibling;
		}
		if (n.LastChild === c) {
			n.LastChild = c.PrevSibling;
		}
		if (!(c.PrevSibling === ptrType.nil)) {
			c.PrevSibling.NextSibling = c.NextSibling;
		}
		c.Parent = ptrType.nil;
		c.PrevSibling = ptrType.nil;
		c.NextSibling = ptrType.nil;
	};
	Node.prototype.RemoveChild = function(c) { return this.$val.RemoveChild(c); };
	reparentChildren = function(dst, src) {
		var child, dst, src;
		while (true) {
			child = src.FirstChild;
			if (child === ptrType.nil) {
				break;
			}
			src.RemoveChild(child);
			dst.AppendChild(child);
		}
	};
	Node.ptr.prototype.clone = function() {
		var m, n;
		n = this;
		m = new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, n.Type, n.DataAtom, n.Data, "", $makeSlice(sliceType$1, n.Attr.$length));
		$copySlice(m.Attr, n.Attr);
		return m;
	};
	Node.prototype.clone = function() { return this.$val.clone(); };
	$ptrType(nodeStack).prototype.pop = function() {
		var i, n, s, x, x$1;
		s = this;
		i = s.$get().$length;
		n = (x = s.$get(), x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		s.$set($subslice((s.$get()), 0, (i - 1 >> 0)));
		return n;
	};
	$ptrType(nodeStack).prototype.top = function() {
		var i, s, x, x$1;
		s = this;
		i = s.$get().$length;
		if (i > 0) {
			return (x = s.$get(), x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		}
		return ptrType.nil;
	};
	$ptrType(nodeStack).prototype.index = function(n) {
		var i, n, s, x;
		s = this;
		i = s.$get().$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if ((x = s.$get(), ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])) === n) {
				return i;
			}
			i = i - (1) >> 0;
		}
		return -1;
	};
	$ptrType(nodeStack).prototype.contains = function(a) {
		var _i, _ref, a, n, s;
		s = this;
		_ref = s.$get();
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if ((n.DataAtom === a) && n.Namespace === "") {
				return true;
			}
			_i++;
		}
		return false;
	};
	$ptrType(nodeStack).prototype.insert = function(i, n) {
		var i, n, s, x;
		s = this;
		s.$set($append(s.$get(), ptrType.nil));
		$copySlice($subslice((s.$get()), (i + 1 >> 0)), $subslice((s.$get()), i));
		(x = s.$get(), ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i] = n));
	};
	$ptrType(nodeStack).prototype.remove = function(n) {
		var i, j, n, s, x;
		s = this;
		i = s.index(n);
		if (i === -1) {
			return;
		}
		$copySlice($subslice((s.$get()), i), $subslice((s.$get()), (i + 1 >> 0)));
		j = s.$get().$length - 1 >> 0;
		(x = s.$get(), ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j] = ptrType.nil));
		s.$set($subslice((s.$get()), 0, j));
	};
	$ptrType(insertionModeStack).prototype.pop = function() {
		var i, im, s, x, x$1;
		im = $throwNilPointerError;
		s = this;
		i = s.$get().$length;
		im = (x = s.$get(), x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		s.$set($subslice((s.$get()), 0, (i - 1 >> 0)));
		im = im;
		return im;
	};
	$ptrType(insertionModeStack).prototype.top = function() {
		var i, s, x, x$1;
		s = this;
		i = s.$get().$length;
		if (i > 0) {
			return (x = s.$get(), x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		}
		return $throwNilPointerError;
	};
	parser.ptr.prototype.top = function() {
		var n, p;
		p = this;
		n = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top();
		if (!(n === ptrType.nil)) {
			return n;
		}
		return p.doc;
	};
	parser.prototype.top = function() { return this.$val.top(); };
	parser.ptr.prototype.popUntil = function(s, matchTags) {
		var i, matchTags, p, s;
		p = this;
		i = p.indexOfElementInScope(s, matchTags);
		if (!((i === -1))) {
			p.oe = $subslice(p.oe, 0, i);
			return true;
		}
		return false;
	};
	parser.prototype.popUntil = function(s, matchTags) { return this.$val.popUntil(s, matchTags); };
	parser.ptr.prototype.indexOfElementInScope = function(s, matchTags) {
		var _1, _2, _entry, _i, _i$1, _ref, _ref$1, i, matchTags, p, s, t, t$1, tagAtom, x, x$1, x$2;
		p = this;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			tagAtom = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom;
			if ((x$1 = p.oe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).Namespace === "") {
				_ref = matchTags;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					t = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
					if (t === tagAtom) {
						return i;
					}
					_i++;
				}
				_1 = s;
				if (_1 === (0)) {
				} else if (_1 === (1)) {
					if ((tagAtom === 79618) || (tagAtom === 42754)) {
						return -1;
					}
				} else if (_1 === (2)) {
					if (tagAtom === 102662) {
						return -1;
					}
				} else if (_1 === (3)) {
					if ((tagAtom === 22020) || (tagAtom === 365829) || (tagAtom === 463880)) {
						return -1;
					}
				} else if (_1 === (6)) {
					if (!((tagAtom === 24328)) && !((tagAtom === 451334))) {
						return -1;
					}
				} else {
					$panic(new $String("unreachable"));
				}
			}
			_2 = s;
			if ((_2 === (0)) || (_2 === (1)) || (_2 === (2))) {
				_ref$1 = (_entry = defaultScopeStopTags[$String.keyFor((x$2 = p.oe, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i])).Namespace)], _entry !== undefined ? _entry.v : sliceType$2.nil);
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					t$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
					if (t$1 === tagAtom) {
						return -1;
					}
					_i$1++;
				}
			}
			i = i - (1) >> 0;
		}
		return -1;
	};
	parser.prototype.indexOfElementInScope = function(s, matchTags) { return this.$val.indexOfElementInScope(s, matchTags); };
	parser.ptr.prototype.elementInScope = function(s, matchTags) {
		var matchTags, p, s;
		p = this;
		return !((p.indexOfElementInScope(s, matchTags) === -1));
	};
	parser.prototype.elementInScope = function(s, matchTags) { return this.$val.elementInScope(s, matchTags); };
	parser.ptr.prototype.clearStackToContext = function(s) {
		var _1, i, p, s, tagAtom, x;
		p = this;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			tagAtom = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom;
			_1 = s;
			if (_1 === (3)) {
				if ((tagAtom === 22020) || (tagAtom === 365829) || (tagAtom === 463880)) {
					p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
					return;
				}
			} else if (_1 === (4)) {
				if ((tagAtom === 22020) || (tagAtom === 52226) || (tagAtom === 463880)) {
					p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
					return;
				}
			} else if (_1 === (5)) {
				if ((tagAtom === 22020) || (tagAtom === 9989) || (tagAtom === 62725) || (tagAtom === 208901) || (tagAtom === 463880)) {
					p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
					return;
				}
			} else {
				$panic(new $String("unreachable"));
			}
			i = i - (1) >> 0;
		}
	};
	parser.prototype.clearStackToContext = function(s) { return this.$val.clearStackToContext(s); };
	parser.ptr.prototype.generateImpliedEndTags = function(exceptions) {
		var _1, _i, _ref, except, exceptions, i, n, p, x;
		p = this;
		i = 0;
		i = p.oe.$length - 1 >> 0;
		loop:
		while (true) {
			if (!(i >= 0)) { break; }
			n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (n.Type === 3) {
				_1 = n.DataAtom;
				if ((_1 === (186114)) || (_1 === (412418)) || (_1 === (45570)) || (_1 === (24328)) || (_1 === (451334)) || (_1 === (3073)) || (_1 === (14850)) || (_1 === (146434)) || (_1 === (104962)) || (_1 === (104963))) {
					_ref = exceptions;
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						except = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
						if (n.Data === except) {
							break loop;
						}
						_i++;
					}
					i = i - (1) >> 0;
					continue;
				}
			}
			break;
		}
		p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
	};
	parser.prototype.generateImpliedEndTags = function(exceptions) { return this.$val.generateImpliedEndTags(exceptions); };
	parser.ptr.prototype.addChild = function(n) {
		var n, p;
		p = this;
		if (p.shouldFosterParent()) {
			p.fosterParent(n);
		} else {
			p.top().AppendChild(n);
		}
		if (n.Type === 3) {
			p.oe = $append(p.oe, n);
		}
	};
	parser.prototype.addChild = function(n) { return this.$val.addChild(n); };
	parser.ptr.prototype.shouldFosterParent = function() {
		var _1, p;
		p = this;
		if (p.fosterParenting) {
			_1 = p.top().DataAtom;
			if ((_1 === (365829)) || (_1 === (9989)) || (_1 === (62725)) || (_1 === (208901)) || (_1 === (52226))) {
				return true;
			}
		}
		return false;
	};
	parser.prototype.shouldFosterParent = function() { return this.$val.shouldFosterParent(); };
	parser.ptr.prototype.fosterParent = function(n) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, j, n, p, parent, prev, table, template, x, x$1, x$2, x$3, x$4, x$5, x$6;
		p = this;
		_tmp = ptrType.nil;
		_tmp$1 = ptrType.nil;
		_tmp$2 = ptrType.nil;
		_tmp$3 = ptrType.nil;
		table = _tmp;
		parent = _tmp$1;
		prev = _tmp$2;
		template = _tmp$3;
		i = 0;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if ((x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom === 365829) {
				table = (x$1 = p.oe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]));
				break;
			}
			i = i - (1) >> 0;
		}
		j = 0;
		j = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(j >= 0)) { break; }
			if ((x$2 = p.oe, ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j])).DataAtom === 463880) {
				template = (x$3 = p.oe, ((j < 0 || j >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + j]));
				break;
			}
			j = j - (1) >> 0;
		}
		if (!(template === ptrType.nil) && (table === ptrType.nil || j > i)) {
			template.AppendChild(n);
			return;
		}
		if (table === ptrType.nil) {
			parent = (x$4 = p.oe, (0 >= x$4.$length ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + 0]));
		} else {
			parent = table.Parent;
		}
		if (parent === ptrType.nil) {
			parent = (x$5 = p.oe, x$6 = i - 1 >> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6]));
		}
		if (!(table === ptrType.nil)) {
			prev = table.PrevSibling;
		} else {
			prev = parent.LastChild;
		}
		if (!(prev === ptrType.nil) && (prev.Type === 1) && (n.Type === 1)) {
			prev.Data = prev.Data + (n.Data);
			return;
		}
		parent.InsertChildBefore(n, table);
	};
	parser.prototype.fosterParent = function(n) { return this.$val.fosterParent(n); };
	parser.ptr.prototype.addText = function(text) {
		var n, p, t, text;
		p = this;
		if (text === "") {
			return;
		}
		if (p.shouldFosterParent()) {
			p.fosterParent(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, text, "", sliceType$1.nil));
			return;
		}
		t = p.top();
		n = t.LastChild;
		if (!(n === ptrType.nil) && (n.Type === 1)) {
			n.Data = n.Data + (text);
			return;
		}
		p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, text, "", sliceType$1.nil));
	};
	parser.prototype.addText = function(text) { return this.$val.addText(text); };
	parser.ptr.prototype.addElement = function() {
		var p;
		p = this;
		p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, p.tok.DataAtom, p.tok.Data, "", p.tok.Attr));
	};
	parser.prototype.addElement = function() { return this.$val.addElement(); };
	parser.ptr.prototype.addFormattingElement = function() {
		var _i, _i$1, _ref, _ref$1, _tmp, _tmp$1, attr, i, identicalElements, n, p, t0, t1, tagAtom, x;
		p = this;
		_tmp = p.tok.DataAtom;
		_tmp$1 = p.tok.Attr;
		tagAtom = _tmp;
		attr = _tmp$1;
		p.addElement();
		identicalElements = 0;
		i = p.afe.$length - 1 >> 0;
		findIdenticalElements:
		while (true) {
			if (!(i >= 0)) { break; }
			n = (x = p.afe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (n.Type === 6) {
				break;
			}
			if (!((n.Type === 3))) {
				i = i - (1) >> 0;
				continue;
			}
			if (!(n.Namespace === "")) {
				i = i - (1) >> 0;
				continue;
			}
			if (!((n.DataAtom === tagAtom))) {
				i = i - (1) >> 0;
				continue;
			}
			if (!((n.Attr.$length === attr.$length))) {
				i = i - (1) >> 0;
				continue;
			}
			_ref = n.Attr;
			_i = 0;
			compareAttributes:
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				t0 = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
				_ref$1 = attr;
				_i$1 = 0;
				while (true) {
					if (!(_i$1 < _ref$1.$length)) { break; }
					t1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), Attribute);
					if (t0.Key === t1.Key && t0.Namespace === t1.Namespace && t0.Val === t1.Val) {
						_i++;
						continue compareAttributes;
					}
					_i$1++;
				}
				i = i - (1) >> 0;
				continue findIdenticalElements;
			}
			identicalElements = identicalElements + (1) >> 0;
			if (identicalElements >= 3) {
				(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(n);
			}
			i = i - (1) >> 0;
		}
		p.afe = $append(p.afe, p.top());
	};
	parser.prototype.addFormattingElement = function() { return this.$val.addFormattingElement(); };
	parser.ptr.prototype.clearActiveFormattingElements = function() {
		var n, p;
		p = this;
		while (true) {
			n = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).pop();
			if ((p.afe.$length === 0) || (n.Type === 6)) {
				return;
			}
		}
	};
	parser.prototype.clearActiveFormattingElements = function() { return this.$val.clearActiveFormattingElements(); };
	parser.ptr.prototype.reconstructActiveFormattingElements = function() {
		var clone, i, n, p, x, x$1, x$2;
		p = this;
		n = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).top();
		if (n === ptrType.nil) {
			return;
		}
		if ((n.Type === 6) || !(((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(n) === -1))) {
			return;
		}
		i = p.afe.$length - 1 >> 0;
		while (true) {
			if (!(!((n.Type === 6)) && ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(n) === -1))) { break; }
			if (i === 0) {
				i = -1;
				break;
			}
			i = i - (1) >> 0;
			n = (x = p.afe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
		}
		while (true) {
			i = i + (1) >> 0;
			clone = (x$1 = p.afe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).clone();
			p.addChild(clone);
			(x$2 = p.afe, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i] = clone));
			if (i === (p.afe.$length - 1 >> 0)) {
				break;
			}
		}
	};
	parser.prototype.reconstructActiveFormattingElements = function() { return this.$val.reconstructActiveFormattingElements(); };
	parser.ptr.prototype.acknowledgeSelfClosingTag = function() {
		var p;
		p = this;
		p.hasSelfClosingToken = false;
	};
	parser.prototype.acknowledgeSelfClosingTag = function() { return this.$val.acknowledgeSelfClosingTag(); };
	parser.ptr.prototype.setOriginalIM = function() {
		var p;
		p = this;
		if (!(p.originalIM === $throwNilPointerError)) {
			$panic(new $String("html: bad parser state: originalIM was set twice"));
		}
		p.originalIM = p.im;
	};
	parser.prototype.setOriginalIM = function() { return this.$val.setOriginalIM(); };
	parser.ptr.prototype.resetInsertionMode = function() {
		var _1, _2, _tmp, _tmp$1, ancestor, first, i, last, n, p, x, x$1, x$2, x$3;
		p = this;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			last = i === 0;
			if (last && !(p.context === ptrType.nil)) {
				n = p.context;
			}
			_1 = n.DataAtom;
			if (_1 === (408582)) {
				if (!last) {
					_tmp = n;
					_tmp$1 = (x$1 = p.oe, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]));
					ancestor = _tmp;
					first = _tmp$1;
					while (true) {
						if (!(!(ancestor === first))) { break; }
						ancestor = (x$2 = p.oe, x$3 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(ancestor) - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
						_2 = ancestor.DataAtom;
						if (_2 === (463880)) {
							p.im = inSelectIM;
							return;
						} else if (_2 === (365829)) {
							p.im = inSelectInTableIM;
							return;
						}
					}
				}
				p.im = inSelectIM;
			} else if ((_1 === (37378)) || (_1 === (87554))) {
				p.im = inCellIM;
			} else if (_1 === (52226)) {
				p.im = inRowIM;
			} else if ((_1 === (9989)) || (_1 === (208901)) || (_1 === (62725))) {
				p.im = inTableBodyIM;
			} else if (_1 === (143623)) {
				p.im = inCaptionIM;
			} else if (_1 === (109320)) {
				p.im = inColumnGroupIM;
			} else if (_1 === (365829)) {
				p.im = inTableIM;
			} else if (_1 === (463880)) {
				if (!(n.Namespace === "")) {
					i = i - (1) >> 0;
					continue;
				}
				p.im = (p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).top();
			} else if (_1 === (209156)) {
				p.im = inHeadIM;
			} else if (_1 === (10244)) {
				p.im = inBodyIM;
			} else if (_1 === (35592)) {
				p.im = inFramesetIM;
			} else if (_1 === (22020)) {
				if (p.head === ptrType.nil) {
					p.im = beforeHeadIM;
				} else {
					p.im = afterHeadIM;
				}
			} else {
				if (last) {
					p.im = inBodyIM;
					return;
				}
				i = i - (1) >> 0;
				continue;
			}
			return;
		}
	};
	parser.prototype.resetInsertionMode = function() { return this.$val.resetInsertionMode(); };
	beforeHeadIM = function(p) {
		var _1, _2, _3, _r, _r$1, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 2:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				p.tok.Data = _r;
				if (p.tok.Data.length === 0) {
					$s = -1; return true;
				}
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (209156)) { $s = 10; continue; }
					/* */ if (_2 === (22020)) { $s = 11; continue; }
					/* */ $s = 12; continue;
					/* if (_2 === (209156)) { */ case 10:
						p.addElement();
						p.head = p.top();
						p.im = inHeadIM;
						$s = -1; return true;
					/* } else if (_2 === (22020)) { */ case 11:
						_r$1 = inBodyIM(p); /* */ $s = 13; case 13: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } */ case 12:
				case 9:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if ((_3 === (209156)) || (_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if ((_3 === (209156)) || (_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { */ case 15:
						$r = p.parseImpliedToken(2, 209156, new atom.Atom(209156).String()); /* */ $s = 18; case 18: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else { */ case 16:
						$s = -1; return true;
					/* } */ case 17:
				case 14:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } */ case 7:
		case 1:
		$r = p.parseImpliedToken(2, 209156, new atom.Atom(209156).String()); /* */ $s = 19; case 19: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: beforeHeadIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inHeadIM = function(p) {
		var _1, _2, _3, _r, _r$1, i, n, p, s, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; i = $f.i; n = $f.n; p = $f.p; s = $f.s; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 2:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (s.length < p.tok.Data.length) {
					p.addText($substring(p.tok.Data, 0, (p.tok.Data.length - s.length >> 0)));
					if (s === "") {
						$s = -1; return true;
					}
					p.tok.Data = s;
				}
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 10; continue; }
					/* */ if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (120583)) || (_2 === (95236)) || (_2 === (309252))) { $s = 11; continue; }
					/* */ if (_2 === (136712)) { $s = 12; continue; }
					/* */ if ((_2 === (137222)) || (_2 === (69637)) || (_2 === (35080)) || (_2 === (458501))) { $s = 13; continue; }
					/* */ if (_2 === (209156)) { $s = 14; continue; }
					/* */ if (_2 === (463880)) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if (_2 === (22020)) { */ case 10:
						_r$1 = inBodyIM(p); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (120583)) || (_2 === (95236)) || (_2 === (309252))) { */ case 11:
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						$s = -1; return true;
					/* } else if (_2 === (136712)) { */ case 12:
						p.addElement();
						if (p.scripting) {
							p.setOriginalIM();
							p.im = textIM;
						} else {
							p.im = inHeadNoscriptIM;
						}
						$s = -1; return true;
					/* } else if ((_2 === (137222)) || (_2 === (69637)) || (_2 === (35080)) || (_2 === (458501))) { */ case 13:
						p.addElement();
						p.setOriginalIM();
						p.im = textIM;
						$s = -1; return true;
					/* } else if (_2 === (209156)) { */ case 14:
						$s = -1; return true;
					/* } else if (_2 === (463880)) { */ case 15:
						p.addElement();
						p.afe = $append(p.afe, scopeMarker);
						p.framesetOK = false;
						p.im = inTemplateIM;
						p.templateStack = $append(p.templateStack, inTemplateIM);
						$s = -1; return true;
					/* } */ case 16:
				case 9:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (209156)) { $s = 19; continue; }
					/* */ if ((_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { $s = 20; continue; }
					/* */ if (_3 === (463880)) { $s = 21; continue; }
					/* */ $s = 22; continue;
					/* if (_3 === (209156)) { */ case 19:
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.im = afterHeadIM;
						$s = -1; return true;
					/* } else if ((_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { */ case 20:
						$r = p.parseImpliedToken(3, 209156, new atom.Atom(209156).String()); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else if (_3 === (463880)) { */ case 21:
						if (!(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							$s = -1; return true;
						}
						p.generateImpliedEndTags(new sliceType([]));
						i = p.oe.$length - 1 >> 0;
						while (true) {
							if (!(i >= 0)) { break; }
							n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
							if (n.Namespace === "" && (n.DataAtom === 463880)) {
								p.oe = $subslice(p.oe, 0, i);
								break;
							}
							i = i - (1) >> 0;
						}
						p.clearActiveFormattingElements();
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.resetInsertionMode();
						$s = -1; return true;
					/* } else { */ case 22:
						$s = -1; return true;
					/* } */ case 23:
				case 18:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } */ case 7:
		case 1:
		$r = p.parseImpliedToken(3, 209156, new atom.Atom(209156).String()); /* */ $s = 25; case 25: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inHeadIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f.i = i; $f.n = n; $f.p = p; $f.s = s; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	inHeadNoscriptIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, _r$4, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (6)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (1)) { $s = 5; continue; }
			/* */ if (_1 === (5)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (6)) { */ case 2:
				$s = -1; return true;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 9; continue; }
					/* */ if ((_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (458501))) { $s = 10; continue; }
					/* */ if ((_2 === (209156)) || (_2 === (136712))) { $s = 11; continue; }
					/* */ $s = 12; continue;
					/* if (_2 === (22020)) { */ case 9:
						_r = inBodyIM(p); /* */ $s = 13; case 13: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						$s = -1; return _r;
					/* } else if ((_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (458501))) { */ case 10:
						_r$1 = inHeadIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if ((_2 === (209156)) || (_2 === (136712))) { */ case 11:
						$s = -1; return true;
					/* } */ case 12:
				case 8:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
				_3 = p.tok.DataAtom;
				if ((_3 === (136712)) || (_3 === (514))) {
				} else {
					$s = -1; return true;
				}
				$s = 7; continue;
			/* } else if (_1 === (1)) { */ case 5:
				_r$2 = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				s = _r$2;
				/* */ if (s.length === 0) { $s = 16; continue; }
				/* */ $s = 17; continue;
				/* if (s.length === 0) { */ case 16:
					_r$3 = inHeadIM(p); /* */ $s = 18; case 18: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					$s = -1; return _r$3;
				/* } */ case 17:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 6:
				_r$4 = inHeadIM(p); /* */ $s = 19; case 19: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$s = -1; return _r$4;
			/* } */ case 7:
		case 1:
		(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
		if (!((p.top().DataAtom === 209156))) {
			$panic(new $String("html: the new current node will be a head element."));
		}
		p.im = inHeadIM;
		if (p.tok.DataAtom === 136712) {
			$s = -1; return true;
		}
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inHeadNoscriptIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterHeadIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, p, s, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; p = $f.p; s = $f.s; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 2:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (s.length < p.tok.Data.length) {
					p.addText($substring(p.tok.Data, 0, (p.tok.Data.length - s.length >> 0)));
					if (s === "") {
						$s = -1; return true;
					}
					p.tok.Data = s;
				}
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 10; continue; }
					/* */ if (_2 === (10244)) { $s = 11; continue; }
					/* */ if (_2 === (35592)) { $s = 12; continue; }
					/* */ if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (137222)) || (_2 === (458501)) || (_2 === (463880)) || (_2 === (69637))) { $s = 13; continue; }
					/* */ if (_2 === (209156)) { $s = 14; continue; }
					/* */ $s = 15; continue;
					/* if (_2 === (22020)) { */ case 10:
						_r$1 = inBodyIM(p); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_2 === (10244)) { */ case 11:
						p.addElement();
						p.framesetOK = false;
						p.im = inBodyIM;
						$s = -1; return true;
					/* } else if (_2 === (35592)) { */ case 12:
						p.addElement();
						p.im = inFramesetIM;
						$s = -1; return true;
					/* } else if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (137222)) || (_2 === (458501)) || (_2 === (463880)) || (_2 === (69637))) { */ case 13:
						p.oe = $append(p.oe, p.head);
						$deferred.push([$methodVal((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))), "remove"), [p.head]]);
						_r$2 = inHeadIM(p); /* */ $s = 17; case 17: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } else if (_2 === (209156)) { */ case 14:
						$s = -1; return true;
					/* } */ case 15:
				case 9:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if ((_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { $s = 19; continue; }
					/* */ if (_3 === (463880)) { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if ((_3 === (10244)) || (_3 === (22020)) || (_3 === (514))) { */ case 19:
						$s = 22; continue;
					/* } else if (_3 === (463880)) { */ case 20:
						_r$3 = inHeadIM(p); /* */ $s = 23; case 23: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } else { */ case 21:
						$s = -1; return true;
					/* } */ case 22:
				case 18:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } */ case 7:
		case 1:
		$r = p.parseImpliedToken(2, 10244, new atom.Atom(10244).String()); /* */ $s = 24; case 24: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		p.framesetOK = true;
		$s = -1; return false;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return false; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: afterHeadIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.p = p; $f.s = s; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	copyAttributes = function(dst, src) {
		var _entry, _i, _i$1, _key, _key$1, _ref, _ref$1, _tuple, attr, dst, ok, src, t, t$1;
		if (src.Attr.$length === 0) {
			return;
		}
		attr = $makeMap($String.keyFor, []);
		_ref = dst.Attr;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			t = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
			_key = t.Key; (attr || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: t.Val };
			_i++;
		}
		_ref$1 = src.Attr;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			t$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), Attribute);
			_tuple = (_entry = attr[$String.keyFor(t$1.Key)], _entry !== undefined ? [_entry.v, true] : ["", false]);
			ok = _tuple[1];
			if (!ok) {
				dst.Attr = $append(dst.Attr, t$1);
				_key$1 = t$1.Key; (attr || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: t$1.Val };
			}
			_i$1++;
		}
	};
	inBodyIM = function(p) {
		var _1, _2, _3, _4, _5, _6, _7, _8, _9, _i, _i$1, _i$2, _r, _r$1, _r$2, _r$3, _ref, _ref$1, _ref$2, _v, action, attr, body, body$1, d, e, i, i$1, i$2, i$3, i$4, n, n$1, n$2, node, node$1, node$2, p, prompt, t, t$1, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _6 = $f._6; _7 = $f._7; _8 = $f._8; _9 = $f._9; _i = $f._i; _i$1 = $f._i$1; _i$2 = $f._i$2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; _ref$1 = $f._ref$1; _ref$2 = $f._ref$2; _v = $f._v; action = $f.action; attr = $f.attr; body = $f.body; body$1 = $f.body$1; d = $f.d; e = $f.e; i = $f.i; i$1 = $f.i$1; i$2 = $f.i$2; i$3 = $f.i$3; i$4 = $f.i$4; n = $f.n; n$1 = $f.n$1; n$2 = $f.n$2; node = $f.node; node$1 = $f.node$1; node$2 = $f.node$2; p = $f.p; prompt = $f.prompt; t = $f.t; t$1 = $f.t$1; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (0)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (1)) { */ case 2:
				d = p.tok.Data;
				n = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top();
				_2 = n.DataAtom;
				if ((_2 === (290819)) || (_2 === (305415))) {
					if (n.FirstChild === ptrType.nil) {
						if (!(d === "") && (d.charCodeAt(0) === 13)) {
							d = $substring(d, 1);
						}
						if (!(d === "") && (d.charCodeAt(0) === 10)) {
							d = $substring(d, 1);
						}
					}
				}
				d = strings.Replace(d, "\x00", "", -1);
				if (d === "") {
					$s = -1; return true;
				}
				p.reconstructActiveFormattingElements();
				p.addText(d);
				if (!(p.framesetOK)) { _v = false; $s = 10; continue s; }
				_r = strings.TrimLeft(d, " \t\r\n\f"); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_v = !(_r === ""); case 10:
				/* */ if (_v) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if (_v) { */ case 8:
					p.framesetOK = false;
				/* } */ case 9:
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (22020)) { $s = 13; continue; }
					/* */ if ((_3 === (15108)) || (_3 === (15112)) || (_3 === (89607)) || (_3 === (120583)) || (_3 === (95236)) || (_3 === (309252)) || (_3 === (35080)) || (_3 === (137222)) || (_3 === (458501)) || (_3 === (463880)) || (_3 === (69637))) { $s = 14; continue; }
					/* */ if (_3 === (10244)) { $s = 15; continue; }
					/* */ if (_3 === (35592)) { $s = 16; continue; }
					/* */ if ((_3 === (455431)) || (_3 === (261127)) || (_3 === (67333)) || (_3 === (100106)) || (_3 === (139270)) || (_3 === (29191)) || (_3 === (37635)) || (_3 === (92931)) || (_3 === (386562)) || (_3 === (140808)) || (_3 === (142858)) || (_3 === (149510)) || (_3 === (62982)) || (_3 === (209158)) || (_3 === (182790)) || (_3 === (231172)) || (_3 === (4867)) || (_3 === (79618)) || (_3 === (3073)) || (_3 === (354311)) || (_3 === (459783)) || (_3 === (42754))) { $s = 17; continue; }
					/* */ if ((_3 === (89090)) || (_3 === (187906)) || (_3 === (199938)) || (_3 === (214274)) || (_3 === (216834)) || (_3 === (412930))) { $s = 18; continue; }
					/* */ if ((_3 === (290819)) || (_3 === (305415))) { $s = 19; continue; }
					/* */ if (_3 === (159236)) { $s = 20; continue; }
					/* */ if (_3 === (45570)) { $s = 21; continue; }
					/* */ if ((_3 === (186114)) || (_3 === (412418))) { $s = 22; continue; }
					/* */ if (_3 === (111113)) { $s = 23; continue; }
					/* */ if (_3 === (102662)) { $s = 24; continue; }
					/* */ if (_3 === (1)) { $s = 25; continue; }
					/* */ if ((_3 === (257)) || (_3 === (94211)) || (_3 === (378116)) || (_3 === (28162)) || (_3 === (16132)) || (_3 === (1537)) || (_3 === (9473)) || (_3 === (132613)) || (_3 === (53766)) || (_3 === (449798)) || (_3 === (26626)) || (_3 === (2817))) { $s = 26; continue; }
					/* */ if (_3 === (14084)) { $s = 27; continue; }
					/* */ if ((_3 === (203014)) || (_3 === (206599)) || (_3 === (157702))) { $s = 28; continue; }
					/* */ if (_3 === (365829)) { $s = 29; continue; }
					/* */ if ((_3 === (218628)) || (_3 === (514)) || (_3 === (28165)) || (_3 === (198403)) || (_3 === (281349)) || (_3 === (12806)) || (_3 === (359427))) { $s = 30; continue; }
					/* */ if ((_3 === (3077)) || (_3 === (227334)) || (_3 === (113157))) { $s = 31; continue; }
					/* */ if (_3 === (87810)) { $s = 32; continue; }
					/* */ if (_3 === (197125)) { $s = 33; continue; }
					/* */ if (_3 === (200455)) { $s = 34; continue; }
					/* */ if (_3 === (217608)) { $s = 35; continue; }
					/* */ if (_3 === (77571)) { $s = 36; continue; }
					/* */ if (_3 === (195590)) { $s = 37; continue; }
					/* */ if ((_3 === (27655)) || (_3 === (136712))) { $s = 38; continue; }
					/* */ if (_3 === (408582)) { $s = 39; continue; }
					/* */ if ((_3 === (24328)) || (_3 === (451334))) { $s = 40; continue; }
					/* */ if ((_3 === (14850)) || (_3 === (104963))) { $s = 41; continue; }
					/* */ if ((_3 === (146434)) || (_3 === (104962))) { $s = 42; continue; }
					/* */ if ((_3 === (208388)) || (_3 === (462339))) { $s = 43; continue; }
					/* */ if ((_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (35589)) || (_3 === (209156)) || (_3 === (9989)) || (_3 === (37378)) || (_3 === (62725)) || (_3 === (87554)) || (_3 === (208901)) || (_3 === (52226))) { $s = 44; continue; }
					/* */ $s = 45; continue;
					/* if (_3 === (22020)) { */ case 13:
						if ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							$s = -1; return true;
						}
						copyAttributes((x = p.oe, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])), $clone(p.tok, Token));
						$s = 46; continue;
					/* } else if ((_3 === (15108)) || (_3 === (15112)) || (_3 === (89607)) || (_3 === (120583)) || (_3 === (95236)) || (_3 === (309252)) || (_3 === (35080)) || (_3 === (137222)) || (_3 === (458501)) || (_3 === (463880)) || (_3 === (69637))) { */ case 14:
						_r$1 = inHeadIM(p); /* */ $s = 47; case 47: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_3 === (10244)) { */ case 15:
						if ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							$s = -1; return true;
						}
						if (p.oe.$length >= 2) {
							body = (x$1 = p.oe, (1 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 1]));
							if ((body.Type === 3) && (body.DataAtom === 10244)) {
								p.framesetOK = false;
								copyAttributes(body, $clone(p.tok, Token));
							}
						}
						$s = 46; continue;
					/* } else if (_3 === (35592)) { */ case 16:
						if (!p.framesetOK || p.oe.$length < 2 || !(((x$2 = p.oe, (1 >= x$2.$length ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + 1])).DataAtom === 10244))) {
							$s = -1; return true;
						}
						body$1 = (x$3 = p.oe, (1 >= x$3.$length ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + 1]));
						if (!(body$1.Parent === ptrType.nil)) {
							body$1.Parent.RemoveChild(body$1);
						}
						p.oe = $subslice(p.oe, 0, 1);
						p.addElement();
						p.im = inFramesetIM;
						$s = -1; return true;
					/* } else if ((_3 === (455431)) || (_3 === (261127)) || (_3 === (67333)) || (_3 === (100106)) || (_3 === (139270)) || (_3 === (29191)) || (_3 === (37635)) || (_3 === (92931)) || (_3 === (386562)) || (_3 === (140808)) || (_3 === (142858)) || (_3 === (149510)) || (_3 === (62982)) || (_3 === (209158)) || (_3 === (182790)) || (_3 === (231172)) || (_3 === (4867)) || (_3 === (79618)) || (_3 === (3073)) || (_3 === (354311)) || (_3 === (459783)) || (_3 === (42754))) { */ case 17:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (89090)) || (_3 === (187906)) || (_3 === (199938)) || (_3 === (214274)) || (_3 === (216834)) || (_3 === (412930))) { */ case 18:
						p.popUntil(2, new sliceType$2([3073]));
						n$1 = p.top();
						_4 = n$1.DataAtom;
						if ((_4 === (89090)) || (_4 === (187906)) || (_4 === (199938)) || (_4 === (214274)) || (_4 === (216834)) || (_4 === (412930))) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (290819)) || (_3 === (305415))) { */ case 19:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if (_3 === (159236)) { */ case 20:
						if (!(p.form === ptrType.nil) && !(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							$s = -1; return true;
						}
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						if (!(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							p.form = p.top();
						}
						$s = 46; continue;
					/* } else if (_3 === (45570)) { */ case 21:
						p.framesetOK = false;
						i = p.oe.$length - 1 >> 0;
						/* while (true) { */ case 48:
							/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 49; continue; }
							node = (x$4 = p.oe, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i]));
							_5 = node.DataAtom;
							if (_5 === (45570)) {
								p.oe = $subslice(p.oe, 0, i);
							} else if ((_5 === (455431)) || (_5 === (92931)) || (_5 === (3073))) {
								i = i - (1) >> 0;
								/* continue; */ $s = 48; continue;
							} else if (!isSpecialElement(node)) {
								i = i - (1) >> 0;
								/* continue; */ $s = 48; continue;
							}
							/* break; */ $s = 49; continue;
						/* } */ $s = 48; continue; case 49:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (186114)) || (_3 === (412418))) { */ case 22:
						p.framesetOK = false;
						i$1 = p.oe.$length - 1 >> 0;
						/* while (true) { */ case 50:
							/* if (!(i$1 >= 0)) { break; } */ if(!(i$1 >= 0)) { $s = 51; continue; }
							node$1 = (x$5 = p.oe, ((i$1 < 0 || i$1 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i$1]));
							_6 = node$1.DataAtom;
							if ((_6 === (186114)) || (_6 === (412418))) {
								p.oe = $subslice(p.oe, 0, i$1);
							} else if ((_6 === (455431)) || (_6 === (92931)) || (_6 === (3073))) {
								i$1 = i$1 - (1) >> 0;
								/* continue; */ $s = 50; continue;
							} else if (!isSpecialElement(node$1)) {
								i$1 = i$1 - (1) >> 0;
								/* continue; */ $s = 50; continue;
							}
							/* break; */ $s = 51; continue;
						/* } */ $s = 50; continue; case 51:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						$s = 46; continue;
					/* } else if (_3 === (111113)) { */ case 23:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						$s = 46; continue;
					/* } else if (_3 === (102662)) { */ case 24:
						p.popUntil(0, new sliceType$2([102662]));
						p.reconstructActiveFormattingElements();
						p.addElement();
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if (_3 === (1)) { */ case 25:
						i$2 = p.afe.$length - 1 >> 0;
						while (true) {
							if (!(i$2 >= 0 && !(((x$6 = p.afe, ((i$2 < 0 || i$2 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i$2])).Type === 6)))) { break; }
							n$2 = (x$7 = p.afe, ((i$2 < 0 || i$2 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + i$2]));
							if ((n$2.Type === 3) && (n$2.DataAtom === 1)) {
								p.inBodyEndTagFormatting(1, "a");
								(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).remove(n$2);
								(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(n$2);
								break;
							}
							i$2 = i$2 - (1) >> 0;
						}
						p.reconstructActiveFormattingElements();
						p.addFormattingElement();
						$s = 46; continue;
					/* } else if ((_3 === (257)) || (_3 === (94211)) || (_3 === (378116)) || (_3 === (28162)) || (_3 === (16132)) || (_3 === (1537)) || (_3 === (9473)) || (_3 === (132613)) || (_3 === (53766)) || (_3 === (449798)) || (_3 === (26626)) || (_3 === (2817))) { */ case 26:
						p.reconstructActiveFormattingElements();
						p.addFormattingElement();
						$s = 46; continue;
					/* } else if (_3 === (14084)) { */ case 27:
						p.reconstructActiveFormattingElements();
						if (p.elementInScope(0, new sliceType$2([14084]))) {
							p.inBodyEndTagFormatting(14084, "nobr");
							p.reconstructActiveFormattingElements();
						}
						p.addFormattingElement();
						$s = 46; continue;
					/* } else if ((_3 === (203014)) || (_3 === (206599)) || (_3 === (157702))) { */ case 28:
						p.reconstructActiveFormattingElements();
						p.addElement();
						p.afe = $append(p.afe, scopeMarker);
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if (_3 === (365829)) { */ case 29:
						if (!p.quirks) {
							p.popUntil(2, new sliceType$2([3073]));
						}
						p.addElement();
						p.framesetOK = false;
						p.im = inTableIM;
						$s = -1; return true;
					/* } else if ((_3 === (218628)) || (_3 === (514)) || (_3 === (28165)) || (_3 === (198403)) || (_3 === (281349)) || (_3 === (12806)) || (_3 === (359427))) { */ case 30:
						p.reconstructActiveFormattingElements();
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						/* */ if (p.tok.DataAtom === 281349) { $s = 52; continue; }
						/* */ $s = 53; continue;
						/* if (p.tok.DataAtom === 281349) { */ case 52:
							_ref = p.tok.Attr;
							_i = 0;
							/* while (true) { */ case 54:
								/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 55; continue; }
								t = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
								/* */ if (t.Key === "type") { $s = 56; continue; }
								/* */ $s = 57; continue;
								/* if (t.Key === "type") { */ case 56:
									_r$2 = strings.ToLower(t.Val); /* */ $s = 60; case 60: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
									/* */ if (_r$2 === "hidden") { $s = 58; continue; }
									/* */ $s = 59; continue;
									/* if (_r$2 === "hidden") { */ case 58:
										$s = -1; return true;
									/* } */ case 59:
								/* } */ case 57:
								_i++;
							/* } */ $s = 54; continue; case 55:
						/* } */ case 53:
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if ((_3 === (3077)) || (_3 === (227334)) || (_3 === (113157))) { */ case 31:
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						$s = 46; continue;
					/* } else if (_3 === (87810)) { */ case 32:
						p.popUntil(2, new sliceType$2([3073]));
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						p.framesetOK = false;
						$s = 46; continue;
					/* } else if (_3 === (197125)) { */ case 33:
						p.tok.DataAtom = 198403;
						p.tok.Data = new atom.Atom(198403).String();
						$s = -1; return false;
					/* } else if (_3 === (200455)) { */ case 34:
						if (!(p.form === ptrType.nil)) {
							$s = -1; return true;
						}
						action = "";
						prompt = "This is a searchable index. Enter search keywords: ";
						attr = new sliceType$1([new Attribute.ptr("", "name", "isindex")]);
						_ref$1 = p.tok.Attr;
						_i$1 = 0;
						while (true) {
							if (!(_i$1 < _ref$1.$length)) { break; }
							t$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), Attribute);
							_7 = t$1.Key;
							if (_7 === ("action")) {
								action = t$1.Val;
							} else if (_7 === ("name")) {
							} else if (_7 === ("prompt")) {
								prompt = t$1.Val;
							} else {
								attr = $append(attr, t$1);
							}
							_i$1++;
						}
						p.acknowledgeSelfClosingTag();
						p.popUntil(2, new sliceType$2([3073]));
						$r = p.parseImpliedToken(2, 159236, new atom.Atom(159236).String()); /* */ $s = 61; case 61: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						if (p.form === ptrType.nil) {
							$s = -1; return true;
						}
						if (!(action === "")) {
							p.form.Attr = new sliceType$1([new Attribute.ptr("", "action", action)]);
						}
						$r = p.parseImpliedToken(2, 87810, new atom.Atom(87810).String()); /* */ $s = 62; case 62: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$r = p.parseImpliedToken(2, 22789, new atom.Atom(22789).String()); /* */ $s = 63; case 63: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						p.addText(prompt);
						p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, 281349, new atom.Atom(281349).String(), "", attr));
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						$r = p.parseImpliedToken(3, 22789, new atom.Atom(22789).String()); /* */ $s = 64; case 64: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$r = p.parseImpliedToken(2, 87810, new atom.Atom(87810).String()); /* */ $s = 65; case 65: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$r = p.parseImpliedToken(3, 159236, new atom.Atom(159236).String()); /* */ $s = 66; case 66: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = 46; continue;
					/* } else if (_3 === (217608)) { */ case 35:
						p.addElement();
						p.setOriginalIM();
						p.framesetOK = false;
						p.im = textIM;
						$s = 46; continue;
					/* } else if (_3 === (77571)) { */ case 36:
						p.popUntil(2, new sliceType$2([3073]));
						p.reconstructActiveFormattingElements();
						p.framesetOK = false;
						p.addElement();
						p.setOriginalIM();
						p.im = textIM;
						$s = 46; continue;
					/* } else if (_3 === (195590)) { */ case 37:
						p.framesetOK = false;
						p.addElement();
						p.setOriginalIM();
						p.im = textIM;
						$s = 46; continue;
					/* } else if ((_3 === (27655)) || (_3 === (136712))) { */ case 38:
						p.addElement();
						p.setOriginalIM();
						p.im = textIM;
						$s = 46; continue;
					/* } else if (_3 === (408582)) { */ case 39:
						p.reconstructActiveFormattingElements();
						p.addElement();
						p.framesetOK = false;
						p.im = inSelectIM;
						$s = -1; return true;
					/* } else if ((_3 === (24328)) || (_3 === (451334))) { */ case 40:
						if (p.top().DataAtom === 451334) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						p.reconstructActiveFormattingElements();
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (14850)) || (_3 === (104963))) { */ case 41:
						if (p.elementInScope(0, new sliceType$2([64260]))) {
							p.generateImpliedEndTags(new sliceType([]));
						}
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (146434)) || (_3 === (104962))) { */ case 42:
						if (p.elementInScope(0, new sliceType$2([64260]))) {
							p.generateImpliedEndTags(new sliceType(["rtc"]));
						}
						p.addElement();
						$s = 46; continue;
					/* } else if ((_3 === (208388)) || (_3 === (462339))) { */ case 43:
						p.reconstructActiveFormattingElements();
						if (p.tok.DataAtom === 208388) {
							adjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments);
						} else {
							adjustAttributeNames(p.tok.Attr, svgAttributeAdjustments);
						}
						adjustForeignAttributes(p.tok.Attr);
						p.addElement();
						p.top().Namespace = p.tok.Data;
						if (p.hasSelfClosingToken) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
							p.acknowledgeSelfClosingTag();
						}
						$s = -1; return true;
					/* } else if ((_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (35589)) || (_3 === (209156)) || (_3 === (9989)) || (_3 === (37378)) || (_3 === (62725)) || (_3 === (87554)) || (_3 === (208901)) || (_3 === (52226))) { */ case 44:
						$s = 46; continue;
					/* } else { */ case 45:
						p.reconstructActiveFormattingElements();
						p.addElement();
					/* } */ case 46:
				case 12:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_8 = p.tok.DataAtom;
					/* */ if (_8 === (10244)) { $s = 68; continue; }
					/* */ if (_8 === (22020)) { $s = 69; continue; }
					/* */ if ((_8 === (455431)) || (_8 === (261127)) || (_8 === (67333)) || (_8 === (100106)) || (_8 === (102662)) || (_8 === (139270)) || (_8 === (29191)) || (_8 === (37635)) || (_8 === (92931)) || (_8 === (386562)) || (_8 === (140808)) || (_8 === (142858)) || (_8 === (149510)) || (_8 === (62982)) || (_8 === (209158)) || (_8 === (182790)) || (_8 === (305415)) || (_8 === (231172)) || (_8 === (4867)) || (_8 === (79618)) || (_8 === (290819)) || (_8 === (354311)) || (_8 === (459783)) || (_8 === (42754))) { $s = 70; continue; }
					/* */ if (_8 === (159236)) { $s = 71; continue; }
					/* */ if (_8 === (3073)) { $s = 72; continue; }
					/* */ if (_8 === (45570)) { $s = 73; continue; }
					/* */ if ((_8 === (186114)) || (_8 === (412418))) { $s = 74; continue; }
					/* */ if ((_8 === (89090)) || (_8 === (187906)) || (_8 === (199938)) || (_8 === (214274)) || (_8 === (216834)) || (_8 === (412930))) { $s = 75; continue; }
					/* */ if ((_8 === (1)) || (_8 === (257)) || (_8 === (94211)) || (_8 === (378116)) || (_8 === (28162)) || (_8 === (16132)) || (_8 === (1537)) || (_8 === (14084)) || (_8 === (9473)) || (_8 === (132613)) || (_8 === (53766)) || (_8 === (449798)) || (_8 === (26626)) || (_8 === (2817))) { $s = 76; continue; }
					/* */ if ((_8 === (203014)) || (_8 === (206599)) || (_8 === (157702))) { $s = 77; continue; }
					/* */ if (_8 === (514)) { $s = 78; continue; }
					/* */ if (_8 === (463880)) { $s = 79; continue; }
					/* */ $s = 80; continue;
					/* if (_8 === (10244)) { */ case 68:
						if (p.elementInScope(0, new sliceType$2([10244]))) {
							p.im = afterBodyIM;
						}
						$s = 81; continue;
					/* } else if (_8 === (22020)) { */ case 69:
						/* */ if (p.elementInScope(0, new sliceType$2([10244]))) { $s = 82; continue; }
						/* */ $s = 83; continue;
						/* if (p.elementInScope(0, new sliceType$2([10244]))) { */ case 82:
							$r = p.parseImpliedToken(3, 10244, new atom.Atom(10244).String()); /* */ $s = 84; case 84: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return false;
						/* } */ case 83:
						$s = -1; return true;
					/* } else if ((_8 === (455431)) || (_8 === (261127)) || (_8 === (67333)) || (_8 === (100106)) || (_8 === (102662)) || (_8 === (139270)) || (_8 === (29191)) || (_8 === (37635)) || (_8 === (92931)) || (_8 === (386562)) || (_8 === (140808)) || (_8 === (142858)) || (_8 === (149510)) || (_8 === (62982)) || (_8 === (209158)) || (_8 === (182790)) || (_8 === (305415)) || (_8 === (231172)) || (_8 === (4867)) || (_8 === (79618)) || (_8 === (290819)) || (_8 === (354311)) || (_8 === (459783)) || (_8 === (42754))) { */ case 70:
						p.popUntil(0, new sliceType$2([p.tok.DataAtom]));
						$s = 81; continue;
					/* } else if (_8 === (159236)) { */ case 71:
						if ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
							i$3 = p.indexOfElementInScope(0, new sliceType$2([159236]));
							if (i$3 === -1) {
								$s = -1; return true;
							}
							p.generateImpliedEndTags(new sliceType([]));
							if (!(((x$8 = p.oe, ((i$3 < 0 || i$3 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + i$3])).DataAtom === 159236))) {
								$s = -1; return true;
							}
							p.popUntil(0, new sliceType$2([159236]));
						} else {
							node$2 = p.form;
							p.form = ptrType.nil;
							i$4 = p.indexOfElementInScope(0, new sliceType$2([159236]));
							if (node$2 === ptrType.nil || (i$4 === -1) || !((x$9 = p.oe, ((i$4 < 0 || i$4 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + i$4])) === node$2)) {
								$s = -1; return true;
							}
							p.generateImpliedEndTags(new sliceType([]));
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).remove(node$2);
						}
						$s = 81; continue;
					/* } else if (_8 === (3073)) { */ case 72:
						/* */ if (!p.elementInScope(2, new sliceType$2([3073]))) { $s = 85; continue; }
						/* */ $s = 86; continue;
						/* if (!p.elementInScope(2, new sliceType$2([3073]))) { */ case 85:
							$r = p.parseImpliedToken(2, 3073, new atom.Atom(3073).String()); /* */ $s = 87; case 87: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						/* } */ case 86:
						p.popUntil(2, new sliceType$2([3073]));
						$s = 81; continue;
					/* } else if (_8 === (45570)) { */ case 73:
						p.popUntil(1, new sliceType$2([45570]));
						$s = 81; continue;
					/* } else if ((_8 === (186114)) || (_8 === (412418))) { */ case 74:
						p.popUntil(0, new sliceType$2([p.tok.DataAtom]));
						$s = 81; continue;
					/* } else if ((_8 === (89090)) || (_8 === (187906)) || (_8 === (199938)) || (_8 === (214274)) || (_8 === (216834)) || (_8 === (412930))) { */ case 75:
						p.popUntil(0, new sliceType$2([89090, 187906, 199938, 214274, 216834, 412930]));
						$s = 81; continue;
					/* } else if ((_8 === (1)) || (_8 === (257)) || (_8 === (94211)) || (_8 === (378116)) || (_8 === (28162)) || (_8 === (16132)) || (_8 === (1537)) || (_8 === (14084)) || (_8 === (9473)) || (_8 === (132613)) || (_8 === (53766)) || (_8 === (449798)) || (_8 === (26626)) || (_8 === (2817))) { */ case 76:
						p.inBodyEndTagFormatting(p.tok.DataAtom, p.tok.Data);
						$s = 81; continue;
					/* } else if ((_8 === (203014)) || (_8 === (206599)) || (_8 === (157702))) { */ case 77:
						if (p.popUntil(0, new sliceType$2([p.tok.DataAtom]))) {
							p.clearActiveFormattingElements();
						}
						$s = 81; continue;
					/* } else if (_8 === (514)) { */ case 78:
						p.tok.Type = 2;
						$s = -1; return false;
					/* } else if (_8 === (463880)) { */ case 79:
						_r$3 = inHeadIM(p); /* */ $s = 88; case 88: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } else { */ case 80:
						p.inBodyEndTagOther(p.tok.DataAtom, p.tok.Data);
					/* } */ case 81:
				case 67:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 7; continue;
			/* } else if (_1 === (0)) { */ case 6:
				if (p.templateStack.$length > 0) {
					p.im = inTemplateIM;
					$s = -1; return false;
				} else {
					_ref$2 = p.oe;
					_i$2 = 0;
					while (true) {
						if (!(_i$2 < _ref$2.$length)) { break; }
						e = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
						_9 = e.DataAtom;
						if ((_9 === (186114)) || (_9 === (412418)) || (_9 === (45570)) || (_9 === (24328)) || (_9 === (451334)) || (_9 === (3073)) || (_9 === (14850)) || (_9 === (146434)) || (_9 === (104962)) || (_9 === (104963)) || (_9 === (9989)) || (_9 === (37378)) || (_9 === (62725)) || (_9 === (87554)) || (_9 === (208901)) || (_9 === (52226)) || (_9 === (10244)) || (_9 === (22020))) {
						} else {
							$s = -1; return true;
						}
						_i$2++;
					}
				}
			/* } */ case 7:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inBodyIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._6 = _6; $f._7 = _7; $f._8 = _8; $f._9 = _9; $f._i = _i; $f._i$1 = _i$1; $f._i$2 = _i$2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f._ref$1 = _ref$1; $f._ref$2 = _ref$2; $f._v = _v; $f.action = action; $f.attr = attr; $f.body = body; $f.body$1 = body$1; $f.d = d; $f.e = e; $f.i = i; $f.i$1 = i$1; $f.i$2 = i$2; $f.i$3 = i$3; $f.i$4 = i$4; $f.n = n; $f.n$1 = n$1; $f.n$2 = n$2; $f.node = node; $f.node$1 = node$1; $f.node$2 = node$2; $f.p = p; $f.prompt = prompt; $f.t = t; $f.t$1 = t$1; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.ptr.prototype.inBodyEndTagFormatting = function(tagAtom, tagName) {
		var _1, _i, _ref, bookmark, clone, clone$1, commonAncestor, e, e$1, feIndex, formattingElement, furthestBlock, i, j, j$1, lastNode, node, oldLoc, p, tagAtom, tagName, x, x$1, x$10, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		p = this;
		i = 0;
		while (true) {
			if (!(i < 8)) { break; }
			formattingElement = ptrType.nil;
			j = p.afe.$length - 1 >> 0;
			while (true) {
				if (!(j >= 0)) { break; }
				if ((x = p.afe, ((j < 0 || j >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + j])).Type === 6) {
					break;
				}
				if ((x$1 = p.afe, ((j < 0 || j >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + j])).DataAtom === tagAtom) {
					formattingElement = (x$2 = p.afe, ((j < 0 || j >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + j]));
					break;
				}
				j = j - (1) >> 0;
			}
			if (formattingElement === ptrType.nil) {
				p.inBodyEndTagOther(tagAtom, tagName);
				return;
			}
			feIndex = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(formattingElement);
			if (feIndex === -1) {
				(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(formattingElement);
				return;
			}
			if (!p.elementInScope(0, new sliceType$2([tagAtom]))) {
				return;
			}
			furthestBlock = ptrType.nil;
			_ref = $subslice(p.oe, feIndex);
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				e = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (isSpecialElement(e)) {
					furthestBlock = e;
					break;
				}
				_i++;
			}
			if (furthestBlock === ptrType.nil) {
				e$1 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
				while (true) {
					if (!(!(e$1 === formattingElement))) { break; }
					e$1 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
				}
				(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(e$1);
				return;
			}
			commonAncestor = (x$3 = p.oe, x$4 = feIndex - 1 >> 0, ((x$4 < 0 || x$4 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + x$4]));
			bookmark = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(formattingElement);
			lastNode = furthestBlock;
			node = furthestBlock;
			x$5 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(node);
			j$1 = 0;
			while (true) {
				if (!(j$1 < 3)) { break; }
				x$5 = x$5 - (1) >> 0;
				node = (x$6 = p.oe, ((x$5 < 0 || x$5 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$5]));
				if ((p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(node) === -1) {
					(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).remove(node);
					j$1 = j$1 + (1) >> 0;
					continue;
				}
				if (node === formattingElement) {
					break;
				}
				clone = node.clone();
				(x$7 = p.afe, x$8 = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(node), ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8] = clone));
				(x$9 = p.oe, x$10 = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(node), ((x$10 < 0 || x$10 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + x$10] = clone));
				node = clone;
				if (lastNode === furthestBlock) {
					bookmark = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(node) + 1 >> 0;
				}
				if (!(lastNode.Parent === ptrType.nil)) {
					lastNode.Parent.RemoveChild(lastNode);
				}
				node.AppendChild(lastNode);
				lastNode = node;
				j$1 = j$1 + (1) >> 0;
			}
			if (!(lastNode.Parent === ptrType.nil)) {
				lastNode.Parent.RemoveChild(lastNode);
			}
			_1 = commonAncestor.DataAtom;
			if ((_1 === (365829)) || (_1 === (9989)) || (_1 === (62725)) || (_1 === (208901)) || (_1 === (52226))) {
				p.fosterParent(lastNode);
			} else {
				commonAncestor.AppendChild(lastNode);
			}
			clone$1 = formattingElement.clone();
			reparentChildren(clone$1, furthestBlock);
			furthestBlock.AppendChild(clone$1);
			oldLoc = (p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).index(formattingElement);
			if (!((oldLoc === -1)) && oldLoc < bookmark) {
				bookmark = bookmark - (1) >> 0;
			}
			(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).remove(formattingElement);
			(p.$ptr_afe || (p.$ptr_afe = new ptrType$1(function() { return this.$target.afe; }, function($v) { this.$target.afe = $v; }, p))).insert(bookmark, clone$1);
			(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).remove(formattingElement);
			(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).insert((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).index(furthestBlock) + 1 >> 0, clone$1);
			i = i + (1) >> 0;
		}
	};
	parser.prototype.inBodyEndTagFormatting = function(tagAtom, tagName) { return this.$val.inBodyEndTagFormatting(tagAtom, tagName); };
	parser.ptr.prototype.inBodyEndTagOther = function(tagAtom, tagName) {
		var i, p, tagAtom, tagName, x, x$1, x$2;
		p = this;
		i = p.oe.$length - 1 >> 0;
		while (true) {
			if (!(i >= 0)) { break; }
			if ((((x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom === tagAtom)) && ((!((tagAtom === 0))) || ((x$1 = p.oe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).Data === tagName))) {
				p.oe = $subslice(p.oe, 0, i);
				break;
			}
			if (isSpecialElement((x$2 = p.oe, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i])))) {
				break;
			}
			i = i - (1) >> 0;
		}
	};
	parser.prototype.inBodyEndTagOther = function(tagAtom, tagName) { return this.$val.inBodyEndTagOther(tagAtom, tagName); };
	textIM = function(p) {
		var _1, d, n, p;
		_1 = p.tok.Type;
		if (_1 === (0)) {
			(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
		} else if (_1 === (1)) {
			d = p.tok.Data;
			n = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top();
			if ((n.DataAtom === 217608) && n.FirstChild === ptrType.nil) {
				if (!(d === "") && (d.charCodeAt(0) === 13)) {
					d = $substring(d, 1);
				}
				if (!(d === "") && (d.charCodeAt(0) === 10)) {
					d = $substring(d, 1);
				}
			}
			if (d === "") {
				return true;
			}
			p.addText(d);
			return true;
		} else if (_1 === (3)) {
			(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
		}
		p.im = p.originalIM;
		p.originalIM = $throwNilPointerError;
		return p.tok.Type === 3;
	};
	inTableIM = function(p) {
		var _1, _2, _3, _4, _5, _i, _r, _r$1, _r$2, _r$3, _r$4, _r$5, _ref, _v, p, t, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _ref = $f._ref; _v = $f._v; p = $f.p; t = $f.t; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		p = [p];
			_1 = p[0].tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ if (_1 === (0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (1)) { */ case 2:
				p[0].tok.Data = strings.Replace(p[0].tok.Data, "\x00", "", -1);
					_2 = (p[0].$ptr_oe || (p[0].$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p[0]))).top().DataAtom;
					/* */ if ((_2 === (365829)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226))) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if ((_2 === (365829)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226))) { */ case 10:
						_r = strings.Trim(p[0].tok.Data, " \t\r\n\f"); /* */ $s = 14; case 14: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						/* */ if (_r === "") { $s = 12; continue; }
						/* */ $s = 13; continue;
						/* if (_r === "") { */ case 12:
							p[0].addText(p[0].tok.Data);
							$s = -1; return true;
						/* } */ case 13:
					/* } */ case 11:
				case 9:
				$s = 8; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_3 = p[0].tok.DataAtom;
					/* */ if (_3 === (143623)) { $s = 16; continue; }
					/* */ if (_3 === (109320)) { $s = 17; continue; }
					/* */ if (_3 === (109315)) { $s = 18; continue; }
					/* */ if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) { $s = 19; continue; }
					/* */ if ((_3 === (37378)) || (_3 === (87554)) || (_3 === (52226))) { $s = 20; continue; }
					/* */ if (_3 === (365829)) { $s = 21; continue; }
					/* */ if ((_3 === (458501)) || (_3 === (137222)) || (_3 === (463880))) { $s = 22; continue; }
					/* */ if (_3 === (281349)) { $s = 23; continue; }
					/* */ if (_3 === (159236)) { $s = 24; continue; }
					/* */ if (_3 === (408582)) { $s = 25; continue; }
					/* */ $s = 26; continue;
					/* if (_3 === (143623)) { */ case 16:
						p[0].clearStackToContext(3);
						p[0].afe = $append(p[0].afe, scopeMarker);
						p[0].addElement();
						p[0].im = inCaptionIM;
						$s = -1; return true;
					/* } else if (_3 === (109320)) { */ case 17:
						p[0].clearStackToContext(3);
						p[0].addElement();
						p[0].im = inColumnGroupIM;
						$s = -1; return true;
					/* } else if (_3 === (109315)) { */ case 18:
						$r = p[0].parseImpliedToken(2, 109320, new atom.Atom(109320).String()); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) { */ case 19:
						p[0].clearStackToContext(3);
						p[0].addElement();
						p[0].im = inTableBodyIM;
						$s = -1; return true;
					/* } else if ((_3 === (37378)) || (_3 === (87554)) || (_3 === (52226))) { */ case 20:
						$r = p[0].parseImpliedToken(2, 9989, new atom.Atom(9989).String()); /* */ $s = 28; case 28: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else if (_3 === (365829)) { */ case 21:
						if (p[0].popUntil(3, new sliceType$2([365829]))) {
							p[0].resetInsertionMode();
							$s = -1; return false;
						}
						$s = -1; return true;
					/* } else if ((_3 === (458501)) || (_3 === (137222)) || (_3 === (463880))) { */ case 22:
						_r$1 = inHeadIM(p[0]); /* */ $s = 29; case 29: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_3 === (281349)) { */ case 23:
						_ref = p[0].tok.Attr;
						_i = 0;
						/* while (true) { */ case 30:
							/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 31; continue; }
							t = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
							if (!(t.Key === "type")) { _v = false; $s = 34; continue s; }
							_r$2 = strings.ToLower(t.Val); /* */ $s = 35; case 35: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
							_v = _r$2 === "hidden"; case 34:
							/* */ if (_v) { $s = 32; continue; }
							/* */ $s = 33; continue;
							/* if (_v) { */ case 32:
								p[0].addElement();
								(p[0].$ptr_oe || (p[0].$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p[0]))).pop();
								$s = -1; return true;
							/* } */ case 33:
							_i++;
						/* } */ $s = 30; continue; case 31:
						$s = 26; continue;
					/* } else if (_3 === (159236)) { */ case 24:
						if ((p[0].$ptr_oe || (p[0].$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p[0]))).contains(463880) || !(p[0].form === ptrType.nil)) {
							$s = -1; return true;
						}
						p[0].addElement();
						p[0].form = (p[0].$ptr_oe || (p[0].$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p[0]))).pop();
						$s = 26; continue;
					/* } else if (_3 === (408582)) { */ case 25:
						p[0].reconstructActiveFormattingElements();
						_4 = p[0].top().DataAtom;
						if ((_4 === (365829)) || (_4 === (9989)) || (_4 === (62725)) || (_4 === (208901)) || (_4 === (52226))) {
							p[0].fosterParenting = true;
						}
						p[0].addElement();
						p[0].fosterParenting = false;
						p[0].framesetOK = false;
						p[0].im = inSelectInTableIM;
						$s = -1; return true;
					/* } */ case 26:
				case 15:
				$s = 8; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_5 = p[0].tok.DataAtom;
					/* */ if (_5 === (365829)) { $s = 37; continue; }
					/* */ if ((_5 === (10244)) || (_5 === (143623)) || (_5 === (109315)) || (_5 === (109320)) || (_5 === (22020)) || (_5 === (9989)) || (_5 === (37378)) || (_5 === (62725)) || (_5 === (87554)) || (_5 === (208901)) || (_5 === (52226))) { $s = 38; continue; }
					/* */ if (_5 === (463880)) { $s = 39; continue; }
					/* */ $s = 40; continue;
					/* if (_5 === (365829)) { */ case 37:
						if (p[0].popUntil(3, new sliceType$2([365829]))) {
							p[0].resetInsertionMode();
							$s = -1; return true;
						}
						$s = -1; return true;
					/* } else if ((_5 === (10244)) || (_5 === (143623)) || (_5 === (109315)) || (_5 === (109320)) || (_5 === (22020)) || (_5 === (9989)) || (_5 === (37378)) || (_5 === (62725)) || (_5 === (87554)) || (_5 === (208901)) || (_5 === (52226))) { */ case 38:
						$s = -1; return true;
					/* } else if (_5 === (463880)) { */ case 39:
						_r$3 = inHeadIM(p[0]); /* */ $s = 41; case 41: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } */ case 40:
				case 36:
				$s = 8; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p[0].addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p[0].tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } else if (_1 === (0)) { */ case 7:
				_r$4 = inBodyIM(p[0]); /* */ $s = 42; case 42: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$s = -1; return _r$4;
			/* } */ case 8:
		case 1:
		p[0].fosterParenting = true;
		$deferred.push([(function(p) { return function() {
			p[0].fosterParenting = false;
		}; })(p), []]);
		_r$5 = inBodyIM(p[0]); /* */ $s = 43; case 43: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		$s = -1; return _r$5;
		/* */ } return; } } catch(err) { $err = err; $s = -1; return false; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: inTableIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._ref = _ref; $f._v = _v; $f.p = p; $f.t = t; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	inCaptionIM = function(p) {
		var _1, _2, _3, _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_1 = p.tok.Type;
		if (_1 === (2)) {
			_2 = p.tok.DataAtom;
			if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (37378)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226))) {
				if (p.popUntil(3, new sliceType$2([143623]))) {
					p.clearActiveFormattingElements();
					p.im = inTableIM;
					$s = -1; return false;
				} else {
					$s = -1; return true;
				}
			} else if (_2 === (408582)) {
				p.reconstructActiveFormattingElements();
				p.addElement();
				p.framesetOK = false;
				p.im = inSelectInTableIM;
				$s = -1; return true;
			}
		} else if (_1 === (3)) {
			_3 = p.tok.DataAtom;
			if (_3 === (143623)) {
				if (p.popUntil(3, new sliceType$2([143623]))) {
					p.clearActiveFormattingElements();
					p.im = inTableIM;
				}
				$s = -1; return true;
			} else if (_3 === (365829)) {
				if (p.popUntil(3, new sliceType$2([143623]))) {
					p.clearActiveFormattingElements();
					p.im = inTableIM;
					$s = -1; return false;
				} else {
					$s = -1; return true;
				}
			} else if ((_3 === (10244)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020)) || (_3 === (9989)) || (_3 === (37378)) || (_3 === (62725)) || (_3 === (87554)) || (_3 === (208901)) || (_3 === (52226))) {
				$s = -1; return true;
			}
		}
		_r = inBodyIM(p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inCaptionIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inColumnGroupIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, _r$4, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (5)) { $s = 3; continue; }
			/* */ if (_1 === (6)) { $s = 4; continue; }
			/* */ if (_1 === (2)) { $s = 5; continue; }
			/* */ if (_1 === (3)) { $s = 6; continue; }
			/* */ if (_1 === (0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (1)) { */ case 2:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (s.length < p.tok.Data.length) {
					p.addText($substring(p.tok.Data, 0, (p.tok.Data.length - s.length >> 0)));
					if (s === "") {
						$s = -1; return true;
					}
					p.tok.Data = s;
				}
				$s = 8; continue;
			/* } else if (_1 === (5)) { */ case 3:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 4:
				$s = -1; return true;
			/* } else if (_1 === (2)) { */ case 5:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 11; continue; }
					/* */ if (_2 === (109315)) { $s = 12; continue; }
					/* */ if (_2 === (463880)) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if (_2 === (22020)) { */ case 11:
						_r$1 = inBodyIM(p); /* */ $s = 15; case 15: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_2 === (109315)) { */ case 12:
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						$s = -1; return true;
					/* } else if (_2 === (463880)) { */ case 13:
						_r$2 = inHeadIM(p); /* */ $s = 16; case 16: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 14:
				case 10:
				$s = 8; continue;
			/* } else if (_1 === (3)) { */ case 6:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (109320)) { $s = 18; continue; }
					/* */ if (_3 === (109315)) { $s = 19; continue; }
					/* */ if (_3 === (463880)) { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if (_3 === (109320)) { */ case 18:
						if ((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top().DataAtom === 109320) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
							p.im = inTableIM;
						}
						$s = -1; return true;
					/* } else if (_3 === (109315)) { */ case 19:
						$s = -1; return true;
					/* } else if (_3 === (463880)) { */ case 20:
						_r$3 = inHeadIM(p); /* */ $s = 22; case 22: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } */ case 21:
				case 17:
				$s = 8; continue;
			/* } else if (_1 === (0)) { */ case 7:
				_r$4 = inBodyIM(p); /* */ $s = 23; case 23: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$s = -1; return _r$4;
			/* } */ case 8:
		case 1:
		if (!(((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top().DataAtom === 109320))) {
			$s = -1; return true;
		}
		(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
		p.im = inTableIM;
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inColumnGroupIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	inTableBodyIM = function(p) {
		var _1, _2, _3, _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (2)) { $s = 2; continue; }
			/* */ if (_1 === (3)) { $s = 3; continue; }
			/* */ if (_1 === (5)) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_1 === (2)) { */ case 2:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (52226)) { $s = 7; continue; }
					/* */ if ((_2 === (37378)) || (_2 === (87554))) { $s = 8; continue; }
					/* */ if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901))) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (_2 === (52226)) { */ case 7:
						p.clearStackToContext(5);
						p.addElement();
						p.im = inRowIM;
						$s = -1; return true;
					/* } else if ((_2 === (37378)) || (_2 === (87554))) { */ case 8:
						$r = p.parseImpliedToken(2, 52226, new atom.Atom(52226).String()); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						$s = -1; return false;
					/* } else if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901))) { */ case 9:
						if (p.popUntil(3, new sliceType$2([9989, 208901, 62725]))) {
							p.im = inTableIM;
							$s = -1; return false;
						}
						$s = -1; return true;
					/* } */ case 10:
				case 6:
				$s = 5; continue;
			/* } else if (_1 === (3)) { */ case 3:
				_3 = p.tok.DataAtom;
				if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) {
					if (p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) {
						p.clearStackToContext(5);
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.im = inTableIM;
					}
					$s = -1; return true;
				} else if (_3 === (365829)) {
					if (p.popUntil(3, new sliceType$2([9989, 208901, 62725]))) {
						p.im = inTableIM;
						$s = -1; return false;
					}
					$s = -1; return true;
				} else if ((_3 === (10244)) || (_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020)) || (_3 === (37378)) || (_3 === (87554)) || (_3 === (52226))) {
					$s = -1; return true;
				}
				$s = 5; continue;
			/* } else if (_1 === (5)) { */ case 4:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } */ case 5:
		case 1:
		_r = inTableIM(p); /* */ $s = 12; case 12: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inTableBodyIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inRowIM = function(p) {
		var _1, _2, _3, _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (2)) { $s = 2; continue; }
			/* */ if (_1 === (3)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_1 === (2)) { */ case 2:
				_2 = p.tok.DataAtom;
				if ((_2 === (37378)) || (_2 === (87554))) {
					p.clearStackToContext(4);
					p.addElement();
					p.afe = $append(p.afe, scopeMarker);
					p.im = inCellIM;
					$s = -1; return true;
				} else if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226))) {
					if (p.popUntil(3, new sliceType$2([52226]))) {
						p.im = inTableBodyIM;
						$s = -1; return false;
					}
					$s = -1; return true;
				}
				$s = 4; continue;
			/* } else if (_1 === (3)) { */ case 3:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (52226)) { $s = 6; continue; }
					/* */ if (_3 === (365829)) { $s = 7; continue; }
					/* */ if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) { $s = 8; continue; }
					/* */ if ((_3 === (10244)) || (_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020)) || (_3 === (37378)) || (_3 === (87554))) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (_3 === (52226)) { */ case 6:
						if (p.popUntil(3, new sliceType$2([52226]))) {
							p.im = inTableBodyIM;
							$s = -1; return true;
						}
						$s = -1; return true;
					/* } else if (_3 === (365829)) { */ case 7:
						if (p.popUntil(3, new sliceType$2([52226]))) {
							p.im = inTableBodyIM;
							$s = -1; return false;
						}
						$s = -1; return true;
					/* } else if ((_3 === (9989)) || (_3 === (62725)) || (_3 === (208901))) { */ case 8:
						/* */ if (p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) { $s = 11; continue; }
						/* */ $s = 12; continue;
						/* if (p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) { */ case 11:
							$r = p.parseImpliedToken(3, 52226, new atom.Atom(52226).String()); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return false;
						/* } */ case 12:
						$s = -1; return true;
					/* } else if ((_3 === (10244)) || (_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020)) || (_3 === (37378)) || (_3 === (87554))) { */ case 9:
						$s = -1; return true;
					/* } */ case 10:
				case 5:
			/* } */ case 4:
		case 1:
		_r = inTableIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inRowIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inCellIM = function(p) {
		var _1, _2, _3, _r, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_1 = p.tok.Type;
		if (_1 === (2)) {
			_2 = p.tok.DataAtom;
			if ((_2 === (143623)) || (_2 === (109315)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (37378)) || (_2 === (62725)) || (_2 === (87554)) || (_2 === (208901)) || (_2 === (52226))) {
				if (p.popUntil(3, new sliceType$2([37378, 87554]))) {
					p.clearActiveFormattingElements();
					p.im = inRowIM;
					$s = -1; return false;
				}
				$s = -1; return true;
			} else if (_2 === (408582)) {
				p.reconstructActiveFormattingElements();
				p.addElement();
				p.framesetOK = false;
				p.im = inSelectInTableIM;
				$s = -1; return true;
			}
		} else if (_1 === (3)) {
			_3 = p.tok.DataAtom;
			if ((_3 === (37378)) || (_3 === (87554))) {
				if (!p.popUntil(3, new sliceType$2([p.tok.DataAtom]))) {
					$s = -1; return true;
				}
				p.clearActiveFormattingElements();
				p.im = inRowIM;
				$s = -1; return true;
			} else if ((_3 === (10244)) || (_3 === (143623)) || (_3 === (109315)) || (_3 === (109320)) || (_3 === (22020))) {
				$s = -1; return true;
			} else if ((_3 === (365829)) || (_3 === (9989)) || (_3 === (62725)) || (_3 === (208901)) || (_3 === (52226))) {
				if (!p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) {
					$s = -1; return true;
				}
				if (p.popUntil(3, new sliceType$2([37378, 87554]))) {
					p.clearActiveFormattingElements();
				}
				p.im = inRowIM;
				$s = -1; return false;
			}
		}
		_r = inBodyIM(p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inCellIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	inSelectIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, _r$3, i, p, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; i = $f.i; p = $f.p; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ if (_1 === (0)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (1)) { */ case 2:
				p.addText(strings.Replace(p.tok.Data, "\x00", "", -1));
				$s = 8; continue;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if (_2 === (22020)) { $s = 10; continue; }
					/* */ if (_2 === (451334)) { $s = 11; continue; }
					/* */ if (_2 === (24328)) { $s = 12; continue; }
					/* */ if (_2 === (408582)) { $s = 13; continue; }
					/* */ if ((_2 === (281349)) || (_2 === (12806)) || (_2 === (217608))) { $s = 14; continue; }
					/* */ if ((_2 === (137222)) || (_2 === (463880))) { $s = 15; continue; }
					/* */ $s = 16; continue;
					/* if (_2 === (22020)) { */ case 10:
						_r = inBodyIM(p); /* */ $s = 17; case 17: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						$s = -1; return _r;
					/* } else if (_2 === (451334)) { */ case 11:
						if (p.top().DataAtom === 451334) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						p.addElement();
						$s = 16; continue;
					/* } else if (_2 === (24328)) { */ case 12:
						if (p.top().DataAtom === 451334) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						if (p.top().DataAtom === 24328) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						p.addElement();
						$s = 16; continue;
					/* } else if (_2 === (408582)) { */ case 13:
						if (p.popUntil(6, new sliceType$2([408582]))) {
							p.resetInsertionMode();
						} else {
							$s = -1; return true;
						}
						$s = 16; continue;
					/* } else if ((_2 === (281349)) || (_2 === (12806)) || (_2 === (217608))) { */ case 14:
						/* */ if (p.elementInScope(6, new sliceType$2([408582]))) { $s = 18; continue; }
						/* */ $s = 19; continue;
						/* if (p.elementInScope(6, new sliceType$2([408582]))) { */ case 18:
							$r = p.parseImpliedToken(3, 408582, new atom.Atom(408582).String()); /* */ $s = 20; case 20: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = -1; return false;
						/* } */ case 19:
						p.tokenizer.NextIsNotRawText();
						$s = -1; return true;
					/* } else if ((_2 === (137222)) || (_2 === (463880))) { */ case 15:
						_r$1 = inHeadIM(p); /* */ $s = 21; case 21: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } */ case 16:
				case 9:
				$s = 8; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (451334)) { $s = 23; continue; }
					/* */ if (_3 === (24328)) { $s = 24; continue; }
					/* */ if (_3 === (408582)) { $s = 25; continue; }
					/* */ if (_3 === (463880)) { $s = 26; continue; }
					/* */ $s = 27; continue;
					/* if (_3 === (451334)) { */ case 23:
						if (p.top().DataAtom === 451334) {
							(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						}
						$s = 27; continue;
					/* } else if (_3 === (24328)) { */ case 24:
						i = p.oe.$length - 1 >> 0;
						if ((x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])).DataAtom === 451334) {
							i = i - (1) >> 0;
						}
						if ((x$1 = p.oe, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i])).DataAtom === 24328) {
							p.oe = $subslice(p.oe, 0, i);
						}
						$s = 27; continue;
					/* } else if (_3 === (408582)) { */ case 25:
						if (p.popUntil(6, new sliceType$2([408582]))) {
							p.resetInsertionMode();
						} else {
							$s = -1; return true;
						}
						$s = 27; continue;
					/* } else if (_3 === (463880)) { */ case 26:
						_r$2 = inHeadIM(p); /* */ $s = 28; case 28: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 27:
				case 22:
				$s = 8; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 8; continue;
			/* } else if (_1 === (6)) { */ case 6:
				$s = -1; return true;
			/* } else if (_1 === (0)) { */ case 7:
				_r$3 = inBodyIM(p); /* */ $s = 29; case 29: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				$s = -1; return _r$3;
			/* } */ case 8:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inSelectIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.i = i; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	inSelectInTableIM = function(p) {
		var _1, _2, _r, i, n, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; i = $f.i; n = $f.n; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_1 = p.tok.Type;
		if ((_1 === (2)) || (_1 === (3))) {
			_2 = p.tok.DataAtom;
			if ((_2 === (143623)) || (_2 === (365829)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901)) || (_2 === (52226)) || (_2 === (37378)) || (_2 === (87554))) {
				if ((p.tok.Type === 3) && !p.elementInScope(3, new sliceType$2([p.tok.DataAtom]))) {
					$s = -1; return true;
				}
				i = p.oe.$length - 1 >> 0;
				while (true) {
					if (!(i >= 0)) { break; }
					n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
					if (n.DataAtom === 408582) {
						p.oe = $subslice(p.oe, 0, i);
						break;
					}
					i = i - (1) >> 0;
				}
				p.resetInsertionMode();
				$s = -1; return false;
			}
		}
		_r = inSelectIM(p); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inSelectInTableIM }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f.i = i; $f.n = n; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	inTemplateIM = function(p) {
		var _1, _2, _3, _r, _r$1, _r$2, i, n, p, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; i = $f.i; n = $f.n; p = $f.p; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if ((_1 === (1)) || (_1 === (5)) || (_1 === (6))) { $s = 2; continue; }
			/* */ if (_1 === (2)) { $s = 3; continue; }
			/* */ if (_1 === (3)) { $s = 4; continue; }
			/* */ if (_1 === (0)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if ((_1 === (1)) || (_1 === (5)) || (_1 === (6))) { */ case 2:
				_r = inBodyIM(p); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (2)) { */ case 3:
					_2 = p.tok.DataAtom;
					/* */ if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (137222)) || (_2 === (458501)) || (_2 === (463880)) || (_2 === (69637))) { $s = 9; continue; }
					/* */ if ((_2 === (143623)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901))) { $s = 10; continue; }
					/* */ if (_2 === (109315)) { $s = 11; continue; }
					/* */ if (_2 === (52226)) { $s = 12; continue; }
					/* */ if ((_2 === (37378)) || (_2 === (87554))) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if ((_2 === (15108)) || (_2 === (15112)) || (_2 === (89607)) || (_2 === (95236)) || (_2 === (309252)) || (_2 === (35080)) || (_2 === (137222)) || (_2 === (458501)) || (_2 === (463880)) || (_2 === (69637))) { */ case 9:
						_r$1 = inHeadIM(p); /* */ $s = 16; case 16: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if ((_2 === (143623)) || (_2 === (109320)) || (_2 === (9989)) || (_2 === (62725)) || (_2 === (208901))) { */ case 10:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inTableIM);
						p.im = inTableIM;
						$s = -1; return false;
					/* } else if (_2 === (109315)) { */ case 11:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inColumnGroupIM);
						p.im = inColumnGroupIM;
						$s = -1; return false;
					/* } else if (_2 === (52226)) { */ case 12:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inTableBodyIM);
						p.im = inTableBodyIM;
						$s = -1; return false;
					/* } else if ((_2 === (37378)) || (_2 === (87554))) { */ case 13:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inRowIM);
						p.im = inRowIM;
						$s = -1; return false;
					/* } else { */ case 14:
						(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
						p.templateStack = $append(p.templateStack, inBodyIM);
						p.im = inBodyIM;
						$s = -1; return false;
					/* } */ case 15:
				case 8:
				$s = 6; continue;
			/* } else if (_1 === (3)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (463880)) { $s = 18; continue; }
					/* */ $s = 19; continue;
					/* if (_3 === (463880)) { */ case 18:
						_r$2 = inHeadIM(p); /* */ $s = 21; case 21: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } else { */ case 19:
						$s = -1; return true;
					/* } */ case 20:
				case 17:
				$s = 6; continue;
			/* } else if (_1 === (0)) { */ case 5:
				if (!(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).contains(463880)) {
					$s = -1; return true;
				}
				p.generateImpliedEndTags(new sliceType([]));
				i = p.oe.$length - 1 >> 0;
				while (true) {
					if (!(i >= 0)) { break; }
					n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
					if (n.Namespace === "" && (n.DataAtom === 463880)) {
						p.oe = $subslice(p.oe, 0, i);
						break;
					}
					i = i - (1) >> 0;
				}
				p.clearActiveFormattingElements();
				(p.$ptr_templateStack || (p.$ptr_templateStack = new ptrType$2(function() { return this.$target.templateStack; }, function($v) { this.$target.templateStack = $v; }, p))).pop();
				p.resetInsertionMode();
				$s = -1; return false;
			/* } */ case 6:
		case 1:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inTemplateIM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.i = i; $f.n = n; $f.p = p; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterBodyIM = function(p) {
		var _1, _r, _r$1, _r$2, p, s, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; p = $f.p; s = $f.s; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ if (_1 === (5)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (0)) { */ case 2:
				$s = -1; return true;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				/* */ if (s.length === 0) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if (s.length === 0) { */ case 9:
					_r$1 = inBodyIM(p); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					$s = -1; return _r$1;
				/* } */ case 10:
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 4:
				/* */ if (p.tok.DataAtom === 22020) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (p.tok.DataAtom === 22020) { */ case 12:
					_r$2 = inBodyIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					$s = -1; return _r$2;
				/* } */ case 13:
				$s = 7; continue;
			/* } else if (_1 === (3)) { */ case 5:
				if (p.tok.DataAtom === 22020) {
					if (!p.fragment) {
						p.im = afterAfterBodyIM;
					}
					$s = -1; return true;
				}
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 6:
				if (p.oe.$length < 1 || !(((x = p.oe, (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0])).DataAtom === 22020))) {
					$panic(new $String("html: bad parser state: <html> element not found, in the after-body insertion mode"));
				}
				(x$1 = p.oe, (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0])).AppendChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } */ case 7:
		case 1:
		p.im = inBodyIM;
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: afterBodyIM }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.p = p; $f.s = s; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	inFramesetIM = function(p) {
		var _1, _3, _4, _r, _r$1, _r$2, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _3 = $f._3; _4 = $f._4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (5)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (5)) { */ case 2:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 6; continue;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.Map((function(c) {
					var _2, c;
					_2 = c;
					if ((_2 === (32)) || (_2 === (9)) || (_2 === (10)) || (_2 === (12)) || (_2 === (13))) {
						return c;
					}
					return -1;
				}), p.tok.Data); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (!(s === "")) {
					p.addText(s);
				}
				$s = 6; continue;
			/* } else if (_1 === (2)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (22020)) { $s = 9; continue; }
					/* */ if (_3 === (35592)) { $s = 10; continue; }
					/* */ if (_3 === (35589)) { $s = 11; continue; }
					/* */ if (_3 === (35080)) { $s = 12; continue; }
					/* */ $s = 13; continue;
					/* if (_3 === (22020)) { */ case 9:
						_r$1 = inBodyIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_3 === (35592)) { */ case 10:
						p.addElement();
						$s = 13; continue;
					/* } else if (_3 === (35589)) { */ case 11:
						p.addElement();
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						p.acknowledgeSelfClosingTag();
						$s = 13; continue;
					/* } else if (_3 === (35080)) { */ case 12:
						_r$2 = inHeadIM(p); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 13:
				case 8:
				$s = 6; continue;
			/* } else if (_1 === (3)) { */ case 5:
				_4 = p.tok.DataAtom;
				if (_4 === (35592)) {
					if (!(((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top().DataAtom === 22020))) {
						(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
						if (!(((p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top().DataAtom === 35592))) {
							p.im = afterFramesetIM;
							$s = -1; return true;
						}
					}
				}
			/* } */ case 6:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: inFramesetIM }; } $f._1 = _1; $f._3 = _3; $f._4 = _4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterFramesetIM = function(p) {
		var _1, _3, _4, _r, _r$1, _r$2, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _3 = $f._3; _4 = $f._4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (5)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (5)) { */ case 2:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 6; continue;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.Map((function(c) {
					var _2, c;
					_2 = c;
					if ((_2 === (32)) || (_2 === (9)) || (_2 === (10)) || (_2 === (12)) || (_2 === (13))) {
						return c;
					}
					return -1;
				}), p.tok.Data); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				if (!(s === "")) {
					p.addText(s);
				}
				$s = 6; continue;
			/* } else if (_1 === (2)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (22020)) { $s = 9; continue; }
					/* */ if (_3 === (35080)) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if (_3 === (22020)) { */ case 9:
						_r$1 = inBodyIM(p); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						$s = -1; return _r$1;
					/* } else if (_3 === (35080)) { */ case 10:
						_r$2 = inHeadIM(p); /* */ $s = 13; case 13: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 11:
				case 8:
				$s = 6; continue;
			/* } else if (_1 === (3)) { */ case 5:
				_4 = p.tok.DataAtom;
				if (_4 === (22020)) {
					p.im = afterAfterFramesetIM;
					$s = -1; return true;
				}
			/* } */ case 6:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: afterFramesetIM }; } $f._1 = _1; $f._3 = _3; $f._4 = _4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterAfterBodyIM = function(p) {
		var _1, _r, _r$1, _r$2, _r$3, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (5)) { $s = 5; continue; }
			/* */ if (_1 === (6)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (0)) { */ case 2:
				$s = -1; return true;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f"); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				/* */ if (s.length === 0) { $s = 9; continue; }
				/* */ $s = 10; continue;
				/* if (s.length === 0) { */ case 9:
					_r$1 = inBodyIM(p); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					$s = -1; return _r$1;
				/* } */ case 10:
				$s = 7; continue;
			/* } else if (_1 === (2)) { */ case 4:
				/* */ if (p.tok.DataAtom === 22020) { $s = 12; continue; }
				/* */ $s = 13; continue;
				/* if (p.tok.DataAtom === 22020) { */ case 12:
					_r$2 = inBodyIM(p); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					$s = -1; return _r$2;
				/* } */ case 13:
				$s = 7; continue;
			/* } else if (_1 === (5)) { */ case 5:
				p.doc.AppendChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = -1; return true;
			/* } else if (_1 === (6)) { */ case 6:
				_r$3 = inBodyIM(p); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				$s = -1; return _r$3;
			/* } */ case 7:
		case 1:
		p.im = inBodyIM;
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: afterAfterBodyIM }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	afterAfterFramesetIM = function(p) {
		var _1, _3, _r, _r$1, _r$2, _r$3, _r$4, p, s, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _3 = $f._3; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; p = $f.p; s = $f.s; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (5)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (6)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (5)) { */ case 2:
				p.doc.AppendChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 6; continue;
			/* } else if (_1 === (1)) { */ case 3:
				_r = strings.Map((function(c) {
					var _2, c;
					_2 = c;
					if ((_2 === (32)) || (_2 === (9)) || (_2 === (10)) || (_2 === (12)) || (_2 === (13))) {
						return c;
					}
					return -1;
				}), p.tok.Data); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				/* */ if (!(s === "")) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if (!(s === "")) { */ case 8:
					p.tok.Data = s;
					_r$1 = inBodyIM(p); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					$s = -1; return _r$1;
				/* } */ case 9:
				$s = 6; continue;
			/* } else if (_1 === (2)) { */ case 4:
					_3 = p.tok.DataAtom;
					/* */ if (_3 === (22020)) { $s = 12; continue; }
					/* */ if (_3 === (35080)) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if (_3 === (22020)) { */ case 12:
						_r$2 = inBodyIM(p); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } else if (_3 === (35080)) { */ case 13:
						_r$3 = inHeadIM(p); /* */ $s = 16; case 16: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
						$s = -1; return _r$3;
					/* } */ case 14:
				case 11:
				$s = 6; continue;
			/* } else if (_1 === (6)) { */ case 5:
				_r$4 = inBodyIM(p); /* */ $s = 17; case 17: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				$s = -1; return _r$4;
			/* } */ case 6:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: afterAfterFramesetIM }; } $f._1 = _1; $f._3 = _3; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f.p = p; $f.s = s; $f.$s = $s; $f.$r = $r; return $f;
	};
	parseForeignContent = function(p) {
		var _1, _2, _3, _entry, _entry$1, _i, _r, _r$1, _r$2, _ref, _v, attr, b, i, i$1, n, namespace, p, x, x$1, x$2, x$3, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _entry = $f._entry; _entry$1 = $f._entry$1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _v = $f._v; attr = $f.attr; b = $f.b; i = $f.i; i$1 = $f.i$1; n = $f.n; namespace = $f.namespace; p = $f.p; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = p.tok.Type;
			/* */ if (_1 === (1)) { $s = 2; continue; }
			/* */ if (_1 === (5)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (1)) { */ case 2:
				/* */ if (p.framesetOK) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (p.framesetOK) { */ case 7:
					_r = strings.TrimLeft(p.tok.Data, " \t\r\n\f\x00"); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					p.framesetOK = _r === "";
				/* } */ case 8:
				p.tok.Data = strings.Replace(p.tok.Data, "\x00", "\xEF\xBF\xBD", -1);
				p.addText(p.tok.Data);
				$s = 6; continue;
			/* } else if (_1 === (5)) { */ case 3:
				p.addChild(new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 4, 0, p.tok.Data, "", sliceType$1.nil));
				$s = 6; continue;
			/* } else if (_1 === (2)) { */ case 4:
				b = (_entry = breakout[$String.keyFor(p.tok.Data)], _entry !== undefined ? _entry.v : false);
				if (p.tok.DataAtom === 16132) {
					_ref = p.tok.Attr;
					_i = 0;
					loop:
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
						_2 = attr.Key;
						if (_2 === ("color") || _2 === ("face") || _2 === ("size")) {
							b = true;
							break loop;
						}
						_i++;
					}
				}
				/* */ if (b) { $s = 10; continue; }
				/* */ $s = 11; continue;
				/* if (b) { */ case 10:
					i = p.oe.$length - 1 >> 0;
					/* while (true) { */ case 12:
						/* if (!(i >= 0)) { break; } */ if(!(i >= 0)) { $s = 13; continue; }
						n = (x = p.oe, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
						if (n.Namespace === "") { _v = true; $s = 16; continue s; }
						_r$1 = htmlIntegrationPoint(n); /* */ $s = 17; case 17: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						_v = _r$1; case 16:
						/* */ if (_v || mathMLTextIntegrationPoint(n)) { $s = 14; continue; }
						/* */ $s = 15; continue;
						/* if (_v || mathMLTextIntegrationPoint(n)) { */ case 14:
							p.oe = $subslice(p.oe, 0, (i + 1 >> 0));
							/* break; */ $s = 13; continue;
						/* } */ case 15:
						i = i - (1) >> 0;
					/* } */ $s = 12; continue; case 13:
					$s = -1; return false;
				/* } */ case 11:
				_3 = p.top().Namespace;
				if (_3 === ("math")) {
					adjustAttributeNames(p.tok.Attr, mathMLAttributeAdjustments);
				} else if (_3 === ("svg")) {
					x$1 = (_entry$1 = svgTagNameAdjustments[$String.keyFor(p.tok.Data)], _entry$1 !== undefined ? _entry$1.v : "");
					if (!(x$1 === "")) {
						p.tok.DataAtom = atom.Lookup((new sliceType$3($stringToBytes(x$1))));
						p.tok.Data = x$1;
					}
					adjustAttributeNames(p.tok.Attr, svgAttributeAdjustments);
				} else {
					$panic(new $String("html: bad parser state: unexpected namespace"));
				}
				adjustForeignAttributes(p.tok.Attr);
				namespace = p.top().Namespace;
				p.addElement();
				p.top().Namespace = namespace;
				if (!(namespace === "")) {
					p.tokenizer.NextIsNotRawText();
				}
				if (p.hasSelfClosingToken) {
					(p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).pop();
					p.acknowledgeSelfClosingTag();
				}
				$s = 6; continue;
			/* } else if (_1 === (3)) { */ case 5:
				i$1 = p.oe.$length - 1 >> 0;
				/* while (true) { */ case 18:
					/* if (!(i$1 >= 0)) { break; } */ if(!(i$1 >= 0)) { $s = 19; continue; }
					/* */ if ((x$2 = p.oe, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1])).Namespace === "") { $s = 20; continue; }
					/* */ $s = 21; continue;
					/* if ((x$2 = p.oe, ((i$1 < 0 || i$1 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i$1])).Namespace === "") { */ case 20:
						_r$2 = p.im(p); /* */ $s = 22; case 22: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						$s = -1; return _r$2;
					/* } */ case 21:
					if (strings.EqualFold((x$3 = p.oe, ((i$1 < 0 || i$1 >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i$1])).Data, p.tok.Data)) {
						p.oe = $subslice(p.oe, 0, i$1);
						/* break; */ $s = 19; continue;
					}
					i$1 = i$1 - (1) >> 0;
				/* } */ $s = 18; continue; case 19:
				$s = -1; return true;
			/* } */ case 6:
		case 1:
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parseForeignContent }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._entry = _entry; $f._entry$1 = _entry$1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._v = _v; $f.attr = attr; $f.b = b; $f.i = i; $f.i$1 = i$1; $f.n = n; $f.namespace = namespace; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.ptr.prototype.inForeignContent = function() {
		var _r, n, p, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; p = $f.p; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (p.oe.$length === 0) {
			$s = -1; return false;
		}
		n = (x = p.oe, x$1 = p.oe.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (n.Namespace === "") {
			$s = -1; return false;
		}
		if (mathMLTextIntegrationPoint(n)) {
			if ((p.tok.Type === 2) && !((p.tok.DataAtom === 198662)) && !((p.tok.DataAtom === 45066))) {
				$s = -1; return false;
			}
			if (p.tok.Type === 1) {
				$s = -1; return false;
			}
		}
		if (n.Namespace === "math" && (n.DataAtom === 117006) && (p.tok.Type === 2) && (p.tok.DataAtom === 462339)) {
			$s = -1; return false;
		}
		_r = htmlIntegrationPoint(n); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		/* */ if (_r && ((p.tok.Type === 2) || (p.tok.Type === 1))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (_r && ((p.tok.Type === 2) || (p.tok.Type === 1))) { */ case 1:
			$s = -1; return false;
		/* } */ case 2:
		if (p.tok.Type === 0) {
			$s = -1; return false;
		}
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.inForeignContent }; } $f._r = _r; $f.n = n; $f.p = p; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.inForeignContent = function() { return this.$val.inForeignContent(); };
	parser.ptr.prototype.parseImpliedToken = function(t, dataAtom, data) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, data, dataAtom, p, realToken, selfClosing, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; data = $f.data; dataAtom = $f.dataAtom; p = $f.p; realToken = $f.realToken; selfClosing = $f.selfClosing; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		_tmp = $clone(p.tok, Token);
		_tmp$1 = p.hasSelfClosingToken;
		realToken = $clone(_tmp, Token);
		selfClosing = _tmp$1;
		Token.copy(p.tok, new Token.ptr(t, dataAtom, data, sliceType$1.nil));
		p.hasSelfClosingToken = false;
		$r = p.parseCurrentToken(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_tmp$2 = $clone(realToken, Token);
		_tmp$3 = selfClosing;
		Token.copy(p.tok, _tmp$2);
		p.hasSelfClosingToken = _tmp$3;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseImpliedToken }; } $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f.data = data; $f.dataAtom = dataAtom; $f.p = p; $f.realToken = realToken; $f.selfClosing = selfClosing; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseImpliedToken = function(t, dataAtom, data) { return this.$val.parseImpliedToken(t, dataAtom, data); };
	parser.ptr.prototype.parseCurrentToken = function() {
		var _r, _r$1, _r$2, consumed, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; consumed = $f.consumed; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		if (p.tok.Type === 4) {
			p.hasSelfClosingToken = true;
			p.tok.Type = 2;
		}
		consumed = false;
		/* while (true) { */ case 1:
			/* if (!(!consumed)) { break; } */ if(!(!consumed)) { $s = 2; continue; }
			_r = p.inForeignContent(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			/* */ if (_r) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (_r) { */ case 3:
				_r$1 = parseForeignContent(p); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				consumed = _r$1;
				$s = 5; continue;
			/* } else { */ case 4:
				_r$2 = p.im(p); /* */ $s = 8; case 8: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				consumed = _r$2;
			/* } */ case 5:
		/* } */ $s = 1; continue; case 2:
		if (p.hasSelfClosingToken) {
			p.hasSelfClosingToken = false;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parseCurrentToken }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.consumed = consumed; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parseCurrentToken = function() { return this.$val.parseCurrentToken(); };
	parser.ptr.prototype.parse = function() {
		var _r, err, n, p, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; n = $f.n; p = $f.p; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		p = this;
		err = $ifaceNil;
		/* while (true) { */ case 1:
			/* if (!(!($interfaceIsEqual(err, io.EOF)))) { break; } */ if(!(!($interfaceIsEqual(err, io.EOF)))) { $s = 2; continue; }
			n = (p.$ptr_oe || (p.$ptr_oe = new ptrType$1(function() { return this.$target.oe; }, function($v) { this.$target.oe = $v; }, p))).top();
			p.tokenizer.AllowCDATA(!(n === ptrType.nil) && !(n.Namespace === ""));
			_r = p.tokenizer.Next(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
			Token.copy(p.tok, p.tokenizer.Token());
			if (p.tok.Type === 0) {
				err = p.tokenizer.Err();
				if (!($interfaceIsEqual(err, $ifaceNil)) && !($interfaceIsEqual(err, io.EOF))) {
					$s = -1; return err;
				}
			}
			$r = p.parseCurrentToken(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: parser.ptr.prototype.parse }; } $f._r = _r; $f.err = err; $f.n = n; $f.p = p; $f.$s = $s; $f.$r = $r; return $f;
	};
	parser.prototype.parse = function() { return this.$val.parse(); };
	ParseFragment = function(r, context) {
		var _r, context, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; context = $f.context; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = ParseFragmentWithOptions(r, context, new sliceType$5([])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: ParseFragment }; } $f._r = _r; $f.context = context; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ParseFragment = ParseFragment;
	ParseFragmentWithOptions = function(r, context, opts) {
		var _i, _r, _r$1, _ref, c, context, contextTag, err, f, n, next, opts, p, parent, r, result, root, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; c = $f.c; context = $f.context; contextTag = $f.contextTag; err = $f.err; f = $f.f; n = $f.n; next = $f.next; opts = $f.opts; p = $f.p; parent = $f.parent; r = $f.r; result = $f.result; root = $f.root; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		contextTag = "";
		if (!(context === ptrType.nil)) {
			if (!((context.Type === 3))) {
				$s = -1; return [sliceType$6.nil, errors.New("html: ParseFragment of non-element Node")];
			}
			if (!((context.DataAtom === atom.Lookup((new sliceType$3($stringToBytes(context.Data))))))) {
				$s = -1; return [sliceType$6.nil, errors.New("html: inconsistent Node: DataAtom=" + strconv.Itoa(((context.DataAtom >> 0))) + ", Data=" + context.Data)];
			}
			contextTag = new atom.Atom(context.DataAtom).String();
		}
		_r = NewTokenizerFragment(r, contextTag); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		p = new parser.ptr(_r, new Token.ptr(0, 0, "", sliceType$1.nil), false, new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 2, 0, "", "", sliceType$1.nil), nodeStack.nil, nodeStack.nil, ptrType.nil, ptrType.nil, true, false, insertionModeStack.nil, $throwNilPointerError, $throwNilPointerError, false, false, true, context);
		_ref = opts;
		_i = 0;
		/* while (true) { */ case 2:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 3; continue; }
			f = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			$r = f(p); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 2; continue; case 3:
		root = new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, 22020, new atom.Atom(22020).String(), "", sliceType$1.nil);
		p.doc.AppendChild(root);
		p.oe = new nodeStack([root]);
		if (!(context === ptrType.nil) && (context.DataAtom === 463880)) {
			p.templateStack = $append(p.templateStack, inTemplateIM);
		}
		p.resetInsertionMode();
		n = context;
		while (true) {
			if (!(!(n === ptrType.nil))) { break; }
			if ((n.Type === 3) && (n.DataAtom === 159236)) {
				p.form = n;
				break;
			}
			n = n.Parent;
		}
		_r$1 = p.parse(); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return [sliceType$6.nil, err];
		}
		parent = p.doc;
		if (!(context === ptrType.nil)) {
			parent = root;
		}
		result = sliceType$6.nil;
		c = parent.FirstChild;
		while (true) {
			if (!(!(c === ptrType.nil))) { break; }
			next = c.NextSibling;
			parent.RemoveChild(c);
			result = $append(result, c);
			c = next;
		}
		$s = -1; return [result, $ifaceNil];
		/* */ } return; } if ($f === undefined) { $f = { $blk: ParseFragmentWithOptions }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f.c = c; $f.context = context; $f.contextTag = contextTag; $f.err = err; $f.f = f; $f.n = n; $f.next = next; $f.opts = opts; $f.p = p; $f.parent = parent; $f.r = r; $f.result = result; $f.root = root; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.ParseFragmentWithOptions = ParseFragmentWithOptions;
	Render = function(w, n) {
		var _r, _r$1, _r$2, _tuple, buf, err, n, ok, w, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; buf = $f.buf; err = $f.err; n = $f.n; ok = $f.ok; w = $f.w; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_tuple = $assertType(w, writer, true);
		x = _tuple[0];
		ok = _tuple[1];
		/* */ if (ok) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (ok) { */ case 1:
			_r = render(x, n); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			$s = -1; return _r;
		/* } */ case 2:
		buf = bufio.NewWriter(w);
		_r$1 = render(buf, n); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		err = _r$1;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r$2 = buf.Flush(); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		$s = -1; return _r$2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Render }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f.buf = buf; $f.err = err; $f.n = n; $f.ok = ok; $f.w = w; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Render = Render;
	render = function(w, n) {
		var _r, err, n, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; err = $f.err; n = $f.n; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = render1(w, n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if ($interfaceIsEqual(err, plaintextAbort)) {
			err = $ifaceNil;
		}
		$s = -1; return err;
		/* */ } return; } if ($f === undefined) { $f = { $blk: render }; } $f._r = _r; $f.err = err; $f.n = n; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	render1 = function(w, n) {
		var _1, _2, _3, _4, _entry, _i, _i$1, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$2, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$26, _r$27, _r$28, _r$29, _r$3, _r$30, _r$31, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _ref$1, _tmp, _tmp$1, _tuple, _tuple$1, _tuple$10, _tuple$11, _tuple$12, _tuple$13, _tuple$14, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, a, a$1, c, c$1, c$2, c$3, err, err$1, err$10, err$11, err$12, err$13, err$14, err$15, err$16, err$17, err$18, err$19, err$2, err$20, err$21, err$22, err$23, err$24, err$25, err$26, err$27, err$28, err$3, err$4, err$5, err$6, err$7, err$8, err$9, n, p, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _entry = $f._entry; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$2 = $f._r$2; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$26 = $f._r$26; _r$27 = $f._r$27; _r$28 = $f._r$28; _r$29 = $f._r$29; _r$3 = $f._r$3; _r$30 = $f._r$30; _r$31 = $f._r$31; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _ref$1 = $f._ref$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$10 = $f._tuple$10; _tuple$11 = $f._tuple$11; _tuple$12 = $f._tuple$12; _tuple$13 = $f._tuple$13; _tuple$14 = $f._tuple$14; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; a = $f.a; a$1 = $f.a$1; c = $f.c; c$1 = $f.c$1; c$2 = $f.c$2; c$3 = $f.c$3; err = $f.err; err$1 = $f.err$1; err$10 = $f.err$10; err$11 = $f.err$11; err$12 = $f.err$12; err$13 = $f.err$13; err$14 = $f.err$14; err$15 = $f.err$15; err$16 = $f.err$16; err$17 = $f.err$17; err$18 = $f.err$18; err$19 = $f.err$19; err$2 = $f.err$2; err$20 = $f.err$20; err$21 = $f.err$21; err$22 = $f.err$22; err$23 = $f.err$23; err$24 = $f.err$24; err$25 = $f.err$25; err$26 = $f.err$26; err$27 = $f.err$27; err$28 = $f.err$28; err$3 = $f.err$3; err$4 = $f.err$4; err$5 = $f.err$5; err$6 = $f.err$6; err$7 = $f.err$7; err$8 = $f.err$8; err$9 = $f.err$9; n = $f.n; p = $f.p; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = n.Type;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ if (_1 === (4)) { $s = 6; continue; }
			/* */ if (_1 === (5)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (0)) { */ case 2:
				$s = -1; return errors.New("html: cannot render an ErrorNode node");
			/* } else if (_1 === (1)) { */ case 3:
				_r = escape(w, n.Data); /* */ $s = 10; case 10: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (2)) { */ case 4:
				c = n.FirstChild;
				/* while (true) { */ case 11:
					/* if (!(!(c === ptrType.nil))) { break; } */ if(!(!(c === ptrType.nil))) { $s = 12; continue; }
					_r$1 = render1(w, c); /* */ $s = 13; case 13: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					err = _r$1;
					if (!($interfaceIsEqual(err, $ifaceNil))) {
						$s = -1; return err;
					}
					c = c.NextSibling;
				/* } */ $s = 11; continue; case 12:
				$s = -1; return $ifaceNil;
			/* } else if (_1 === (3)) { */ case 5:
				$s = 9; continue;
			/* } else if (_1 === (4)) { */ case 6:
				_r$2 = w.WriteString("<!--"); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_tuple = _r$2;
				err$1 = _tuple[1];
				if (!($interfaceIsEqual(err$1, $ifaceNil))) {
					$s = -1; return err$1;
				}
				_r$3 = w.WriteString(n.Data); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				_tuple$1 = _r$3;
				err$2 = _tuple$1[1];
				if (!($interfaceIsEqual(err$2, $ifaceNil))) {
					$s = -1; return err$2;
				}
				_r$4 = w.WriteString("-->"); /* */ $s = 16; case 16: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				_tuple$2 = _r$4;
				err$3 = _tuple$2[1];
				if (!($interfaceIsEqual(err$3, $ifaceNil))) {
					$s = -1; return err$3;
				}
				$s = -1; return $ifaceNil;
			/* } else if (_1 === (5)) { */ case 7:
				_r$5 = w.WriteString("<!DOCTYPE "); /* */ $s = 17; case 17: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
				_tuple$3 = _r$5;
				err$4 = _tuple$3[1];
				if (!($interfaceIsEqual(err$4, $ifaceNil))) {
					$s = -1; return err$4;
				}
				_r$6 = w.WriteString(n.Data); /* */ $s = 18; case 18: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				_tuple$4 = _r$6;
				err$5 = _tuple$4[1];
				if (!($interfaceIsEqual(err$5, $ifaceNil))) {
					$s = -1; return err$5;
				}
				/* */ if (!(n.Attr === sliceType$1.nil)) { $s = 19; continue; }
				/* */ $s = 20; continue;
				/* if (!(n.Attr === sliceType$1.nil)) { */ case 19:
					_tmp = "";
					_tmp$1 = "";
					p = _tmp;
					s = _tmp$1;
					_ref = n.Attr;
					_i = 0;
					while (true) {
						if (!(_i < _ref.$length)) { break; }
						a = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
						_2 = a.Key;
						if (_2 === ("public")) {
							p = a.Val;
						} else if (_2 === ("system")) {
							s = a.Val;
						}
						_i++;
					}
					/* */ if (!(p === "")) { $s = 21; continue; }
					/* */ if (!(s === "")) { $s = 22; continue; }
					/* */ $s = 23; continue;
					/* if (!(p === "")) { */ case 21:
						_r$7 = w.WriteString(" PUBLIC "); /* */ $s = 24; case 24: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
						_tuple$5 = _r$7;
						err$6 = _tuple$5[1];
						if (!($interfaceIsEqual(err$6, $ifaceNil))) {
							$s = -1; return err$6;
						}
						_r$8 = writeQuoted(w, p); /* */ $s = 25; case 25: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
						err$7 = _r$8;
						if (!($interfaceIsEqual(err$7, $ifaceNil))) {
							$s = -1; return err$7;
						}
						/* */ if (!(s === "")) { $s = 26; continue; }
						/* */ $s = 27; continue;
						/* if (!(s === "")) { */ case 26:
							_r$9 = w.WriteByte(32); /* */ $s = 28; case 28: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
							err$8 = _r$9;
							if (!($interfaceIsEqual(err$8, $ifaceNil))) {
								$s = -1; return err$8;
							}
							_r$10 = writeQuoted(w, s); /* */ $s = 29; case 29: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
							err$9 = _r$10;
							if (!($interfaceIsEqual(err$9, $ifaceNil))) {
								$s = -1; return err$9;
							}
						/* } */ case 27:
						$s = 23; continue;
					/* } else if (!(s === "")) { */ case 22:
						_r$11 = w.WriteString(" SYSTEM "); /* */ $s = 30; case 30: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
						_tuple$6 = _r$11;
						err$10 = _tuple$6[1];
						if (!($interfaceIsEqual(err$10, $ifaceNil))) {
							$s = -1; return err$10;
						}
						_r$12 = writeQuoted(w, s); /* */ $s = 31; case 31: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
						err$11 = _r$12;
						if (!($interfaceIsEqual(err$11, $ifaceNil))) {
							$s = -1; return err$11;
						}
					/* } */ case 23:
				/* } */ case 20:
				_r$13 = w.WriteByte(62); /* */ $s = 32; case 32: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				$s = -1; return _r$13;
			/* } else { */ case 8:
				$s = -1; return errors.New("html: unknown node type");
			/* } */ case 9:
		case 1:
		_r$14 = w.WriteByte(60); /* */ $s = 33; case 33: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
		err$12 = _r$14;
		if (!($interfaceIsEqual(err$12, $ifaceNil))) {
			$s = -1; return err$12;
		}
		_r$15 = w.WriteString(n.Data); /* */ $s = 34; case 34: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
		_tuple$7 = _r$15;
		err$13 = _tuple$7[1];
		if (!($interfaceIsEqual(err$13, $ifaceNil))) {
			$s = -1; return err$13;
		}
		_ref$1 = n.Attr;
		_i$1 = 0;
		/* while (true) { */ case 35:
			/* if (!(_i$1 < _ref$1.$length)) { break; } */ if(!(_i$1 < _ref$1.$length)) { $s = 36; continue; }
			a$1 = $clone(((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]), Attribute);
			_r$16 = w.WriteByte(32); /* */ $s = 37; case 37: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
			err$14 = _r$16;
			if (!($interfaceIsEqual(err$14, $ifaceNil))) {
				$s = -1; return err$14;
			}
			/* */ if (!(a$1.Namespace === "")) { $s = 38; continue; }
			/* */ $s = 39; continue;
			/* if (!(a$1.Namespace === "")) { */ case 38:
				_r$17 = w.WriteString(a$1.Namespace); /* */ $s = 40; case 40: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
				_tuple$8 = _r$17;
				err$15 = _tuple$8[1];
				if (!($interfaceIsEqual(err$15, $ifaceNil))) {
					$s = -1; return err$15;
				}
				_r$18 = w.WriteByte(58); /* */ $s = 41; case 41: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
				err$16 = _r$18;
				if (!($interfaceIsEqual(err$16, $ifaceNil))) {
					$s = -1; return err$16;
				}
			/* } */ case 39:
			_r$19 = w.WriteString(a$1.Key); /* */ $s = 42; case 42: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
			_tuple$9 = _r$19;
			err$17 = _tuple$9[1];
			if (!($interfaceIsEqual(err$17, $ifaceNil))) {
				$s = -1; return err$17;
			}
			_r$20 = w.WriteString("=\""); /* */ $s = 43; case 43: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
			_tuple$10 = _r$20;
			err$18 = _tuple$10[1];
			if (!($interfaceIsEqual(err$18, $ifaceNil))) {
				$s = -1; return err$18;
			}
			_r$21 = escape(w, a$1.Val); /* */ $s = 44; case 44: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
			err$19 = _r$21;
			if (!($interfaceIsEqual(err$19, $ifaceNil))) {
				$s = -1; return err$19;
			}
			_r$22 = w.WriteByte(34); /* */ $s = 45; case 45: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
			err$20 = _r$22;
			if (!($interfaceIsEqual(err$20, $ifaceNil))) {
				$s = -1; return err$20;
			}
			_i$1++;
		/* } */ $s = 35; continue; case 36:
		/* */ if ((_entry = voidElements[$String.keyFor(n.Data)], _entry !== undefined ? _entry.v : false)) { $s = 46; continue; }
		/* */ $s = 47; continue;
		/* if ((_entry = voidElements[$String.keyFor(n.Data)], _entry !== undefined ? _entry.v : false)) { */ case 46:
			if (!(n.FirstChild === ptrType.nil)) {
				$s = -1; return errors.New("html: void element <" + n.Data + " has child nodes");
			}
			_r$23 = w.WriteString("/>"); /* */ $s = 48; case 48: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
			_tuple$11 = _r$23;
			err$21 = _tuple$11[1];
			$s = -1; return err$21;
		/* } */ case 47:
		_r$24 = w.WriteByte(62); /* */ $s = 49; case 49: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
		err$22 = _r$24;
		if (!($interfaceIsEqual(err$22, $ifaceNil))) {
			$s = -1; return err$22;
		}
		c$1 = n.FirstChild;
		/* */ if (!(c$1 === ptrType.nil) && (c$1.Type === 1) && strings.HasPrefix(c$1.Data, "\n")) { $s = 50; continue; }
		/* */ $s = 51; continue;
		/* if (!(c$1 === ptrType.nil) && (c$1.Type === 1) && strings.HasPrefix(c$1.Data, "\n")) { */ case 50:
				_3 = n.Data;
				/* */ if (_3 === ("pre") || _3 === ("listing") || _3 === ("textarea")) { $s = 53; continue; }
				/* */ $s = 54; continue;
				/* if (_3 === ("pre") || _3 === ("listing") || _3 === ("textarea")) { */ case 53:
					_r$25 = w.WriteByte(10); /* */ $s = 55; case 55: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
					err$23 = _r$25;
					if (!($interfaceIsEqual(err$23, $ifaceNil))) {
						$s = -1; return err$23;
					}
				/* } */ case 54:
			case 52:
		/* } */ case 51:
			_4 = n.Data;
			/* */ if (_4 === ("iframe") || _4 === ("noembed") || _4 === ("noframes") || _4 === ("noscript") || _4 === ("plaintext") || _4 === ("script") || _4 === ("style") || _4 === ("xmp")) { $s = 57; continue; }
			/* */ $s = 58; continue;
			/* if (_4 === ("iframe") || _4 === ("noembed") || _4 === ("noframes") || _4 === ("noscript") || _4 === ("plaintext") || _4 === ("script") || _4 === ("style") || _4 === ("xmp")) { */ case 57:
				c$2 = n.FirstChild;
				/* while (true) { */ case 60:
					/* if (!(!(c$2 === ptrType.nil))) { break; } */ if(!(!(c$2 === ptrType.nil))) { $s = 61; continue; }
					/* */ if (c$2.Type === 1) { $s = 62; continue; }
					/* */ $s = 63; continue;
					/* if (c$2.Type === 1) { */ case 62:
						_r$26 = w.WriteString(c$2.Data); /* */ $s = 65; case 65: if($c) { $c = false; _r$26 = _r$26.$blk(); } if (_r$26 && _r$26.$blk !== undefined) { break s; }
						_tuple$12 = _r$26;
						err$24 = _tuple$12[1];
						if (!($interfaceIsEqual(err$24, $ifaceNil))) {
							$s = -1; return err$24;
						}
						$s = 64; continue;
					/* } else { */ case 63:
						_r$27 = render1(w, c$2); /* */ $s = 66; case 66: if($c) { $c = false; _r$27 = _r$27.$blk(); } if (_r$27 && _r$27.$blk !== undefined) { break s; }
						err$25 = _r$27;
						if (!($interfaceIsEqual(err$25, $ifaceNil))) {
							$s = -1; return err$25;
						}
					/* } */ case 64:
					c$2 = c$2.NextSibling;
				/* } */ $s = 60; continue; case 61:
				if (n.Data === "plaintext") {
					$s = -1; return plaintextAbort;
				}
				$s = 59; continue;
			/* } else { */ case 58:
				c$3 = n.FirstChild;
				/* while (true) { */ case 67:
					/* if (!(!(c$3 === ptrType.nil))) { break; } */ if(!(!(c$3 === ptrType.nil))) { $s = 68; continue; }
					_r$28 = render1(w, c$3); /* */ $s = 69; case 69: if($c) { $c = false; _r$28 = _r$28.$blk(); } if (_r$28 && _r$28.$blk !== undefined) { break s; }
					err$26 = _r$28;
					if (!($interfaceIsEqual(err$26, $ifaceNil))) {
						$s = -1; return err$26;
					}
					c$3 = c$3.NextSibling;
				/* } */ $s = 67; continue; case 68:
			/* } */ case 59:
		case 56:
		_r$29 = w.WriteString("</"); /* */ $s = 70; case 70: if($c) { $c = false; _r$29 = _r$29.$blk(); } if (_r$29 && _r$29.$blk !== undefined) { break s; }
		_tuple$13 = _r$29;
		err$27 = _tuple$13[1];
		if (!($interfaceIsEqual(err$27, $ifaceNil))) {
			$s = -1; return err$27;
		}
		_r$30 = w.WriteString(n.Data); /* */ $s = 71; case 71: if($c) { $c = false; _r$30 = _r$30.$blk(); } if (_r$30 && _r$30.$blk !== undefined) { break s; }
		_tuple$14 = _r$30;
		err$28 = _tuple$14[1];
		if (!($interfaceIsEqual(err$28, $ifaceNil))) {
			$s = -1; return err$28;
		}
		_r$31 = w.WriteByte(62); /* */ $s = 72; case 72: if($c) { $c = false; _r$31 = _r$31.$blk(); } if (_r$31 && _r$31.$blk !== undefined) { break s; }
		$s = -1; return _r$31;
		/* */ } return; } if ($f === undefined) { $f = { $blk: render1 }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._entry = _entry; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$2 = _r$2; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$26 = _r$26; $f._r$27 = _r$27; $f._r$28 = _r$28; $f._r$29 = _r$29; $f._r$3 = _r$3; $f._r$30 = _r$30; $f._r$31 = _r$31; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$10 = _tuple$10; $f._tuple$11 = _tuple$11; $f._tuple$12 = _tuple$12; $f._tuple$13 = _tuple$13; $f._tuple$14 = _tuple$14; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.a = a; $f.a$1 = a$1; $f.c = c; $f.c$1 = c$1; $f.c$2 = c$2; $f.c$3 = c$3; $f.err = err; $f.err$1 = err$1; $f.err$10 = err$10; $f.err$11 = err$11; $f.err$12 = err$12; $f.err$13 = err$13; $f.err$14 = err$14; $f.err$15 = err$15; $f.err$16 = err$16; $f.err$17 = err$17; $f.err$18 = err$18; $f.err$19 = err$19; $f.err$2 = err$2; $f.err$20 = err$20; $f.err$21 = err$21; $f.err$22 = err$22; $f.err$23 = err$23; $f.err$24 = err$24; $f.err$25 = err$25; $f.err$26 = err$26; $f.err$27 = err$27; $f.err$28 = err$28; $f.err$3 = err$3; $f.err$4 = err$4; $f.err$5 = err$5; $f.err$6 = err$6; $f.err$7 = err$7; $f.err$8 = err$8; $f.err$9 = err$9; $f.n = n; $f.p = p; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	writeQuoted = function(w, s) {
		var _r, _r$1, _r$2, _tuple, err, err$1, err$2, q, s, w, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; err = $f.err; err$1 = $f.err$1; err$2 = $f.err$2; q = $f.q; s = $f.s; w = $f.w; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		q = 34;
		if (strings.Contains(s, "\"")) {
			q = 39;
		}
		_r = w.WriteByte(q); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		err = _r;
		if (!($interfaceIsEqual(err, $ifaceNil))) {
			$s = -1; return err;
		}
		_r$1 = w.WriteString(s); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		_tuple = _r$1;
		err$1 = _tuple[1];
		if (!($interfaceIsEqual(err$1, $ifaceNil))) {
			$s = -1; return err$1;
		}
		_r$2 = w.WriteByte(q); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		err$2 = _r$2;
		if (!($interfaceIsEqual(err$2, $ifaceNil))) {
			$s = -1; return err$2;
		}
		$s = -1; return $ifaceNil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: writeQuoted }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f.err = err; $f.err$1 = err$1; $f.err$2 = err$2; $f.q = q; $f.s = s; $f.w = w; $f.$s = $s; $f.$r = $r; return $f;
	};
	TokenType.prototype.String = function() {
		var _1, t;
		t = this.$val;
		_1 = t;
		if (_1 === (0)) {
			return "Error";
		} else if (_1 === (1)) {
			return "Text";
		} else if (_1 === (2)) {
			return "StartTag";
		} else if (_1 === (3)) {
			return "EndTag";
		} else if (_1 === (4)) {
			return "SelfClosingTag";
		} else if (_1 === (5)) {
			return "Comment";
		} else if (_1 === (6)) {
			return "Doctype";
		}
		return "Invalid(" + strconv.Itoa(((t >> 0))) + ")";
	};
	$ptrType(TokenType).prototype.String = function() { return new TokenType(this.$get()).String(); };
	Token.ptr.prototype.tagString = function() {
		var _i, _r, _ref, a, buf, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; a = $f.a; buf = $f.buf; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (t.Attr.$length === 0) {
			$s = -1; return t.Data;
		}
		buf = bytes.NewBufferString(t.Data);
		_ref = t.Attr;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			a = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), Attribute);
			buf.WriteByte(32);
			buf.WriteString(a.Key);
			buf.WriteString("=\"");
			_r = escape(buf, a.Val); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r;
			buf.WriteByte(34);
			_i++;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return buf.String();
		/* */ } return; } if ($f === undefined) { $f = { $blk: Token.ptr.prototype.tagString }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.a = a; $f.buf = buf; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Token.prototype.tagString = function() { return this.$val.tagString(); };
	Token.ptr.prototype.String = function() {
		var _1, _r, _r$1, _r$2, _r$3, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
			_1 = t.Type;
			/* */ if (_1 === (0)) { $s = 2; continue; }
			/* */ if (_1 === (1)) { $s = 3; continue; }
			/* */ if (_1 === (2)) { $s = 4; continue; }
			/* */ if (_1 === (3)) { $s = 5; continue; }
			/* */ if (_1 === (4)) { $s = 6; continue; }
			/* */ if (_1 === (5)) { $s = 7; continue; }
			/* */ if (_1 === (6)) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (_1 === (0)) { */ case 2:
				$s = -1; return "";
			/* } else if (_1 === (1)) { */ case 3:
				_r = EscapeString(t.Data); /* */ $s = 10; case 10: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (2)) { */ case 4:
				_r$1 = $clone(t, Token).tagString(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$s = -1; return "<" + _r$1 + ">";
			/* } else if (_1 === (3)) { */ case 5:
				_r$2 = $clone(t, Token).tagString(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				$s = -1; return "</" + _r$2 + ">";
			/* } else if (_1 === (4)) { */ case 6:
				_r$3 = $clone(t, Token).tagString(); /* */ $s = 13; case 13: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				$s = -1; return "<" + _r$3 + "/>";
			/* } else if (_1 === (5)) { */ case 7:
				$s = -1; return "<!--" + t.Data + "-->";
			/* } else if (_1 === (6)) { */ case 8:
				$s = -1; return "<!DOCTYPE " + t.Data + ">";
			/* } */ case 9:
		case 1:
		$s = -1; return "Invalid(" + strconv.Itoa(((t.Type >> 0))) + ")";
		/* */ } return; } if ($f === undefined) { $f = { $blk: Token.ptr.prototype.String }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Token.prototype.String = function() { return this.$val.String(); };
	Tokenizer.ptr.prototype.AllowCDATA = function(allowCDATA) {
		var allowCDATA, z;
		z = this;
		z.allowCDATA = allowCDATA;
	};
	Tokenizer.prototype.AllowCDATA = function(allowCDATA) { return this.$val.AllowCDATA(allowCDATA); };
	Tokenizer.ptr.prototype.NextIsNotRawText = function() {
		var z;
		z = this;
		z.rawTag = "";
	};
	Tokenizer.prototype.NextIsNotRawText = function() { return this.$val.NextIsNotRawText(); };
	Tokenizer.ptr.prototype.Err = function() {
		var z;
		z = this;
		if (!((z.tt === 0))) {
			return $ifaceNil;
		}
		return z.err;
	};
	Tokenizer.prototype.Err = function() { return this.$val.Err(); };
	Tokenizer.ptr.prototype.readByte = function() {
		var _i, _r, _ref, _tmp, _tmp$1, _tmp$2, _tuple, buf1, c, d, i, n, x, x$1, x$10, x$11, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; buf1 = $f.buf1; c = $f.c; d = $f.d; i = $f.i; n = $f.n; x = $f.x; x$1 = $f.x$1; x$10 = $f.x$10; x$11 = $f.x$11; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; x$9 = $f.x$9; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		/* */ if (z.raw.end >= z.buf.$length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (z.raw.end >= z.buf.$length) { */ case 1:
			if (!($interfaceIsEqual(z.readErr, $ifaceNil))) {
				z.err = z.readErr;
				$s = -1; return 0;
			}
			c = z.buf.$capacity;
			d = z.raw.end - z.raw.start >> 0;
			buf1 = sliceType$3.nil;
			if (($imul(2, d)) > c) {
				buf1 = $makeSlice(sliceType$3, d, ($imul(2, c)));
			} else {
				buf1 = $subslice(z.buf, 0, d);
			}
			$copySlice(buf1, $subslice(z.buf, z.raw.start, z.raw.end));
			x = z.raw.start;
			if (!((x === 0))) {
				z.data.start = z.data.start - (x) >> 0;
				z.data.end = z.data.end - (x) >> 0;
				z.pendingAttr[0].start = z.pendingAttr[0].start - (x) >> 0;
				z.pendingAttr[0].end = z.pendingAttr[0].end - (x) >> 0;
				z.pendingAttr[1].start = z.pendingAttr[1].start - (x) >> 0;
				z.pendingAttr[1].end = z.pendingAttr[1].end - (x) >> 0;
				_ref = z.attr;
				_i = 0;
				while (true) {
					if (!(_i < _ref.$length)) { break; }
					i = _i;
					(x$2 = z.attr, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]))[0].start = (x$1 = z.attr, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]))[0].start - (x) >> 0;
					(x$4 = z.attr, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i]))[0].end = (x$3 = z.attr, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i]))[0].end - (x) >> 0;
					(x$6 = z.attr, ((i < 0 || i >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + i]))[1].start = (x$5 = z.attr, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i]))[1].start - (x) >> 0;
					(x$8 = z.attr, ((i < 0 || i >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + i]))[1].end = (x$7 = z.attr, ((i < 0 || i >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + i]))[1].end - (x) >> 0;
					_i++;
				}
			}
			_tmp = 0;
			_tmp$1 = d;
			_tmp$2 = $subslice(buf1, 0, d);
			z.raw.start = _tmp;
			z.raw.end = _tmp$1;
			z.buf = _tmp$2;
			n = 0;
			_r = readAtLeastOneByte(z.r, $subslice(buf1, d, buf1.$capacity)); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			n = _tuple[0];
			z.readErr = _tuple[1];
			if (n === 0) {
				z.err = z.readErr;
				$s = -1; return 0;
			}
			z.buf = $subslice(buf1, 0, (d + n >> 0));
		/* } */ case 2:
		x$11 = (x$9 = z.buf, x$10 = z.raw.end, ((x$10 < 0 || x$10 >= x$9.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$9.$array[x$9.$offset + x$10]));
		z.raw.end = z.raw.end + (1) >> 0;
		if (z.maxBuf > 0 && (z.raw.end - z.raw.start >> 0) >= z.maxBuf) {
			z.err = $pkg.ErrBufferExceeded;
			$s = -1; return 0;
		}
		$s = -1; return x$11;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readByte }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f.buf1 = buf1; $f.c = c; $f.d = d; $f.i = i; $f.n = n; $f.x = x; $f.x$1 = x$1; $f.x$10 = x$10; $f.x$11 = x$11; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.x$9 = x$9; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readByte = function() { return this.$val.readByte(); };
	Tokenizer.ptr.prototype.Buffered = function() {
		var z;
		z = this;
		return $subslice(z.buf, z.raw.end);
	};
	Tokenizer.prototype.Buffered = function() { return this.$val.Buffered(); };
	readAtLeastOneByte = function(r, b) {
		var _r, _tuple, b, err, i, n, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; b = $f.b; err = $f.err; i = $f.i; n = $f.n; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < 100)) { break; } */ if(!(i < 100)) { $s = 2; continue; }
			_r = r.Read(b); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_tuple = _r;
			n = _tuple[0];
			err = _tuple[1];
			if (!((n === 0)) || !($interfaceIsEqual(err, $ifaceNil))) {
				$s = -1; return [n, err];
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return [0, io.ErrNoProgress];
		/* */ } return; } if ($f === undefined) { $f = { $blk: readAtLeastOneByte }; } $f._r = _r; $f._tuple = _tuple; $f.b = b; $f.err = err; $f.i = i; $f.n = n; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.ptr.prototype.skipWhiteSpace = function() {
		var _1, _r, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		/* while (true) { */ case 1:
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				$s = -1; return;
			}
			_1 = c;
			if ((_1 === (32)) || (_1 === (10)) || (_1 === (13)) || (_1 === (9)) || (_1 === (12))) {
			} else {
				z.raw.end = z.raw.end - (1) >> 0;
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.skipWhiteSpace }; } $f._1 = _1; $f._r = _r; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.skipWhiteSpace = function() { return this.$val.skipWhiteSpace(); };
	Tokenizer.ptr.prototype.readRawOrRCDATA = function() {
		var _r, _r$1, _r$2, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		/* */ if (z.rawTag === "script") { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (z.rawTag === "script") { */ case 1:
			$r = z.readScript(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			z.textIsRaw = true;
			z.rawTag = "";
			$s = -1; return;
		/* } */ case 2:
		/* while (true) { */ case 4:
			_r = z.readByte(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break loop; */ $s = 5; continue s;
			}
			/* */ if (!((c === 60))) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (!((c === 60))) { */ case 7:
				/* continue loop; */ $s = 4; continue s;
			/* } */ case 8:
			_r$1 = z.readByte(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			c = _r$1;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break loop; */ $s = 5; continue s;
			}
			/* */ if (!((c === 47))) { $s = 10; continue; }
			/* */ $s = 11; continue;
			/* if (!((c === 47))) { */ case 10:
				/* continue loop; */ $s = 4; continue s;
			/* } */ case 11:
			_r$2 = z.readRawEndTag(); /* */ $s = 14; case 14: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			/* */ if (_r$2 || !($interfaceIsEqual(z.err, $ifaceNil))) { $s = 12; continue; }
			/* */ $s = 13; continue;
			/* if (_r$2 || !($interfaceIsEqual(z.err, $ifaceNil))) { */ case 12:
				/* break loop; */ $s = 5; continue s;
			/* } */ case 13:
		/* } */ $s = 4; continue; case 5:
		z.data.end = z.raw.end;
		z.textIsRaw = !(z.rawTag === "textarea") && !(z.rawTag === "title");
		z.rawTag = "";
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readRawOrRCDATA }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readRawOrRCDATA = function() { return this.$val.readRawOrRCDATA(); };
	Tokenizer.ptr.prototype.readRawEndTag = function() {
		var _1, _r, _r$1, c, c$1, i, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; c = $f.c; c$1 = $f.c$1; i = $f.i; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < z.rawTag.length)) { break; } */ if(!(i < z.rawTag.length)) { $s = 2; continue; }
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				$s = -1; return false;
			}
			if (!((c === z.rawTag.charCodeAt(i))) && !((c === (z.rawTag.charCodeAt(i) - 32 << 24 >>> 24)))) {
				z.raw.end = z.raw.end - (1) >> 0;
				$s = -1; return false;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		_r$1 = z.readByte(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		c$1 = _r$1;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return false;
		}
		_1 = c$1;
		if ((_1 === (32)) || (_1 === (10)) || (_1 === (13)) || (_1 === (9)) || (_1 === (12)) || (_1 === (47)) || (_1 === (62))) {
			z.raw.end = z.raw.end - ((3 + z.rawTag.length >> 0)) >> 0;
			$s = -1; return true;
		}
		z.raw.end = z.raw.end - (1) >> 0;
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readRawEndTag }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readRawEndTag = function() { return this.$val.readRawEndTag(); };
	Tokenizer.ptr.prototype.readScript = function() {
		var _1, _2, _3, _4, _5, _6, _7, _8, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, c, i, z, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _6 = $f._6; _7 = $f._7; _8 = $f._8; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; c = $f.c; i = $f.i; z = $f.z; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		z = [z];
		z[0] = this;
		$deferred.push([(function(z) { return function() {
			z[0].data.end = z[0].raw.end;
		}; })(z), []]);
		c = 0;
		/* scriptData: */ case 1:
		_r = z[0].readByte(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		c = _r;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 60) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (c === 60) { */ case 3:
			/* goto scriptDataLessThanSign */ $s = 5; continue;
		/* } */ case 4:
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataLessThanSign: */ case 5:
		_r$1 = z[0].readByte(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		c = _r$1;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_1 = c;
			/* */ if (_1 === (47)) { $s = 8; continue; }
			/* */ if (_1 === (33)) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_1 === (47)) { */ case 8:
				/* goto scriptDataEndTagOpen */ $s = 11; continue;
				$s = 10; continue;
			/* } else if (_1 === (33)) { */ case 9:
				/* goto scriptDataEscapeStart */ $s = 12; continue;
			/* } */ case 10:
		case 7:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEndTagOpen: */ case 11:
		_r$2 = z[0].readRawEndTag(); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		/* */ if (_r$2 || !($interfaceIsEqual(z[0].err, $ifaceNil))) { $s = 13; continue; }
		/* */ $s = 14; continue;
		/* if (_r$2 || !($interfaceIsEqual(z[0].err, $ifaceNil))) { */ case 13:
			$s = -1; return;
		/* } */ case 14:
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEscapeStart: */ case 12:
		_r$3 = z[0].readByte(); /* */ $s = 16; case 16: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		c = _r$3;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 45) { $s = 17; continue; }
		/* */ $s = 18; continue;
		/* if (c === 45) { */ case 17:
			/* goto scriptDataEscapeStartDash */ $s = 19; continue;
		/* } */ case 18:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEscapeStartDash: */ case 19:
		_r$4 = z[0].readByte(); /* */ $s = 20; case 20: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
		c = _r$4;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 45) { $s = 21; continue; }
		/* */ $s = 22; continue;
		/* if (c === 45) { */ case 21:
			/* goto scriptDataEscapedDashDash */ $s = 23; continue;
		/* } */ case 22:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEscaped: */ case 24:
		_r$5 = z[0].readByte(); /* */ $s = 25; case 25: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
		c = _r$5;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_2 = c;
			/* */ if (_2 === (45)) { $s = 27; continue; }
			/* */ if (_2 === (60)) { $s = 28; continue; }
			/* */ $s = 29; continue;
			/* if (_2 === (45)) { */ case 27:
				/* goto scriptDataEscapedDash */ $s = 30; continue;
				$s = 29; continue;
			/* } else if (_2 === (60)) { */ case 28:
				/* goto scriptDataEscapedLessThanSign */ $s = 31; continue;
			/* } */ case 29:
		case 26:
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataEscapedDash: */ case 30:
		_r$6 = z[0].readByte(); /* */ $s = 32; case 32: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
		c = _r$6;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_3 = c;
			/* */ if (_3 === (45)) { $s = 34; continue; }
			/* */ if (_3 === (60)) { $s = 35; continue; }
			/* */ $s = 36; continue;
			/* if (_3 === (45)) { */ case 34:
				/* goto scriptDataEscapedDashDash */ $s = 23; continue;
				$s = 36; continue;
			/* } else if (_3 === (60)) { */ case 35:
				/* goto scriptDataEscapedLessThanSign */ $s = 31; continue;
			/* } */ case 36:
		case 33:
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataEscapedDashDash: */ case 23:
		_r$7 = z[0].readByte(); /* */ $s = 37; case 37: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
		c = _r$7;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_4 = c;
			/* */ if (_4 === (45)) { $s = 39; continue; }
			/* */ if (_4 === (60)) { $s = 40; continue; }
			/* */ if (_4 === (62)) { $s = 41; continue; }
			/* */ $s = 42; continue;
			/* if (_4 === (45)) { */ case 39:
				/* goto scriptDataEscapedDashDash */ $s = 23; continue;
				$s = 42; continue;
			/* } else if (_4 === (60)) { */ case 40:
				/* goto scriptDataEscapedLessThanSign */ $s = 31; continue;
				$s = 42; continue;
			/* } else if (_4 === (62)) { */ case 41:
				/* goto scriptData */ $s = 1; continue;
			/* } */ case 42:
		case 38:
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataEscapedLessThanSign: */ case 31:
		_r$8 = z[0].readByte(); /* */ $s = 43; case 43: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
		c = _r$8;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 47) { $s = 44; continue; }
		/* */ $s = 45; continue;
		/* if (c === 47) { */ case 44:
			/* goto scriptDataEscapedEndTagOpen */ $s = 46; continue;
		/* } */ case 45:
		/* */ if (97 <= c && c <= 122 || 65 <= c && c <= 90) { $s = 47; continue; }
		/* */ $s = 48; continue;
		/* if (97 <= c && c <= 122 || 65 <= c && c <= 90) { */ case 47:
			/* goto scriptDataDoubleEscapeStart */ $s = 49; continue;
		/* } */ case 48:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptData */ $s = 1; continue;
		/* scriptDataEscapedEndTagOpen: */ case 46:
		_r$9 = z[0].readRawEndTag(); /* */ $s = 52; case 52: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
		/* */ if (_r$9 || !($interfaceIsEqual(z[0].err, $ifaceNil))) { $s = 50; continue; }
		/* */ $s = 51; continue;
		/* if (_r$9 || !($interfaceIsEqual(z[0].err, $ifaceNil))) { */ case 50:
			$s = -1; return;
		/* } */ case 51:
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataDoubleEscapeStart: */ case 49:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		i = 0;
		/* while (true) { */ case 53:
			/* if (!(i < 6)) { break; } */ if(!(i < 6)) { $s = 54; continue; }
			_r$10 = z[0].readByte(); /* */ $s = 55; case 55: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
			c = _r$10;
			if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
				$s = -1; return;
			}
			/* */ if (!((c === "script".charCodeAt(i))) && !((c === "SCRIPT".charCodeAt(i)))) { $s = 56; continue; }
			/* */ $s = 57; continue;
			/* if (!((c === "script".charCodeAt(i))) && !((c === "SCRIPT".charCodeAt(i)))) { */ case 56:
				z[0].raw.end = z[0].raw.end - (1) >> 0;
				/* goto scriptDataEscaped */ $s = 24; continue;
			/* } */ case 57:
			i = i + (1) >> 0;
		/* } */ $s = 53; continue; case 54:
		_r$11 = z[0].readByte(); /* */ $s = 58; case 58: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
		c = _r$11;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_5 = c;
			/* */ if ((_5 === (32)) || (_5 === (10)) || (_5 === (13)) || (_5 === (9)) || (_5 === (12)) || (_5 === (47)) || (_5 === (62))) { $s = 60; continue; }
			/* */ $s = 61; continue;
			/* if ((_5 === (32)) || (_5 === (10)) || (_5 === (13)) || (_5 === (9)) || (_5 === (12)) || (_5 === (47)) || (_5 === (62))) { */ case 60:
				/* goto scriptDataDoubleEscaped */ $s = 62; continue;
			/* } */ case 61:
		case 59:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptDataEscaped */ $s = 24; continue;
		/* scriptDataDoubleEscaped: */ case 62:
		_r$12 = z[0].readByte(); /* */ $s = 63; case 63: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
		c = _r$12;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_6 = c;
			/* */ if (_6 === (45)) { $s = 65; continue; }
			/* */ if (_6 === (60)) { $s = 66; continue; }
			/* */ $s = 67; continue;
			/* if (_6 === (45)) { */ case 65:
				/* goto scriptDataDoubleEscapedDash */ $s = 68; continue;
				$s = 67; continue;
			/* } else if (_6 === (60)) { */ case 66:
				/* goto scriptDataDoubleEscapedLessThanSign */ $s = 69; continue;
			/* } */ case 67:
		case 64:
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		/* scriptDataDoubleEscapedDash: */ case 68:
		_r$13 = z[0].readByte(); /* */ $s = 70; case 70: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
		c = _r$13;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_7 = c;
			/* */ if (_7 === (45)) { $s = 72; continue; }
			/* */ if (_7 === (60)) { $s = 73; continue; }
			/* */ $s = 74; continue;
			/* if (_7 === (45)) { */ case 72:
				/* goto scriptDataDoubleEscapedDashDash */ $s = 75; continue;
				$s = 74; continue;
			/* } else if (_7 === (60)) { */ case 73:
				/* goto scriptDataDoubleEscapedLessThanSign */ $s = 69; continue;
			/* } */ case 74:
		case 71:
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		/* scriptDataDoubleEscapedDashDash: */ case 75:
		_r$14 = z[0].readByte(); /* */ $s = 76; case 76: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
		c = _r$14;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
			_8 = c;
			/* */ if (_8 === (45)) { $s = 78; continue; }
			/* */ if (_8 === (60)) { $s = 79; continue; }
			/* */ if (_8 === (62)) { $s = 80; continue; }
			/* */ $s = 81; continue;
			/* if (_8 === (45)) { */ case 78:
				/* goto scriptDataDoubleEscapedDashDash */ $s = 75; continue;
				$s = 81; continue;
			/* } else if (_8 === (60)) { */ case 79:
				/* goto scriptDataDoubleEscapedLessThanSign */ $s = 69; continue;
				$s = 81; continue;
			/* } else if (_8 === (62)) { */ case 80:
				/* goto scriptData */ $s = 1; continue;
			/* } */ case 81:
		case 77:
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		/* scriptDataDoubleEscapedLessThanSign: */ case 69:
		_r$15 = z[0].readByte(); /* */ $s = 82; case 82: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
		c = _r$15;
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* */ if (c === 47) { $s = 83; continue; }
		/* */ $s = 84; continue;
		/* if (c === 47) { */ case 83:
			/* goto scriptDataDoubleEscapeEnd */ $s = 85; continue;
		/* } */ case 84:
		z[0].raw.end = z[0].raw.end - (1) >> 0;
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		/* scriptDataDoubleEscapeEnd: */ case 85:
		_r$16 = z[0].readRawEndTag(); /* */ $s = 88; case 88: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
		/* */ if (_r$16) { $s = 86; continue; }
		/* */ $s = 87; continue;
		/* if (_r$16) { */ case 86:
			z[0].raw.end = z[0].raw.end + (9) >> 0;
			/* goto scriptDataEscaped */ $s = 24; continue;
		/* } */ case 87:
		if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
			$s = -1; return;
		}
		/* goto scriptDataDoubleEscaped */ $s = 62; continue;
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readScript }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._6 = _6; $f._7 = _7; $f._8 = _8; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f.c = c; $f.i = i; $f.z = z; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Tokenizer.prototype.readScript = function() { return this.$val.readScript(); };
	Tokenizer.ptr.prototype.readComment = function() {
		var _1, _r, _r$1, c, dashCount, z, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; c = $f.c; dashCount = $f.dashCount; z = $f.z; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		z = [z];
		z[0] = this;
		z[0].data.start = z[0].raw.end;
		$deferred.push([(function(z) { return function() {
			if (z[0].data.end < z[0].data.start) {
				z[0].data.end = z[0].data.start;
			}
		}; })(z), []]);
		dashCount = 2;
		/* while (true) { */ case 1:
			_r = z[0].readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
				if (dashCount > 2) {
					dashCount = 2;
				}
				z[0].data.end = z[0].raw.end - dashCount >> 0;
				$s = -1; return;
			}
				_1 = c;
				/* */ if (_1 === (45)) { $s = 5; continue; }
				/* */ if (_1 === (62)) { $s = 6; continue; }
				/* */ if (_1 === (33)) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if (_1 === (45)) { */ case 5:
					dashCount = dashCount + (1) >> 0;
					/* continue; */ $s = 1; continue;
					$s = 8; continue;
				/* } else if (_1 === (62)) { */ case 6:
					if (dashCount >= 2) {
						z[0].data.end = z[0].raw.end - 3 >> 0;
						$s = -1; return;
					}
					$s = 8; continue;
				/* } else if (_1 === (33)) { */ case 7:
					/* */ if (dashCount >= 2) { $s = 9; continue; }
					/* */ $s = 10; continue;
					/* if (dashCount >= 2) { */ case 9:
						_r$1 = z[0].readByte(); /* */ $s = 11; case 11: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						c = _r$1;
						if (!($interfaceIsEqual(z[0].err, $ifaceNil))) {
							z[0].data.end = z[0].raw.end;
							$s = -1; return;
						}
						if (c === 62) {
							z[0].data.end = z[0].raw.end - 4 >> 0;
							$s = -1; return;
						}
					/* } */ case 10:
				/* } */ case 8:
			case 4:
			dashCount = 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readComment }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.c = c; $f.dashCount = dashCount; $f.z = z; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Tokenizer.prototype.readComment = function() { return this.$val.readComment(); };
	Tokenizer.ptr.prototype.readUntilCloseAngle = function() {
		var _r, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.data.start = z.raw.end;
		/* while (true) { */ case 1:
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return;
			}
			if (c === 62) {
				z.data.end = z.raw.end - 1 >> 0;
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readUntilCloseAngle }; } $f._r = _r; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readUntilCloseAngle = function() { return this.$val.readUntilCloseAngle(); };
	Tokenizer.ptr.prototype.readMarkupDeclaration = function() {
		var _r, _r$1, _r$2, _v, c, i, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _v = $f._v; c = $f.c; i = $f.i; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.data.start = z.raw.end;
		c = arrayType.zero();
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < 2)) { break; } */ if(!(i < 2)) { $s = 2; continue; }
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			((i < 0 || i >= c.length) ? ($throwRuntimeError("index out of range"), undefined) : c[i] = _r);
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return 5;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		/* */ if ((c[0] === 45) && (c[1] === 45)) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if ((c[0] === 45) && (c[1] === 45)) { */ case 4:
			$r = z.readComment(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return 5;
		/* } */ case 5:
		z.raw.end = z.raw.end - (2) >> 0;
		_r$1 = z.readDoctype(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		/* */ if (_r$1) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (_r$1) { */ case 7:
			$s = -1; return 6;
		/* } */ case 8:
		if (!(z.allowCDATA)) { _v = false; $s = 12; continue s; }
		_r$2 = z.readCDATA(); /* */ $s = 13; case 13: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		_v = _r$2; case 12:
		/* */ if (_v) { $s = 10; continue; }
		/* */ $s = 11; continue;
		/* if (_v) { */ case 10:
			z.convertNUL = true;
			$s = -1; return 1;
		/* } */ case 11:
		$r = z.readUntilCloseAngle(); /* */ $s = 14; case 14: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return 5;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readMarkupDeclaration }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._v = _v; $f.c = c; $f.i = i; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readMarkupDeclaration = function() { return this.$val.readMarkupDeclaration(); };
	Tokenizer.ptr.prototype.readDoctype = function() {
		var _r, c, i, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; i = $f.i; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < 7)) { break; } */ if(!(i < 7)) { $s = 2; continue; }
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return false;
			}
			if (!((c === "DOCTYPE".charCodeAt(i))) && !((c === ("DOCTYPE".charCodeAt(i) + 32 << 24 >>> 24)))) {
				z.raw.end = z.data.start;
				$s = -1; return false;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$r = z.skipWhiteSpace(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			z.data.start = z.raw.end;
			z.data.end = z.raw.end;
			$s = -1; return true;
		}
		$r = z.readUntilCloseAngle(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return true;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readDoctype }; } $f._r = _r; $f.c = c; $f.i = i; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readDoctype = function() { return this.$val.readDoctype(); };
	Tokenizer.ptr.prototype.readCDATA = function() {
		var _1, _r, _r$1, brackets, c, c$1, i, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; brackets = $f.brackets; c = $f.c; c$1 = $f.c$1; i = $f.i; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		i = 0;
		/* while (true) { */ case 1:
			/* if (!(i < 7)) { break; } */ if(!(i < 7)) { $s = 2; continue; }
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return false;
			}
			if (!((c === "[CDATA[".charCodeAt(i)))) {
				z.raw.end = z.data.start;
				$s = -1; return false;
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		z.data.start = z.raw.end;
		brackets = 0;
		/* while (true) { */ case 4:
			_r$1 = z.readByte(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			c$1 = _r$1;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return true;
			}
			_1 = c$1;
			if (_1 === (93)) {
				brackets = brackets + (1) >> 0;
			} else if (_1 === (62)) {
				if (brackets >= 2) {
					z.data.end = z.raw.end - 3 >> 0;
					$s = -1; return true;
				}
				brackets = 0;
			} else {
				brackets = 0;
			}
		/* } */ $s = 4; continue; case 5:
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readCDATA }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.brackets = brackets; $f.c = c; $f.c$1 = c$1; $f.i = i; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readCDATA = function() { return this.$val.readCDATA(); };
	Tokenizer.ptr.prototype.startTagIn = function(ss) {
		var _i, _ref, c, i, s, ss, x, x$1, z;
		z = this;
		_ref = ss;
		_i = 0;
		loop:
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			s = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!(((z.data.end - z.data.start >> 0) === s.length))) {
				_i++;
				continue loop;
			}
			i = 0;
			while (true) {
				if (!(i < s.length)) { break; }
				c = (x = z.buf, x$1 = z.data.start + i >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
				if (65 <= c && c <= 90) {
					c = c + (32) << 24 >>> 24;
				}
				if (!((c === s.charCodeAt(i)))) {
					_i++;
					continue loop;
				}
				i = i + (1) >> 0;
			}
			return true;
		}
		return false;
	};
	Tokenizer.prototype.startTagIn = function(ss) { return this.$val.startTagIn(ss); };
	Tokenizer.ptr.prototype.readStartTag = function() {
		var _1, _r, _tmp, _tmp$1, c, raw, x, x$1, x$2, x$3, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; c = $f.c; raw = $f.raw; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		$r = z.readTag(true); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return 0;
		}
		_tmp = (x = z.buf, x$1 = z.data.start, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		_tmp$1 = false;
		c = _tmp;
		raw = _tmp$1;
		if (65 <= c && c <= 90) {
			c = c + (32) << 24 >>> 24;
		}
		_1 = c;
		if (_1 === (105)) {
			raw = z.startTagIn(new sliceType(["iframe"]));
		} else if (_1 === (110)) {
			raw = z.startTagIn(new sliceType(["noembed", "noframes", "noscript"]));
		} else if (_1 === (112)) {
			raw = z.startTagIn(new sliceType(["plaintext"]));
		} else if (_1 === (115)) {
			raw = z.startTagIn(new sliceType(["script", "style"]));
		} else if (_1 === (116)) {
			raw = z.startTagIn(new sliceType(["textarea", "title"]));
		} else if (_1 === (120)) {
			raw = z.startTagIn(new sliceType(["xmp"]));
		}
		/* */ if (raw) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (raw) { */ case 2:
			_r = strings.ToLower(($bytesToString($subslice(z.buf, z.data.start, z.data.end)))); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			z.rawTag = _r;
		/* } */ case 3:
		if ($interfaceIsEqual(z.err, $ifaceNil) && ((x$2 = z.buf, x$3 = z.raw.end - 2 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])) === 47)) {
			$s = -1; return 4;
		}
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readStartTag }; } $f._1 = _1; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f.c = c; $f.raw = raw; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readStartTag = function() { return this.$val.readStartTag(); };
	Tokenizer.ptr.prototype.readTag = function(saveAttr) {
		var _r, c, saveAttr, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; c = $f.c; saveAttr = $f.saveAttr; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.attr = $subslice(z.attr, 0, 0);
		z.nAttrReturned = 0;
		$r = z.readTagName(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = z.skipWhiteSpace(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		/* while (true) { */ case 3:
			_r = z.readByte(); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil)) || (c === 62)) {
				/* break; */ $s = 4; continue;
			}
			z.raw.end = z.raw.end - (1) >> 0;
			$r = z.readTagAttrKey(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$r = z.readTagAttrVal(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			if (saveAttr && !((z.pendingAttr[0].start === z.pendingAttr[0].end))) {
				z.attr = $append(z.attr, z.pendingAttr);
			}
			$r = z.skipWhiteSpace(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break; */ $s = 4; continue;
			}
		/* } */ $s = 3; continue; case 4:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readTag }; } $f._r = _r; $f.c = c; $f.saveAttr = saveAttr; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readTag = function(saveAttr) { return this.$val.readTag(saveAttr); };
	Tokenizer.ptr.prototype.readTagName = function() {
		var _1, _r, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.data.start = z.raw.end - 1 >> 0;
		/* while (true) { */ case 1:
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.data.end = z.raw.end;
				$s = -1; return;
			}
			_1 = c;
			if ((_1 === (32)) || (_1 === (10)) || (_1 === (13)) || (_1 === (9)) || (_1 === (12))) {
				z.data.end = z.raw.end - 1 >> 0;
				$s = -1; return;
			} else if ((_1 === (47)) || (_1 === (62))) {
				z.raw.end = z.raw.end - (1) >> 0;
				z.data.end = z.raw.end;
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readTagName }; } $f._1 = _1; $f._r = _r; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readTagName = function() { return this.$val.readTagName(); };
	Tokenizer.ptr.prototype.readTagAttrKey = function() {
		var _1, _r, c, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; c = $f.c; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.pendingAttr[0].start = z.raw.end;
		/* while (true) { */ case 1:
			_r = z.readByte(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			c = _r;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				z.pendingAttr[0].end = z.raw.end;
				$s = -1; return;
			}
			_1 = c;
			if ((_1 === (32)) || (_1 === (10)) || (_1 === (13)) || (_1 === (9)) || (_1 === (12)) || (_1 === (47))) {
				z.pendingAttr[0].end = z.raw.end - 1 >> 0;
				$s = -1; return;
			} else if ((_1 === (61)) || (_1 === (62))) {
				z.raw.end = z.raw.end - (1) >> 0;
				z.pendingAttr[0].end = z.raw.end;
				$s = -1; return;
			}
		/* } */ $s = 1; continue; case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readTagAttrKey }; } $f._1 = _1; $f._r = _r; $f.c = c; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readTagAttrKey = function() { return this.$val.readTagAttrKey(); };
	Tokenizer.ptr.prototype.readTagAttrVal = function() {
		var _1, _2, _r, _r$1, _r$2, _r$3, c, c$1, c$2, quote, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; c = $f.c; c$1 = $f.c$1; c$2 = $f.c$2; quote = $f.quote; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.pendingAttr[1].start = z.raw.end;
		z.pendingAttr[1].end = z.raw.end;
		$r = z.skipWhiteSpace(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		_r = z.readByte(); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		c = _r;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		if (!((c === 61))) {
			z.raw.end = z.raw.end - (1) >> 0;
			$s = -1; return;
		}
		$r = z.skipWhiteSpace(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
		_r$1 = z.readByte(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		quote = _r$1;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			$s = -1; return;
		}
			_1 = quote;
			/* */ if (_1 === (62)) { $s = 6; continue; }
			/* */ if ((_1 === (39)) || (_1 === (34))) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (_1 === (62)) { */ case 6:
				z.raw.end = z.raw.end - (1) >> 0;
				$s = -1; return;
			/* } else if ((_1 === (39)) || (_1 === (34))) { */ case 7:
				z.pendingAttr[1].start = z.raw.end;
				/* while (true) { */ case 10:
					_r$2 = z.readByte(); /* */ $s = 12; case 12: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					c$1 = _r$2;
					if (!($interfaceIsEqual(z.err, $ifaceNil))) {
						z.pendingAttr[1].end = z.raw.end;
						$s = -1; return;
					}
					if (c$1 === quote) {
						z.pendingAttr[1].end = z.raw.end - 1 >> 0;
						$s = -1; return;
					}
				/* } */ $s = 10; continue; case 11:
				$s = 9; continue;
			/* } else { */ case 8:
				z.pendingAttr[1].start = z.raw.end - 1 >> 0;
				/* while (true) { */ case 13:
					_r$3 = z.readByte(); /* */ $s = 15; case 15: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					c$2 = _r$3;
					if (!($interfaceIsEqual(z.err, $ifaceNil))) {
						z.pendingAttr[1].end = z.raw.end;
						$s = -1; return;
					}
					_2 = c$2;
					if ((_2 === (32)) || (_2 === (10)) || (_2 === (13)) || (_2 === (9)) || (_2 === (12))) {
						z.pendingAttr[1].end = z.raw.end - 1 >> 0;
						$s = -1; return;
					} else if (_2 === (62)) {
						z.raw.end = z.raw.end - (1) >> 0;
						z.pendingAttr[1].end = z.raw.end;
						$s = -1; return;
					}
				/* } */ $s = 13; continue; case 14:
			/* } */ case 9:
		case 5:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.readTagAttrVal }; } $f._1 = _1; $f._2 = _2; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.c = c; $f.c$1 = c$1; $f.c$2 = c$2; $f.quote = quote; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.readTagAttrVal = function() { return this.$val.readTagAttrVal(); };
	Tokenizer.ptr.prototype.Next = function() {
		var _1, _r, _r$1, _r$2, _r$3, _r$4, _r$5, c, tokenType, x, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; c = $f.c; tokenType = $f.tokenType; x = $f.x; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = this;
		z.raw.start = z.raw.end;
		z.data.start = z.raw.end;
		z.data.end = z.raw.end;
		if (!($interfaceIsEqual(z.err, $ifaceNil))) {
			z.tt = 0;
			$s = -1; return z.tt;
		}
		/* */ if (!(z.rawTag === "")) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(z.rawTag === "")) { */ case 1:
			/* */ if (z.rawTag === "plaintext") { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (z.rawTag === "plaintext") { */ case 3:
				/* while (true) { */ case 6:
					/* if (!($interfaceIsEqual(z.err, $ifaceNil))) { break; } */ if(!($interfaceIsEqual(z.err, $ifaceNil))) { $s = 7; continue; }
					_r = z.readByte(); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					_r;
				/* } */ $s = 6; continue; case 7:
				z.data.end = z.raw.end;
				z.textIsRaw = true;
				$s = 5; continue;
			/* } else { */ case 4:
				$r = z.readRawOrRCDATA(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			/* } */ case 5:
			if (z.data.end > z.data.start) {
				z.tt = 1;
				z.convertNUL = true;
				$s = -1; return z.tt;
			}
		/* } */ case 2:
		z.textIsRaw = false;
		z.convertNUL = false;
		/* while (true) { */ case 10:
			_r$1 = z.readByte(); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			c = _r$1;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break loop; */ $s = 11; continue s;
			}
			/* */ if (!((c === 60))) { $s = 13; continue; }
			/* */ $s = 14; continue;
			/* if (!((c === 60))) { */ case 13:
				/* continue loop; */ $s = 10; continue s;
			/* } */ case 14:
			_r$2 = z.readByte(); /* */ $s = 15; case 15: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			c = _r$2;
			if (!($interfaceIsEqual(z.err, $ifaceNil))) {
				/* break loop; */ $s = 11; continue s;
			}
			tokenType = 0;
				if (97 <= c && c <= 122 || 65 <= c && c <= 90) {
					tokenType = 2;
				} else if ((c === 47)) {
					tokenType = 3;
				} else if ((c === 33) || (c === 63)) {
					tokenType = 5;
				} else {
					z.raw.end = z.raw.end - (1) >> 0;
					/* continue; */ $s = 10; continue;
				}
			case 16:
			x = z.raw.end - 2 >> 0;
			if (z.raw.start < x) {
				z.raw.end = x;
				z.data.end = x;
				z.tt = 1;
				$s = -1; return z.tt;
			}
				_1 = tokenType;
				/* */ if (_1 === (2)) { $s = 18; continue; }
				/* */ if (_1 === (3)) { $s = 19; continue; }
				/* */ if (_1 === (5)) { $s = 20; continue; }
				/* */ $s = 21; continue;
				/* if (_1 === (2)) { */ case 18:
					_r$3 = z.readStartTag(); /* */ $s = 22; case 22: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					z.tt = _r$3;
					$s = -1; return z.tt;
				/* } else if (_1 === (3)) { */ case 19:
					_r$4 = z.readByte(); /* */ $s = 23; case 23: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
					c = _r$4;
					if (!($interfaceIsEqual(z.err, $ifaceNil))) {
						/* break loop; */ $s = 11; continue s;
					}
					if (c === 62) {
						z.tt = 5;
						$s = -1; return z.tt;
					}
					/* */ if (97 <= c && c <= 122 || 65 <= c && c <= 90) { $s = 24; continue; }
					/* */ $s = 25; continue;
					/* if (97 <= c && c <= 122 || 65 <= c && c <= 90) { */ case 24:
						$r = z.readTag(false); /* */ $s = 26; case 26: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						if (!($interfaceIsEqual(z.err, $ifaceNil))) {
							z.tt = 0;
						} else {
							z.tt = 3;
						}
						$s = -1; return z.tt;
					/* } */ case 25:
					z.raw.end = z.raw.end - (1) >> 0;
					$r = z.readUntilCloseAngle(); /* */ $s = 27; case 27: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					z.tt = 5;
					$s = -1; return z.tt;
				/* } else if (_1 === (5)) { */ case 20:
					/* */ if (c === 33) { $s = 28; continue; }
					/* */ $s = 29; continue;
					/* if (c === 33) { */ case 28:
						_r$5 = z.readMarkupDeclaration(); /* */ $s = 30; case 30: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
						z.tt = _r$5;
						$s = -1; return z.tt;
					/* } */ case 29:
					z.raw.end = z.raw.end - (1) >> 0;
					$r = z.readUntilCloseAngle(); /* */ $s = 31; case 31: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					z.tt = 5;
					$s = -1; return z.tt;
				/* } */ case 21:
			case 17:
		/* } */ $s = 10; continue; case 11:
		if (z.raw.start < z.raw.end) {
			z.data.end = z.raw.end;
			z.tt = 1;
			$s = -1; return z.tt;
		}
		z.tt = 0;
		$s = -1; return z.tt;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tokenizer.ptr.prototype.Next }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f.c = c; $f.tokenType = tokenType; $f.x = x; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tokenizer.prototype.Next = function() { return this.$val.Next(); };
	Tokenizer.ptr.prototype.Raw = function() {
		var z;
		z = this;
		return $subslice(z.buf, z.raw.start, z.raw.end);
	};
	Tokenizer.prototype.Raw = function() { return this.$val.Raw(); };
	convertNewlines = function(s) {
		var _i, _ref, c, dst, i, s, src, x;
		_ref = s;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			c = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((c === 13))) {
				_i++;
				continue;
			}
			src = i + 1 >> 0;
			if (src >= s.$length || !((((src < 0 || src >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + src]) === 10))) {
				((i < 0 || i >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + i] = 10);
				_i++;
				continue;
			}
			dst = i;
			while (true) {
				if (!(src < s.$length)) { break; }
				if (((src < 0 || src >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + src]) === 13) {
					if ((src + 1 >> 0) < s.$length && ((x = src + 1 >> 0, ((x < 0 || x >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + x])) === 10)) {
						src = src + (1) >> 0;
					}
					((dst < 0 || dst >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + dst] = 10);
				} else {
					((dst < 0 || dst >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + dst] = ((src < 0 || src >= s.$length) ? ($throwRuntimeError("index out of range"), undefined) : s.$array[s.$offset + src]));
				}
				src = src + (1) >> 0;
				dst = dst + (1) >> 0;
			}
			return $subslice(s, 0, dst);
		}
		return s;
	};
	Tokenizer.ptr.prototype.Text = function() {
		var _1, s, z;
		z = this;
		_1 = z.tt;
		if ((_1 === (1)) || (_1 === (5)) || (_1 === (6))) {
			s = $subslice(z.buf, z.data.start, z.data.end);
			z.data.start = z.raw.end;
			z.data.end = z.raw.end;
			s = convertNewlines(s);
			if ((z.convertNUL || (z.tt === 5)) && bytes.Contains(s, nul)) {
				s = bytes.Replace(s, nul, replacement, -1);
			}
			if (!z.textIsRaw) {
				s = unescape(s, false);
			}
			return s;
		}
		return sliceType$3.nil;
	};
	Tokenizer.prototype.Text = function() { return this.$val.Text(); };
	Tokenizer.ptr.prototype.TagName = function() {
		var _1, _tmp, _tmp$1, _tmp$2, _tmp$3, hasAttr, name, s, z;
		name = sliceType$3.nil;
		hasAttr = false;
		z = this;
		if (z.data.start < z.data.end) {
			_1 = z.tt;
			if ((_1 === (2)) || (_1 === (3)) || (_1 === (4))) {
				s = $subslice(z.buf, z.data.start, z.data.end);
				z.data.start = z.raw.end;
				z.data.end = z.raw.end;
				_tmp = lower(s);
				_tmp$1 = z.nAttrReturned < z.attr.$length;
				name = _tmp;
				hasAttr = _tmp$1;
				return [name, hasAttr];
			}
		}
		_tmp$2 = sliceType$3.nil;
		_tmp$3 = false;
		name = _tmp$2;
		hasAttr = _tmp$3;
		return [name, hasAttr];
	};
	Tokenizer.prototype.TagName = function() { return this.$val.TagName(); };
	Tokenizer.ptr.prototype.TagAttr = function() {
		var _1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, key, moreAttr, val, x, x$1, x$2, z;
		key = sliceType$3.nil;
		val = sliceType$3.nil;
		moreAttr = false;
		z = this;
		if (z.nAttrReturned < z.attr.$length) {
			_1 = z.tt;
			if ((_1 === (2)) || (_1 === (4))) {
				x$2 = $clone((x = z.attr, x$1 = z.nAttrReturned, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])), arrayType$1);
				z.nAttrReturned = z.nAttrReturned + (1) >> 0;
				key = $subslice(z.buf, x$2[0].start, x$2[0].end);
				val = $subslice(z.buf, x$2[1].start, x$2[1].end);
				_tmp = lower(key);
				_tmp$1 = unescape(convertNewlines(val), true);
				_tmp$2 = z.nAttrReturned < z.attr.$length;
				key = _tmp;
				val = _tmp$1;
				moreAttr = _tmp$2;
				return [key, val, moreAttr];
			}
		}
		_tmp$3 = sliceType$3.nil;
		_tmp$4 = sliceType$3.nil;
		_tmp$5 = false;
		key = _tmp$3;
		val = _tmp$4;
		moreAttr = _tmp$5;
		return [key, val, moreAttr];
	};
	Tokenizer.prototype.TagAttr = function() { return this.$val.TagAttr(); };
	Tokenizer.ptr.prototype.Token = function() {
		var _1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, _tuple$1, a, key, moreAttr, name, t, val, z;
		z = this;
		t = new Token.ptr(z.tt, 0, "", sliceType$1.nil);
		_1 = z.tt;
		if ((_1 === (1)) || (_1 === (5)) || (_1 === (6))) {
			t.Data = ($bytesToString(z.Text()));
		} else if ((_1 === (2)) || (_1 === (4)) || (_1 === (3))) {
			_tuple = z.TagName();
			name = _tuple[0];
			moreAttr = _tuple[1];
			while (true) {
				if (!(moreAttr)) { break; }
				_tmp = sliceType$3.nil;
				_tmp$1 = sliceType$3.nil;
				key = _tmp;
				val = _tmp$1;
				_tuple$1 = z.TagAttr();
				key = _tuple$1[0];
				val = _tuple$1[1];
				moreAttr = _tuple$1[2];
				t.Attr = $append(t.Attr, new Attribute.ptr("", atom.String(key), ($bytesToString(val))));
			}
			a = atom.Lookup(name);
			if (!((a === 0))) {
				_tmp$2 = a;
				_tmp$3 = new atom.Atom(a).String();
				t.DataAtom = _tmp$2;
				t.Data = _tmp$3;
			} else {
				_tmp$4 = 0;
				_tmp$5 = ($bytesToString(name));
				t.DataAtom = _tmp$4;
				t.Data = _tmp$5;
			}
		}
		return t;
	};
	Tokenizer.prototype.Token = function() { return this.$val.Token(); };
	Tokenizer.ptr.prototype.SetMaxBuf = function(n) {
		var n, z;
		z = this;
		z.maxBuf = n;
	};
	Tokenizer.prototype.SetMaxBuf = function(n) { return this.$val.SetMaxBuf(n); };
	NewTokenizer = function(r) {
		var _r, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = NewTokenizerFragment(r, ""); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewTokenizer }; } $f._r = _r; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewTokenizer = NewTokenizer;
	NewTokenizerFragment = function(r, contextTag) {
		var _1, _r, contextTag, r, s, z, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; contextTag = $f.contextTag; r = $f.r; s = $f.s; z = $f.z; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		z = new Tokenizer.ptr(r, 0, $ifaceNil, $ifaceNil, new span.ptr(0, 0), $makeSlice(sliceType$3, 0, 4096), 0, new span.ptr(0, 0), arrayType$1.zero(), sliceType$7.nil, 0, "", false, false, false);
		/* */ if (!(contextTag === "")) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!(contextTag === "")) { */ case 1:
				_r = strings.ToLower(contextTag); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				s = _r;
				_1 = s;
				if (_1 === ("iframe") || _1 === ("noembed") || _1 === ("noframes") || _1 === ("noscript") || _1 === ("plaintext") || _1 === ("script") || _1 === ("style") || _1 === ("title") || _1 === ("textarea") || _1 === ("xmp")) {
					z.rawTag = s;
				}
			case 3:
		/* } */ case 2:
		$s = -1; return z;
		/* */ } return; } if ($f === undefined) { $f = { $blk: NewTokenizerFragment }; } $f._1 = _1; $f._r = _r; $f.contextTag = contextTag; $f.r = r; $f.s = s; $f.z = z; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.NewTokenizerFragment = NewTokenizerFragment;
	ptrType.methods = [{prop: "Unlink", name: "Unlink", pkg: "", typ: $funcType([], [], false)}, {prop: "InsertBefore", name: "InsertBefore", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "InsertAfter", name: "InsertAfter", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "InsertChildBefore", name: "InsertChildBefore", pkg: "", typ: $funcType([ptrType, ptrType], [], false)}, {prop: "AppendChild", name: "AppendChild", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "RemoveChild", name: "RemoveChild", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "clone", name: "clone", pkg: "lute/html", typ: $funcType([], [ptrType], false)}];
	ptrType$1.methods = [{prop: "pop", name: "pop", pkg: "lute/html", typ: $funcType([], [ptrType], false)}, {prop: "top", name: "top", pkg: "lute/html", typ: $funcType([], [ptrType], false)}, {prop: "index", name: "index", pkg: "lute/html", typ: $funcType([ptrType], [$Int], false)}, {prop: "contains", name: "contains", pkg: "lute/html", typ: $funcType([atom.Atom], [$Bool], false)}, {prop: "insert", name: "insert", pkg: "lute/html", typ: $funcType([$Int, ptrType], [], false)}, {prop: "remove", name: "remove", pkg: "lute/html", typ: $funcType([ptrType], [], false)}];
	ptrType$2.methods = [{prop: "pop", name: "pop", pkg: "lute/html", typ: $funcType([], [insertionMode], false)}, {prop: "top", name: "top", pkg: "lute/html", typ: $funcType([], [insertionMode], false)}];
	ptrType$4.methods = [{prop: "top", name: "top", pkg: "lute/html", typ: $funcType([], [ptrType], false)}, {prop: "popUntil", name: "popUntil", pkg: "lute/html", typ: $funcType([scope, sliceType$2], [$Bool], true)}, {prop: "indexOfElementInScope", name: "indexOfElementInScope", pkg: "lute/html", typ: $funcType([scope, sliceType$2], [$Int], true)}, {prop: "elementInScope", name: "elementInScope", pkg: "lute/html", typ: $funcType([scope, sliceType$2], [$Bool], true)}, {prop: "clearStackToContext", name: "clearStackToContext", pkg: "lute/html", typ: $funcType([scope], [], false)}, {prop: "generateImpliedEndTags", name: "generateImpliedEndTags", pkg: "lute/html", typ: $funcType([sliceType], [], true)}, {prop: "addChild", name: "addChild", pkg: "lute/html", typ: $funcType([ptrType], [], false)}, {prop: "shouldFosterParent", name: "shouldFosterParent", pkg: "lute/html", typ: $funcType([], [$Bool], false)}, {prop: "fosterParent", name: "fosterParent", pkg: "lute/html", typ: $funcType([ptrType], [], false)}, {prop: "addText", name: "addText", pkg: "lute/html", typ: $funcType([$String], [], false)}, {prop: "addElement", name: "addElement", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "addFormattingElement", name: "addFormattingElement", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "clearActiveFormattingElements", name: "clearActiveFormattingElements", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "reconstructActiveFormattingElements", name: "reconstructActiveFormattingElements", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "acknowledgeSelfClosingTag", name: "acknowledgeSelfClosingTag", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "setOriginalIM", name: "setOriginalIM", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "resetInsertionMode", name: "resetInsertionMode", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "inBodyEndTagFormatting", name: "inBodyEndTagFormatting", pkg: "lute/html", typ: $funcType([atom.Atom, $String], [], false)}, {prop: "inBodyEndTagOther", name: "inBodyEndTagOther", pkg: "lute/html", typ: $funcType([atom.Atom, $String], [], false)}, {prop: "inForeignContent", name: "inForeignContent", pkg: "lute/html", typ: $funcType([], [$Bool], false)}, {prop: "parseImpliedToken", name: "parseImpliedToken", pkg: "lute/html", typ: $funcType([TokenType, atom.Atom, $String], [], false)}, {prop: "parseCurrentToken", name: "parseCurrentToken", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "parse", name: "parse", pkg: "lute/html", typ: $funcType([], [$error], false)}];
	TokenType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Token.methods = [{prop: "tagString", name: "tagString", pkg: "lute/html", typ: $funcType([], [$String], false)}, {prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	ptrType$3.methods = [{prop: "AllowCDATA", name: "AllowCDATA", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "NextIsNotRawText", name: "NextIsNotRawText", pkg: "", typ: $funcType([], [], false)}, {prop: "Err", name: "Err", pkg: "", typ: $funcType([], [$error], false)}, {prop: "readByte", name: "readByte", pkg: "lute/html", typ: $funcType([], [$Uint8], false)}, {prop: "Buffered", name: "Buffered", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "skipWhiteSpace", name: "skipWhiteSpace", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "readRawOrRCDATA", name: "readRawOrRCDATA", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "readRawEndTag", name: "readRawEndTag", pkg: "lute/html", typ: $funcType([], [$Bool], false)}, {prop: "readScript", name: "readScript", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "readComment", name: "readComment", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "readUntilCloseAngle", name: "readUntilCloseAngle", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "readMarkupDeclaration", name: "readMarkupDeclaration", pkg: "lute/html", typ: $funcType([], [TokenType], false)}, {prop: "readDoctype", name: "readDoctype", pkg: "lute/html", typ: $funcType([], [$Bool], false)}, {prop: "readCDATA", name: "readCDATA", pkg: "lute/html", typ: $funcType([], [$Bool], false)}, {prop: "startTagIn", name: "startTagIn", pkg: "lute/html", typ: $funcType([sliceType], [$Bool], true)}, {prop: "readStartTag", name: "readStartTag", pkg: "lute/html", typ: $funcType([], [TokenType], false)}, {prop: "readTag", name: "readTag", pkg: "lute/html", typ: $funcType([$Bool], [], false)}, {prop: "readTagName", name: "readTagName", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "readTagAttrKey", name: "readTagAttrKey", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "readTagAttrVal", name: "readTagAttrVal", pkg: "lute/html", typ: $funcType([], [], false)}, {prop: "Next", name: "Next", pkg: "", typ: $funcType([], [TokenType], false)}, {prop: "Raw", name: "Raw", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "Text", name: "Text", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "TagName", name: "TagName", pkg: "", typ: $funcType([], [sliceType$3, $Bool], false)}, {prop: "TagAttr", name: "TagAttr", pkg: "", typ: $funcType([], [sliceType$3, sliceType$3, $Bool], false)}, {prop: "Token", name: "Token", pkg: "", typ: $funcType([], [Token], false)}, {prop: "SetMaxBuf", name: "SetMaxBuf", pkg: "", typ: $funcType([$Int], [], false)}];
	Node.init("", [{prop: "Parent", name: "Parent", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "FirstChild", name: "FirstChild", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "LastChild", name: "LastChild", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "PrevSibling", name: "PrevSibling", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "NextSibling", name: "NextSibling", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "Type", name: "Type", embedded: false, exported: true, typ: NodeType, tag: ""}, {prop: "DataAtom", name: "DataAtom", embedded: false, exported: true, typ: atom.Atom, tag: ""}, {prop: "Data", name: "Data", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Namespace", name: "Namespace", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Attr", name: "Attr", embedded: false, exported: true, typ: sliceType$1, tag: ""}]);
	nodeStack.init(ptrType);
	insertionModeStack.init(insertionMode);
	parser.init("lute/html", [{prop: "tokenizer", name: "tokenizer", embedded: false, exported: false, typ: ptrType$3, tag: ""}, {prop: "tok", name: "tok", embedded: false, exported: false, typ: Token, tag: ""}, {prop: "hasSelfClosingToken", name: "hasSelfClosingToken", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "doc", name: "doc", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "oe", name: "oe", embedded: false, exported: false, typ: nodeStack, tag: ""}, {prop: "afe", name: "afe", embedded: false, exported: false, typ: nodeStack, tag: ""}, {prop: "head", name: "head", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "form", name: "form", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "scripting", name: "scripting", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "framesetOK", name: "framesetOK", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "templateStack", name: "templateStack", embedded: false, exported: false, typ: insertionModeStack, tag: ""}, {prop: "im", name: "im", embedded: false, exported: false, typ: insertionMode, tag: ""}, {prop: "originalIM", name: "originalIM", embedded: false, exported: false, typ: insertionMode, tag: ""}, {prop: "fosterParenting", name: "fosterParenting", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "quirks", name: "quirks", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "fragment", name: "fragment", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "context", name: "context", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	insertionMode.init([ptrType$4], [$Bool], false);
	ParseOption.init([ptrType$4], [], false);
	writer.init([{prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$3], [$Int, $error], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [$error], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [$Int, $error], false)}]);
	Attribute.init("", [{prop: "Namespace", name: "Namespace", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Key", name: "Key", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Val", name: "Val", embedded: false, exported: true, typ: $String, tag: ""}]);
	Token.init("", [{prop: "Type", name: "Type", embedded: false, exported: true, typ: TokenType, tag: ""}, {prop: "DataAtom", name: "DataAtom", embedded: false, exported: true, typ: atom.Atom, tag: ""}, {prop: "Data", name: "Data", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Attr", name: "Attr", embedded: false, exported: true, typ: sliceType$1, tag: ""}]);
	span.init("lute/html", [{prop: "start", name: "start", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "end", name: "end", embedded: false, exported: false, typ: $Int, tag: ""}]);
	Tokenizer.init("lute/html", [{prop: "r", name: "r", embedded: false, exported: false, typ: io.Reader, tag: ""}, {prop: "tt", name: "tt", embedded: false, exported: false, typ: TokenType, tag: ""}, {prop: "err", name: "err", embedded: false, exported: false, typ: $error, tag: ""}, {prop: "readErr", name: "readErr", embedded: false, exported: false, typ: $error, tag: ""}, {prop: "raw", name: "raw", embedded: false, exported: false, typ: span, tag: ""}, {prop: "buf", name: "buf", embedded: false, exported: false, typ: sliceType$3, tag: ""}, {prop: "maxBuf", name: "maxBuf", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "data", name: "data", embedded: false, exported: false, typ: span, tag: ""}, {prop: "pendingAttr", name: "pendingAttr", embedded: false, exported: false, typ: arrayType$1, tag: ""}, {prop: "attr", name: "attr", embedded: false, exported: false, typ: sliceType$7, tag: ""}, {prop: "nAttrReturned", name: "nAttrReturned", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "rawTag", name: "rawTag", embedded: false, exported: false, typ: $String, tag: ""}, {prop: "textIsRaw", name: "textIsRaw", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "convertNUL", name: "convertNUL", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "allowCDATA", name: "allowCDATA", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bufio.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = bytes.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = errors.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atom.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		isSpecialElementMap = $makeMap($String.keyFor, [{ k: "address", v: true }, { k: "applet", v: true }, { k: "area", v: true }, { k: "article", v: true }, { k: "aside", v: true }, { k: "base", v: true }, { k: "basefont", v: true }, { k: "bgsound", v: true }, { k: "blockquote", v: true }, { k: "body", v: true }, { k: "br", v: true }, { k: "button", v: true }, { k: "caption", v: true }, { k: "center", v: true }, { k: "col", v: true }, { k: "colgroup", v: true }, { k: "dd", v: true }, { k: "details", v: true }, { k: "dir", v: true }, { k: "div", v: true }, { k: "dl", v: true }, { k: "dt", v: true }, { k: "embed", v: true }, { k: "fieldset", v: true }, { k: "figcaption", v: true }, { k: "figure", v: true }, { k: "footer", v: true }, { k: "form", v: true }, { k: "frame", v: true }, { k: "frameset", v: true }, { k: "h1", v: true }, { k: "h2", v: true }, { k: "h3", v: true }, { k: "h4", v: true }, { k: "h5", v: true }, { k: "h6", v: true }, { k: "head", v: true }, { k: "header", v: true }, { k: "hgroup", v: true }, { k: "hr", v: true }, { k: "html", v: true }, { k: "iframe", v: true }, { k: "img", v: true }, { k: "input", v: true }, { k: "isindex", v: true }, { k: "keygen", v: true }, { k: "li", v: true }, { k: "link", v: true }, { k: "listing", v: true }, { k: "main", v: true }, { k: "marquee", v: true }, { k: "menu", v: true }, { k: "meta", v: true }, { k: "nav", v: true }, { k: "noembed", v: true }, { k: "noframes", v: true }, { k: "noscript", v: true }, { k: "object", v: true }, { k: "ol", v: true }, { k: "p", v: true }, { k: "param", v: true }, { k: "plaintext", v: true }, { k: "pre", v: true }, { k: "script", v: true }, { k: "section", v: true }, { k: "select", v: true }, { k: "source", v: true }, { k: "style", v: true }, { k: "summary", v: true }, { k: "table", v: true }, { k: "tbody", v: true }, { k: "td", v: true }, { k: "template", v: true }, { k: "textarea", v: true }, { k: "tfoot", v: true }, { k: "th", v: true }, { k: "thead", v: true }, { k: "title", v: true }, { k: "tr", v: true }, { k: "track", v: true }, { k: "ul", v: true }, { k: "wbr", v: true }, { k: "xmp", v: true }]);
		$pkg.Entities = $makeMap($String.keyFor, [{ k: "AElig;", v: "\xC3\x86" }, { k: "AMP;", v: "&" }, { k: "Aacute;", v: "\xC3\x81" }, { k: "Abreve;", v: "\xC4\x82" }, { k: "Acirc;", v: "\xC3\x82" }, { k: "Acy;", v: "\xD0\x90" }, { k: "Afr;", v: "\xF0\x9D\x94\x84" }, { k: "Agrave;", v: "\xC3\x80" }, { k: "Alpha;", v: "\xCE\x91" }, { k: "Amacr;", v: "\xC4\x80" }, { k: "And;", v: "\xE2\xA9\x93" }, { k: "Aogon;", v: "\xC4\x84" }, { k: "Aopf;", v: "\xF0\x9D\x94\xB8" }, { k: "ApplyFunction;", v: "\xE2\x81\xA1" }, { k: "Aring;", v: "\xC3\x85" }, { k: "Ascr;", v: "\xF0\x9D\x92\x9C" }, { k: "Assign;", v: "\xE2\x89\x94" }, { k: "Atilde;", v: "\xC3\x83" }, { k: "Auml;", v: "\xC3\x84" }, { k: "Backslash;", v: "\xE2\x88\x96" }, { k: "Barv;", v: "\xE2\xAB\xA7" }, { k: "Barwed;", v: "\xE2\x8C\x86" }, { k: "Bcy;", v: "\xD0\x91" }, { k: "Because;", v: "\xE2\x88\xB5" }, { k: "Bernoullis;", v: "\xE2\x84\xAC" }, { k: "Beta;", v: "\xCE\x92" }, { k: "Bfr;", v: "\xF0\x9D\x94\x85" }, { k: "Bopf;", v: "\xF0\x9D\x94\xB9" }, { k: "Breve;", v: "\xCB\x98" }, { k: "Bscr;", v: "\xE2\x84\xAC" }, { k: "Bumpeq;", v: "\xE2\x89\x8E" }, { k: "CHcy;", v: "\xD0\xA7" }, { k: "COPY;", v: "\xC2\xA9" }, { k: "Cacute;", v: "\xC4\x86" }, { k: "Cap;", v: "\xE2\x8B\x92" }, { k: "CapitalDifferentialD;", v: "\xE2\x85\x85" }, { k: "Cayleys;", v: "\xE2\x84\xAD" }, { k: "Ccaron;", v: "\xC4\x8C" }, { k: "Ccedil;", v: "\xC3\x87" }, { k: "Ccirc;", v: "\xC4\x88" }, { k: "Cconint;", v: "\xE2\x88\xB0" }, { k: "Cdot;", v: "\xC4\x8A" }, { k: "Cedilla;", v: "\xC2\xB8" }, { k: "CenterDot;", v: "\xC2\xB7" }, { k: "Cfr;", v: "\xE2\x84\xAD" }, { k: "Chi;", v: "\xCE\xA7" }, { k: "CircleDot;", v: "\xE2\x8A\x99" }, { k: "CircleMinus;", v: "\xE2\x8A\x96" }, { k: "CirclePlus;", v: "\xE2\x8A\x95" }, { k: "CircleTimes;", v: "\xE2\x8A\x97" }, { k: "ClockwiseContourIntegral;", v: "\xE2\x88\xB2" }, { k: "CloseCurlyDoubleQuote;", v: "\xE2\x80\x9D" }, { k: "CloseCurlyQuote;", v: "\xE2\x80\x99" }, { k: "Colon;", v: "\xE2\x88\xB7" }, { k: "Colone;", v: "\xE2\xA9\xB4" }, { k: "Congruent;", v: "\xE2\x89\xA1" }, { k: "Conint;", v: "\xE2\x88\xAF" }, { k: "ContourIntegral;", v: "\xE2\x88\xAE" }, { k: "Copf;", v: "\xE2\x84\x82" }, { k: "Coproduct;", v: "\xE2\x88\x90" }, { k: "CounterClockwiseContourIntegral;", v: "\xE2\x88\xB3" }, { k: "Cross;", v: "\xE2\xA8\xAF" }, { k: "Cscr;", v: "\xF0\x9D\x92\x9E" }, { k: "Cup;", v: "\xE2\x8B\x93" }, { k: "CupCap;", v: "\xE2\x89\x8D" }, { k: "DD;", v: "\xE2\x85\x85" }, { k: "DDotrahd;", v: "\xE2\xA4\x91" }, { k: "DJcy;", v: "\xD0\x82" }, { k: "DScy;", v: "\xD0\x85" }, { k: "DZcy;", v: "\xD0\x8F" }, { k: "Dagger;", v: "\xE2\x80\xA1" }, { k: "Darr;", v: "\xE2\x86\xA1" }, { k: "Dashv;", v: "\xE2\xAB\xA4" }, { k: "Dcaron;", v: "\xC4\x8E" }, { k: "Dcy;", v: "\xD0\x94" }, { k: "Del;", v: "\xE2\x88\x87" }, { k: "Delta;", v: "\xCE\x94" }, { k: "Dfr;", v: "\xF0\x9D\x94\x87" }, { k: "DiacriticalAcute;", v: "\xC2\xB4" }, { k: "DiacriticalDot;", v: "\xCB\x99" }, { k: "DiacriticalDoubleAcute;", v: "\xCB\x9D" }, { k: "DiacriticalGrave;", v: "`" }, { k: "DiacriticalTilde;", v: "\xCB\x9C" }, { k: "Diamond;", v: "\xE2\x8B\x84" }, { k: "DifferentialD;", v: "\xE2\x85\x86" }, { k: "Dopf;", v: "\xF0\x9D\x94\xBB" }, { k: "Dot;", v: "\xC2\xA8" }, { k: "DotDot;", v: "\xE2\x83\x9C" }, { k: "DotEqual;", v: "\xE2\x89\x90" }, { k: "DoubleContourIntegral;", v: "\xE2\x88\xAF" }, { k: "DoubleDot;", v: "\xC2\xA8" }, { k: "DoubleDownArrow;", v: "\xE2\x87\x93" }, { k: "DoubleLeftArrow;", v: "\xE2\x87\x90" }, { k: "DoubleLeftRightArrow;", v: "\xE2\x87\x94" }, { k: "DoubleLeftTee;", v: "\xE2\xAB\xA4" }, { k: "DoubleLongLeftArrow;", v: "\xE2\x9F\xB8" }, { k: "DoubleLongLeftRightArrow;", v: "\xE2\x9F\xBA" }, { k: "DoubleLongRightArrow;", v: "\xE2\x9F\xB9" }, { k: "DoubleRightArrow;", v: "\xE2\x87\x92" }, { k: "DoubleRightTee;", v: "\xE2\x8A\xA8" }, { k: "DoubleUpArrow;", v: "\xE2\x87\x91" }, { k: "DoubleUpDownArrow;", v: "\xE2\x87\x95" }, { k: "DoubleVerticalBar;", v: "\xE2\x88\xA5" }, { k: "DownArrow;", v: "\xE2\x86\x93" }, { k: "DownArrowBar;", v: "\xE2\xA4\x93" }, { k: "DownArrowUpArrow;", v: "\xE2\x87\xB5" }, { k: "DownBreve;", v: "\xCC\x91" }, { k: "DownLeftRightVector;", v: "\xE2\xA5\x90" }, { k: "DownLeftTeeVector;", v: "\xE2\xA5\x9E" }, { k: "DownLeftVector;", v: "\xE2\x86\xBD" }, { k: "DownLeftVectorBar;", v: "\xE2\xA5\x96" }, { k: "DownRightTeeVector;", v: "\xE2\xA5\x9F" }, { k: "DownRightVector;", v: "\xE2\x87\x81" }, { k: "DownRightVectorBar;", v: "\xE2\xA5\x97" }, { k: "DownTee;", v: "\xE2\x8A\xA4" }, { k: "DownTeeArrow;", v: "\xE2\x86\xA7" }, { k: "Downarrow;", v: "\xE2\x87\x93" }, { k: "Dscr;", v: "\xF0\x9D\x92\x9F" }, { k: "Dstrok;", v: "\xC4\x90" }, { k: "ENG;", v: "\xC5\x8A" }, { k: "ETH;", v: "\xC3\x90" }, { k: "Eacute;", v: "\xC3\x89" }, { k: "Ecaron;", v: "\xC4\x9A" }, { k: "Ecirc;", v: "\xC3\x8A" }, { k: "Ecy;", v: "\xD0\xAD" }, { k: "Edot;", v: "\xC4\x96" }, { k: "Efr;", v: "\xF0\x9D\x94\x88" }, { k: "Egrave;", v: "\xC3\x88" }, { k: "Element;", v: "\xE2\x88\x88" }, { k: "Emacr;", v: "\xC4\x92" }, { k: "EmptySmallSquare;", v: "\xE2\x97\xBB" }, { k: "EmptyVerySmallSquare;", v: "\xE2\x96\xAB" }, { k: "Eogon;", v: "\xC4\x98" }, { k: "Eopf;", v: "\xF0\x9D\x94\xBC" }, { k: "Epsilon;", v: "\xCE\x95" }, { k: "Equal;", v: "\xE2\xA9\xB5" }, { k: "EqualTilde;", v: "\xE2\x89\x82" }, { k: "Equilibrium;", v: "\xE2\x87\x8C" }, { k: "Escr;", v: "\xE2\x84\xB0" }, { k: "Esim;", v: "\xE2\xA9\xB3" }, { k: "Eta;", v: "\xCE\x97" }, { k: "Euml;", v: "\xC3\x8B" }, { k: "Exists;", v: "\xE2\x88\x83" }, { k: "ExponentialE;", v: "\xE2\x85\x87" }, { k: "Fcy;", v: "\xD0\xA4" }, { k: "Ffr;", v: "\xF0\x9D\x94\x89" }, { k: "FilledSmallSquare;", v: "\xE2\x97\xBC" }, { k: "FilledVerySmallSquare;", v: "\xE2\x96\xAA" }, { k: "Fopf;", v: "\xF0\x9D\x94\xBD" }, { k: "ForAll;", v: "\xE2\x88\x80" }, { k: "Fouriertrf;", v: "\xE2\x84\xB1" }, { k: "Fscr;", v: "\xE2\x84\xB1" }, { k: "GJcy;", v: "\xD0\x83" }, { k: "GT;", v: ">" }, { k: "Gamma;", v: "\xCE\x93" }, { k: "Gammad;", v: "\xCF\x9C" }, { k: "Gbreve;", v: "\xC4\x9E" }, { k: "Gcedil;", v: "\xC4\xA2" }, { k: "Gcirc;", v: "\xC4\x9C" }, { k: "Gcy;", v: "\xD0\x93" }, { k: "Gdot;", v: "\xC4\xA0" }, { k: "Gfr;", v: "\xF0\x9D\x94\x8A" }, { k: "Gg;", v: "\xE2\x8B\x99" }, { k: "Gopf;", v: "\xF0\x9D\x94\xBE" }, { k: "GreaterEqual;", v: "\xE2\x89\xA5" }, { k: "GreaterEqualLess;", v: "\xE2\x8B\x9B" }, { k: "GreaterFullEqual;", v: "\xE2\x89\xA7" }, { k: "GreaterGreater;", v: "\xE2\xAA\xA2" }, { k: "GreaterLess;", v: "\xE2\x89\xB7" }, { k: "GreaterSlantEqual;", v: "\xE2\xA9\xBE" }, { k: "GreaterTilde;", v: "\xE2\x89\xB3" }, { k: "Gscr;", v: "\xF0\x9D\x92\xA2" }, { k: "Gt;", v: "\xE2\x89\xAB" }, { k: "HARDcy;", v: "\xD0\xAA" }, { k: "Hacek;", v: "\xCB\x87" }, { k: "Hat;", v: "^" }, { k: "Hcirc;", v: "\xC4\xA4" }, { k: "Hfr;", v: "\xE2\x84\x8C" }, { k: "HilbertSpace;", v: "\xE2\x84\x8B" }, { k: "Hopf;", v: "\xE2\x84\x8D" }, { k: "HorizontalLine;", v: "\xE2\x94\x80" }, { k: "Hscr;", v: "\xE2\x84\x8B" }, { k: "Hstrok;", v: "\xC4\xA6" }, { k: "HumpDownHump;", v: "\xE2\x89\x8E" }, { k: "HumpEqual;", v: "\xE2\x89\x8F" }, { k: "IEcy;", v: "\xD0\x95" }, { k: "IJlig;", v: "\xC4\xB2" }, { k: "IOcy;", v: "\xD0\x81" }, { k: "Iacute;", v: "\xC3\x8D" }, { k: "Icirc;", v: "\xC3\x8E" }, { k: "Icy;", v: "\xD0\x98" }, { k: "Idot;", v: "\xC4\xB0" }, { k: "Ifr;", v: "\xE2\x84\x91" }, { k: "Igrave;", v: "\xC3\x8C" }, { k: "Im;", v: "\xE2\x84\x91" }, { k: "Imacr;", v: "\xC4\xAA" }, { k: "ImaginaryI;", v: "\xE2\x85\x88" }, { k: "Implies;", v: "\xE2\x87\x92" }, { k: "Int;", v: "\xE2\x88\xAC" }, { k: "Integral;", v: "\xE2\x88\xAB" }, { k: "Intersection;", v: "\xE2\x8B\x82" }, { k: "InvisibleComma;", v: "\xE2\x81\xA3" }, { k: "InvisibleTimes;", v: "\xE2\x81\xA2" }, { k: "Iogon;", v: "\xC4\xAE" }, { k: "Iopf;", v: "\xF0\x9D\x95\x80" }, { k: "Iota;", v: "\xCE\x99" }, { k: "Iscr;", v: "\xE2\x84\x90" }, { k: "Itilde;", v: "\xC4\xA8" }, { k: "Iukcy;", v: "\xD0\x86" }, { k: "Iuml;", v: "\xC3\x8F" }, { k: "Jcirc;", v: "\xC4\xB4" }, { k: "Jcy;", v: "\xD0\x99" }, { k: "Jfr;", v: "\xF0\x9D\x94\x8D" }, { k: "Jopf;", v: "\xF0\x9D\x95\x81" }, { k: "Jscr;", v: "\xF0\x9D\x92\xA5" }, { k: "Jsercy;", v: "\xD0\x88" }, { k: "Jukcy;", v: "\xD0\x84" }, { k: "KHcy;", v: "\xD0\xA5" }, { k: "KJcy;", v: "\xD0\x8C" }, { k: "Kappa;", v: "\xCE\x9A" }, { k: "Kcedil;", v: "\xC4\xB6" }, { k: "Kcy;", v: "\xD0\x9A" }, { k: "Kfr;", v: "\xF0\x9D\x94\x8E" }, { k: "Kopf;", v: "\xF0\x9D\x95\x82" }, { k: "Kscr;", v: "\xF0\x9D\x92\xA6" }, { k: "LJcy;", v: "\xD0\x89" }, { k: "LT;", v: "<" }, { k: "Lacute;", v: "\xC4\xB9" }, { k: "Lambda;", v: "\xCE\x9B" }, { k: "Lang;", v: "\xE2\x9F\xAA" }, { k: "Laplacetrf;", v: "\xE2\x84\x92" }, { k: "Larr;", v: "\xE2\x86\x9E" }, { k: "Lcaron;", v: "\xC4\xBD" }, { k: "Lcedil;", v: "\xC4\xBB" }, { k: "Lcy;", v: "\xD0\x9B" }, { k: "LeftAngleBracket;", v: "\xE2\x9F\xA8" }, { k: "LeftArrow;", v: "\xE2\x86\x90" }, { k: "LeftArrowBar;", v: "\xE2\x87\xA4" }, { k: "LeftArrowRightArrow;", v: "\xE2\x87\x86" }, { k: "LeftCeiling;", v: "\xE2\x8C\x88" }, { k: "LeftDoubleBracket;", v: "\xE2\x9F\xA6" }, { k: "LeftDownTeeVector;", v: "\xE2\xA5\xA1" }, { k: "LeftDownVector;", v: "\xE2\x87\x83" }, { k: "LeftDownVectorBar;", v: "\xE2\xA5\x99" }, { k: "LeftFloor;", v: "\xE2\x8C\x8A" }, { k: "LeftRightArrow;", v: "\xE2\x86\x94" }, { k: "LeftRightVector;", v: "\xE2\xA5\x8E" }, { k: "LeftTee;", v: "\xE2\x8A\xA3" }, { k: "LeftTeeArrow;", v: "\xE2\x86\xA4" }, { k: "LeftTeeVector;", v: "\xE2\xA5\x9A" }, { k: "LeftTriangle;", v: "\xE2\x8A\xB2" }, { k: "LeftTriangleBar;", v: "\xE2\xA7\x8F" }, { k: "LeftTriangleEqual;", v: "\xE2\x8A\xB4" }, { k: "LeftUpDownVector;", v: "\xE2\xA5\x91" }, { k: "LeftUpTeeVector;", v: "\xE2\xA5\xA0" }, { k: "LeftUpVector;", v: "\xE2\x86\xBF" }, { k: "LeftUpVectorBar;", v: "\xE2\xA5\x98" }, { k: "LeftVector;", v: "\xE2\x86\xBC" }, { k: "LeftVectorBar;", v: "\xE2\xA5\x92" }, { k: "Leftarrow;", v: "\xE2\x87\x90" }, { k: "Leftrightarrow;", v: "\xE2\x87\x94" }, { k: "LessEqualGreater;", v: "\xE2\x8B\x9A" }, { k: "LessFullEqual;", v: "\xE2\x89\xA6" }, { k: "LessGreater;", v: "\xE2\x89\xB6" }, { k: "LessLess;", v: "\xE2\xAA\xA1" }, { k: "LessSlantEqual;", v: "\xE2\xA9\xBD" }, { k: "LessTilde;", v: "\xE2\x89\xB2" }, { k: "Lfr;", v: "\xF0\x9D\x94\x8F" }, { k: "Ll;", v: "\xE2\x8B\x98" }, { k: "Lleftarrow;", v: "\xE2\x87\x9A" }, { k: "Lmidot;", v: "\xC4\xBF" }, { k: "LongLeftArrow;", v: "\xE2\x9F\xB5" }, { k: "LongLeftRightArrow;", v: "\xE2\x9F\xB7" }, { k: "LongRightArrow;", v: "\xE2\x9F\xB6" }, { k: "Longleftarrow;", v: "\xE2\x9F\xB8" }, { k: "Longleftrightarrow;", v: "\xE2\x9F\xBA" }, { k: "Longrightarrow;", v: "\xE2\x9F\xB9" }, { k: "Lopf;", v: "\xF0\x9D\x95\x83" }, { k: "LowerLeftArrow;", v: "\xE2\x86\x99" }, { k: "LowerRightArrow;", v: "\xE2\x86\x98" }, { k: "Lscr;", v: "\xE2\x84\x92" }, { k: "Lsh;", v: "\xE2\x86\xB0" }, { k: "Lstrok;", v: "\xC5\x81" }, { k: "Lt;", v: "\xE2\x89\xAA" }, { k: "Map;", v: "\xE2\xA4\x85" }, { k: "Mcy;", v: "\xD0\x9C" }, { k: "MediumSpace;", v: "\xE2\x81\x9F" }, { k: "Mellintrf;", v: "\xE2\x84\xB3" }, { k: "Mfr;", v: "\xF0\x9D\x94\x90" }, { k: "MinusPlus;", v: "\xE2\x88\x93" }, { k: "Mopf;", v: "\xF0\x9D\x95\x84" }, { k: "Mscr;", v: "\xE2\x84\xB3" }, { k: "Mu;", v: "\xCE\x9C" }, { k: "NJcy;", v: "\xD0\x8A" }, { k: "Nacute;", v: "\xC5\x83" }, { k: "Ncaron;", v: "\xC5\x87" }, { k: "Ncedil;", v: "\xC5\x85" }, { k: "Ncy;", v: "\xD0\x9D" }, { k: "NegativeMediumSpace;", v: "\xE2\x80\x8B" }, { k: "NegativeThickSpace;", v: "\xE2\x80\x8B" }, { k: "NegativeThinSpace;", v: "\xE2\x80\x8B" }, { k: "NegativeVeryThinSpace;", v: "\xE2\x80\x8B" }, { k: "NestedGreaterGreater;", v: "\xE2\x89\xAB" }, { k: "NestedLessLess;", v: "\xE2\x89\xAA" }, { k: "NewLine;", v: "\n" }, { k: "Nfr;", v: "\xF0\x9D\x94\x91" }, { k: "NoBreak;", v: "\xE2\x81\xA0" }, { k: "NonBreakingSpace;", v: "\xC2\xA0" }, { k: "Nopf;", v: "\xE2\x84\x95" }, { k: "Not;", v: "\xE2\xAB\xAC" }, { k: "NotCongruent;", v: "\xE2\x89\xA2" }, { k: "NotCupCap;", v: "\xE2\x89\xAD" }, { k: "NotDoubleVerticalBar;", v: "\xE2\x88\xA6" }, { k: "NotElement;", v: "\xE2\x88\x89" }, { k: "NotEqual;", v: "\xE2\x89\xA0" }, { k: "NotEqualTilde;", v: "\xE2\x89\x82\xCC\xB8" }, { k: "NotExists;", v: "\xE2\x88\x84" }, { k: "NotGreater;", v: "\xE2\x89\xAF" }, { k: "NotGreaterEqual;", v: "\xE2\x89\xB1" }, { k: "NotGreaterFullEqual;", v: "\xE2\x89\xA7\xCC\xB8" }, { k: "NotGreaterGreater;", v: "\xE2\x89\xAB\xCC\xB8" }, { k: "NotGreaterLess;", v: "\xE2\x89\xB9" }, { k: "NotGreaterSlantEqual;", v: "\xE2\xA9\xBE\xCC\xB8" }, { k: "NotGreaterTilde;", v: "\xE2\x89\xB5" }, { k: "NotHumpDownHump;", v: "\xE2\x89\x8E\xCC\xB8" }, { k: "NotHumpEqual;", v: "\xE2\x89\x8F\xCC\xB8" }, { k: "NotLeftTriangle;", v: "\xE2\x8B\xAA" }, { k: "NotLeftTriangleBar;", v: "\xE2\xA7\x8F\xCC\xB8" }, { k: "NotLeftTriangleEqual;", v: "\xE2\x8B\xAC" }, { k: "NotLess;", v: "\xE2\x89\xAE" }, { k: "NotLessEqual;", v: "\xE2\x89\xB0" }, { k: "NotLessGreater;", v: "\xE2\x89\xB8" }, { k: "NotLessLess;", v: "\xE2\x89\xAA\xCC\xB8" }, { k: "NotLessSlantEqual;", v: "\xE2\xA9\xBD\xCC\xB8" }, { k: "NotLessTilde;", v: "\xE2\x89\xB4" }, { k: "NotNestedGreaterGreater;", v: "\xE2\xAA\xA2\xCC\xB8" }, { k: "NotNestedLessLess;", v: "\xE2\xAA\xA1\xCC\xB8" }, { k: "NotPrecedes;", v: "\xE2\x8A\x80" }, { k: "NotPrecedesEqual;", v: "\xE2\xAA\xAF\xCC\xB8" }, { k: "NotPrecedesSlantEqual;", v: "\xE2\x8B\xA0" }, { k: "NotReverseElement;", v: "\xE2\x88\x8C" }, { k: "NotRightTriangle;", v: "\xE2\x8B\xAB" }, { k: "NotRightTriangleBar;", v: "\xE2\xA7\x90\xCC\xB8" }, { k: "NotRightTriangleEqual;", v: "\xE2\x8B\xAD" }, { k: "NotSquareSubset;", v: "\xE2\x8A\x8F\xCC\xB8" }, { k: "NotSquareSubsetEqual;", v: "\xE2\x8B\xA2" }, { k: "NotSquareSuperset;", v: "\xE2\x8A\x90\xCC\xB8" }, { k: "NotSquareSupersetEqual;", v: "\xE2\x8B\xA3" }, { k: "NotSubset;", v: "\xE2\x8A\x82\xE2\x83\x92" }, { k: "NotSubsetEqual;", v: "\xE2\x8A\x88" }, { k: "NotSucceeds;", v: "\xE2\x8A\x81" }, { k: "NotSucceedsEqual;", v: "\xE2\xAA\xB0\xCC\xB8" }, { k: "NotSucceedsSlantEqual;", v: "\xE2\x8B\xA1" }, { k: "NotSucceedsTilde;", v: "\xE2\x89\xBF\xCC\xB8" }, { k: "NotSuperset;", v: "\xE2\x8A\x83\xE2\x83\x92" }, { k: "NotSupersetEqual;", v: "\xE2\x8A\x89" }, { k: "NotTilde;", v: "\xE2\x89\x81" }, { k: "NotTildeEqual;", v: "\xE2\x89\x84" }, { k: "NotTildeFullEqual;", v: "\xE2\x89\x87" }, { k: "NotTildeTilde;", v: "\xE2\x89\x89" }, { k: "NotVerticalBar;", v: "\xE2\x88\xA4" }, { k: "Nscr;", v: "\xF0\x9D\x92\xA9" }, { k: "Ntilde;", v: "\xC3\x91" }, { k: "Nu;", v: "\xCE\x9D" }, { k: "OElig;", v: "\xC5\x92" }, { k: "Oacute;", v: "\xC3\x93" }, { k: "Ocirc;", v: "\xC3\x94" }, { k: "Ocy;", v: "\xD0\x9E" }, { k: "Odblac;", v: "\xC5\x90" }, { k: "Ofr;", v: "\xF0\x9D\x94\x92" }, { k: "Ograve;", v: "\xC3\x92" }, { k: "Omacr;", v: "\xC5\x8C" }, { k: "Omega;", v: "\xCE\xA9" }, { k: "Omicron;", v: "\xCE\x9F" }, { k: "Oopf;", v: "\xF0\x9D\x95\x86" }, { k: "OpenCurlyDoubleQuote;", v: "\xE2\x80\x9C" }, { k: "OpenCurlyQuote;", v: "\xE2\x80\x98" }, { k: "Or;", v: "\xE2\xA9\x94" }, { k: "Oscr;", v: "\xF0\x9D\x92\xAA" }, { k: "Oslash;", v: "\xC3\x98" }, { k: "Otilde;", v: "\xC3\x95" }, { k: "Otimes;", v: "\xE2\xA8\xB7" }, { k: "Ouml;", v: "\xC3\x96" }, { k: "OverBar;", v: "\xE2\x80\xBE" }, { k: "OverBrace;", v: "\xE2\x8F\x9E" }, { k: "OverBracket;", v: "\xE2\x8E\xB4" }, { k: "OverParenthesis;", v: "\xE2\x8F\x9C" }, { k: "PartialD;", v: "\xE2\x88\x82" }, { k: "Pcy;", v: "\xD0\x9F" }, { k: "Pfr;", v: "\xF0\x9D\x94\x93" }, { k: "Phi;", v: "\xCE\xA6" }, { k: "Pi;", v: "\xCE\xA0" }, { k: "PlusMinus;", v: "\xC2\xB1" }, { k: "Poincareplane;", v: "\xE2\x84\x8C" }, { k: "Popf;", v: "\xE2\x84\x99" }, { k: "Pr;", v: "\xE2\xAA\xBB" }, { k: "Precedes;", v: "\xE2\x89\xBA" }, { k: "PrecedesEqual;", v: "\xE2\xAA\xAF" }, { k: "PrecedesSlantEqual;", v: "\xE2\x89\xBC" }, { k: "PrecedesTilde;", v: "\xE2\x89\xBE" }, { k: "Prime;", v: "\xE2\x80\xB3" }, { k: "Product;", v: "\xE2\x88\x8F" }, { k: "Proportion;", v: "\xE2\x88\xB7" }, { k: "Proportional;", v: "\xE2\x88\x9D" }, { k: "Pscr;", v: "\xF0\x9D\x92\xAB" }, { k: "Psi;", v: "\xCE\xA8" }, { k: "QUOT;", v: "\"" }, { k: "Qfr;", v: "\xF0\x9D\x94\x94" }, { k: "Qopf;", v: "\xE2\x84\x9A" }, { k: "Qscr;", v: "\xF0\x9D\x92\xAC" }, { k: "RBarr;", v: "\xE2\xA4\x90" }, { k: "REG;", v: "\xC2\xAE" }, { k: "Racute;", v: "\xC5\x94" }, { k: "Rang;", v: "\xE2\x9F\xAB" }, { k: "Rarr;", v: "\xE2\x86\xA0" }, { k: "Rarrtl;", v: "\xE2\xA4\x96" }, { k: "Rcaron;", v: "\xC5\x98" }, { k: "Rcedil;", v: "\xC5\x96" }, { k: "Rcy;", v: "\xD0\xA0" }, { k: "Re;", v: "\xE2\x84\x9C" }, { k: "ReverseElement;", v: "\xE2\x88\x8B" }, { k: "ReverseEquilibrium;", v: "\xE2\x87\x8B" }, { k: "ReverseUpEquilibrium;", v: "\xE2\xA5\xAF" }, { k: "Rfr;", v: "\xE2\x84\x9C" }, { k: "Rho;", v: "\xCE\xA1" }, { k: "RightAngleBracket;", v: "\xE2\x9F\xA9" }, { k: "RightArrow;", v: "\xE2\x86\x92" }, { k: "RightArrowBar;", v: "\xE2\x87\xA5" }, { k: "RightArrowLeftArrow;", v: "\xE2\x87\x84" }, { k: "RightCeiling;", v: "\xE2\x8C\x89" }, { k: "RightDoubleBracket;", v: "\xE2\x9F\xA7" }, { k: "RightDownTeeVector;", v: "\xE2\xA5\x9D" }, { k: "RightDownVector;", v: "\xE2\x87\x82" }, { k: "RightDownVectorBar;", v: "\xE2\xA5\x95" }, { k: "RightFloor;", v: "\xE2\x8C\x8B" }, { k: "RightTee;", v: "\xE2\x8A\xA2" }, { k: "RightTeeArrow;", v: "\xE2\x86\xA6" }, { k: "RightTeeVector;", v: "\xE2\xA5\x9B" }, { k: "RightTriangle;", v: "\xE2\x8A\xB3" }, { k: "RightTriangleBar;", v: "\xE2\xA7\x90" }, { k: "RightTriangleEqual;", v: "\xE2\x8A\xB5" }, { k: "RightUpDownVector;", v: "\xE2\xA5\x8F" }, { k: "RightUpTeeVector;", v: "\xE2\xA5\x9C" }, { k: "RightUpVector;", v: "\xE2\x86\xBE" }, { k: "RightUpVectorBar;", v: "\xE2\xA5\x94" }, { k: "RightVector;", v: "\xE2\x87\x80" }, { k: "RightVectorBar;", v: "\xE2\xA5\x93" }, { k: "Rightarrow;", v: "\xE2\x87\x92" }, { k: "Ropf;", v: "\xE2\x84\x9D" }, { k: "RoundImplies;", v: "\xE2\xA5\xB0" }, { k: "Rrightarrow;", v: "\xE2\x87\x9B" }, { k: "Rscr;", v: "\xE2\x84\x9B" }, { k: "Rsh;", v: "\xE2\x86\xB1" }, { k: "RuleDelayed;", v: "\xE2\xA7\xB4" }, { k: "SHCHcy;", v: "\xD0\xA9" }, { k: "SHcy;", v: "\xD0\xA8" }, { k: "SOFTcy;", v: "\xD0\xAC" }, { k: "Sacute;", v: "\xC5\x9A" }, { k: "Sc;", v: "\xE2\xAA\xBC" }, { k: "Scaron;", v: "\xC5\xA0" }, { k: "Scedil;", v: "\xC5\x9E" }, { k: "Scirc;", v: "\xC5\x9C" }, { k: "Scy;", v: "\xD0\xA1" }, { k: "Sfr;", v: "\xF0\x9D\x94\x96" }, { k: "ShortDownArrow;", v: "\xE2\x86\x93" }, { k: "ShortLeftArrow;", v: "\xE2\x86\x90" }, { k: "ShortRightArrow;", v: "\xE2\x86\x92" }, { k: "ShortUpArrow;", v: "\xE2\x86\x91" }, { k: "Sigma;", v: "\xCE\xA3" }, { k: "SmallCircle;", v: "\xE2\x88\x98" }, { k: "Sopf;", v: "\xF0\x9D\x95\x8A" }, { k: "Sqrt;", v: "\xE2\x88\x9A" }, { k: "Square;", v: "\xE2\x96\xA1" }, { k: "SquareIntersection;", v: "\xE2\x8A\x93" }, { k: "SquareSubset;", v: "\xE2\x8A\x8F" }, { k: "SquareSubsetEqual;", v: "\xE2\x8A\x91" }, { k: "SquareSuperset;", v: "\xE2\x8A\x90" }, { k: "SquareSupersetEqual;", v: "\xE2\x8A\x92" }, { k: "SquareUnion;", v: "\xE2\x8A\x94" }, { k: "Sscr;", v: "\xF0\x9D\x92\xAE" }, { k: "Star;", v: "\xE2\x8B\x86" }, { k: "Sub;", v: "\xE2\x8B\x90" }, { k: "Subset;", v: "\xE2\x8B\x90" }, { k: "SubsetEqual;", v: "\xE2\x8A\x86" }, { k: "Succeeds;", v: "\xE2\x89\xBB" }, { k: "SucceedsEqual;", v: "\xE2\xAA\xB0" }, { k: "SucceedsSlantEqual;", v: "\xE2\x89\xBD" }, { k: "SucceedsTilde;", v: "\xE2\x89\xBF" }, { k: "SuchThat;", v: "\xE2\x88\x8B" }, { k: "Sum;", v: "\xE2\x88\x91" }, { k: "Sup;", v: "\xE2\x8B\x91" }, { k: "Superset;", v: "\xE2\x8A\x83" }, { k: "SupersetEqual;", v: "\xE2\x8A\x87" }, { k: "Supset;", v: "\xE2\x8B\x91" }, { k: "THORN;", v: "\xC3\x9E" }, { k: "TRADE;", v: "\xE2\x84\xA2" }, { k: "TSHcy;", v: "\xD0\x8B" }, { k: "TScy;", v: "\xD0\xA6" }, { k: "Tab;", v: "\t" }, { k: "Tau;", v: "\xCE\xA4" }, { k: "Tcaron;", v: "\xC5\xA4" }, { k: "Tcedil;", v: "\xC5\xA2" }, { k: "Tcy;", v: "\xD0\xA2" }, { k: "Tfr;", v: "\xF0\x9D\x94\x97" }, { k: "Therefore;", v: "\xE2\x88\xB4" }, { k: "Theta;", v: "\xCE\x98" }, { k: "ThickSpace;", v: "\xE2\x81\x9F\xE2\x80\x8A" }, { k: "ThinSpace;", v: "\xE2\x80\x89" }, { k: "Tilde;", v: "\xE2\x88\xBC" }, { k: "TildeEqual;", v: "\xE2\x89\x83" }, { k: "TildeFullEqual;", v: "\xE2\x89\x85" }, { k: "TildeTilde;", v: "\xE2\x89\x88" }, { k: "Topf;", v: "\xF0\x9D\x95\x8B" }, { k: "TripleDot;", v: "\xE2\x83\x9B" }, { k: "Tscr;", v: "\xF0\x9D\x92\xAF" }, { k: "Tstrok;", v: "\xC5\xA6" }, { k: "Uacute;", v: "\xC3\x9A" }, { k: "Uarr;", v: "\xE2\x86\x9F" }, { k: "Uarrocir;", v: "\xE2\xA5\x89" }, { k: "Ubrcy;", v: "\xD0\x8E" }, { k: "Ubreve;", v: "\xC5\xAC" }, { k: "Ucirc;", v: "\xC3\x9B" }, { k: "Ucy;", v: "\xD0\xA3" }, { k: "Udblac;", v: "\xC5\xB0" }, { k: "Ufr;", v: "\xF0\x9D\x94\x98" }, { k: "Ugrave;", v: "\xC3\x99" }, { k: "Umacr;", v: "\xC5\xAA" }, { k: "UnderBar;", v: "_" }, { k: "UnderBrace;", v: "\xE2\x8F\x9F" }, { k: "UnderBracket;", v: "\xE2\x8E\xB5" }, { k: "UnderParenthesis;", v: "\xE2\x8F\x9D" }, { k: "Union;", v: "\xE2\x8B\x83" }, { k: "UnionPlus;", v: "\xE2\x8A\x8E" }, { k: "Uogon;", v: "\xC5\xB2" }, { k: "Uopf;", v: "\xF0\x9D\x95\x8C" }, { k: "UpArrow;", v: "\xE2\x86\x91" }, { k: "UpArrowBar;", v: "\xE2\xA4\x92" }, { k: "UpArrowDownArrow;", v: "\xE2\x87\x85" }, { k: "UpDownArrow;", v: "\xE2\x86\x95" }, { k: "UpEquilibrium;", v: "\xE2\xA5\xAE" }, { k: "UpTee;", v: "\xE2\x8A\xA5" }, { k: "UpTeeArrow;", v: "\xE2\x86\xA5" }, { k: "Uparrow;", v: "\xE2\x87\x91" }, { k: "Updownarrow;", v: "\xE2\x87\x95" }, { k: "UpperLeftArrow;", v: "\xE2\x86\x96" }, { k: "UpperRightArrow;", v: "\xE2\x86\x97" }, { k: "Upsi;", v: "\xCF\x92" }, { k: "Upsilon;", v: "\xCE\xA5" }, { k: "Uring;", v: "\xC5\xAE" }, { k: "Uscr;", v: "\xF0\x9D\x92\xB0" }, { k: "Utilde;", v: "\xC5\xA8" }, { k: "Uuml;", v: "\xC3\x9C" }, { k: "VDash;", v: "\xE2\x8A\xAB" }, { k: "Vbar;", v: "\xE2\xAB\xAB" }, { k: "Vcy;", v: "\xD0\x92" }, { k: "Vdash;", v: "\xE2\x8A\xA9" }, { k: "Vdashl;", v: "\xE2\xAB\xA6" }, { k: "Vee;", v: "\xE2\x8B\x81" }, { k: "Verbar;", v: "\xE2\x80\x96" }, { k: "Vert;", v: "\xE2\x80\x96" }, { k: "VerticalBar;", v: "\xE2\x88\xA3" }, { k: "VerticalLine;", v: "|" }, { k: "VerticalSeparator;", v: "\xE2\x9D\x98" }, { k: "VerticalTilde;", v: "\xE2\x89\x80" }, { k: "VeryThinSpace;", v: "\xE2\x80\x8A" }, { k: "Vfr;", v: "\xF0\x9D\x94\x99" }, { k: "Vopf;", v: "\xF0\x9D\x95\x8D" }, { k: "Vscr;", v: "\xF0\x9D\x92\xB1" }, { k: "Vvdash;", v: "\xE2\x8A\xAA" }, { k: "Wcirc;", v: "\xC5\xB4" }, { k: "Wedge;", v: "\xE2\x8B\x80" }, { k: "Wfr;", v: "\xF0\x9D\x94\x9A" }, { k: "Wopf;", v: "\xF0\x9D\x95\x8E" }, { k: "Wscr;", v: "\xF0\x9D\x92\xB2" }, { k: "Xfr;", v: "\xF0\x9D\x94\x9B" }, { k: "Xi;", v: "\xCE\x9E" }, { k: "Xopf;", v: "\xF0\x9D\x95\x8F" }, { k: "Xscr;", v: "\xF0\x9D\x92\xB3" }, { k: "YAcy;", v: "\xD0\xAF" }, { k: "YIcy;", v: "\xD0\x87" }, { k: "YUcy;", v: "\xD0\xAE" }, { k: "Yacute;", v: "\xC3\x9D" }, { k: "Ycirc;", v: "\xC5\xB6" }, { k: "Ycy;", v: "\xD0\xAB" }, { k: "Yfr;", v: "\xF0\x9D\x94\x9C" }, { k: "Yopf;", v: "\xF0\x9D\x95\x90" }, { k: "Yscr;", v: "\xF0\x9D\x92\xB4" }, { k: "Yuml;", v: "\xC5\xB8" }, { k: "ZHcy;", v: "\xD0\x96" }, { k: "Zacute;", v: "\xC5\xB9" }, { k: "Zcaron;", v: "\xC5\xBD" }, { k: "Zcy;", v: "\xD0\x97" }, { k: "Zdot;", v: "\xC5\xBB" }, { k: "ZeroWidthSpace;", v: "\xE2\x80\x8B" }, { k: "Zeta;", v: "\xCE\x96" }, { k: "Zfr;", v: "\xE2\x84\xA8" }, { k: "Zopf;", v: "\xE2\x84\xA4" }, { k: "Zscr;", v: "\xF0\x9D\x92\xB5" }, { k: "aacute;", v: "\xC3\xA1" }, { k: "abreve;", v: "\xC4\x83" }, { k: "ac;", v: "\xE2\x88\xBE" }, { k: "acE;", v: "\xE2\x88\xBE\xCC\xB3" }, { k: "acd;", v: "\xE2\x88\xBF" }, { k: "acirc;", v: "\xC3\xA2" }, { k: "acute;", v: "\xC2\xB4" }, { k: "acy;", v: "\xD0\xB0" }, { k: "aelig;", v: "\xC3\xA6" }, { k: "af;", v: "\xE2\x81\xA1" }, { k: "afr;", v: "\xF0\x9D\x94\x9E" }, { k: "agrave;", v: "\xC3\xA0" }, { k: "alefsym;", v: "\xE2\x84\xB5" }, { k: "aleph;", v: "\xE2\x84\xB5" }, { k: "alpha;", v: "\xCE\xB1" }, { k: "amacr;", v: "\xC4\x81" }, { k: "amalg;", v: "\xE2\xA8\xBF" }, { k: "amp;", v: "&" }, { k: "and;", v: "\xE2\x88\xA7" }, { k: "andand;", v: "\xE2\xA9\x95" }, { k: "andd;", v: "\xE2\xA9\x9C" }, { k: "andslope;", v: "\xE2\xA9\x98" }, { k: "andv;", v: "\xE2\xA9\x9A" }, { k: "ang;", v: "\xE2\x88\xA0" }, { k: "ange;", v: "\xE2\xA6\xA4" }, { k: "angle;", v: "\xE2\x88\xA0" }, { k: "angmsd;", v: "\xE2\x88\xA1" }, { k: "angmsdaa;", v: "\xE2\xA6\xA8" }, { k: "angmsdab;", v: "\xE2\xA6\xA9" }, { k: "angmsdac;", v: "\xE2\xA6\xAA" }, { k: "angmsdad;", v: "\xE2\xA6\xAB" }, { k: "angmsdae;", v: "\xE2\xA6\xAC" }, { k: "angmsdaf;", v: "\xE2\xA6\xAD" }, { k: "angmsdag;", v: "\xE2\xA6\xAE" }, { k: "angmsdah;", v: "\xE2\xA6\xAF" }, { k: "angrt;", v: "\xE2\x88\x9F" }, { k: "angrtvb;", v: "\xE2\x8A\xBE" }, { k: "angrtvbd;", v: "\xE2\xA6\x9D" }, { k: "angsph;", v: "\xE2\x88\xA2" }, { k: "angst;", v: "\xC3\x85" }, { k: "angzarr;", v: "\xE2\x8D\xBC" }, { k: "aogon;", v: "\xC4\x85" }, { k: "aopf;", v: "\xF0\x9D\x95\x92" }, { k: "ap;", v: "\xE2\x89\x88" }, { k: "apE;", v: "\xE2\xA9\xB0" }, { k: "apacir;", v: "\xE2\xA9\xAF" }, { k: "ape;", v: "\xE2\x89\x8A" }, { k: "apid;", v: "\xE2\x89\x8B" }, { k: "apos;", v: "'" }, { k: "approx;", v: "\xE2\x89\x88" }, { k: "approxeq;", v: "\xE2\x89\x8A" }, { k: "aring;", v: "\xC3\xA5" }, { k: "ascr;", v: "\xF0\x9D\x92\xB6" }, { k: "ast;", v: "*" }, { k: "asymp;", v: "\xE2\x89\x88" }, { k: "asympeq;", v: "\xE2\x89\x8D" }, { k: "atilde;", v: "\xC3\xA3" }, { k: "auml;", v: "\xC3\xA4" }, { k: "awconint;", v: "\xE2\x88\xB3" }, { k: "awint;", v: "\xE2\xA8\x91" }, { k: "bNot;", v: "\xE2\xAB\xAD" }, { k: "backcong;", v: "\xE2\x89\x8C" }, { k: "backepsilon;", v: "\xCF\xB6" }, { k: "backprime;", v: "\xE2\x80\xB5" }, { k: "backsim;", v: "\xE2\x88\xBD" }, { k: "backsimeq;", v: "\xE2\x8B\x8D" }, { k: "barvee;", v: "\xE2\x8A\xBD" }, { k: "barwed;", v: "\xE2\x8C\x85" }, { k: "barwedge;", v: "\xE2\x8C\x85" }, { k: "bbrk;", v: "\xE2\x8E\xB5" }, { k: "bbrktbrk;", v: "\xE2\x8E\xB6" }, { k: "bcong;", v: "\xE2\x89\x8C" }, { k: "bcy;", v: "\xD0\xB1" }, { k: "bdquo;", v: "\xE2\x80\x9E" }, { k: "becaus;", v: "\xE2\x88\xB5" }, { k: "because;", v: "\xE2\x88\xB5" }, { k: "bemptyv;", v: "\xE2\xA6\xB0" }, { k: "bepsi;", v: "\xCF\xB6" }, { k: "bernou;", v: "\xE2\x84\xAC" }, { k: "beta;", v: "\xCE\xB2" }, { k: "beth;", v: "\xE2\x84\xB6" }, { k: "between;", v: "\xE2\x89\xAC" }, { k: "bfr;", v: "\xF0\x9D\x94\x9F" }, { k: "bigcap;", v: "\xE2\x8B\x82" }, { k: "bigcirc;", v: "\xE2\x97\xAF" }, { k: "bigcup;", v: "\xE2\x8B\x83" }, { k: "bigodot;", v: "\xE2\xA8\x80" }, { k: "bigoplus;", v: "\xE2\xA8\x81" }, { k: "bigotimes;", v: "\xE2\xA8\x82" }, { k: "bigsqcup;", v: "\xE2\xA8\x86" }, { k: "bigstar;", v: "\xE2\x98\x85" }, { k: "bigtriangledown;", v: "\xE2\x96\xBD" }, { k: "bigtriangleup;", v: "\xE2\x96\xB3" }, { k: "biguplus;", v: "\xE2\xA8\x84" }, { k: "bigvee;", v: "\xE2\x8B\x81" }, { k: "bigwedge;", v: "\xE2\x8B\x80" }, { k: "bkarow;", v: "\xE2\xA4\x8D" }, { k: "blacklozenge;", v: "\xE2\xA7\xAB" }, { k: "blacksquare;", v: "\xE2\x96\xAA" }, { k: "blacktriangle;", v: "\xE2\x96\xB4" }, { k: "blacktriangledown;", v: "\xE2\x96\xBE" }, { k: "blacktriangleleft;", v: "\xE2\x97\x82" }, { k: "blacktriangleright;", v: "\xE2\x96\xB8" }, { k: "blank;", v: "\xE2\x90\xA3" }, { k: "blk12;", v: "\xE2\x96\x92" }, { k: "blk14;", v: "\xE2\x96\x91" }, { k: "blk34;", v: "\xE2\x96\x93" }, { k: "block;", v: "\xE2\x96\x88" }, { k: "bne;", v: "=\xE2\x83\xA5" }, { k: "bnequiv;", v: "\xE2\x89\xA1\xE2\x83\xA5" }, { k: "bnot;", v: "\xE2\x8C\x90" }, { k: "bopf;", v: "\xF0\x9D\x95\x93" }, { k: "bot;", v: "\xE2\x8A\xA5" }, { k: "bottom;", v: "\xE2\x8A\xA5" }, { k: "bowtie;", v: "\xE2\x8B\x88" }, { k: "boxDL;", v: "\xE2\x95\x97" }, { k: "boxDR;", v: "\xE2\x95\x94" }, { k: "boxDl;", v: "\xE2\x95\x96" }, { k: "boxDr;", v: "\xE2\x95\x93" }, { k: "boxH;", v: "\xE2\x95\x90" }, { k: "boxHD;", v: "\xE2\x95\xA6" }, { k: "boxHU;", v: "\xE2\x95\xA9" }, { k: "boxHd;", v: "\xE2\x95\xA4" }, { k: "boxHu;", v: "\xE2\x95\xA7" }, { k: "boxUL;", v: "\xE2\x95\x9D" }, { k: "boxUR;", v: "\xE2\x95\x9A" }, { k: "boxUl;", v: "\xE2\x95\x9C" }, { k: "boxUr;", v: "\xE2\x95\x99" }, { k: "boxV;", v: "\xE2\x95\x91" }, { k: "boxVH;", v: "\xE2\x95\xAC" }, { k: "boxVL;", v: "\xE2\x95\xA3" }, { k: "boxVR;", v: "\xE2\x95\xA0" }, { k: "boxVh;", v: "\xE2\x95\xAB" }, { k: "boxVl;", v: "\xE2\x95\xA2" }, { k: "boxVr;", v: "\xE2\x95\x9F" }, { k: "boxbox;", v: "\xE2\xA7\x89" }, { k: "boxdL;", v: "\xE2\x95\x95" }, { k: "boxdR;", v: "\xE2\x95\x92" }, { k: "boxdl;", v: "\xE2\x94\x90" }, { k: "boxdr;", v: "\xE2\x94\x8C" }, { k: "boxh;", v: "\xE2\x94\x80" }, { k: "boxhD;", v: "\xE2\x95\xA5" }, { k: "boxhU;", v: "\xE2\x95\xA8" }, { k: "boxhd;", v: "\xE2\x94\xAC" }, { k: "boxhu;", v: "\xE2\x94\xB4" }, { k: "boxminus;", v: "\xE2\x8A\x9F" }, { k: "boxplus;", v: "\xE2\x8A\x9E" }, { k: "boxtimes;", v: "\xE2\x8A\xA0" }, { k: "boxuL;", v: "\xE2\x95\x9B" }, { k: "boxuR;", v: "\xE2\x95\x98" }, { k: "boxul;", v: "\xE2\x94\x98" }, { k: "boxur;", v: "\xE2\x94\x94" }, { k: "boxv;", v: "\xE2\x94\x82" }, { k: "boxvH;", v: "\xE2\x95\xAA" }, { k: "boxvL;", v: "\xE2\x95\xA1" }, { k: "boxvR;", v: "\xE2\x95\x9E" }, { k: "boxvh;", v: "\xE2\x94\xBC" }, { k: "boxvl;", v: "\xE2\x94\xA4" }, { k: "boxvr;", v: "\xE2\x94\x9C" }, { k: "bprime;", v: "\xE2\x80\xB5" }, { k: "breve;", v: "\xCB\x98" }, { k: "brvbar;", v: "\xC2\xA6" }, { k: "bscr;", v: "\xF0\x9D\x92\xB7" }, { k: "bsemi;", v: "\xE2\x81\x8F" }, { k: "bsim;", v: "\xE2\x88\xBD" }, { k: "bsime;", v: "\xE2\x8B\x8D" }, { k: "bsol;", v: "\\" }, { k: "bsolb;", v: "\xE2\xA7\x85" }, { k: "bsolhsub;", v: "\xE2\x9F\x88" }, { k: "bull;", v: "\xE2\x80\xA2" }, { k: "bullet;", v: "\xE2\x80\xA2" }, { k: "bump;", v: "\xE2\x89\x8E" }, { k: "bumpE;", v: "\xE2\xAA\xAE" }, { k: "bumpe;", v: "\xE2\x89\x8F" }, { k: "bumpeq;", v: "\xE2\x89\x8F" }, { k: "cacute;", v: "\xC4\x87" }, { k: "cap;", v: "\xE2\x88\xA9" }, { k: "capand;", v: "\xE2\xA9\x84" }, { k: "capbrcup;", v: "\xE2\xA9\x89" }, { k: "capcap;", v: "\xE2\xA9\x8B" }, { k: "capcup;", v: "\xE2\xA9\x87" }, { k: "capdot;", v: "\xE2\xA9\x80" }, { k: "caps;", v: "\xE2\x88\xA9\xEF\xB8\x80" }, { k: "caret;", v: "\xE2\x81\x81" }, { k: "caron;", v: "\xCB\x87" }, { k: "ccaps;", v: "\xE2\xA9\x8D" }, { k: "ccaron;", v: "\xC4\x8D" }, { k: "ccedil;", v: "\xC3\xA7" }, { k: "ccirc;", v: "\xC4\x89" }, { k: "ccups;", v: "\xE2\xA9\x8C" }, { k: "ccupssm;", v: "\xE2\xA9\x90" }, { k: "cdot;", v: "\xC4\x8B" }, { k: "cedil;", v: "\xC2\xB8" }, { k: "cemptyv;", v: "\xE2\xA6\xB2" }, { k: "cent;", v: "\xC2\xA2" }, { k: "centerdot;", v: "\xC2\xB7" }, { k: "cfr;", v: "\xF0\x9D\x94\xA0" }, { k: "chcy;", v: "\xD1\x87" }, { k: "check;", v: "\xE2\x9C\x93" }, { k: "checkmark;", v: "\xE2\x9C\x93" }, { k: "chi;", v: "\xCF\x87" }, { k: "cir;", v: "\xE2\x97\x8B" }, { k: "cirE;", v: "\xE2\xA7\x83" }, { k: "circ;", v: "\xCB\x86" }, { k: "circeq;", v: "\xE2\x89\x97" }, { k: "circlearrowleft;", v: "\xE2\x86\xBA" }, { k: "circlearrowright;", v: "\xE2\x86\xBB" }, { k: "circledR;", v: "\xC2\xAE" }, { k: "circledS;", v: "\xE2\x93\x88" }, { k: "circledast;", v: "\xE2\x8A\x9B" }, { k: "circledcirc;", v: "\xE2\x8A\x9A" }, { k: "circleddash;", v: "\xE2\x8A\x9D" }, { k: "cire;", v: "\xE2\x89\x97" }, { k: "cirfnint;", v: "\xE2\xA8\x90" }, { k: "cirmid;", v: "\xE2\xAB\xAF" }, { k: "cirscir;", v: "\xE2\xA7\x82" }, { k: "clubs;", v: "\xE2\x99\xA3" }, { k: "clubsuit;", v: "\xE2\x99\xA3" }, { k: "colon;", v: ":" }, { k: "colone;", v: "\xE2\x89\x94" }, { k: "coloneq;", v: "\xE2\x89\x94" }, { k: "comma;", v: "," }, { k: "commat;", v: "@" }, { k: "comp;", v: "\xE2\x88\x81" }, { k: "compfn;", v: "\xE2\x88\x98" }, { k: "complement;", v: "\xE2\x88\x81" }, { k: "complexes;", v: "\xE2\x84\x82" }, { k: "cong;", v: "\xE2\x89\x85" }, { k: "congdot;", v: "\xE2\xA9\xAD" }, { k: "conint;", v: "\xE2\x88\xAE" }, { k: "copf;", v: "\xF0\x9D\x95\x94" }, { k: "coprod;", v: "\xE2\x88\x90" }, { k: "copy;", v: "\xC2\xA9" }, { k: "copysr;", v: "\xE2\x84\x97" }, { k: "crarr;", v: "\xE2\x86\xB5" }, { k: "cross;", v: "\xE2\x9C\x97" }, { k: "cscr;", v: "\xF0\x9D\x92\xB8" }, { k: "csub;", v: "\xE2\xAB\x8F" }, { k: "csube;", v: "\xE2\xAB\x91" }, { k: "csup;", v: "\xE2\xAB\x90" }, { k: "csupe;", v: "\xE2\xAB\x92" }, { k: "ctdot;", v: "\xE2\x8B\xAF" }, { k: "cudarrl;", v: "\xE2\xA4\xB8" }, { k: "cudarrr;", v: "\xE2\xA4\xB5" }, { k: "cuepr;", v: "\xE2\x8B\x9E" }, { k: "cuesc;", v: "\xE2\x8B\x9F" }, { k: "cularr;", v: "\xE2\x86\xB6" }, { k: "cularrp;", v: "\xE2\xA4\xBD" }, { k: "cup;", v: "\xE2\x88\xAA" }, { k: "cupbrcap;", v: "\xE2\xA9\x88" }, { k: "cupcap;", v: "\xE2\xA9\x86" }, { k: "cupcup;", v: "\xE2\xA9\x8A" }, { k: "cupdot;", v: "\xE2\x8A\x8D" }, { k: "cupor;", v: "\xE2\xA9\x85" }, { k: "cups;", v: "\xE2\x88\xAA\xEF\xB8\x80" }, { k: "curarr;", v: "\xE2\x86\xB7" }, { k: "curarrm;", v: "\xE2\xA4\xBC" }, { k: "curlyeqprec;", v: "\xE2\x8B\x9E" }, { k: "curlyeqsucc;", v: "\xE2\x8B\x9F" }, { k: "curlyvee;", v: "\xE2\x8B\x8E" }, { k: "curlywedge;", v: "\xE2\x8B\x8F" }, { k: "curren;", v: "\xC2\xA4" }, { k: "curvearrowleft;", v: "\xE2\x86\xB6" }, { k: "curvearrowright;", v: "\xE2\x86\xB7" }, { k: "cuvee;", v: "\xE2\x8B\x8E" }, { k: "cuwed;", v: "\xE2\x8B\x8F" }, { k: "cwconint;", v: "\xE2\x88\xB2" }, { k: "cwint;", v: "\xE2\x88\xB1" }, { k: "cylcty;", v: "\xE2\x8C\xAD" }, { k: "dArr;", v: "\xE2\x87\x93" }, { k: "dHar;", v: "\xE2\xA5\xA5" }, { k: "dagger;", v: "\xE2\x80\xA0" }, { k: "daleth;", v: "\xE2\x84\xB8" }, { k: "darr;", v: "\xE2\x86\x93" }, { k: "dash;", v: "\xE2\x80\x90" }, { k: "dashv;", v: "\xE2\x8A\xA3" }, { k: "dbkarow;", v: "\xE2\xA4\x8F" }, { k: "dblac;", v: "\xCB\x9D" }, { k: "dcaron;", v: "\xC4\x8F" }, { k: "dcy;", v: "\xD0\xB4" }, { k: "dd;", v: "\xE2\x85\x86" }, { k: "ddagger;", v: "\xE2\x80\xA1" }, { k: "ddarr;", v: "\xE2\x87\x8A" }, { k: "ddotseq;", v: "\xE2\xA9\xB7" }, { k: "deg;", v: "\xC2\xB0" }, { k: "delta;", v: "\xCE\xB4" }, { k: "demptyv;", v: "\xE2\xA6\xB1" }, { k: "dfisht;", v: "\xE2\xA5\xBF" }, { k: "dfr;", v: "\xF0\x9D\x94\xA1" }, { k: "dharl;", v: "\xE2\x87\x83" }, { k: "dharr;", v: "\xE2\x87\x82" }, { k: "diam;", v: "\xE2\x8B\x84" }, { k: "diamond;", v: "\xE2\x8B\x84" }, { k: "diamondsuit;", v: "\xE2\x99\xA6" }, { k: "diams;", v: "\xE2\x99\xA6" }, { k: "die;", v: "\xC2\xA8" }, { k: "digamma;", v: "\xCF\x9D" }, { k: "disin;", v: "\xE2\x8B\xB2" }, { k: "div;", v: "\xC3\xB7" }, { k: "divide;", v: "\xC3\xB7" }, { k: "divideontimes;", v: "\xE2\x8B\x87" }, { k: "divonx;", v: "\xE2\x8B\x87" }, { k: "djcy;", v: "\xD1\x92" }, { k: "dlcorn;", v: "\xE2\x8C\x9E" }, { k: "dlcrop;", v: "\xE2\x8C\x8D" }, { k: "dollar;", v: "$" }, { k: "dopf;", v: "\xF0\x9D\x95\x95" }, { k: "dot;", v: "\xCB\x99" }, { k: "doteq;", v: "\xE2\x89\x90" }, { k: "doteqdot;", v: "\xE2\x89\x91" }, { k: "dotminus;", v: "\xE2\x88\xB8" }, { k: "dotplus;", v: "\xE2\x88\x94" }, { k: "dotsquare;", v: "\xE2\x8A\xA1" }, { k: "doublebarwedge;", v: "\xE2\x8C\x86" }, { k: "downarrow;", v: "\xE2\x86\x93" }, { k: "downdownarrows;", v: "\xE2\x87\x8A" }, { k: "downharpoonleft;", v: "\xE2\x87\x83" }, { k: "downharpoonright;", v: "\xE2\x87\x82" }, { k: "drbkarow;", v: "\xE2\xA4\x90" }, { k: "drcorn;", v: "\xE2\x8C\x9F" }, { k: "drcrop;", v: "\xE2\x8C\x8C" }, { k: "dscr;", v: "\xF0\x9D\x92\xB9" }, { k: "dscy;", v: "\xD1\x95" }, { k: "dsol;", v: "\xE2\xA7\xB6" }, { k: "dstrok;", v: "\xC4\x91" }, { k: "dtdot;", v: "\xE2\x8B\xB1" }, { k: "dtri;", v: "\xE2\x96\xBF" }, { k: "dtrif;", v: "\xE2\x96\xBE" }, { k: "duarr;", v: "\xE2\x87\xB5" }, { k: "duhar;", v: "\xE2\xA5\xAF" }, { k: "dwangle;", v: "\xE2\xA6\xA6" }, { k: "dzcy;", v: "\xD1\x9F" }, { k: "dzigrarr;", v: "\xE2\x9F\xBF" }, { k: "eDDot;", v: "\xE2\xA9\xB7" }, { k: "eDot;", v: "\xE2\x89\x91" }, { k: "eacute;", v: "\xC3\xA9" }, { k: "easter;", v: "\xE2\xA9\xAE" }, { k: "ecaron;", v: "\xC4\x9B" }, { k: "ecir;", v: "\xE2\x89\x96" }, { k: "ecirc;", v: "\xC3\xAA" }, { k: "ecolon;", v: "\xE2\x89\x95" }, { k: "ecy;", v: "\xD1\x8D" }, { k: "edot;", v: "\xC4\x97" }, { k: "ee;", v: "\xE2\x85\x87" }, { k: "efDot;", v: "\xE2\x89\x92" }, { k: "efr;", v: "\xF0\x9D\x94\xA2" }, { k: "eg;", v: "\xE2\xAA\x9A" }, { k: "egrave;", v: "\xC3\xA8" }, { k: "egs;", v: "\xE2\xAA\x96" }, { k: "egsdot;", v: "\xE2\xAA\x98" }, { k: "el;", v: "\xE2\xAA\x99" }, { k: "elinters;", v: "\xE2\x8F\xA7" }, { k: "ell;", v: "\xE2\x84\x93" }, { k: "els;", v: "\xE2\xAA\x95" }, { k: "elsdot;", v: "\xE2\xAA\x97" }, { k: "emacr;", v: "\xC4\x93" }, { k: "empty;", v: "\xE2\x88\x85" }, { k: "emptyset;", v: "\xE2\x88\x85" }, { k: "emptyv;", v: "\xE2\x88\x85" }, { k: "emsp;", v: "\xE2\x80\x83" }, { k: "emsp13;", v: "\xE2\x80\x84" }, { k: "emsp14;", v: "\xE2\x80\x85" }, { k: "eng;", v: "\xC5\x8B" }, { k: "ensp;", v: "\xE2\x80\x82" }, { k: "eogon;", v: "\xC4\x99" }, { k: "eopf;", v: "\xF0\x9D\x95\x96" }, { k: "epar;", v: "\xE2\x8B\x95" }, { k: "eparsl;", v: "\xE2\xA7\xA3" }, { k: "eplus;", v: "\xE2\xA9\xB1" }, { k: "epsi;", v: "\xCE\xB5" }, { k: "epsilon;", v: "\xCE\xB5" }, { k: "epsiv;", v: "\xCF\xB5" }, { k: "eqcirc;", v: "\xE2\x89\x96" }, { k: "eqcolon;", v: "\xE2\x89\x95" }, { k: "eqsim;", v: "\xE2\x89\x82" }, { k: "eqslantgtr;", v: "\xE2\xAA\x96" }, { k: "eqslantless;", v: "\xE2\xAA\x95" }, { k: "equals;", v: "=" }, { k: "equest;", v: "\xE2\x89\x9F" }, { k: "equiv;", v: "\xE2\x89\xA1" }, { k: "equivDD;", v: "\xE2\xA9\xB8" }, { k: "eqvparsl;", v: "\xE2\xA7\xA5" }, { k: "erDot;", v: "\xE2\x89\x93" }, { k: "erarr;", v: "\xE2\xA5\xB1" }, { k: "escr;", v: "\xE2\x84\xAF" }, { k: "esdot;", v: "\xE2\x89\x90" }, { k: "esim;", v: "\xE2\x89\x82" }, { k: "eta;", v: "\xCE\xB7" }, { k: "eth;", v: "\xC3\xB0" }, { k: "euml;", v: "\xC3\xAB" }, { k: "euro;", v: "\xE2\x82\xAC" }, { k: "excl;", v: "!" }, { k: "exist;", v: "\xE2\x88\x83" }, { k: "expectation;", v: "\xE2\x84\xB0" }, { k: "exponentiale;", v: "\xE2\x85\x87" }, { k: "fallingdotseq;", v: "\xE2\x89\x92" }, { k: "fcy;", v: "\xD1\x84" }, { k: "female;", v: "\xE2\x99\x80" }, { k: "ffilig;", v: "\xEF\xAC\x83" }, { k: "fflig;", v: "\xEF\xAC\x80" }, { k: "ffllig;", v: "\xEF\xAC\x84" }, { k: "ffr;", v: "\xF0\x9D\x94\xA3" }, { k: "filig;", v: "\xEF\xAC\x81" }, { k: "fjlig;", v: "fj fj" }, { k: "flat;", v: "\xE2\x99\xAD" }, { k: "fllig;", v: "\xEF\xAC\x82" }, { k: "fltns;", v: "\xE2\x96\xB1" }, { k: "fnof;", v: "\xC6\x92" }, { k: "fopf;", v: "\xF0\x9D\x95\x97" }, { k: "forall;", v: "\xE2\x88\x80" }, { k: "fork;", v: "\xE2\x8B\x94" }, { k: "forkv;", v: "\xE2\xAB\x99" }, { k: "fpartint;", v: "\xE2\xA8\x8D" }, { k: "frac12;", v: "\xC2\xBD" }, { k: "frac13;", v: "\xE2\x85\x93" }, { k: "frac14;", v: "\xC2\xBC" }, { k: "frac15;", v: "\xE2\x85\x95" }, { k: "frac16;", v: "\xE2\x85\x99" }, { k: "frac18;", v: "\xE2\x85\x9B" }, { k: "frac23;", v: "\xE2\x85\x94" }, { k: "frac25;", v: "\xE2\x85\x96" }, { k: "frac34;", v: "\xC2\xBE" }, { k: "frac35;", v: "\xE2\x85\x97" }, { k: "frac38;", v: "\xE2\x85\x9C" }, { k: "frac45;", v: "\xE2\x85\x98" }, { k: "frac56;", v: "\xE2\x85\x9A" }, { k: "frac58;", v: "\xE2\x85\x9D" }, { k: "frac78;", v: "\xE2\x85\x9E" }, { k: "frasl;", v: "\xE2\x81\x84" }, { k: "frown;", v: "\xE2\x8C\xA2" }, { k: "fscr;", v: "\xF0\x9D\x92\xBB" }, { k: "gE;", v: "\xE2\x89\xA7" }, { k: "gEl;", v: "\xE2\xAA\x8C" }, { k: "gacute;", v: "\xC7\xB5" }, { k: "gamma;", v: "\xCE\xB3" }, { k: "gammad;", v: "\xCF\x9D" }, { k: "gap;", v: "\xE2\xAA\x86" }, { k: "gbreve;", v: "\xC4\x9F" }, { k: "gcirc;", v: "\xC4\x9D" }, { k: "gcy;", v: "\xD0\xB3" }, { k: "gdot;", v: "\xC4\xA1" }, { k: "ge;", v: "\xE2\x89\xA5" }, { k: "gel;", v: "\xE2\x8B\x9B" }, { k: "geq;", v: "\xE2\x89\xA5" }, { k: "geqq;", v: "\xE2\x89\xA7" }, { k: "geqslant;", v: "\xE2\xA9\xBE" }, { k: "ges;", v: "\xE2\xA9\xBE" }, { k: "gescc;", v: "\xE2\xAA\xA9" }, { k: "gesdot;", v: "\xE2\xAA\x80" }, { k: "gesdoto;", v: "\xE2\xAA\x82" }, { k: "gesdotol;", v: "\xE2\xAA\x84" }, { k: "gesl;", v: "\xE2\x8B\x9B\xEF\xB8\x80" }, { k: "gesles;", v: "\xE2\xAA\x94" }, { k: "gfr;", v: "\xF0\x9D\x94\xA4" }, { k: "gg;", v: "\xE2\x89\xAB" }, { k: "ggg;", v: "\xE2\x8B\x99" }, { k: "gimel;", v: "\xE2\x84\xB7" }, { k: "gjcy;", v: "\xD1\x93" }, { k: "gl;", v: "\xE2\x89\xB7" }, { k: "glE;", v: "\xE2\xAA\x92" }, { k: "gla;", v: "\xE2\xAA\xA5" }, { k: "glj;", v: "\xE2\xAA\xA4" }, { k: "gnE;", v: "\xE2\x89\xA9" }, { k: "gnap;", v: "\xE2\xAA\x8A" }, { k: "gnapprox;", v: "\xE2\xAA\x8A" }, { k: "gne;", v: "\xE2\xAA\x88" }, { k: "gneq;", v: "\xE2\xAA\x88" }, { k: "gneqq;", v: "\xE2\x89\xA9" }, { k: "gnsim;", v: "\xE2\x8B\xA7" }, { k: "gopf;", v: "\xF0\x9D\x95\x98" }, { k: "grave;", v: "`" }, { k: "gscr;", v: "\xE2\x84\x8A" }, { k: "gsim;", v: "\xE2\x89\xB3" }, { k: "gsime;", v: "\xE2\xAA\x8E" }, { k: "gsiml;", v: "\xE2\xAA\x90" }, { k: "gt;", v: ">" }, { k: "gtcc;", v: "\xE2\xAA\xA7" }, { k: "gtcir;", v: "\xE2\xA9\xBA" }, { k: "gtdot;", v: "\xE2\x8B\x97" }, { k: "gtlPar;", v: "\xE2\xA6\x95" }, { k: "gtquest;", v: "\xE2\xA9\xBC" }, { k: "gtrapprox;", v: "\xE2\xAA\x86" }, { k: "gtrarr;", v: "\xE2\xA5\xB8" }, { k: "gtrdot;", v: "\xE2\x8B\x97" }, { k: "gtreqless;", v: "\xE2\x8B\x9B" }, { k: "gtreqqless;", v: "\xE2\xAA\x8C" }, { k: "gtrless;", v: "\xE2\x89\xB7" }, { k: "gtrsim;", v: "\xE2\x89\xB3" }, { k: "gvertneqq;", v: "\xE2\x89\xA9\xEF\xB8\x80" }, { k: "gvnE;", v: "\xE2\x89\xA9\xEF\xB8\x80" }, { k: "hArr;", v: "\xE2\x87\x94" }, { k: "hairsp;", v: "\xE2\x80\x8A" }, { k: "half;", v: "\xC2\xBD" }, { k: "hamilt;", v: "\xE2\x84\x8B" }, { k: "hardcy;", v: "\xD1\x8A" }, { k: "harr;", v: "\xE2\x86\x94" }, { k: "harrcir;", v: "\xE2\xA5\x88" }, { k: "harrw;", v: "\xE2\x86\xAD" }, { k: "hbar;", v: "\xE2\x84\x8F" }, { k: "hcirc;", v: "\xC4\xA5" }, { k: "hearts;", v: "\xE2\x99\xA5" }, { k: "heartsuit;", v: "\xE2\x99\xA5" }, { k: "hellip;", v: "\xE2\x80\xA6" }, { k: "hercon;", v: "\xE2\x8A\xB9" }, { k: "hfr;", v: "\xF0\x9D\x94\xA5" }, { k: "hksearow;", v: "\xE2\xA4\xA5" }, { k: "hkswarow;", v: "\xE2\xA4\xA6" }, { k: "hoarr;", v: "\xE2\x87\xBF" }, { k: "homtht;", v: "\xE2\x88\xBB" }, { k: "hookleftarrow;", v: "\xE2\x86\xA9" }, { k: "hookrightarrow;", v: "\xE2\x86\xAA" }, { k: "hopf;", v: "\xF0\x9D\x95\x99" }, { k: "horbar;", v: "\xE2\x80\x95" }, { k: "hscr;", v: "\xF0\x9D\x92\xBD" }, { k: "hslash;", v: "\xE2\x84\x8F" }, { k: "hstrok;", v: "\xC4\xA7" }, { k: "hybull;", v: "\xE2\x81\x83" }, { k: "hyphen;", v: "\xE2\x80\x90" }, { k: "iacute;", v: "\xC3\xAD" }, { k: "ic;", v: "\xE2\x81\xA3" }, { k: "icirc;", v: "\xC3\xAE" }, { k: "icy;", v: "\xD0\xB8" }, { k: "iecy;", v: "\xD0\xB5" }, { k: "iexcl;", v: "\xC2\xA1" }, { k: "iff;", v: "\xE2\x87\x94" }, { k: "ifr;", v: "\xF0\x9D\x94\xA6" }, { k: "igrave;", v: "\xC3\xAC" }, { k: "ii;", v: "\xE2\x85\x88" }, { k: "iiiint;", v: "\xE2\xA8\x8C" }, { k: "iiint;", v: "\xE2\x88\xAD" }, { k: "iinfin;", v: "\xE2\xA7\x9C" }, { k: "iiota;", v: "\xE2\x84\xA9" }, { k: "ijlig;", v: "\xC4\xB3" }, { k: "imacr;", v: "\xC4\xAB" }, { k: "image;", v: "\xE2\x84\x91" }, { k: "imagline;", v: "\xE2\x84\x90" }, { k: "imagpart;", v: "\xE2\x84\x91" }, { k: "imath;", v: "\xC4\xB1" }, { k: "imof;", v: "\xE2\x8A\xB7" }, { k: "imped;", v: "\xC6\xB5" }, { k: "in;", v: "\xE2\x88\x88" }, { k: "incare;", v: "\xE2\x84\x85" }, { k: "infin;", v: "\xE2\x88\x9E" }, { k: "infintie;", v: "\xE2\xA7\x9D" }, { k: "inodot;", v: "\xC4\xB1" }, { k: "int;", v: "\xE2\x88\xAB" }, { k: "intcal;", v: "\xE2\x8A\xBA" }, { k: "integers;", v: "\xE2\x84\xA4" }, { k: "intercal;", v: "\xE2\x8A\xBA" }, { k: "intlarhk;", v: "\xE2\xA8\x97" }, { k: "intprod;", v: "\xE2\xA8\xBC" }, { k: "iocy;", v: "\xD1\x91" }, { k: "iogon;", v: "\xC4\xAF" }, { k: "iopf;", v: "\xF0\x9D\x95\x9A" }, { k: "iota;", v: "\xCE\xB9" }, { k: "iprod;", v: "\xE2\xA8\xBC" }, { k: "iquest;", v: "\xC2\xBF" }, { k: "iscr;", v: "\xF0\x9D\x92\xBE" }, { k: "isin;", v: "\xE2\x88\x88" }, { k: "isinE;", v: "\xE2\x8B\xB9" }, { k: "isindot;", v: "\xE2\x8B\xB5" }, { k: "isins;", v: "\xE2\x8B\xB4" }, { k: "isinsv;", v: "\xE2\x8B\xB3" }, { k: "isinv;", v: "\xE2\x88\x88" }, { k: "it;", v: "\xE2\x81\xA2" }, { k: "itilde;", v: "\xC4\xA9" }, { k: "iukcy;", v: "\xD1\x96" }, { k: "iuml;", v: "\xC3\xAF" }, { k: "jcirc;", v: "\xC4\xB5" }, { k: "jcy;", v: "\xD0\xB9" }, { k: "jfr;", v: "\xF0\x9D\x94\xA7" }, { k: "jmath;", v: "\xC8\xB7" }, { k: "jopf;", v: "\xF0\x9D\x95\x9B" }, { k: "jscr;", v: "\xF0\x9D\x92\xBF" }, { k: "jsercy;", v: "\xD1\x98" }, { k: "jukcy;", v: "\xD1\x94" }, { k: "kappa;", v: "\xCE\xBA" }, { k: "kappav;", v: "\xCF\xB0" }, { k: "kcedil;", v: "\xC4\xB7" }, { k: "kcy;", v: "\xD0\xBA" }, { k: "kfr;", v: "\xF0\x9D\x94\xA8" }, { k: "kgreen;", v: "\xC4\xB8" }, { k: "khcy;", v: "\xD1\x85" }, { k: "kjcy;", v: "\xD1\x9C" }, { k: "kopf;", v: "\xF0\x9D\x95\x9C" }, { k: "kscr;", v: "\xF0\x9D\x93\x80" }, { k: "lAarr;", v: "\xE2\x87\x9A" }, { k: "lArr;", v: "\xE2\x87\x90" }, { k: "lAtail;", v: "\xE2\xA4\x9B" }, { k: "lBarr;", v: "\xE2\xA4\x8E" }, { k: "lE;", v: "\xE2\x89\xA6" }, { k: "lEg;", v: "\xE2\xAA\x8B" }, { k: "lHar;", v: "\xE2\xA5\xA2" }, { k: "lacute;", v: "\xC4\xBA" }, { k: "laemptyv;", v: "\xE2\xA6\xB4" }, { k: "lagran;", v: "\xE2\x84\x92" }, { k: "lambda;", v: "\xCE\xBB" }, { k: "lang;", v: "\xE2\x9F\xA8" }, { k: "langd;", v: "\xE2\xA6\x91" }, { k: "langle;", v: "\xE2\x9F\xA8" }, { k: "lap;", v: "\xE2\xAA\x85" }, { k: "laquo;", v: "\xC2\xAB" }, { k: "larr;", v: "\xE2\x86\x90" }, { k: "larrb;", v: "\xE2\x87\xA4" }, { k: "larrbfs;", v: "\xE2\xA4\x9F" }, { k: "larrfs;", v: "\xE2\xA4\x9D" }, { k: "larrhk;", v: "\xE2\x86\xA9" }, { k: "larrlp;", v: "\xE2\x86\xAB" }, { k: "larrpl;", v: "\xE2\xA4\xB9" }, { k: "larrsim;", v: "\xE2\xA5\xB3" }, { k: "larrtl;", v: "\xE2\x86\xA2" }, { k: "lat;", v: "\xE2\xAA\xAB" }, { k: "latail;", v: "\xE2\xA4\x99" }, { k: "late;", v: "\xE2\xAA\xAD" }, { k: "lates;", v: "\xE2\xAA\xAD\xEF\xB8\x80" }, { k: "lbarr;", v: "\xE2\xA4\x8C" }, { k: "lbbrk;", v: "\xE2\x9D\xB2" }, { k: "lbrace;", v: "{" }, { k: "lbrack;", v: "[" }, { k: "lbrke;", v: "\xE2\xA6\x8B" }, { k: "lbrksld;", v: "\xE2\xA6\x8F" }, { k: "lbrkslu;", v: "\xE2\xA6\x8D" }, { k: "lcaron;", v: "\xC4\xBE" }, { k: "lcedil;", v: "\xC4\xBC" }, { k: "lceil;", v: "\xE2\x8C\x88" }, { k: "lcub;", v: "{" }, { k: "lcy;", v: "\xD0\xBB" }, { k: "ldca;", v: "\xE2\xA4\xB6" }, { k: "ldquo;", v: "\xE2\x80\x9C" }, { k: "ldquor;", v: "\xE2\x80\x9E" }, { k: "ldrdhar;", v: "\xE2\xA5\xA7" }, { k: "ldrushar;", v: "\xE2\xA5\x8B" }, { k: "ldsh;", v: "\xE2\x86\xB2" }, { k: "le;", v: "\xE2\x89\xA4" }, { k: "leftarrow;", v: "\xE2\x86\x90" }, { k: "leftarrowtail;", v: "\xE2\x86\xA2" }, { k: "leftharpoondown;", v: "\xE2\x86\xBD" }, { k: "leftharpoonup;", v: "\xE2\x86\xBC" }, { k: "leftleftarrows;", v: "\xE2\x87\x87" }, { k: "leftrightarrow;", v: "\xE2\x86\x94" }, { k: "leftrightarrows;", v: "\xE2\x87\x86" }, { k: "leftrightharpoons;", v: "\xE2\x87\x8B" }, { k: "leftrightsquigarrow;", v: "\xE2\x86\xAD" }, { k: "leftthreetimes;", v: "\xE2\x8B\x8B" }, { k: "leg;", v: "\xE2\x8B\x9A" }, { k: "leq;", v: "\xE2\x89\xA4" }, { k: "leqq;", v: "\xE2\x89\xA6" }, { k: "leqslant;", v: "\xE2\xA9\xBD" }, { k: "les;", v: "\xE2\xA9\xBD" }, { k: "lescc;", v: "\xE2\xAA\xA8" }, { k: "lesdot;", v: "\xE2\xA9\xBF" }, { k: "lesdoto;", v: "\xE2\xAA\x81" }, { k: "lesdotor;", v: "\xE2\xAA\x83" }, { k: "lesg;", v: "\xE2\x8B\x9A\xEF\xB8\x80" }, { k: "lesges;", v: "\xE2\xAA\x93" }, { k: "lessapprox;", v: "\xE2\xAA\x85" }, { k: "lessdot;", v: "\xE2\x8B\x96" }, { k: "lesseqgtr;", v: "\xE2\x8B\x9A" }, { k: "lesseqqgtr;", v: "\xE2\xAA\x8B" }, { k: "lessgtr;", v: "\xE2\x89\xB6" }, { k: "lesssim;", v: "\xE2\x89\xB2" }, { k: "lfisht;", v: "\xE2\xA5\xBC" }, { k: "lfloor;", v: "\xE2\x8C\x8A" }, { k: "lfr;", v: "\xF0\x9D\x94\xA9" }, { k: "lg;", v: "\xE2\x89\xB6" }, { k: "lgE;", v: "\xE2\xAA\x91" }, { k: "lhard;", v: "\xE2\x86\xBD" }, { k: "lharu;", v: "\xE2\x86\xBC" }, { k: "lharul;", v: "\xE2\xA5\xAA" }, { k: "lhblk;", v: "\xE2\x96\x84" }, { k: "ljcy;", v: "\xD1\x99" }, { k: "ll;", v: "\xE2\x89\xAA" }, { k: "llarr;", v: "\xE2\x87\x87" }, { k: "llcorner;", v: "\xE2\x8C\x9E" }, { k: "llhard;", v: "\xE2\xA5\xAB" }, { k: "lltri;", v: "\xE2\x97\xBA" }, { k: "lmidot;", v: "\xC5\x80" }, { k: "lmoust;", v: "\xE2\x8E\xB0" }, { k: "lmoustache;", v: "\xE2\x8E\xB0" }, { k: "lnE;", v: "\xE2\x89\xA8" }, { k: "lnap;", v: "\xE2\xAA\x89" }, { k: "lnapprox;", v: "\xE2\xAA\x89" }, { k: "lne;", v: "\xE2\xAA\x87" }, { k: "lneq;", v: "\xE2\xAA\x87" }, { k: "lneqq;", v: "\xE2\x89\xA8" }, { k: "lnsim;", v: "\xE2\x8B\xA6" }, { k: "loang;", v: "\xE2\x9F\xAC" }, { k: "loarr;", v: "\xE2\x87\xBD" }, { k: "lobrk;", v: "\xE2\x9F\xA6" }, { k: "longleftarrow;", v: "\xE2\x9F\xB5" }, { k: "longleftrightarrow;", v: "\xE2\x9F\xB7" }, { k: "longmapsto;", v: "\xE2\x9F\xBC" }, { k: "longrightarrow;", v: "\xE2\x9F\xB6" }, { k: "looparrowleft;", v: "\xE2\x86\xAB" }, { k: "looparrowright;", v: "\xE2\x86\xAC" }, { k: "lopar;", v: "\xE2\xA6\x85" }, { k: "lopf;", v: "\xF0\x9D\x95\x9D" }, { k: "loplus;", v: "\xE2\xA8\xAD" }, { k: "lotimes;", v: "\xE2\xA8\xB4" }, { k: "lowast;", v: "\xE2\x88\x97" }, { k: "lowbar;", v: "_" }, { k: "loz;", v: "\xE2\x97\x8A" }, { k: "lozenge;", v: "\xE2\x97\x8A" }, { k: "lozf;", v: "\xE2\xA7\xAB" }, { k: "lpar;", v: "(" }, { k: "lparlt;", v: "\xE2\xA6\x93" }, { k: "lrarr;", v: "\xE2\x87\x86" }, { k: "lrcorner;", v: "\xE2\x8C\x9F" }, { k: "lrhar;", v: "\xE2\x87\x8B" }, { k: "lrhard;", v: "\xE2\xA5\xAD" }, { k: "lrm;", v: "\xE2\x80\x8E" }, { k: "lrtri;", v: "\xE2\x8A\xBF" }, { k: "lsaquo;", v: "\xE2\x80\xB9" }, { k: "lscr;", v: "\xF0\x9D\x93\x81" }, { k: "lsh;", v: "\xE2\x86\xB0" }, { k: "lsim;", v: "\xE2\x89\xB2" }, { k: "lsime;", v: "\xE2\xAA\x8D" }, { k: "lsimg;", v: "\xE2\xAA\x8F" }, { k: "lsqb;", v: "[" }, { k: "lsquo;", v: "\xE2\x80\x98" }, { k: "lsquor;", v: "\xE2\x80\x9A" }, { k: "lstrok;", v: "\xC5\x82" }, { k: "lt;", v: "<" }, { k: "ltcc;", v: "\xE2\xAA\xA6" }, { k: "ltcir;", v: "\xE2\xA9\xB9" }, { k: "ltdot;", v: "\xE2\x8B\x96" }, { k: "lthree;", v: "\xE2\x8B\x8B" }, { k: "ltimes;", v: "\xE2\x8B\x89" }, { k: "ltlarr;", v: "\xE2\xA5\xB6" }, { k: "ltquest;", v: "\xE2\xA9\xBB" }, { k: "ltrPar;", v: "\xE2\xA6\x96" }, { k: "ltri;", v: "\xE2\x97\x83" }, { k: "ltrie;", v: "\xE2\x8A\xB4" }, { k: "ltrif;", v: "\xE2\x97\x82" }, { k: "lurdshar;", v: "\xE2\xA5\x8A" }, { k: "luruhar;", v: "\xE2\xA5\xA6" }, { k: "lvertneqq;", v: "\xE2\x89\xA8\xEF\xB8\x80" }, { k: "lvnE;", v: "\xE2\x89\xA8\xEF\xB8\x80" }, { k: "mDDot;", v: "\xE2\x88\xBA" }, { k: "macr;", v: "\xC2\xAF" }, { k: "male;", v: "\xE2\x99\x82" }, { k: "malt;", v: "\xE2\x9C\xA0" }, { k: "maltese;", v: "\xE2\x9C\xA0" }, { k: "map;", v: "\xE2\x86\xA6" }, { k: "mapsto;", v: "\xE2\x86\xA6" }, { k: "mapstodown;", v: "\xE2\x86\xA7" }, { k: "mapstoleft;", v: "\xE2\x86\xA4" }, { k: "mapstoup;", v: "\xE2\x86\xA5" }, { k: "marker;", v: "\xE2\x96\xAE" }, { k: "mcomma;", v: "\xE2\xA8\xA9" }, { k: "mcy;", v: "\xD0\xBC" }, { k: "mdash;", v: "\xE2\x80\x94" }, { k: "measuredangle;", v: "\xE2\x88\xA1" }, { k: "mfr;", v: "\xF0\x9D\x94\xAA" }, { k: "mho;", v: "\xE2\x84\xA7" }, { k: "micro;", v: "\xC2\xB5" }, { k: "mid;", v: "\xE2\x88\xA3" }, { k: "midast;", v: "*" }, { k: "midcir;", v: "\xE2\xAB\xB0" }, { k: "middot;", v: "\xC2\xB7" }, { k: "minus;", v: "\xE2\x88\x92" }, { k: "minusb;", v: "\xE2\x8A\x9F" }, { k: "minusd;", v: "\xE2\x88\xB8" }, { k: "minusdu;", v: "\xE2\xA8\xAA" }, { k: "mlcp;", v: "\xE2\xAB\x9B" }, { k: "mldr;", v: "\xE2\x80\xA6" }, { k: "mnplus;", v: "\xE2\x88\x93" }, { k: "models;", v: "\xE2\x8A\xA7" }, { k: "mopf;", v: "\xF0\x9D\x95\x9E" }, { k: "mp;", v: "\xE2\x88\x93" }, { k: "mscr;", v: "\xF0\x9D\x93\x82" }, { k: "mstpos;", v: "\xE2\x88\xBE" }, { k: "mu;", v: "\xCE\xBC" }, { k: "multimap;", v: "\xE2\x8A\xB8" }, { k: "mumap;", v: "\xE2\x8A\xB8" }, { k: "nGg;", v: "\xE2\x8B\x99\xCC\xB8" }, { k: "nGt;", v: "\xE2\x89\xAB\xE2\x83\x92" }, { k: "nGtv;", v: "\xE2\x89\xAB\xCC\xB8" }, { k: "nLeftarrow;", v: "\xE2\x87\x8D" }, { k: "nLeftrightarrow;", v: "\xE2\x87\x8E" }, { k: "nLl;", v: "\xE2\x8B\x98\xCC\xB8" }, { k: "nLt;", v: "\xE2\x89\xAA\xE2\x83\x92" }, { k: "nLtv;", v: "\xE2\x89\xAA\xCC\xB8" }, { k: "nRightarrow;", v: "\xE2\x87\x8F" }, { k: "nVDash;", v: "\xE2\x8A\xAF" }, { k: "nVdash;", v: "\xE2\x8A\xAE" }, { k: "nabla;", v: "\xE2\x88\x87" }, { k: "nacute;", v: "\xC5\x84" }, { k: "nang;", v: "\xE2\x88\xA0\xE2\x83\x92" }, { k: "nap;", v: "\xE2\x89\x89" }, { k: "napE;", v: "\xE2\xA9\xB0\xCC\xB8" }, { k: "napid;", v: "\xE2\x89\x8B\xCC\xB8" }, { k: "napos;", v: "\xC5\x89" }, { k: "napprox;", v: "\xE2\x89\x89" }, { k: "natur;", v: "\xE2\x99\xAE" }, { k: "natural;", v: "\xE2\x99\xAE" }, { k: "naturals;", v: "\xE2\x84\x95" }, { k: "nbsp;", v: "\xC2\xA0" }, { k: "nbump;", v: "\xE2\x89\x8E\xCC\xB8" }, { k: "nbumpe;", v: "\xE2\x89\x8F\xCC\xB8" }, { k: "ncap;", v: "\xE2\xA9\x83" }, { k: "ncaron;", v: "\xC5\x88" }, { k: "ncedil;", v: "\xC5\x86" }, { k: "ncong;", v: "\xE2\x89\x87" }, { k: "ncongdot;", v: "\xE2\xA9\xAD\xCC\xB8" }, { k: "ncup;", v: "\xE2\xA9\x82" }, { k: "ncy;", v: "\xD0\xBD" }, { k: "ndash;", v: "\xE2\x80\x93" }, { k: "ne;", v: "\xE2\x89\xA0" }, { k: "neArr;", v: "\xE2\x87\x97" }, { k: "nearhk;", v: "\xE2\xA4\xA4" }, { k: "nearr;", v: "\xE2\x86\x97" }, { k: "nearrow;", v: "\xE2\x86\x97" }, { k: "nedot;", v: "\xE2\x89\x90\xCC\xB8" }, { k: "nequiv;", v: "\xE2\x89\xA2" }, { k: "nesear;", v: "\xE2\xA4\xA8" }, { k: "nesim;", v: "\xE2\x89\x82\xCC\xB8" }, { k: "nexist;", v: "\xE2\x88\x84" }, { k: "nexists;", v: "\xE2\x88\x84" }, { k: "nfr;", v: "\xF0\x9D\x94\xAB" }, { k: "ngE;", v: "\xE2\x89\xA7\xCC\xB8" }, { k: "nge;", v: "\xE2\x89\xB1" }, { k: "ngeq;", v: "\xE2\x89\xB1" }, { k: "ngeqq;", v: "\xE2\x89\xA7\xCC\xB8" }, { k: "ngeqslant;", v: "\xE2\xA9\xBE\xCC\xB8" }, { k: "nges;", v: "\xE2\xA9\xBE\xCC\xB8" }, { k: "ngsim;", v: "\xE2\x89\xB5" }, { k: "ngt;", v: "\xE2\x89\xAF" }, { k: "ngtr;", v: "\xE2\x89\xAF" }, { k: "nhArr;", v: "\xE2\x87\x8E" }, { k: "nharr;", v: "\xE2\x86\xAE" }, { k: "nhpar;", v: "\xE2\xAB\xB2" }, { k: "ni;", v: "\xE2\x88\x8B" }, { k: "nis;", v: "\xE2\x8B\xBC" }, { k: "nisd;", v: "\xE2\x8B\xBA" }, { k: "niv;", v: "\xE2\x88\x8B" }, { k: "njcy;", v: "\xD1\x9A" }, { k: "nlArr;", v: "\xE2\x87\x8D" }, { k: "nlE;", v: "\xE2\x89\xA6\xCC\xB8" }, { k: "nlarr;", v: "\xE2\x86\x9A" }, { k: "nldr;", v: "\xE2\x80\xA5" }, { k: "nle;", v: "\xE2\x89\xB0" }, { k: "nleftarrow;", v: "\xE2\x86\x9A" }, { k: "nleftrightarrow;", v: "\xE2\x86\xAE" }, { k: "nleq;", v: "\xE2\x89\xB0" }, { k: "nleqq;", v: "\xE2\x89\xA6\xCC\xB8" }, { k: "nleqslant;", v: "\xE2\xA9\xBD\xCC\xB8" }, { k: "nles;", v: "\xE2\xA9\xBD\xCC\xB8" }, { k: "nless;", v: "\xE2\x89\xAE" }, { k: "nlsim;", v: "\xE2\x89\xB4" }, { k: "nlt;", v: "\xE2\x89\xAE" }, { k: "nltri;", v: "\xE2\x8B\xAA" }, { k: "nltrie;", v: "\xE2\x8B\xAC" }, { k: "nmid;", v: "\xE2\x88\xA4" }, { k: "nopf;", v: "\xF0\x9D\x95\x9F" }, { k: "not;", v: "\xC2\xAC" }, { k: "notin;", v: "\xE2\x88\x89" }, { k: "notinE;", v: "\xE2\x8B\xB9\xCC\xB8" }, { k: "notindot;", v: "\xE2\x8B\xB5\xCC\xB8" }, { k: "notinva;", v: "\xE2\x88\x89" }, { k: "notinvb;", v: "\xE2\x8B\xB7" }, { k: "notinvc;", v: "\xE2\x8B\xB6" }, { k: "notni;", v: "\xE2\x88\x8C" }, { k: "notniva;", v: "\xE2\x88\x8C" }, { k: "notnivb;", v: "\xE2\x8B\xBE" }, { k: "notnivc;", v: "\xE2\x8B\xBD" }, { k: "npar;", v: "\xE2\x88\xA6" }, { k: "nparallel;", v: "\xE2\x88\xA6" }, { k: "nparsl;", v: "\xE2\xAB\xBD\xE2\x83\xA5" }, { k: "npart;", v: "\xE2\x88\x82\xCC\xB8" }, { k: "npolint;", v: "\xE2\xA8\x94" }, { k: "npr;", v: "\xE2\x8A\x80" }, { k: "nprcue;", v: "\xE2\x8B\xA0" }, { k: "npre;", v: "\xE2\xAA\xAF\xCC\xB8" }, { k: "nprec;", v: "\xE2\x8A\x80" }, { k: "npreceq;", v: "\xE2\xAA\xAF\xCC\xB8" }, { k: "nrArr;", v: "\xE2\x87\x8F" }, { k: "nrarr;", v: "\xE2\x86\x9B" }, { k: "nrarrc;", v: "\xE2\xA4\xB3\xCC\xB8" }, { k: "nrarrw;", v: "\xE2\x86\x9D\xCC\xB8" }, { k: "nrightarrow;", v: "\xE2\x86\x9B" }, { k: "nrtri;", v: "\xE2\x8B\xAB" }, { k: "nrtrie;", v: "\xE2\x8B\xAD" }, { k: "nsc;", v: "\xE2\x8A\x81" }, { k: "nsccue;", v: "\xE2\x8B\xA1" }, { k: "nsce;", v: "\xE2\xAA\xB0\xCC\xB8" }, { k: "nscr;", v: "\xF0\x9D\x93\x83" }, { k: "nshortmid;", v: "\xE2\x88\xA4" }, { k: "nshortparallel;", v: "\xE2\x88\xA6" }, { k: "nsim;", v: "\xE2\x89\x81" }, { k: "nsime;", v: "\xE2\x89\x84" }, { k: "nsimeq;", v: "\xE2\x89\x84" }, { k: "nsmid;", v: "\xE2\x88\xA4" }, { k: "nspar;", v: "\xE2\x88\xA6" }, { k: "nsqsube;", v: "\xE2\x8B\xA2" }, { k: "nsqsupe;", v: "\xE2\x8B\xA3" }, { k: "nsub;", v: "\xE2\x8A\x84" }, { k: "nsubE;", v: "\xE2\xAB\x85\xCC\xB8" }, { k: "nsube;", v: "\xE2\x8A\x88" }, { k: "nsubset;", v: "\xE2\x8A\x82\xE2\x83\x92" }, { k: "nsubseteq;", v: "\xE2\x8A\x88" }, { k: "nsubseteqq;", v: "\xE2\xAB\x85\xCC\xB8" }, { k: "nsucc;", v: "\xE2\x8A\x81" }, { k: "nsucceq;", v: "\xE2\xAA\xB0\xCC\xB8" }, { k: "nsup;", v: "\xE2\x8A\x85" }, { k: "nsupE;", v: "\xE2\xAB\x86\xCC\xB8" }, { k: "nsupe;", v: "\xE2\x8A\x89" }, { k: "nsupset;", v: "\xE2\x8A\x83\xE2\x83\x92" }, { k: "nsupseteq;", v: "\xE2\x8A\x89" }, { k: "nsupseteqq;", v: "\xE2\xAB\x86\xCC\xB8" }, { k: "ntgl;", v: "\xE2\x89\xB9" }, { k: "ntilde;", v: "\xC3\xB1" }, { k: "ntlg;", v: "\xE2\x89\xB8" }, { k: "ntriangleleft;", v: "\xE2\x8B\xAA" }, { k: "ntrianglelefteq;", v: "\xE2\x8B\xAC" }, { k: "ntriangleright;", v: "\xE2\x8B\xAB" }, { k: "ntrianglerighteq;", v: "\xE2\x8B\xAD" }, { k: "nu;", v: "\xCE\xBD" }, { k: "num;", v: "#" }, { k: "numero;", v: "\xE2\x84\x96" }, { k: "numsp;", v: "\xE2\x80\x87" }, { k: "nvDash;", v: "\xE2\x8A\xAD" }, { k: "nvHarr;", v: "\xE2\xA4\x84" }, { k: "nvap;", v: "\xE2\x89\x8D\xE2\x83\x92" }, { k: "nvdash;", v: "\xE2\x8A\xAC" }, { k: "nvge;", v: "\xE2\x89\xA5\xE2\x83\x92" }, { k: "nvgt;", v: ">\xE2\x83\x92" }, { k: "nvinfin;", v: "\xE2\xA7\x9E" }, { k: "nvlArr;", v: "\xE2\xA4\x82" }, { k: "nvle;", v: "\xE2\x89\xA4\xE2\x83\x92" }, { k: "nvlt;", v: "<\xE2\x83\x92" }, { k: "nvltrie;", v: "\xE2\x8A\xB4\xE2\x83\x92" }, { k: "nvrArr;", v: "\xE2\xA4\x83" }, { k: "nvrtrie;", v: "\xE2\x8A\xB5\xE2\x83\x92" }, { k: "nvsim;", v: "\xE2\x88\xBC\xE2\x83\x92" }, { k: "nwArr;", v: "\xE2\x87\x96" }, { k: "nwarhk;", v: "\xE2\xA4\xA3" }, { k: "nwarr;", v: "\xE2\x86\x96" }, { k: "nwarrow;", v: "\xE2\x86\x96" }, { k: "nwnear;", v: "\xE2\xA4\xA7" }, { k: "oS;", v: "\xE2\x93\x88" }, { k: "oacute;", v: "\xC3\xB3" }, { k: "oast;", v: "\xE2\x8A\x9B" }, { k: "ocir;", v: "\xE2\x8A\x9A" }, { k: "ocirc;", v: "\xC3\xB4" }, { k: "ocy;", v: "\xD0\xBE" }, { k: "odash;", v: "\xE2\x8A\x9D" }, { k: "odblac;", v: "\xC5\x91" }, { k: "odiv;", v: "\xE2\xA8\xB8" }, { k: "odot;", v: "\xE2\x8A\x99" }, { k: "odsold;", v: "\xE2\xA6\xBC" }, { k: "oelig;", v: "\xC5\x93" }, { k: "ofcir;", v: "\xE2\xA6\xBF" }, { k: "ofr;", v: "\xF0\x9D\x94\xAC" }, { k: "ogon;", v: "\xCB\x9B" }, { k: "ograve;", v: "\xC3\xB2" }, { k: "ogt;", v: "\xE2\xA7\x81" }, { k: "ohbar;", v: "\xE2\xA6\xB5" }, { k: "ohm;", v: "\xCE\xA9" }, { k: "oint;", v: "\xE2\x88\xAE" }, { k: "olarr;", v: "\xE2\x86\xBA" }, { k: "olcir;", v: "\xE2\xA6\xBE" }, { k: "olcross;", v: "\xE2\xA6\xBB" }, { k: "oline;", v: "\xE2\x80\xBE" }, { k: "olt;", v: "\xE2\xA7\x80" }, { k: "omacr;", v: "\xC5\x8D" }, { k: "omega;", v: "\xCF\x89" }, { k: "omicron;", v: "\xCE\xBF" }, { k: "omid;", v: "\xE2\xA6\xB6" }, { k: "ominus;", v: "\xE2\x8A\x96" }, { k: "oopf;", v: "\xF0\x9D\x95\xA0" }, { k: "opar;", v: "\xE2\xA6\xB7" }, { k: "operp;", v: "\xE2\xA6\xB9" }, { k: "oplus;", v: "\xE2\x8A\x95" }, { k: "or;", v: "\xE2\x88\xA8" }, { k: "orarr;", v: "\xE2\x86\xBB" }, { k: "ord;", v: "\xE2\xA9\x9D" }, { k: "order;", v: "\xE2\x84\xB4" }, { k: "orderof;", v: "\xE2\x84\xB4" }, { k: "ordf;", v: "\xC2\xAA" }, { k: "ordm;", v: "\xC2\xBA" }, { k: "origof;", v: "\xE2\x8A\xB6" }, { k: "oror;", v: "\xE2\xA9\x96" }, { k: "orslope;", v: "\xE2\xA9\x97" }, { k: "orv;", v: "\xE2\xA9\x9B" }, { k: "oscr;", v: "\xE2\x84\xB4" }, { k: "oslash;", v: "\xC3\xB8" }, { k: "osol;", v: "\xE2\x8A\x98" }, { k: "otilde;", v: "\xC3\xB5" }, { k: "otimes;", v: "\xE2\x8A\x97" }, { k: "otimesas;", v: "\xE2\xA8\xB6" }, { k: "ouml;", v: "\xC3\xB6" }, { k: "ovbar;", v: "\xE2\x8C\xBD" }, { k: "par;", v: "\xE2\x88\xA5" }, { k: "para;", v: "\xC2\xB6" }, { k: "parallel;", v: "\xE2\x88\xA5" }, { k: "parsim;", v: "\xE2\xAB\xB3" }, { k: "parsl;", v: "\xE2\xAB\xBD" }, { k: "part;", v: "\xE2\x88\x82" }, { k: "pcy;", v: "\xD0\xBF" }, { k: "percnt;", v: "%" }, { k: "period;", v: "." }, { k: "permil;", v: "\xE2\x80\xB0" }, { k: "perp;", v: "\xE2\x8A\xA5" }, { k: "pertenk;", v: "\xE2\x80\xB1" }, { k: "pfr;", v: "\xF0\x9D\x94\xAD" }, { k: "phi;", v: "\xCF\x86" }, { k: "phiv;", v: "\xCF\x95" }, { k: "phmmat;", v: "\xE2\x84\xB3" }, { k: "phone;", v: "\xE2\x98\x8E" }, { k: "pi;", v: "\xCF\x80" }, { k: "pitchfork;", v: "\xE2\x8B\x94" }, { k: "piv;", v: "\xCF\x96" }, { k: "planck;", v: "\xE2\x84\x8F" }, { k: "planckh;", v: "\xE2\x84\x8E" }, { k: "plankv;", v: "\xE2\x84\x8F" }, { k: "plus;", v: "+" }, { k: "plusacir;", v: "\xE2\xA8\xA3" }, { k: "plusb;", v: "\xE2\x8A\x9E" }, { k: "pluscir;", v: "\xE2\xA8\xA2" }, { k: "plusdo;", v: "\xE2\x88\x94" }, { k: "plusdu;", v: "\xE2\xA8\xA5" }, { k: "pluse;", v: "\xE2\xA9\xB2" }, { k: "plusmn;", v: "\xC2\xB1" }, { k: "plussim;", v: "\xE2\xA8\xA6" }, { k: "plustwo;", v: "\xE2\xA8\xA7" }, { k: "pm;", v: "\xC2\xB1" }, { k: "pointint;", v: "\xE2\xA8\x95" }, { k: "popf;", v: "\xF0\x9D\x95\xA1" }, { k: "pound;", v: "\xC2\xA3" }, { k: "pr;", v: "\xE2\x89\xBA" }, { k: "prE;", v: "\xE2\xAA\xB3" }, { k: "prap;", v: "\xE2\xAA\xB7" }, { k: "prcue;", v: "\xE2\x89\xBC" }, { k: "pre;", v: "\xE2\xAA\xAF" }, { k: "prec;", v: "\xE2\x89\xBA" }, { k: "precapprox;", v: "\xE2\xAA\xB7" }, { k: "preccurlyeq;", v: "\xE2\x89\xBC" }, { k: "preceq;", v: "\xE2\xAA\xAF" }, { k: "precnapprox;", v: "\xE2\xAA\xB9" }, { k: "precneqq;", v: "\xE2\xAA\xB5" }, { k: "precnsim;", v: "\xE2\x8B\xA8" }, { k: "precsim;", v: "\xE2\x89\xBE" }, { k: "prime;", v: "\xE2\x80\xB2" }, { k: "primes;", v: "\xE2\x84\x99" }, { k: "prnE;", v: "\xE2\xAA\xB5" }, { k: "prnap;", v: "\xE2\xAA\xB9" }, { k: "prnsim;", v: "\xE2\x8B\xA8" }, { k: "prod;", v: "\xE2\x88\x8F" }, { k: "profalar;", v: "\xE2\x8C\xAE" }, { k: "profline;", v: "\xE2\x8C\x92" }, { k: "profsurf;", v: "\xE2\x8C\x93" }, { k: "prop;", v: "\xE2\x88\x9D" }, { k: "propto;", v: "\xE2\x88\x9D" }, { k: "prsim;", v: "\xE2\x89\xBE" }, { k: "prurel;", v: "\xE2\x8A\xB0" }, { k: "pscr;", v: "\xF0\x9D\x93\x85" }, { k: "psi;", v: "\xCF\x88" }, { k: "puncsp;", v: "\xE2\x80\x88" }, { k: "qfr;", v: "\xF0\x9D\x94\xAE" }, { k: "qint;", v: "\xE2\xA8\x8C" }, { k: "qopf;", v: "\xF0\x9D\x95\xA2" }, { k: "qprime;", v: "\xE2\x81\x97" }, { k: "qscr;", v: "\xF0\x9D\x93\x86" }, { k: "quaternions;", v: "\xE2\x84\x8D" }, { k: "quatint;", v: "\xE2\xA8\x96" }, { k: "quest;", v: "?" }, { k: "questeq;", v: "\xE2\x89\x9F" }, { k: "quot;", v: "\"" }, { k: "rAarr;", v: "\xE2\x87\x9B" }, { k: "rArr;", v: "\xE2\x87\x92" }, { k: "rAtail;", v: "\xE2\xA4\x9C" }, { k: "rBarr;", v: "\xE2\xA4\x8F" }, { k: "rHar;", v: "\xE2\xA5\xA4" }, { k: "race;", v: "\xE2\x88\xBD\xCC\xB1" }, { k: "racute;", v: "\xC5\x95" }, { k: "radic;", v: "\xE2\x88\x9A" }, { k: "raemptyv;", v: "\xE2\xA6\xB3" }, { k: "rang;", v: "\xE2\x9F\xA9" }, { k: "rangd;", v: "\xE2\xA6\x92" }, { k: "range;", v: "\xE2\xA6\xA5" }, { k: "rangle;", v: "\xE2\x9F\xA9" }, { k: "raquo;", v: "\xC2\xBB" }, { k: "rarr;", v: "\xE2\x86\x92" }, { k: "rarrap;", v: "\xE2\xA5\xB5" }, { k: "rarrb;", v: "\xE2\x87\xA5" }, { k: "rarrbfs;", v: "\xE2\xA4\xA0" }, { k: "rarrc;", v: "\xE2\xA4\xB3" }, { k: "rarrfs;", v: "\xE2\xA4\x9E" }, { k: "rarrhk;", v: "\xE2\x86\xAA" }, { k: "rarrlp;", v: "\xE2\x86\xAC" }, { k: "rarrpl;", v: "\xE2\xA5\x85" }, { k: "rarrsim;", v: "\xE2\xA5\xB4" }, { k: "rarrtl;", v: "\xE2\x86\xA3" }, { k: "rarrw;", v: "\xE2\x86\x9D" }, { k: "ratail;", v: "\xE2\xA4\x9A" }, { k: "ratio;", v: "\xE2\x88\xB6" }, { k: "rationals;", v: "\xE2\x84\x9A" }, { k: "rbarr;", v: "\xE2\xA4\x8D" }, { k: "rbbrk;", v: "\xE2\x9D\xB3" }, { k: "rbrace;", v: "}" }, { k: "rbrack;", v: "]" }, { k: "rbrke;", v: "\xE2\xA6\x8C" }, { k: "rbrksld;", v: "\xE2\xA6\x8E" }, { k: "rbrkslu;", v: "\xE2\xA6\x90" }, { k: "rcaron;", v: "\xC5\x99" }, { k: "rcedil;", v: "\xC5\x97" }, { k: "rceil;", v: "\xE2\x8C\x89" }, { k: "rcub;", v: "}" }, { k: "rcy;", v: "\xD1\x80" }, { k: "rdca;", v: "\xE2\xA4\xB7" }, { k: "rdldhar;", v: "\xE2\xA5\xA9" }, { k: "rdquo;", v: "\xE2\x80\x9D" }, { k: "rdquor;", v: "\xE2\x80\x9D" }, { k: "rdsh;", v: "\xE2\x86\xB3" }, { k: "real;", v: "\xE2\x84\x9C" }, { k: "realine;", v: "\xE2\x84\x9B" }, { k: "realpart;", v: "\xE2\x84\x9C" }, { k: "reals;", v: "\xE2\x84\x9D" }, { k: "rect;", v: "\xE2\x96\xAD" }, { k: "reg;", v: "\xC2\xAE" }, { k: "rfisht;", v: "\xE2\xA5\xBD" }, { k: "rfloor;", v: "\xE2\x8C\x8B" }, { k: "rfr;", v: "\xF0\x9D\x94\xAF" }, { k: "rhard;", v: "\xE2\x87\x81" }, { k: "rharu;", v: "\xE2\x87\x80" }, { k: "rharul;", v: "\xE2\xA5\xAC" }, { k: "rho;", v: "\xCF\x81" }, { k: "rhov;", v: "\xCF\xB1" }, { k: "rightarrow;", v: "\xE2\x86\x92" }, { k: "rightarrowtail;", v: "\xE2\x86\xA3" }, { k: "rightharpoondown;", v: "\xE2\x87\x81" }, { k: "rightharpoonup;", v: "\xE2\x87\x80" }, { k: "rightleftarrows;", v: "\xE2\x87\x84" }, { k: "rightleftharpoons;", v: "\xE2\x87\x8C" }, { k: "rightrightarrows;", v: "\xE2\x87\x89" }, { k: "rightsquigarrow;", v: "\xE2\x86\x9D" }, { k: "rightthreetimes;", v: "\xE2\x8B\x8C" }, { k: "ring;", v: "\xCB\x9A" }, { k: "risingdotseq;", v: "\xE2\x89\x93" }, { k: "rlarr;", v: "\xE2\x87\x84" }, { k: "rlhar;", v: "\xE2\x87\x8C" }, { k: "rlm;", v: "\xE2\x80\x8F" }, { k: "rmoust;", v: "\xE2\x8E\xB1" }, { k: "rmoustache;", v: "\xE2\x8E\xB1" }, { k: "rnmid;", v: "\xE2\xAB\xAE" }, { k: "roang;", v: "\xE2\x9F\xAD" }, { k: "roarr;", v: "\xE2\x87\xBE" }, { k: "robrk;", v: "\xE2\x9F\xA7" }, { k: "ropar;", v: "\xE2\xA6\x86" }, { k: "ropf;", v: "\xF0\x9D\x95\xA3" }, { k: "roplus;", v: "\xE2\xA8\xAE" }, { k: "rotimes;", v: "\xE2\xA8\xB5" }, { k: "rpar;", v: ")" }, { k: "rpargt;", v: "\xE2\xA6\x94" }, { k: "rppolint;", v: "\xE2\xA8\x92" }, { k: "rrarr;", v: "\xE2\x87\x89" }, { k: "rsaquo;", v: "\xE2\x80\xBA" }, { k: "rscr;", v: "\xF0\x9D\x93\x87" }, { k: "rsh;", v: "\xE2\x86\xB1" }, { k: "rsqb;", v: "]" }, { k: "rsquo;", v: "\xE2\x80\x99" }, { k: "rsquor;", v: "\xE2\x80\x99" }, { k: "rthree;", v: "\xE2\x8B\x8C" }, { k: "rtimes;", v: "\xE2\x8B\x8A" }, { k: "rtri;", v: "\xE2\x96\xB9" }, { k: "rtrie;", v: "\xE2\x8A\xB5" }, { k: "rtrif;", v: "\xE2\x96\xB8" }, { k: "rtriltri;", v: "\xE2\xA7\x8E" }, { k: "ruluhar;", v: "\xE2\xA5\xA8" }, { k: "rx;", v: "\xE2\x84\x9E" }, { k: "sacute;", v: "\xC5\x9B" }, { k: "sbquo;", v: "\xE2\x80\x9A" }, { k: "sc;", v: "\xE2\x89\xBB" }, { k: "scE;", v: "\xE2\xAA\xB4" }, { k: "scap;", v: "\xE2\xAA\xB8" }, { k: "scaron;", v: "\xC5\xA1" }, { k: "sccue;", v: "\xE2\x89\xBD" }, { k: "sce;", v: "\xE2\xAA\xB0" }, { k: "scedil;", v: "\xC5\x9F" }, { k: "scirc;", v: "\xC5\x9D" }, { k: "scnE;", v: "\xE2\xAA\xB6" }, { k: "scnap;", v: "\xE2\xAA\xBA" }, { k: "scnsim;", v: "\xE2\x8B\xA9" }, { k: "scpolint;", v: "\xE2\xA8\x93" }, { k: "scsim;", v: "\xE2\x89\xBF" }, { k: "scy;", v: "\xD1\x81" }, { k: "sdot;", v: "\xE2\x8B\x85" }, { k: "sdotb;", v: "\xE2\x8A\xA1" }, { k: "sdote;", v: "\xE2\xA9\xA6" }, { k: "seArr;", v: "\xE2\x87\x98" }, { k: "searhk;", v: "\xE2\xA4\xA5" }, { k: "searr;", v: "\xE2\x86\x98" }, { k: "searrow;", v: "\xE2\x86\x98" }, { k: "sect;", v: "\xC2\xA7" }, { k: "semi;", v: ";" }, { k: "seswar;", v: "\xE2\xA4\xA9" }, { k: "setminus;", v: "\xE2\x88\x96" }, { k: "setmn;", v: "\xE2\x88\x96" }, { k: "sext;", v: "\xE2\x9C\xB6" }, { k: "sfr;", v: "\xF0\x9D\x94\xB0" }, { k: "sfrown;", v: "\xE2\x8C\xA2" }, { k: "sharp;", v: "\xE2\x99\xAF" }, { k: "shchcy;", v: "\xD1\x89" }, { k: "shcy;", v: "\xD1\x88" }, { k: "shortmid;", v: "\xE2\x88\xA3" }, { k: "shortparallel;", v: "\xE2\x88\xA5" }, { k: "shy;", v: "\xC2\xAD" }, { k: "sigma;", v: "\xCF\x83" }, { k: "sigmaf;", v: "\xCF\x82" }, { k: "sigmav;", v: "\xCF\x82" }, { k: "sim;", v: "\xE2\x88\xBC" }, { k: "simdot;", v: "\xE2\xA9\xAA" }, { k: "sime;", v: "\xE2\x89\x83" }, { k: "simeq;", v: "\xE2\x89\x83" }, { k: "simg;", v: "\xE2\xAA\x9E" }, { k: "simgE;", v: "\xE2\xAA\xA0" }, { k: "siml;", v: "\xE2\xAA\x9D" }, { k: "simlE;", v: "\xE2\xAA\x9F" }, { k: "simne;", v: "\xE2\x89\x86" }, { k: "simplus;", v: "\xE2\xA8\xA4" }, { k: "simrarr;", v: "\xE2\xA5\xB2" }, { k: "slarr;", v: "\xE2\x86\x90" }, { k: "smallsetminus;", v: "\xE2\x88\x96" }, { k: "smashp;", v: "\xE2\xA8\xB3" }, { k: "smeparsl;", v: "\xE2\xA7\xA4" }, { k: "smid;", v: "\xE2\x88\xA3" }, { k: "smile;", v: "\xE2\x8C\xA3" }, { k: "smt;", v: "\xE2\xAA\xAA" }, { k: "smte;", v: "\xE2\xAA\xAC" }, { k: "smtes;", v: "\xE2\xAA\xAC\xEF\xB8\x80" }, { k: "softcy;", v: "\xD1\x8C" }, { k: "sol;", v: "/" }, { k: "solb;", v: "\xE2\xA7\x84" }, { k: "solbar;", v: "\xE2\x8C\xBF" }, { k: "sopf;", v: "\xF0\x9D\x95\xA4" }, { k: "spades;", v: "\xE2\x99\xA0" }, { k: "spadesuit;", v: "\xE2\x99\xA0" }, { k: "spar;", v: "\xE2\x88\xA5" }, { k: "sqcap;", v: "\xE2\x8A\x93" }, { k: "sqcaps;", v: "\xE2\x8A\x93\xEF\xB8\x80" }, { k: "sqcup;", v: "\xE2\x8A\x94" }, { k: "sqcups;", v: "\xE2\x8A\x94\xEF\xB8\x80" }, { k: "sqsub;", v: "\xE2\x8A\x8F" }, { k: "sqsube;", v: "\xE2\x8A\x91" }, { k: "sqsubset;", v: "\xE2\x8A\x8F" }, { k: "sqsubseteq;", v: "\xE2\x8A\x91" }, { k: "sqsup;", v: "\xE2\x8A\x90" }, { k: "sqsupe;", v: "\xE2\x8A\x92" }, { k: "sqsupset;", v: "\xE2\x8A\x90" }, { k: "sqsupseteq;", v: "\xE2\x8A\x92" }, { k: "squ;", v: "\xE2\x96\xA1" }, { k: "square;", v: "\xE2\x96\xA1" }, { k: "squarf;", v: "\xE2\x96\xAA" }, { k: "squf;", v: "\xE2\x96\xAA" }, { k: "srarr;", v: "\xE2\x86\x92" }, { k: "sscr;", v: "\xF0\x9D\x93\x88" }, { k: "ssetmn;", v: "\xE2\x88\x96" }, { k: "ssmile;", v: "\xE2\x8C\xA3" }, { k: "sstarf;", v: "\xE2\x8B\x86" }, { k: "star;", v: "\xE2\x98\x86" }, { k: "starf;", v: "\xE2\x98\x85" }, { k: "straightepsilon;", v: "\xCF\xB5" }, { k: "straightphi;", v: "\xCF\x95" }, { k: "strns;", v: "\xC2\xAF" }, { k: "sub;", v: "\xE2\x8A\x82" }, { k: "subE;", v: "\xE2\xAB\x85" }, { k: "subdot;", v: "\xE2\xAA\xBD" }, { k: "sube;", v: "\xE2\x8A\x86" }, { k: "subedot;", v: "\xE2\xAB\x83" }, { k: "submult;", v: "\xE2\xAB\x81" }, { k: "subnE;", v: "\xE2\xAB\x8B" }, { k: "subne;", v: "\xE2\x8A\x8A" }, { k: "subplus;", v: "\xE2\xAA\xBF" }, { k: "subrarr;", v: "\xE2\xA5\xB9" }, { k: "subset;", v: "\xE2\x8A\x82" }, { k: "subseteq;", v: "\xE2\x8A\x86" }, { k: "subseteqq;", v: "\xE2\xAB\x85" }, { k: "subsetneq;", v: "\xE2\x8A\x8A" }, { k: "subsetneqq;", v: "\xE2\xAB\x8B" }, { k: "subsim;", v: "\xE2\xAB\x87" }, { k: "subsub;", v: "\xE2\xAB\x95" }, { k: "subsup;", v: "\xE2\xAB\x93" }, { k: "succ;", v: "\xE2\x89\xBB" }, { k: "succapprox;", v: "\xE2\xAA\xB8" }, { k: "succcurlyeq;", v: "\xE2\x89\xBD" }, { k: "succeq;", v: "\xE2\xAA\xB0" }, { k: "succnapprox;", v: "\xE2\xAA\xBA" }, { k: "succneqq;", v: "\xE2\xAA\xB6" }, { k: "succnsim;", v: "\xE2\x8B\xA9" }, { k: "succsim;", v: "\xE2\x89\xBF" }, { k: "sum;", v: "\xE2\x88\x91" }, { k: "sung;", v: "\xE2\x99\xAA" }, { k: "sup;", v: "\xE2\x8A\x83" }, { k: "sup1;", v: "\xC2\xB9" }, { k: "sup2;", v: "\xC2\xB2" }, { k: "sup3;", v: "\xC2\xB3" }, { k: "supE;", v: "\xE2\xAB\x86" }, { k: "supdot;", v: "\xE2\xAA\xBE" }, { k: "supdsub;", v: "\xE2\xAB\x98" }, { k: "supe;", v: "\xE2\x8A\x87" }, { k: "supedot;", v: "\xE2\xAB\x84" }, { k: "suphsol;", v: "\xE2\x9F\x89" }, { k: "suphsub;", v: "\xE2\xAB\x97" }, { k: "suplarr;", v: "\xE2\xA5\xBB" }, { k: "supmult;", v: "\xE2\xAB\x82" }, { k: "supnE;", v: "\xE2\xAB\x8C" }, { k: "supne;", v: "\xE2\x8A\x8B" }, { k: "supplus;", v: "\xE2\xAB\x80" }, { k: "supset;", v: "\xE2\x8A\x83" }, { k: "supseteq;", v: "\xE2\x8A\x87" }, { k: "supseteqq;", v: "\xE2\xAB\x86" }, { k: "supsetneq;", v: "\xE2\x8A\x8B" }, { k: "supsetneqq;", v: "\xE2\xAB\x8C" }, { k: "supsim;", v: "\xE2\xAB\x88" }, { k: "supsub;", v: "\xE2\xAB\x94" }, { k: "supsup;", v: "\xE2\xAB\x96" }, { k: "swArr;", v: "\xE2\x87\x99" }, { k: "swarhk;", v: "\xE2\xA4\xA6" }, { k: "swarr;", v: "\xE2\x86\x99" }, { k: "swarrow;", v: "\xE2\x86\x99" }, { k: "swnwar;", v: "\xE2\xA4\xAA" }, { k: "szlig;", v: "\xC3\x9F" }, { k: "target;", v: "\xE2\x8C\x96" }, { k: "tau;", v: "\xCF\x84" }, { k: "tbrk;", v: "\xE2\x8E\xB4" }, { k: "tcaron;", v: "\xC5\xA5" }, { k: "tcedil;", v: "\xC5\xA3" }, { k: "tcy;", v: "\xD1\x82" }, { k: "tdot;", v: "\xE2\x83\x9B" }, { k: "telrec;", v: "\xE2\x8C\x95" }, { k: "tfr;", v: "\xF0\x9D\x94\xB1" }, { k: "there4;", v: "\xE2\x88\xB4" }, { k: "therefore;", v: "\xE2\x88\xB4" }, { k: "theta;", v: "\xCE\xB8" }, { k: "thetasym;", v: "\xCF\x91" }, { k: "thetav;", v: "\xCF\x91" }, { k: "thickapprox;", v: "\xE2\x89\x88" }, { k: "thicksim;", v: "\xE2\x88\xBC" }, { k: "thinsp;", v: "\xE2\x80\x89" }, { k: "thkap;", v: "\xE2\x89\x88" }, { k: "thksim;", v: "\xE2\x88\xBC" }, { k: "thorn;", v: "\xC3\xBE" }, { k: "tilde;", v: "\xCB\x9C" }, { k: "times;", v: "\xC3\x97" }, { k: "timesb;", v: "\xE2\x8A\xA0" }, { k: "timesbar;", v: "\xE2\xA8\xB1" }, { k: "timesd;", v: "\xE2\xA8\xB0" }, { k: "tint;", v: "\xE2\x88\xAD" }, { k: "toea;", v: "\xE2\xA4\xA8" }, { k: "top;", v: "\xE2\x8A\xA4" }, { k: "topbot;", v: "\xE2\x8C\xB6" }, { k: "topcir;", v: "\xE2\xAB\xB1" }, { k: "topf;", v: "\xF0\x9D\x95\xA5" }, { k: "topfork;", v: "\xE2\xAB\x9A" }, { k: "tosa;", v: "\xE2\xA4\xA9" }, { k: "tprime;", v: "\xE2\x80\xB4" }, { k: "trade;", v: "\xE2\x84\xA2" }, { k: "triangle;", v: "\xE2\x96\xB5" }, { k: "triangledown;", v: "\xE2\x96\xBF" }, { k: "triangleleft;", v: "\xE2\x97\x83" }, { k: "trianglelefteq;", v: "\xE2\x8A\xB4" }, { k: "triangleq;", v: "\xE2\x89\x9C" }, { k: "triangleright;", v: "\xE2\x96\xB9" }, { k: "trianglerighteq;", v: "\xE2\x8A\xB5" }, { k: "tridot;", v: "\xE2\x97\xAC" }, { k: "trie;", v: "\xE2\x89\x9C" }, { k: "triminus;", v: "\xE2\xA8\xBA" }, { k: "triplus;", v: "\xE2\xA8\xB9" }, { k: "trisb;", v: "\xE2\xA7\x8D" }, { k: "tritime;", v: "\xE2\xA8\xBB" }, { k: "trpezium;", v: "\xE2\x8F\xA2" }, { k: "tscr;", v: "\xF0\x9D\x93\x89" }, { k: "tscy;", v: "\xD1\x86" }, { k: "tshcy;", v: "\xD1\x9B" }, { k: "tstrok;", v: "\xC5\xA7" }, { k: "twixt;", v: "\xE2\x89\xAC" }, { k: "twoheadleftarrow;", v: "\xE2\x86\x9E" }, { k: "twoheadrightarrow;", v: "\xE2\x86\xA0" }, { k: "uArr;", v: "\xE2\x87\x91" }, { k: "uHar;", v: "\xE2\xA5\xA3" }, { k: "uacute;", v: "\xC3\xBA" }, { k: "uarr;", v: "\xE2\x86\x91" }, { k: "ubrcy;", v: "\xD1\x9E" }, { k: "ubreve;", v: "\xC5\xAD" }, { k: "ucirc;", v: "\xC3\xBB" }, { k: "ucy;", v: "\xD1\x83" }, { k: "udarr;", v: "\xE2\x87\x85" }, { k: "udblac;", v: "\xC5\xB1" }, { k: "udhar;", v: "\xE2\xA5\xAE" }, { k: "ufisht;", v: "\xE2\xA5\xBE" }, { k: "ufr;", v: "\xF0\x9D\x94\xB2" }, { k: "ugrave;", v: "\xC3\xB9" }, { k: "uharl;", v: "\xE2\x86\xBF" }, { k: "uharr;", v: "\xE2\x86\xBE" }, { k: "uhblk;", v: "\xE2\x96\x80" }, { k: "ulcorn;", v: "\xE2\x8C\x9C" }, { k: "ulcorner;", v: "\xE2\x8C\x9C" }, { k: "ulcrop;", v: "\xE2\x8C\x8F" }, { k: "ultri;", v: "\xE2\x97\xB8" }, { k: "umacr;", v: "\xC5\xAB" }, { k: "uml;", v: "\xC2\xA8" }, { k: "uogon;", v: "\xC5\xB3" }, { k: "uopf;", v: "\xF0\x9D\x95\xA6" }, { k: "uparrow;", v: "\xE2\x86\x91" }, { k: "updownarrow;", v: "\xE2\x86\x95" }, { k: "upharpoonleft;", v: "\xE2\x86\xBF" }, { k: "upharpoonright;", v: "\xE2\x86\xBE" }, { k: "uplus;", v: "\xE2\x8A\x8E" }, { k: "upsi;", v: "\xCF\x85" }, { k: "upsih;", v: "\xCF\x92" }, { k: "upsilon;", v: "\xCF\x85" }, { k: "upuparrows;", v: "\xE2\x87\x88" }, { k: "urcorn;", v: "\xE2\x8C\x9D" }, { k: "urcorner;", v: "\xE2\x8C\x9D" }, { k: "urcrop;", v: "\xE2\x8C\x8E" }, { k: "uring;", v: "\xC5\xAF" }, { k: "urtri;", v: "\xE2\x97\xB9" }, { k: "uscr;", v: "\xF0\x9D\x93\x8A" }, { k: "utdot;", v: "\xE2\x8B\xB0" }, { k: "utilde;", v: "\xC5\xA9" }, { k: "utri;", v: "\xE2\x96\xB5" }, { k: "utrif;", v: "\xE2\x96\xB4" }, { k: "uuarr;", v: "\xE2\x87\x88" }, { k: "uuml;", v: "\xC3\xBC" }, { k: "uwangle;", v: "\xE2\xA6\xA7" }, { k: "vArr;", v: "\xE2\x87\x95" }, { k: "vBar;", v: "\xE2\xAB\xA8" }, { k: "vBarv;", v: "\xE2\xAB\xA9" }, { k: "vDash;", v: "\xE2\x8A\xA8" }, { k: "vangrt;", v: "\xE2\xA6\x9C" }, { k: "varepsilon;", v: "\xCF\xB5" }, { k: "varkappa;", v: "\xCF\xB0" }, { k: "varnothing;", v: "\xE2\x88\x85" }, { k: "varphi;", v: "\xCF\x95" }, { k: "varpi;", v: "\xCF\x96" }, { k: "varpropto;", v: "\xE2\x88\x9D" }, { k: "varr;", v: "\xE2\x86\x95" }, { k: "varrho;", v: "\xCF\xB1" }, { k: "varsigma;", v: "\xCF\x82" }, { k: "varsubsetneq;", v: "\xE2\x8A\x8A\xEF\xB8\x80" }, { k: "varsubsetneqq;", v: "\xE2\xAB\x8B\xEF\xB8\x80" }, { k: "varsupsetneq;", v: "\xE2\x8A\x8B\xEF\xB8\x80" }, { k: "varsupsetneqq;", v: "\xE2\xAB\x8C\xEF\xB8\x80" }, { k: "vartheta;", v: "\xCF\x91" }, { k: "vartriangleleft;", v: "\xE2\x8A\xB2" }, { k: "vartriangleright;", v: "\xE2\x8A\xB3" }, { k: "vcy;", v: "\xD0\xB2" }, { k: "vdash;", v: "\xE2\x8A\xA2" }, { k: "vee;", v: "\xE2\x88\xA8" }, { k: "veebar;", v: "\xE2\x8A\xBB" }, { k: "veeeq;", v: "\xE2\x89\x9A" }, { k: "vellip;", v: "\xE2\x8B\xAE" }, { k: "verbar;", v: "|" }, { k: "vert;", v: "|" }, { k: "vfr;", v: "\xF0\x9D\x94\xB3" }, { k: "vltri;", v: "\xE2\x8A\xB2" }, { k: "vnsub;", v: "\xE2\x8A\x82\xE2\x83\x92" }, { k: "vnsup;", v: "\xE2\x8A\x83\xE2\x83\x92" }, { k: "vopf;", v: "\xF0\x9D\x95\xA7" }, { k: "vprop;", v: "\xE2\x88\x9D" }, { k: "vrtri;", v: "\xE2\x8A\xB3" }, { k: "vscr;", v: "\xF0\x9D\x93\x8B" }, { k: "vsubnE;", v: "\xE2\xAB\x8B\xEF\xB8\x80" }, { k: "vsubne;", v: "\xE2\x8A\x8A\xEF\xB8\x80" }, { k: "vsupnE;", v: "\xE2\xAB\x8C\xEF\xB8\x80" }, { k: "vsupne;", v: "\xE2\x8A\x8B\xEF\xB8\x80" }, { k: "vzigzag;", v: "\xE2\xA6\x9A" }, { k: "wcirc;", v: "\xC5\xB5" }, { k: "wedbar;", v: "\xE2\xA9\x9F" }, { k: "wedge;", v: "\xE2\x88\xA7" }, { k: "wedgeq;", v: "\xE2\x89\x99" }, { k: "weierp;", v: "\xE2\x84\x98" }, { k: "wfr;", v: "\xF0\x9D\x94\xB4" }, { k: "wopf;", v: "\xF0\x9D\x95\xA8" }, { k: "wp;", v: "\xE2\x84\x98" }, { k: "wr;", v: "\xE2\x89\x80" }, { k: "wreath;", v: "\xE2\x89\x80" }, { k: "wscr;", v: "\xF0\x9D\x93\x8C" }, { k: "xcap;", v: "\xE2\x8B\x82" }, { k: "xcirc;", v: "\xE2\x97\xAF" }, { k: "xcup;", v: "\xE2\x8B\x83" }, { k: "xdtri;", v: "\xE2\x96\xBD" }, { k: "xfr;", v: "\xF0\x9D\x94\xB5" }, { k: "xhArr;", v: "\xE2\x9F\xBA" }, { k: "xharr;", v: "\xE2\x9F\xB7" }, { k: "xi;", v: "\xCE\xBE" }, { k: "xlArr;", v: "\xE2\x9F\xB8" }, { k: "xlarr;", v: "\xE2\x9F\xB5" }, { k: "xmap;", v: "\xE2\x9F\xBC" }, { k: "xnis;", v: "\xE2\x8B\xBB" }, { k: "xodot;", v: "\xE2\xA8\x80" }, { k: "xopf;", v: "\xF0\x9D\x95\xA9" }, { k: "xoplus;", v: "\xE2\xA8\x81" }, { k: "xotime;", v: "\xE2\xA8\x82" }, { k: "xrArr;", v: "\xE2\x9F\xB9" }, { k: "xrarr;", v: "\xE2\x9F\xB6" }, { k: "xscr;", v: "\xF0\x9D\x93\x8D" }, { k: "xsqcup;", v: "\xE2\xA8\x86" }, { k: "xuplus;", v: "\xE2\xA8\x84" }, { k: "xutri;", v: "\xE2\x96\xB3" }, { k: "xvee;", v: "\xE2\x8B\x81" }, { k: "xwedge;", v: "\xE2\x8B\x80" }, { k: "yacute;", v: "\xC3\xBD" }, { k: "yacy;", v: "\xD1\x8F" }, { k: "ycirc;", v: "\xC5\xB7" }, { k: "ycy;", v: "\xD1\x8B" }, { k: "yen;", v: "\xC2\xA5" }, { k: "yfr;", v: "\xF0\x9D\x94\xB6" }, { k: "yicy;", v: "\xD1\x97" }, { k: "yopf;", v: "\xF0\x9D\x95\xAA" }, { k: "yscr;", v: "\xF0\x9D\x93\x8E" }, { k: "yucy;", v: "\xD1\x8E" }, { k: "yuml;", v: "\xC3\xBF" }, { k: "zacute;", v: "\xC5\xBA" }, { k: "zcaron;", v: "\xC5\xBE" }, { k: "zcy;", v: "\xD0\xB7" }, { k: "zdot;", v: "\xC5\xBC" }, { k: "zeetrf;", v: "\xE2\x84\xA8" }, { k: "zeta;", v: "\xCE\xB6" }, { k: "zfr;", v: "\xF0\x9D\x94\xB7" }, { k: "zhcy;", v: "\xD0\xB6" }, { k: "zigrarr;", v: "\xE2\x87\x9D" }, { k: "zopf;", v: "\xF0\x9D\x95\xAB" }, { k: "zscr;", v: "\xF0\x9D\x93\x8F" }, { k: "zwj;", v: "\xE2\x80\x8D" }, { k: "zwnj;", v: "\xE2\x80\x8C" }]);
		replacementTable = $toNativeArray($kindInt32, [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376]);
		breakout = $makeMap($String.keyFor, [{ k: "b", v: true }, { k: "big", v: true }, { k: "blockquote", v: true }, { k: "body", v: true }, { k: "br", v: true }, { k: "center", v: true }, { k: "code", v: true }, { k: "dd", v: true }, { k: "div", v: true }, { k: "dl", v: true }, { k: "dt", v: true }, { k: "em", v: true }, { k: "embed", v: true }, { k: "h1", v: true }, { k: "h2", v: true }, { k: "h3", v: true }, { k: "h4", v: true }, { k: "h5", v: true }, { k: "h6", v: true }, { k: "head", v: true }, { k: "hr", v: true }, { k: "i", v: true }, { k: "img", v: true }, { k: "li", v: true }, { k: "listing", v: true }, { k: "menu", v: true }, { k: "meta", v: true }, { k: "nobr", v: true }, { k: "ol", v: true }, { k: "p", v: true }, { k: "pre", v: true }, { k: "ruby", v: true }, { k: "s", v: true }, { k: "small", v: true }, { k: "span", v: true }, { k: "strong", v: true }, { k: "strike", v: true }, { k: "sub", v: true }, { k: "sup", v: true }, { k: "table", v: true }, { k: "tt", v: true }, { k: "u", v: true }, { k: "ul", v: true }, { k: "var", v: true }]);
		svgTagNameAdjustments = $makeMap($String.keyFor, [{ k: "altglyph", v: "altGlyph" }, { k: "altglyphdef", v: "altGlyphDef" }, { k: "altglyphitem", v: "altGlyphItem" }, { k: "animatecolor", v: "animateColor" }, { k: "animatemotion", v: "animateMotion" }, { k: "animatetransform", v: "animateTransform" }, { k: "clippath", v: "clipPath" }, { k: "feblend", v: "feBlend" }, { k: "fecolormatrix", v: "feColorMatrix" }, { k: "fecomponenttransfer", v: "feComponentTransfer" }, { k: "fecomposite", v: "feComposite" }, { k: "feconvolvematrix", v: "feConvolveMatrix" }, { k: "fediffuselighting", v: "feDiffuseLighting" }, { k: "fedisplacementmap", v: "feDisplacementMap" }, { k: "fedistantlight", v: "feDistantLight" }, { k: "feflood", v: "feFlood" }, { k: "fefunca", v: "feFuncA" }, { k: "fefuncb", v: "feFuncB" }, { k: "fefuncg", v: "feFuncG" }, { k: "fefuncr", v: "feFuncR" }, { k: "fegaussianblur", v: "feGaussianBlur" }, { k: "feimage", v: "feImage" }, { k: "femerge", v: "feMerge" }, { k: "femergenode", v: "feMergeNode" }, { k: "femorphology", v: "feMorphology" }, { k: "feoffset", v: "feOffset" }, { k: "fepointlight", v: "fePointLight" }, { k: "fespecularlighting", v: "feSpecularLighting" }, { k: "fespotlight", v: "feSpotLight" }, { k: "fetile", v: "feTile" }, { k: "feturbulence", v: "feTurbulence" }, { k: "foreignobject", v: "foreignObject" }, { k: "glyphref", v: "glyphRef" }, { k: "lineargradient", v: "linearGradient" }, { k: "radialgradient", v: "radialGradient" }, { k: "textpath", v: "textPath" }]);
		mathMLAttributeAdjustments = $makeMap($String.keyFor, [{ k: "definitionurl", v: "definitionURL" }]);
		svgAttributeAdjustments = $makeMap($String.keyFor, [{ k: "attributename", v: "attributeName" }, { k: "attributetype", v: "attributeType" }, { k: "basefrequency", v: "baseFrequency" }, { k: "baseprofile", v: "baseProfile" }, { k: "calcmode", v: "calcMode" }, { k: "clippathunits", v: "clipPathUnits" }, { k: "contentscripttype", v: "contentScriptType" }, { k: "contentstyletype", v: "contentStyleType" }, { k: "diffuseconstant", v: "diffuseConstant" }, { k: "edgemode", v: "edgeMode" }, { k: "externalresourcesrequired", v: "externalResourcesRequired" }, { k: "filterres", v: "filterRes" }, { k: "filterunits", v: "filterUnits" }, { k: "glyphref", v: "glyphRef" }, { k: "gradienttransform", v: "gradientTransform" }, { k: "gradientunits", v: "gradientUnits" }, { k: "kernelmatrix", v: "kernelMatrix" }, { k: "kernelunitlength", v: "kernelUnitLength" }, { k: "keypoints", v: "keyPoints" }, { k: "keysplines", v: "keySplines" }, { k: "keytimes", v: "keyTimes" }, { k: "lengthadjust", v: "lengthAdjust" }, { k: "limitingconeangle", v: "limitingConeAngle" }, { k: "markerheight", v: "markerHeight" }, { k: "markerunits", v: "markerUnits" }, { k: "markerwidth", v: "markerWidth" }, { k: "maskcontentunits", v: "maskContentUnits" }, { k: "maskunits", v: "maskUnits" }, { k: "numoctaves", v: "numOctaves" }, { k: "pathlength", v: "pathLength" }, { k: "patterncontentunits", v: "patternContentUnits" }, { k: "patterntransform", v: "patternTransform" }, { k: "patternunits", v: "patternUnits" }, { k: "pointsatx", v: "pointsAtX" }, { k: "pointsaty", v: "pointsAtY" }, { k: "pointsatz", v: "pointsAtZ" }, { k: "preservealpha", v: "preserveAlpha" }, { k: "preserveaspectratio", v: "preserveAspectRatio" }, { k: "primitiveunits", v: "primitiveUnits" }, { k: "refx", v: "refX" }, { k: "refy", v: "refY" }, { k: "repeatcount", v: "repeatCount" }, { k: "repeatdur", v: "repeatDur" }, { k: "requiredextensions", v: "requiredExtensions" }, { k: "requiredfeatures", v: "requiredFeatures" }, { k: "specularconstant", v: "specularConstant" }, { k: "specularexponent", v: "specularExponent" }, { k: "spreadmethod", v: "spreadMethod" }, { k: "startoffset", v: "startOffset" }, { k: "stddeviation", v: "stdDeviation" }, { k: "stitchtiles", v: "stitchTiles" }, { k: "surfacescale", v: "surfaceScale" }, { k: "systemlanguage", v: "systemLanguage" }, { k: "tablevalues", v: "tableValues" }, { k: "targetx", v: "targetX" }, { k: "targety", v: "targetY" }, { k: "textlength", v: "textLength" }, { k: "viewbox", v: "viewBox" }, { k: "viewtarget", v: "viewTarget" }, { k: "xchannelselector", v: "xChannelSelector" }, { k: "ychannelselector", v: "yChannelSelector" }, { k: "zoomandpan", v: "zoomAndPan" }]);
		scopeMarker = new Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 6, 0, "", "", sliceType$1.nil);
		defaultScopeStopTags = $makeMap($String.keyFor, [{ k: "", v: new sliceType$2([203014, 143623, 22020, 365829, 37378, 87554, 206599, 157702, 463880]) }, { k: "math", v: new sliceType$2([117006, 214786, 176386, 41986, 422914, 217349]) }, { k: "svg", v: new sliceType$2([352516, 152589, 69637]) }]);
		plaintextAbort = errors.New("html: internal error (plaintext abort)");
		voidElements = $makeMap($String.keyFor, [{ k: "area", v: true }, { k: "base", v: true }, { k: "br", v: true }, { k: "col", v: true }, { k: "command", v: true }, { k: "embed", v: true }, { k: "hr", v: true }, { k: "img", v: true }, { k: "input", v: true }, { k: "keygen", v: true }, { k: "link", v: true }, { k: "meta", v: true }, { k: "param", v: true }, { k: "source", v: true }, { k: "track", v: true }, { k: "wbr", v: true }]);
		$pkg.ErrBufferExceeded = errors.New("max buffer exceeded");
		nul = (new sliceType$3($stringToBytes("\x00")));
		replacement = (new sliceType$3($stringToBytes("\xEF\xBF\xBD")));
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute/lex"] = (function() {
	var $pkg = {}, $init, unicode, utf8, Lexer, ptrType, sliceType, sliceType$1, NewLexer, IsWhitespace, IsUnicodeWhitespace, IsDigit, IsHexDigit, TokenToUpper, IsASCIIPunct, IsASCIILetter, IsASCIILetterNum, IsASCIILetterNumHyphen, IsControl, IsBlank, Split, SplitWithoutBackslashEscape, ReplaceAll, ReplaceNewlineSpace, TrimWhitespace, Trim, TrimRight, TrimLeft, Accept, AcceptTokenss, AcceptTokens, IsBlankLine, SplitWhitespace, IsBackslashEscapePunct, StatWhitespace, Spnl, Peek;
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	Lexer = $pkg.Lexer = $newType(0, $kindStruct, "lex.Lexer", true, "lute/lex", true, function(input_, length_, offset_, width_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.input = sliceType.nil;
			this.length = 0;
			this.offset = 0;
			this.width = 0;
			return;
		}
		this.input = input_;
		this.length = length_;
		this.offset = offset_;
		this.width = width_;
	});
	ptrType = $ptrType(Lexer);
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType(sliceType);
	NewLexer = function(input) {
		var input, ret, x, x$1;
		ret = ptrType.nil;
		ret = new Lexer.ptr(sliceType.nil, 0, 0, 0);
		ret.input = input;
		ret.length = input.$length;
		if (0 < ret.length && !((10 === (x = ret.input, x$1 = ret.length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]))))) {
			ret.input = $append(ret.input, 10);
			ret.length = ret.length + (1) >> 0;
		}
		return ret;
	};
	$pkg.NewLexer = NewLexer;
	Lexer.ptr.prototype.NextLine = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tuple, b, i, l, nb, ret, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		ret = sliceType.nil;
		l = this;
		if (l.offset >= l.length) {
			return ret;
		}
		_tmp = 0;
		_tmp$1 = 0;
		b = _tmp;
		nb = _tmp$1;
		i = l.offset;
		while (true) {
			if (!(i < l.length)) { break; }
			b = (x = l.input, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (10 === b) {
				i = i + (1) >> 0;
				break;
			} else if (13 === b) {
				if (i < (l.length - 1 >> 0)) {
					nb = (x$1 = l.input, x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2]));
					if (10 === nb) {
						l.input = $appendSlice($subslice(l.input, 0, i), $subslice(l.input, (i + 1 >> 0)));
						l.length = l.length - (1) >> 0;
					} else {
						(x$3 = l.input, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i] = 10));
					}
				} else {
					(x$4 = l.input, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i] = 10));
				}
				i = i + (1) >> 0;
				break;
			} else if (0 === b) {
				l.input = $append(l.input, 0, 0);
				$copySlice($subslice(l.input, (i + 2 >> 0)), $subslice(l.input, i));
				_tmp$2 = 239;
				_tmp$3 = 191;
				_tmp$4 = 189;
				(x$5 = l.input, ((i < 0 || i >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + i] = _tmp$2));
				(x$6 = l.input, x$7 = i + 1 >> 0, ((x$7 < 0 || x$7 >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + x$7] = _tmp$3));
				(x$8 = l.input, x$9 = i + 2 >> 0, ((x$9 < 0 || x$9 >= x$8.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$8.$array[x$8.$offset + x$9] = _tmp$4));
				l.length = l.length + (2) >> 0;
				l.width = 3;
				i = i + (l.width) >> 0;
				continue;
			}
			if (128 <= b) {
				_tuple = utf8.DecodeRune($subslice(l.input, i));
				l.width = _tuple[1];
			} else {
				l.width = 1;
			}
			i = i + (l.width) >> 0;
		}
		ret = $subslice(l.input, l.offset, i);
		l.offset = i;
		return ret;
	};
	Lexer.prototype.NextLine = function() { return this.$val.NextLine(); };
	IsWhitespace = function(token) {
		var token;
		return (32 === token) || (10 === token) || (9 === token) || (11 === token) || (12 === token) || (13 === token);
	};
	$pkg.IsWhitespace = IsWhitespace;
	IsUnicodeWhitespace = function(r) {
		var r;
		return unicode.IsSpace(r) || unicode.Is(unicode.Zs, r);
	};
	$pkg.IsUnicodeWhitespace = IsUnicodeWhitespace;
	IsDigit = function(token) {
		var token;
		return 48 <= token && 57 >= token;
	};
	$pkg.IsDigit = IsDigit;
	IsHexDigit = function(token) {
		var token;
		return IsDigit(token) || token >= 97 && token <= 102 || token >= 65 && token <= 70;
	};
	$pkg.IsHexDigit = IsHexDigit;
	TokenToUpper = function(token) {
		var token;
		if (token >= 97 && token <= 122) {
			return (token - 97 << 24 >>> 24) + 65 << 24 >>> 24;
		}
		return token;
	};
	$pkg.TokenToUpper = TokenToUpper;
	IsASCIIPunct = function(token) {
		var token;
		return (33 <= token && 47 >= token) || (58 <= token && 64 >= token) || (91 <= token && 96 >= token) || (123 <= token && 126 >= token);
	};
	$pkg.IsASCIIPunct = IsASCIIPunct;
	IsASCIILetter = function(token) {
		var token;
		return (65 <= token && 90 >= token) || (97 <= token && 122 >= token);
	};
	$pkg.IsASCIILetter = IsASCIILetter;
	IsASCIILetterNum = function(token) {
		var token;
		return (65 <= token && 90 >= token) || (97 <= token && 122 >= token) || (48 <= token && 57 >= token);
	};
	$pkg.IsASCIILetterNum = IsASCIILetterNum;
	IsASCIILetterNumHyphen = function(token) {
		var token;
		return (65 <= token && 90 >= token) || (97 <= token && 122 >= token) || (48 <= token && 57 >= token) || (45 === token);
	};
	$pkg.IsASCIILetterNumHyphen = IsASCIILetterNumHyphen;
	IsControl = function(token) {
		var token;
		return unicode.IsControl(((token >> 0)));
	};
	$pkg.IsControl = IsControl;
	IsBlank = function(tokens) {
		var _i, _ref, token, tokens;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((32 === token))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	$pkg.IsBlank = IsBlank;
	Split = function(tokens, separator) {
		var i, length, line, ret, separator, token, tokens;
		ret = sliceType$1.nil;
		length = tokens.$length;
		i = 0;
		token = 0;
		line = sliceType.nil;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!((separator === token))) {
				line = $append(line, token);
				i = i + (1) >> 0;
				continue;
			}
			ret = $append(ret, line);
			line = new sliceType([]);
			i = i + (1) >> 0;
		}
		if (0 < line.$length) {
			ret = $append(ret, line);
		}
		return ret;
	};
	$pkg.Split = Split;
	SplitWithoutBackslashEscape = function(tokens, separator) {
		var i, length, line, ret, separator, token, tokens;
		ret = sliceType$1.nil;
		length = tokens.$length;
		i = 0;
		token = 0;
		line = sliceType.nil;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!((separator === token)) || IsBackslashEscapePunct(tokens, i)) {
				line = $append(line, token);
				i = i + (1) >> 0;
				continue;
			}
			ret = $append(ret, line);
			line = new sliceType([]);
			i = i + (1) >> 0;
		}
		if (0 < line.$length) {
			ret = $append(ret, line);
		}
		return ret;
	};
	$pkg.SplitWithoutBackslashEscape = SplitWithoutBackslashEscape;
	ReplaceAll = function(tokens, old, new$1) {
		var _i, _ref, i, new$1, old, token, tokens;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (token === old) {
				((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i] = new$1);
			}
			_i++;
		}
		return tokens;
	};
	$pkg.ReplaceAll = ReplaceAll;
	ReplaceNewlineSpace = function(tokens) {
		var i, length, token, tokens, x;
		length = tokens.$length;
		token = 0;
		i = length - 1 >> 0;
		while (true) {
			if (!(0 <= i)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!((10 === token)) && !((32 === token))) {
				break;
			}
			if ((10 === (x = i - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) && ((32 === token) || (10 === token))) {
				tokens = $subslice(tokens, 0, i);
			}
			i = i - (1) >> 0;
		}
		return tokens;
	};
	$pkg.ReplaceNewlineSpace = ReplaceNewlineSpace;
	TrimWhitespace = function(tokens) {
		var _tuple, ret, tokens;
		ret = sliceType.nil;
		_tuple = Trim(tokens);
		ret = _tuple[2];
		return ret;
	};
	$pkg.TrimWhitespace = TrimWhitespace;
	Trim = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, end, leftWhitespaces, length, remains, rightWhitespaces, start, tokens;
		leftWhitespaces = sliceType.nil;
		rightWhitespaces = sliceType.nil;
		remains = sliceType.nil;
		length = tokens.$length;
		if (0 === length) {
			_tmp = sliceType.nil;
			_tmp$1 = sliceType.nil;
			_tmp$2 = tokens;
			leftWhitespaces = _tmp;
			rightWhitespaces = _tmp$1;
			remains = _tmp$2;
			return [leftWhitespaces, rightWhitespaces, remains];
		}
		_tmp$3 = 0;
		_tmp$4 = length - 1 >> 0;
		start = _tmp$3;
		end = _tmp$4;
		while (true) {
			if (!(start < length)) { break; }
			if (!IsWhitespace(((start < 0 || start >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + start]))) {
				break;
			}
			start = start + (1) >> 0;
		}
		leftWhitespaces = $subslice(tokens, 0, start);
		if (start === length) {
			start = start - (1) >> 0;
		}
		while (true) {
			if (!(0 <= end)) { break; }
			if (!IsWhitespace(((end < 0 || end >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + end]))) {
				break;
			}
			end = end - (1) >> 0;
		}
		if (end < start) {
			end = start - 1 >> 0;
		}
		if (0 < end) {
			rightWhitespaces = $subslice(tokens, (end + 1 >> 0), length);
		}
		remains = $subslice(tokens, start, (end + 1 >> 0));
		return [leftWhitespaces, rightWhitespaces, remains];
	};
	$pkg.Trim = Trim;
	TrimRight = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, length, remains, tokens, whitespaces;
		whitespaces = sliceType.nil;
		remains = sliceType.nil;
		length = tokens.$length;
		if (1 > length) {
			_tmp = sliceType.nil;
			_tmp$1 = tokens;
			whitespaces = _tmp;
			remains = _tmp$1;
			return [whitespaces, remains];
		}
		i = length - 1 >> 0;
		while (true) {
			if (!(0 <= i)) { break; }
			if (!IsWhitespace(((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]))) {
				break;
			}
			whitespaces = $append(whitespaces, ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]));
			i = i - (1) >> 0;
		}
		_tmp$2 = whitespaces;
		_tmp$3 = $subslice(tokens, 0, (i + 1 >> 0));
		whitespaces = _tmp$2;
		remains = _tmp$3;
		return [whitespaces, remains];
	};
	$pkg.TrimRight = TrimRight;
	TrimLeft = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, i, length, remains, tokens, whitespaces;
		whitespaces = sliceType.nil;
		remains = sliceType.nil;
		length = tokens.$length;
		if (1 > length) {
			_tmp = sliceType.nil;
			_tmp$1 = tokens;
			whitespaces = _tmp;
			remains = _tmp$1;
			return [whitespaces, remains];
		}
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			if (!IsWhitespace(((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]))) {
				break;
			}
			whitespaces = $append(whitespaces, ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]));
			i = i + (1) >> 0;
		}
		_tmp$2 = whitespaces;
		_tmp$3 = $subslice(tokens, i);
		whitespaces = _tmp$2;
		remains = _tmp$3;
		return [whitespaces, remains];
	};
	$pkg.TrimLeft = TrimLeft;
	Accept = function(tokens, token) {
		var length, pos, token, tokens;
		pos = 0;
		length = tokens.$length;
		while (true) {
			if (!(pos < length)) { break; }
			if (!((token === ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos])))) {
				break;
			}
			pos = pos + (1) >> 0;
		}
		return pos;
	};
	$pkg.Accept = Accept;
	AcceptTokenss = function(tokens, someTokenss) {
		var i, j, length, length2, pos, remains, someTokens, someTokenss, tokens;
		pos = 0;
		length = tokens.$length;
		length2 = someTokenss.$length;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			remains = $subslice(tokens, i);
			j = 0;
			while (true) {
				if (!(j < length2)) { break; }
				someTokens = ((j < 0 || j >= someTokenss.$length) ? ($throwRuntimeError("index out of range"), undefined) : someTokenss.$array[someTokenss.$offset + j]);
				pos = AcceptTokens(remains, someTokens);
				if (0 <= pos) {
					return pos;
				}
				j = j + (1) >> 0;
			}
			i = i + (1) >> 0;
		}
		pos = -1;
		return pos;
	};
	$pkg.AcceptTokenss = AcceptTokenss;
	AcceptTokens = function(remains, someTokens) {
		var length, pos, remains, someTokens;
		pos = 0;
		length = someTokens.$length;
		while (true) {
			if (!(pos < length)) { break; }
			if (!((((pos < 0 || pos >= someTokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : someTokens.$array[someTokens.$offset + pos]) === ((pos < 0 || pos >= remains.$length) ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + pos])))) {
				pos = -1;
				return pos;
			}
			pos = pos + (1) >> 0;
		}
		return pos;
	};
	$pkg.AcceptTokens = AcceptTokens;
	IsBlankLine = function(tokens) {
		var _i, _ref, token, tokens;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((32 === token)) && !((9 === token)) && !((10 === token))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	$pkg.IsBlankLine = IsBlankLine;
	SplitWhitespace = function(tokens) {
		var _i, _ref, i, lastIsWhitespace, ret, token, tokens;
		ret = sliceType$1.nil;
		i = 0;
		ret = $append(ret, new sliceType([]));
		lastIsWhitespace = false;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (IsWhitespace(token)) {
				if (!lastIsWhitespace) {
					i = i + (1) >> 0;
					ret = $append(ret, new sliceType([]));
				}
				lastIsWhitespace = true;
			} else {
				((i < 0 || i >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i] = $append(((i < 0 || i >= ret.$length) ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + i]), token));
				lastIsWhitespace = false;
			}
			_i++;
		}
		return ret;
	};
	$pkg.SplitWhitespace = SplitWhitespace;
	IsBackslashEscapePunct = function(tokens, pos) {
		var _r, backslashes, i, pos, tokens;
		if (!IsASCIIPunct(((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]))) {
			return false;
		}
		backslashes = 0;
		i = pos - 1 >> 0;
		while (true) {
			if (!(0 <= i)) { break; }
			if (!((92 === ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i])))) {
				break;
			}
			backslashes = backslashes + (1) >> 0;
			i = i - (1) >> 0;
		}
		return !((0 === (_r = backslashes % 2, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))));
	};
	$pkg.IsBackslashEscapePunct = IsBackslashEscapePunct;
	StatWhitespace = function(tokens) {
		var _i, _ref, newlines, spaces, tabs, token, tokens;
		newlines = 0;
		spaces = 0;
		tabs = 0;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (10 === token) {
				newlines = newlines + (1) >> 0;
			} else if (32 === token) {
				spaces = spaces + (1) >> 0;
			} else if (9 === token) {
				tabs = tabs + (1) >> 0;
			}
			_i++;
		}
		return [newlines, spaces, tabs];
	};
	$pkg.StatWhitespace = StatWhitespace;
	Spnl = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tuple, _tuple$1, newlines, passed, remains, ret, tokens;
		ret = false;
		passed = sliceType.nil;
		remains = sliceType.nil;
		_tuple = TrimLeft(tokens);
		passed = _tuple[0];
		remains = _tuple[1];
		_tuple$1 = StatWhitespace(passed);
		newlines = _tuple$1[0];
		if (1 < newlines) {
			_tmp = false;
			_tmp$1 = sliceType.nil;
			_tmp$2 = tokens;
			ret = _tmp;
			passed = _tmp$1;
			remains = _tmp$2;
			return [ret, passed, remains];
		}
		ret = true;
		return [ret, passed, remains];
	};
	$pkg.Spnl = Spnl;
	Peek = function(tokens, pos) {
		var pos, tokens;
		if (pos < tokens.$length) {
			return ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]);
		}
		return 0;
	};
	$pkg.Peek = Peek;
	ptrType.methods = [{prop: "NextLine", name: "NextLine", pkg: "", typ: $funcType([], [sliceType], false)}];
	Lexer.init("lute/lex", [{prop: "input", name: "input", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "length", name: "length", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "offset", name: "offset", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "width", name: "width", embedded: false, exported: false, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = unicode.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute/util"] = (function() {
	var $pkg = {}, $init, html, lex, strconv, strings, utf8, sliceType, amp, lt, gt, quot, StrToBytes, BytesToStr, UnescapeHTML, EscapeHTML, EncodeDestination, UnescapeString, HtmlUnescapeString, parseEntity, isValidEntityCode;
	html = $packages["lute/html"];
	lex = $packages["lute/lex"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	utf8 = $packages["unicode/utf8"];
	sliceType = $sliceType($Uint8);
	StrToBytes = function(str) {
		var ret, str;
		ret = sliceType.nil;
		ret = (new sliceType($stringToBytes(str)));
		return ret;
	};
	$pkg.StrToBytes = StrToBytes;
	BytesToStr = function(items) {
		var items;
		return ($bytesToString(items));
	};
	$pkg.BytesToStr = BytesToStr;
	UnescapeHTML = function(h) {
		var h, ret;
		ret = sliceType.nil;
		ret = StrToBytes(html.UnescapeString(BytesToStr(h)));
		return ret;
	};
	$pkg.UnescapeHTML = UnescapeHTML;
	EscapeHTML = function(html$1) {
		var _1, _tmp, _tmp$1, html$1, i, inited, length, ret, start;
		ret = sliceType.nil;
		length = html$1.$length;
		_tmp = 0;
		_tmp$1 = 0;
		start = _tmp;
		i = _tmp$1;
		inited = false;
		ret = html$1;
		while (true) {
			if (!(i < length)) { break; }
			_1 = ((i < 0 || i >= html$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : html$1.$array[html$1.$offset + i]);
			if (_1 === (38)) {
				if (!inited) {
					ret = $makeSlice(sliceType, 0, (length + 128 >> 0));
					inited = true;
				}
				ret = $appendSlice(ret, $subslice(html$1, start, i));
				ret = $appendSlice(ret, amp);
				start = i + 1 >> 0;
			} else if (_1 === (60)) {
				if (!inited) {
					ret = $makeSlice(sliceType, 0, (length + 128 >> 0));
					inited = true;
				}
				ret = $appendSlice(ret, $subslice(html$1, start, i));
				ret = $appendSlice(ret, lt);
				start = i + 1 >> 0;
			} else if (_1 === (62)) {
				if (!inited) {
					ret = $makeSlice(sliceType, 0, (length + 128 >> 0));
					inited = true;
				}
				ret = $appendSlice(ret, $subslice(html$1, start, i));
				ret = $appendSlice(ret, gt);
				start = i + 1 >> 0;
			} else if (_1 === (34)) {
				if (!inited) {
					ret = $makeSlice(sliceType, 0, (length + 128 >> 0));
					inited = true;
				}
				ret = $appendSlice(ret, $subslice(html$1, start, i));
				ret = $appendSlice(ret, quot);
				start = i + 1 >> 0;
			}
			i = i + (1) >> 0;
		}
		if (inited) {
			ret = $appendSlice(ret, $subslice(html$1, start));
		}
		return ret;
	};
	$pkg.EscapeHTML = EscapeHTML;
	EncodeDestination = function(rawurl) {
		var _tmp, _tmp$1, _tuple, b, i, j, n, r, rawurl, ret, rlen, token, x, x$1, x$2, x$3;
		ret = sliceType.nil;
		ret = $makeSlice(sliceType, 0, 256);
		i = 0;
		token = 0;
		while (true) {
			if (!(i < rawurl.$length)) { break; }
			_tuple = utf8.DecodeRune($subslice(rawurl, i));
			r = _tuple[0];
			rlen = _tuple[1];
			if (128 <= r) {
				_tmp = i;
				_tmp$1 = i + rlen >> 0;
				j = _tmp;
				n = _tmp$1;
				while (true) {
					if (!(j < n)) { break; }
					b = ((j < 0 || j >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + j]);
					token = ((j < 0 || j >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + j]);
					ret = $append(ret, 37);
					ret = $append(ret, "0123456789ABCDEF".charCodeAt(((((b >>> 4 << 24 >>> 24)) & 15) >>> 0)));
					ret = $append(ret, "0123456789ABCDEF".charCodeAt(((b & 15) >>> 0)));
					j = j + (1) >> 0;
				}
			} else if (r === 37) {
				token = ((i < 0 || i >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + i]);
				if ((i + 2 >> 0) < rawurl.$length && lex.IsHexDigit((x = i + 1 >> 0, ((x < 0 || x >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + x]))) && lex.IsHexDigit((x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + x$1])))) {
					ret = $append(ret, 37);
					ret = $append(ret, lex.TokenToUpper((x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + x$2]))));
					ret = $append(ret, lex.TokenToUpper((x$3 = i + 2 >> 0, ((x$3 < 0 || x$3 >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + x$3]))));
					i = i + (2) >> 0;
				} else {
					ret = $append(ret, 37);
					ret = $append(ret, 50);
					ret = $append(ret, 53);
				}
			} else if (strings.IndexByte("!#$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~", ((r << 24 >>> 24))) === -1) {
				token = ((i < 0 || i >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + i]);
				ret = $append(ret, 37);
				ret = $append(ret, "0123456789ABCDEF".charCodeAt((((r >> 4 >> 0)) & 15)));
				ret = $append(ret, "0123456789ABCDEF".charCodeAt((r & 15)));
			} else {
				token = ((i < 0 || i >= rawurl.$length) ? ($throwRuntimeError("index out of range"), undefined) : rawurl.$array[rawurl.$offset + i]);
				ret = $append(ret, token);
			}
			i = i + (rlen) >> 0;
		}
		return ret;
	};
	$pkg.EncodeDestination = EncodeDestination;
	UnescapeString = function(tokens) {
		var i, length, ret, tokens;
		ret = sliceType.nil;
		if (sliceType.nil === tokens) {
			return ret;
		}
		tokens = StrToBytes(HtmlUnescapeString(BytesToStr(tokens)));
		length = tokens.$length;
		ret = $makeSlice(sliceType, 0, length);
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			if (lex.IsBackslashEscapePunct(tokens, i)) {
				ret = $subslice(ret, 0, (ret.$length - 1 >> 0));
			}
			ret = $append(ret, ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]));
			i = i + (1) >> 0;
		}
		return ret;
	};
	$pkg.UnescapeString = UnescapeString;
	HtmlUnescapeString = function(s) {
		var _tuple, _tuple$1, anyChanges, b, buf, entityLen, entityStr, i, j, n, s;
		i = strings.IndexByte(s, 38);
		if (i < 0) {
			return s;
		}
		anyChanges = false;
		entityStr = "";
		entityLen = 0;
		while (true) {
			if (!(i < s.length)) { break; }
			if (s.charCodeAt(i) === 38) {
				_tuple = parseEntity($substring(s, i));
				entityStr = _tuple[0];
				entityLen = _tuple[1];
				if (entityLen > 0) {
					anyChanges = true;
					break;
				}
			}
			i = i + (1) >> 0;
		}
		if (!anyChanges) {
			return s;
		}
		buf = $makeSlice(sliceType, ((s.length - entityLen >> 0) + entityStr.length >> 0));
		$copyString($subslice(buf, 0, i), s);
		n = $copyString($subslice(buf, i), entityStr);
		j = i + n >> 0;
		i = i + (entityLen) >> 0;
		while (true) {
			if (!(i < s.length)) { break; }
			b = s.charCodeAt(i);
			if (b === 38) {
				_tuple$1 = parseEntity($substring(s, i));
				entityStr = _tuple$1[0];
				entityLen = _tuple$1[1];
				if (entityLen > 0) {
					n = $copyString($subslice(buf, j), entityStr);
					j = j + (n) >> 0;
					i = i + (entityLen) >> 0;
					continue;
				}
			}
			((j < 0 || j >= buf.$length) ? ($throwRuntimeError("index out of range"), undefined) : buf.$array[buf.$offset + j] = b);
			j = j + (1) >> 0;
			i = i + (1) >> 0;
		}
		return ($bytesToString($subslice(buf, 0, j)));
	};
	$pkg.HtmlUnescapeString = HtmlUnescapeString;
	parseEntity = function(s) {
		var _1, _entry, _tuple, _tuple$1, _tuple$2, b, c, c$1, e, err, i, n, ok, s, st;
		st = 0;
		n = 0;
		i = 1;
		while (true) {
			if (!(i < s.length)) { break; }
			b = s.charCodeAt(i);
			_1 = st;
			if (_1 === (0)) {
				if ((b === 35)) {
					st = 1;
				} else if (lex.IsASCIILetter(b)) {
					n = 1;
					st = 2;
				} else {
					return ["", 0];
				}
			} else if (_1 === (1)) {
				if ((b === 120) || (b === 88)) {
					st = 3;
				} else if (lex.IsDigit(b)) {
					n = 1;
					st = 4;
				} else {
					return ["", 0];
				}
			} else if (_1 === (2)) {
				if (lex.IsASCIILetterNum(b)) {
					n = n + (1) >> 0;
					if (n > 31) {
						return ["", 0];
					}
				} else if ((b === 59)) {
					_tuple = (_entry = html.Entities[$String.keyFor($substring(s, (i - n >> 0), (i + 1 >> 0)))], _entry !== undefined ? [_entry.v, true] : ["", false]);
					e = _tuple[0];
					ok = _tuple[1];
					if (ok) {
						return [e, i + 1 >> 0];
					}
					return ["", 0];
				} else {
					return ["", 0];
				}
			} else if (_1 === (3)) {
				if (lex.IsHexDigit(b)) {
					n = 1;
					st = 5;
				} else {
					return ["", 0];
				}
			} else if (_1 === (4)) {
				if (lex.IsDigit(b)) {
					n = n + (1) >> 0;
					if (n > 8) {
						return ["", 0];
					}
				} else if ((b === 59)) {
					_tuple$1 = strconv.ParseInt($substring(s, (i - n >> 0), i), 10, 32);
					c = _tuple$1[0];
					if (!isValidEntityCode(c)) {
						return ["\xEF\xBF\xBD", i + 1 >> 0];
					}
					return [($encodeRune((((c.$low + ((c.$high >> 31) * 4294967296)) >> 0)))), i + 1 >> 0];
				} else {
					return ["", 0];
				}
			} else if (_1 === (5)) {
				if (lex.IsHexDigit(b)) {
					n = n + (1) >> 0;
					if (n > 8) {
						return ["", 0];
					}
				} else if ((b === 59)) {
					_tuple$2 = strconv.ParseInt($substring(s, (i - n >> 0), i), 16, 32);
					c$1 = _tuple$2[0];
					err = _tuple$2[1];
					if (!($interfaceIsEqual($ifaceNil, err))) {
						return ["\xEF\xBF\xBD", i + 1 >> 0];
					}
					if (!isValidEntityCode(c$1)) {
						return ["\xEF\xBF\xBD", i + 1 >> 0];
					}
					return [($encodeRune((((c$1.$low + ((c$1.$high >> 31) * 4294967296)) >> 0)))), i + 1 >> 0];
				} else {
					return ["", 0];
				}
			}
			i = i + (1) >> 0;
		}
		return ["", 0];
	};
	isValidEntityCode = function(c) {
		var c, x, x$1;
		if (!utf8.ValidRune((((c.$low + ((c.$high >> 31) * 4294967296)) >> 0)))) {
			return false;
		} else if ((c.$high > 0 || (c.$high === 0 && c.$low >= 64976)) && (c.$high < 0 || (c.$high === 0 && c.$low <= 65007))) {
			return false;
		} else if ((x = new $Int64(c.$high & 0, (c.$low & 65535) >>> 0), (x.$high === 0 && x.$low === 65535)) || (x$1 = new $Int64(c.$high & 0, (c.$low & 65535) >>> 0), (x$1.$high === 0 && x$1.$low === 65534))) {
			return false;
		} else if ((c.$high > 0 || (c.$high === 0 && c.$low >= 0)) && (c.$high < 0 || (c.$high === 0 && c.$low <= 8))) {
			return false;
		} else if ((c.$high === 0 && c.$low === 11)) {
			return false;
		} else if ((c.$high > 0 || (c.$high === 0 && c.$low >= 14)) && (c.$high < 0 || (c.$high === 0 && c.$low <= 31))) {
			return false;
		} else if ((c.$high > 0 || (c.$high === 0 && c.$low >= 127)) && (c.$high < 0 || (c.$high === 0 && c.$low <= 159))) {
			return false;
		}
		return true;
	};
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = html.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = lex.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		amp = StrToBytes("&amp;");
		lt = StrToBytes("&lt;");
		gt = StrToBytes("&gt;");
		quot = StrToBytes("&quot;");
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute/ast"] = (function() {
	var $pkg = {}, $init, util, strconv, Node, ListData, NodeType, WalkStatus, ptrType, sliceType, sliceType$1, ptrType$1, sliceType$2, sliceType$3, _NodeType_index_0, _NodeType_index_1, _NodeType_index_2, _NodeType_index_3, _NodeType_index_4, _NodeType_index_5, Str2NodeType, Walk;
	util = $packages["lute/util"];
	strconv = $packages["strconv"];
	Node = $pkg.Node = $newType(0, $kindStruct, "ast.Node", true, "lute/ast", true, function(Type_, Parent_, Previous_, Next_, FirstChild_, LastChild_, Tokens_, Close_, LastLineBlank_, LastLineChecked_, CodeMarkerLen_, IsFencedCodeBlock_, CodeBlockFenceChar_, CodeBlockFenceLen_, CodeBlockFenceOffset_, CodeBlockOpenFence_, CodeBlockInfo_, CodeBlockCloseFence_, HtmlBlockType_, ListData_, TaskListItemChecked_, TableAligns_, TableCellAlign_, TableCellContentWidth_, TableCellContentMaxWidth_, TableCellContent_, TableCellMaxWidthContent_, LinkType_, LinkRefLabel_, HeadingLevel_, HeadingSetext_, HeadingID_, HeadingNormalizedID_, MathBlockDollarOffset_, FootnotesRefLabel_, FootnotesRefId_, FootnotesRefs_, HtmlEntityTokens_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Type = 0;
			this.Parent = ptrType.nil;
			this.Previous = ptrType.nil;
			this.Next = ptrType.nil;
			this.FirstChild = ptrType.nil;
			this.LastChild = ptrType.nil;
			this.Tokens = sliceType$1.nil;
			this.Close = false;
			this.LastLineBlank = false;
			this.LastLineChecked = false;
			this.CodeMarkerLen = 0;
			this.IsFencedCodeBlock = false;
			this.CodeBlockFenceChar = 0;
			this.CodeBlockFenceLen = 0;
			this.CodeBlockFenceOffset = 0;
			this.CodeBlockOpenFence = sliceType$1.nil;
			this.CodeBlockInfo = sliceType$1.nil;
			this.CodeBlockCloseFence = sliceType$1.nil;
			this.HtmlBlockType = 0;
			this.ListData = ptrType$1.nil;
			this.TaskListItemChecked = false;
			this.TableAligns = sliceType$2.nil;
			this.TableCellAlign = 0;
			this.TableCellContentWidth = 0;
			this.TableCellContentMaxWidth = 0;
			this.TableCellContent = sliceType$1.nil;
			this.TableCellMaxWidthContent = sliceType$1.nil;
			this.LinkType = 0;
			this.LinkRefLabel = sliceType$1.nil;
			this.HeadingLevel = 0;
			this.HeadingSetext = false;
			this.HeadingID = sliceType$1.nil;
			this.HeadingNormalizedID = "";
			this.MathBlockDollarOffset = 0;
			this.FootnotesRefLabel = sliceType$1.nil;
			this.FootnotesRefId = "";
			this.FootnotesRefs = sliceType.nil;
			this.HtmlEntityTokens = sliceType$1.nil;
			return;
		}
		this.Type = Type_;
		this.Parent = Parent_;
		this.Previous = Previous_;
		this.Next = Next_;
		this.FirstChild = FirstChild_;
		this.LastChild = LastChild_;
		this.Tokens = Tokens_;
		this.Close = Close_;
		this.LastLineBlank = LastLineBlank_;
		this.LastLineChecked = LastLineChecked_;
		this.CodeMarkerLen = CodeMarkerLen_;
		this.IsFencedCodeBlock = IsFencedCodeBlock_;
		this.CodeBlockFenceChar = CodeBlockFenceChar_;
		this.CodeBlockFenceLen = CodeBlockFenceLen_;
		this.CodeBlockFenceOffset = CodeBlockFenceOffset_;
		this.CodeBlockOpenFence = CodeBlockOpenFence_;
		this.CodeBlockInfo = CodeBlockInfo_;
		this.CodeBlockCloseFence = CodeBlockCloseFence_;
		this.HtmlBlockType = HtmlBlockType_;
		this.ListData = ListData_;
		this.TaskListItemChecked = TaskListItemChecked_;
		this.TableAligns = TableAligns_;
		this.TableCellAlign = TableCellAlign_;
		this.TableCellContentWidth = TableCellContentWidth_;
		this.TableCellContentMaxWidth = TableCellContentMaxWidth_;
		this.TableCellContent = TableCellContent_;
		this.TableCellMaxWidthContent = TableCellMaxWidthContent_;
		this.LinkType = LinkType_;
		this.LinkRefLabel = LinkRefLabel_;
		this.HeadingLevel = HeadingLevel_;
		this.HeadingSetext = HeadingSetext_;
		this.HeadingID = HeadingID_;
		this.HeadingNormalizedID = HeadingNormalizedID_;
		this.MathBlockDollarOffset = MathBlockDollarOffset_;
		this.FootnotesRefLabel = FootnotesRefLabel_;
		this.FootnotesRefId = FootnotesRefId_;
		this.FootnotesRefs = FootnotesRefs_;
		this.HtmlEntityTokens = HtmlEntityTokens_;
	});
	ListData = $pkg.ListData = $newType(0, $kindStruct, "ast.ListData", true, "lute/ast", true, function(Typ_, Tight_, BulletChar_, Start_, Delimiter_, Padding_, MarkerOffset_, Checked_, Marker_, Num_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Typ = 0;
			this.Tight = false;
			this.BulletChar = 0;
			this.Start = 0;
			this.Delimiter = 0;
			this.Padding = 0;
			this.MarkerOffset = 0;
			this.Checked = false;
			this.Marker = sliceType$1.nil;
			this.Num = 0;
			return;
		}
		this.Typ = Typ_;
		this.Tight = Tight_;
		this.BulletChar = BulletChar_;
		this.Start = Start_;
		this.Delimiter = Delimiter_;
		this.Padding = Padding_;
		this.MarkerOffset = MarkerOffset_;
		this.Checked = Checked_;
		this.Marker = Marker_;
		this.Num = Num_;
	});
	NodeType = $pkg.NodeType = $newType(4, $kindInt, "ast.NodeType", true, "lute/ast", true, null);
	WalkStatus = $pkg.WalkStatus = $newType(4, $kindInt, "ast.WalkStatus", true, "lute/ast", true, null);
	ptrType = $ptrType(Node);
	sliceType = $sliceType(ptrType);
	sliceType$1 = $sliceType($Uint8);
	ptrType$1 = $ptrType(ListData);
	sliceType$2 = $sliceType($Int);
	sliceType$3 = $sliceType(NodeType);
	Node.ptr.prototype.TokensStr = function() {
		var n;
		n = this;
		return util.BytesToStr(n.Tokens);
	};
	Node.prototype.TokensStr = function() { return this.$val.TokensStr(); };
	Node.ptr.prototype.LastDeepestChild = function() {
		var n, ret;
		ret = ptrType.nil;
		n = this;
		if (ptrType.nil === n.LastChild) {
			ret = n;
			return ret;
		}
		ret = n.LastChild.LastDeepestChild();
		return ret;
	};
	Node.prototype.LastDeepestChild = function() { return this.$val.LastDeepestChild(); };
	Node.ptr.prototype.FirstDeepestChild = function() {
		var n, ret;
		ret = ptrType.nil;
		n = this;
		if (ptrType.nil === n.FirstChild) {
			ret = n;
			return ret;
		}
		ret = n.FirstChild.FirstDeepestChild();
		return ret;
	};
	Node.prototype.FirstDeepestChild = function() { return this.$val.FirstDeepestChild(); };
	Node.ptr.prototype.ChildByType = function(childType) {
		var c, childType, n;
		n = this;
		c = n.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === c))) { break; }
			if (c.Type === childType) {
				return c;
			}
			c = c.Next;
		}
		return ptrType.nil;
	};
	Node.prototype.ChildByType = function(childType) { return this.$val.ChildByType(childType); };
	Node.ptr.prototype.Text = function() {
		var n, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = [ret];
		ret[0] = "";
		n = this;
		$r = Walk(n, (function(ret) { return function(n$1, entering) {
			var entering, n$1;
			if (((16 === n$1.Type) || (40 === n$1.Type)) && entering) {
				ret[0] = ret[0] + (util.BytesToStr(n$1.Tokens));
			}
			return 2;
		}; })(ret)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return ret[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.Text }; } $f.n = n; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.Text = function() { return this.$val.Text(); };
	Node.ptr.prototype.NextNodeText = function() {
		var _r, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = this;
		if (ptrType.nil === n.Next) {
			$s = -1; return "";
		}
		_r = n.Next.Text(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.NextNodeText }; } $f._r = _r; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.NextNodeText = function() { return this.$val.NextNodeText(); };
	Node.ptr.prototype.PreviousNodeText = function() {
		var _r, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		n = this;
		if (ptrType.nil === n.Previous) {
			$s = -1; return "";
		}
		_r = n.Previous.Text(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		$s = -1; return _r;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.PreviousNodeText }; } $f._r = _r; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.PreviousNodeText = function() { return this.$val.PreviousNodeText(); };
	Node.ptr.prototype.Unlink = function() {
		var n;
		n = this;
		if (!(ptrType.nil === n.Previous)) {
			n.Previous.Next = n.Next;
		} else if (!(ptrType.nil === n.Parent)) {
			n.Parent.FirstChild = n.Next;
		}
		if (!(ptrType.nil === n.Next)) {
			n.Next.Previous = n.Previous;
		} else if (!(ptrType.nil === n.Parent)) {
			n.Parent.LastChild = n.Previous;
		}
		n.Parent = ptrType.nil;
		n.Next = ptrType.nil;
		n.Previous = ptrType.nil;
	};
	Node.prototype.Unlink = function() { return this.$val.Unlink(); };
	Node.ptr.prototype.AppendTokens = function(tokens) {
		var n, tokens;
		n = this;
		n.Tokens = $appendSlice(n.Tokens, tokens);
	};
	Node.prototype.AppendTokens = function(tokens) { return this.$val.AppendTokens(tokens); };
	Node.ptr.prototype.InsertAfter = function(sibling) {
		var n, sibling;
		n = this;
		sibling.Unlink();
		sibling.Next = n.Next;
		if (!(ptrType.nil === sibling.Next)) {
			sibling.Next.Previous = sibling;
		}
		sibling.Previous = n;
		n.Next = sibling;
		sibling.Parent = n.Parent;
		if (!(ptrType.nil === sibling.Parent) && ptrType.nil === sibling.Next && !(ptrType.nil === sibling.Parent.LastChild)) {
			sibling.Parent.LastChild = sibling;
		}
	};
	Node.prototype.InsertAfter = function(sibling) { return this.$val.InsertAfter(sibling); };
	Node.ptr.prototype.InsertBefore = function(sibling) {
		var n, sibling;
		n = this;
		sibling.Unlink();
		sibling.Previous = n.Previous;
		if (!(ptrType.nil === sibling.Previous)) {
			sibling.Previous.Next = sibling;
		}
		sibling.Next = n;
		n.Previous = sibling;
		sibling.Parent = n.Parent;
		if (!(ptrType.nil === sibling.Parent) && ptrType.nil === sibling.Previous) {
			sibling.Parent.FirstChild = sibling;
		}
	};
	Node.prototype.InsertBefore = function(sibling) { return this.$val.InsertBefore(sibling); };
	Node.ptr.prototype.AppendChild = function(child) {
		var child, n;
		n = this;
		child.Unlink();
		child.Parent = n;
		if (!(ptrType.nil === n.LastChild)) {
			n.LastChild.Next = child;
			child.Previous = n.LastChild;
			n.LastChild = child;
		} else {
			n.FirstChild = child;
			n.LastChild = child;
		}
	};
	Node.prototype.AppendChild = function(child) { return this.$val.AppendChild(child); };
	Node.ptr.prototype.PrependChild = function(child) {
		var child, n;
		n = this;
		child.Unlink();
		child.Parent = n;
		if (!(ptrType.nil === n.FirstChild)) {
			n.FirstChild.Previous = child;
			child.Next = n.FirstChild;
			n.FirstChild = child;
		} else {
			n.FirstChild = child;
			n.LastChild = child;
		}
	};
	Node.prototype.PrependChild = function(child) { return this.$val.PrependChild(child); };
	Node.ptr.prototype.List = function() {
		var n, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; n = $f.n; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = [ret];
		ret[0] = sliceType.nil;
		n = this;
		ret[0] = $makeSlice(sliceType, 0, 512);
		$r = Walk(n, (function(ret) { return function(n$1, entering) {
			var entering, n$1;
			if (entering) {
				ret[0] = $append(ret[0], n$1);
			}
			return 2;
		}; })(ret)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return ret[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Node.ptr.prototype.List }; } $f.n = n; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	Node.prototype.List = function() { return this.$val.List(); };
	Node.ptr.prototype.ParentIs = function(nodeType, nodeTypes) {
		var _i, _ref, n, nodeType, nodeTypes, p, pt, types;
		n = this;
		types = $append(nodeTypes, nodeType);
		p = n.Parent;
		while (true) {
			if (!(!(ptrType.nil === p))) { break; }
			_ref = types;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				pt = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (pt === p.Type) {
					return true;
				}
				_i++;
			}
			p = p.Parent;
		}
		return false;
	};
	Node.prototype.ParentIs = function(nodeType, nodeTypes) { return this.$val.ParentIs(nodeType, nodeTypes); };
	Node.ptr.prototype.AcceptLines = function() {
		var _1, n;
		n = this;
		_1 = n.Type;
		if ((_1 === (1)) || (_1 === (11)) || (_1 === (9)) || (_1 === (106)) || (_1 === (300))) {
			return true;
		}
		return false;
	};
	Node.prototype.AcceptLines = function() { return this.$val.AcceptLines(); };
	Node.ptr.prototype.CanContain = function(nodeType) {
		var _1, n, nodeType;
		n = this;
		_1 = n.Type;
		if ((_1 === (11)) || (_1 === (9)) || (_1 === (1)) || (_1 === (4)) || (_1 === (106)) || (_1 === (300))) {
			return false;
		} else if (_1 === (7)) {
			return 8 === nodeType;
		} else if (_1 === (500)) {
			return !((500 === nodeType));
		}
		return !((8 === nodeType));
	};
	Node.prototype.CanContain = function(nodeType) { return this.$val.CanContain(nodeType); };
	Str2NodeType = function(nodeTypeStr) {
		var nodeTypeStr, t;
		t = 0;
		while (true) {
			if (!(t < 1024)) { break; }
			if (nodeTypeStr === new NodeType(t).String()) {
				return t;
			}
			t = t + (1) >> 0;
		}
		return -1;
	};
	$pkg.Str2NodeType = Str2NodeType;
	NodeType.prototype.String = function() {
		var i, x, x$1, x$2, x$3, x$4, x$5;
		i = this.$val;
		if (0 <= i && i <= 44) {
			return $substring("NodeDocumentNodeParagraphNodeHeadingNodeHeadingC8hMarkerNodeThematicBreakNodeBlockquoteNodeBlockquoteMarkerNodeListNodeListItemNodeHTMLBlockNodeInlineHTMLNodeCodeBlockNodeCodeBlockFenceOpenMarkerNodeCodeBlockFenceCloseMarkerNodeCodeBlockFenceInfoMarkerNodeCodeBlockCodeNodeTextNodeEmphasisNodeEmA6kOpenMarkerNodeEmA6kCloseMarkerNodeEmU8eOpenMarkerNodeEmU8eCloseMarkerNodeStrongNodeStrongA6kOpenMarkerNodeStrongA6kCloseMarkerNodeStrongU8eOpenMarkerNodeStrongU8eCloseMarkerNodeCodeSpanNodeCodeSpanOpenMarkerNodeCodeSpanContentNodeCodeSpanCloseMarkerNodeHardBreakNodeSoftBreakNodeLinkNodeImageNodeBangNodeOpenBracketNodeCloseBracketNodeOpenParenNodeCloseParenNodeLinkTextNodeLinkDestNodeLinkTitleNodeLinkSpaceNodeHTMLEntity", ((i < 0 || i >= _NodeType_index_0.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_0[i]), (x = i + 1 >> 0, ((x < 0 || x >= _NodeType_index_0.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_0[x])));
		} else if (100 <= i && i <= 109) {
			i = i - (100) >> 0;
			return $substring("NodeTaskListItemMarkerNodeStrikethroughNodeStrikethrough1OpenMarkerNodeStrikethrough1CloseMarkerNodeStrikethrough2OpenMarkerNodeStrikethrough2CloseMarkerNodeTableNodeTableHeadNodeTableRowNodeTableCell", ((i < 0 || i >= _NodeType_index_1.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_1[i]), (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= _NodeType_index_1.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_1[x$1])));
		} else if (200 <= i && i <= 203) {
			i = i - (200) >> 0;
			return $substring("NodeEmojiNodeEmojiUnicodeNodeEmojiImgNodeEmojiAlias", ((i < 0 || i >= _NodeType_index_2.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_2[i]), (x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= _NodeType_index_2.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_2[x$2])));
		} else if (300 <= i && i <= 307) {
			i = i - (300) >> 0;
			return $substring("NodeMathBlockNodeMathBlockOpenMarkerNodeMathBlockContentNodeMathBlockCloseMarkerNodeInlineMathNodeInlineMathOpenMarkerNodeInlineMathContentNodeInlineMathCloseMarker", ((i < 0 || i >= _NodeType_index_3.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_3[i]), (x$3 = i + 1 >> 0, ((x$3 < 0 || x$3 >= _NodeType_index_3.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_3[x$3])));
		} else if (400 <= i && i <= 401) {
			i = i - (400) >> 0;
			return $substring("NodeBackslashNodeBackslashContent", ((i < 0 || i >= _NodeType_index_4.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_4[i]), (x$4 = i + 1 >> 0, ((x$4 < 0 || x$4 >= _NodeType_index_4.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_4[x$4])));
		} else if (500 <= i && i <= 501) {
			i = i - (500) >> 0;
			return $substring("NodeFootnotesDefNodeFootnotesRef", ((i < 0 || i >= _NodeType_index_5.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_5[i]), (x$5 = i + 1 >> 0, ((x$5 < 0 || x$5 >= _NodeType_index_5.length) ? ($throwRuntimeError("index out of range"), undefined) : _NodeType_index_5[x$5])));
		} else if ((i === 600)) {
			return "NodeToC";
		} else if ((i === 1024)) {
			return "NodeTypeMaxVal";
		} else {
			return "NodeType(" + strconv.FormatInt((new $Int64(0, i)), 10) + ")";
		}
	};
	$ptrType(NodeType).prototype.String = function() { return new NodeType(this.$get()).String(); };
	Walk = function(n, walker) {
		var _r, _r$1, c, n, status, walker, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; c = $f.c; n = $f.n; status = $f.status; walker = $f.walker; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		status = 0;
		_r = walker(n, true); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		status = _r;
		if (status === 0) {
			$s = -1; return;
		}
		/* */ if (!((status === 1))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!((status === 1))) { */ case 2:
			c = n.FirstChild;
			/* while (true) { */ case 4:
				/* if (!(!(ptrType.nil === c))) { break; } */ if(!(!(ptrType.nil === c))) { $s = 5; continue; }
				$r = Walk(c, walker); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				c = c.Next;
			/* } */ $s = 4; continue; case 5:
		/* } */ case 3:
		_r$1 = walker(n, false); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		status = _r$1;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Walk }; } $f._r = _r; $f._r$1 = _r$1; $f.c = c; $f.n = n; $f.status = status; $f.walker = walker; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Walk = Walk;
	ptrType.methods = [{prop: "TokensStr", name: "TokensStr", pkg: "", typ: $funcType([], [$String], false)}, {prop: "LastDeepestChild", name: "LastDeepestChild", pkg: "", typ: $funcType([], [ptrType], false)}, {prop: "FirstDeepestChild", name: "FirstDeepestChild", pkg: "", typ: $funcType([], [ptrType], false)}, {prop: "ChildByType", name: "ChildByType", pkg: "", typ: $funcType([NodeType], [ptrType], false)}, {prop: "Text", name: "Text", pkg: "", typ: $funcType([], [$String], false)}, {prop: "NextNodeText", name: "NextNodeText", pkg: "", typ: $funcType([], [$String], false)}, {prop: "PreviousNodeText", name: "PreviousNodeText", pkg: "", typ: $funcType([], [$String], false)}, {prop: "Unlink", name: "Unlink", pkg: "", typ: $funcType([], [], false)}, {prop: "AppendTokens", name: "AppendTokens", pkg: "", typ: $funcType([sliceType$1], [], false)}, {prop: "InsertAfter", name: "InsertAfter", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "InsertBefore", name: "InsertBefore", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "AppendChild", name: "AppendChild", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "PrependChild", name: "PrependChild", pkg: "", typ: $funcType([ptrType], [], false)}, {prop: "List", name: "List", pkg: "", typ: $funcType([], [sliceType], false)}, {prop: "ParentIs", name: "ParentIs", pkg: "", typ: $funcType([NodeType, sliceType$3], [$Bool], true)}, {prop: "AcceptLines", name: "AcceptLines", pkg: "", typ: $funcType([], [$Bool], false)}, {prop: "CanContain", name: "CanContain", pkg: "", typ: $funcType([NodeType], [$Bool], false)}];
	NodeType.methods = [{prop: "String", name: "String", pkg: "", typ: $funcType([], [$String], false)}];
	Node.init("", [{prop: "Type", name: "Type", embedded: false, exported: true, typ: NodeType, tag: ""}, {prop: "Parent", name: "Parent", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "Previous", name: "Previous", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "Next", name: "Next", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "FirstChild", name: "FirstChild", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "LastChild", name: "LastChild", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "Tokens", name: "Tokens", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Close", name: "Close", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "LastLineBlank", name: "LastLineBlank", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "LastLineChecked", name: "LastLineChecked", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeMarkerLen", name: "CodeMarkerLen", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "IsFencedCodeBlock", name: "IsFencedCodeBlock", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeBlockFenceChar", name: "CodeBlockFenceChar", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "CodeBlockFenceLen", name: "CodeBlockFenceLen", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "CodeBlockFenceOffset", name: "CodeBlockFenceOffset", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "CodeBlockOpenFence", name: "CodeBlockOpenFence", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "CodeBlockInfo", name: "CodeBlockInfo", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "CodeBlockCloseFence", name: "CodeBlockCloseFence", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "HtmlBlockType", name: "HtmlBlockType", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "ListData", name: "ListData", embedded: true, exported: true, typ: ptrType$1, tag: ""}, {prop: "TaskListItemChecked", name: "TaskListItemChecked", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "TableAligns", name: "TableAligns", embedded: false, exported: true, typ: sliceType$2, tag: ""}, {prop: "TableCellAlign", name: "TableCellAlign", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "TableCellContentWidth", name: "TableCellContentWidth", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "TableCellContentMaxWidth", name: "TableCellContentMaxWidth", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "TableCellContent", name: "TableCellContent", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "TableCellMaxWidthContent", name: "TableCellMaxWidthContent", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "LinkType", name: "LinkType", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "LinkRefLabel", name: "LinkRefLabel", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "HeadingLevel", name: "HeadingLevel", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "HeadingSetext", name: "HeadingSetext", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "HeadingID", name: "HeadingID", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "HeadingNormalizedID", name: "HeadingNormalizedID", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "MathBlockDollarOffset", name: "MathBlockDollarOffset", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "FootnotesRefLabel", name: "FootnotesRefLabel", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "FootnotesRefId", name: "FootnotesRefId", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "FootnotesRefs", name: "FootnotesRefs", embedded: false, exported: true, typ: sliceType, tag: ""}, {prop: "HtmlEntityTokens", name: "HtmlEntityTokens", embedded: false, exported: true, typ: sliceType$1, tag: ""}]);
	ListData.init("", [{prop: "Typ", name: "Typ", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Tight", name: "Tight", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "BulletChar", name: "BulletChar", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Start", name: "Start", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Delimiter", name: "Delimiter", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Padding", name: "Padding", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "MarkerOffset", name: "MarkerOffset", embedded: false, exported: true, typ: $Int, tag: ""}, {prop: "Checked", name: "Checked", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "Marker", name: "Marker", embedded: false, exported: true, typ: sliceType$1, tag: ""}, {prop: "Num", name: "Num", embedded: false, exported: true, typ: $Int, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = util.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_NodeType_index_0 = $toNativeArray($kindUint16, [0, 12, 25, 36, 56, 73, 87, 107, 115, 127, 140, 154, 167, 195, 224, 252, 269, 277, 289, 308, 328, 347, 367, 377, 400, 424, 447, 471, 483, 505, 524, 547, 560, 573, 581, 590, 598, 613, 629, 642, 656, 668, 680, 693, 706, 720]);
		_NodeType_index_1 = $toNativeArray($kindUint8, [0, 22, 39, 67, 96, 124, 153, 162, 175, 187, 200]);
		_NodeType_index_2 = $toNativeArray($kindUint8, [0, 9, 25, 37, 51]);
		_NodeType_index_3 = $toNativeArray($kindUint8, [0, 13, 36, 56, 80, 94, 118, 139, 164]);
		_NodeType_index_4 = $toNativeArray($kindUint8, [0, 13, 33]);
		_NodeType_index_5 = $toNativeArray($kindUint8, [0, 16, 32]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute/parse"] = (function() {
	var $pkg = {}, $init, bytes, ast, lex, util, strconv, strings, unicode, utf8, blockStartFunc, delimiter, Context, InlineContext, Tree, Options, sliceType, sliceType$1, sliceType$2, ptrType, ptrType$1, sliceType$3, sliceType$4, sliceType$5, ptrType$2, ptrType$3, ptrType$4, ptrType$5, ptrType$6, ptrType$7, sliceType$6, mapType, mapType$1, mailto, httpProto, validAutoLinkDomainSuffix, markers, blockStarts, codeBlockBacktick, emojiDot, unicodeAliasEmojiMap, aliasUnicodeEmojiMap, htmlBlockTags1, htmlBlockCloseTags1, htmlBlockTags6, htmlBlockSinglequote, htmlBlockDoublequote, htmlBlockGreater, dollar, items1, backslash, BlockquoteContinue, _continue, CodeBlockContinue, codeBlockFinalize, NewEmojis, init, FootnotesContinue, HtmlBlockContinue, htmlBlockFinalize, listFinalize, endsWithBlankLine, ListItemContinue, MathBlockContinue, mathBlockFinalize, isMathBlockClose, ParagraphContinue, paragraphFinalize, Parse;
	bytes = $packages["bytes"];
	ast = $packages["lute/ast"];
	lex = $packages["lute/lex"];
	util = $packages["lute/util"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	blockStartFunc = $pkg.blockStartFunc = $newType(4, $kindFunc, "parse.blockStartFunc", true, "lute/parse", false, null);
	delimiter = $pkg.delimiter = $newType(0, $kindStruct, "parse.delimiter", true, "lute/parse", false, function(node_, typ_, num_, originalNum_, canOpen_, canClose_, previous_, next_, active_, image_, bracketAfter_, index_, previousDelimiter_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.node = ptrType.nil;
			this.typ = 0;
			this.num = 0;
			this.originalNum = 0;
			this.canOpen = false;
			this.canClose = false;
			this.previous = ptrType$2.nil;
			this.next = ptrType$2.nil;
			this.active = false;
			this.image = false;
			this.bracketAfter = false;
			this.index = 0;
			this.previousDelimiter = ptrType$2.nil;
			return;
		}
		this.node = node_;
		this.typ = typ_;
		this.num = num_;
		this.originalNum = originalNum_;
		this.canOpen = canOpen_;
		this.canClose = canClose_;
		this.previous = previous_;
		this.next = next_;
		this.active = active_;
		this.image = image_;
		this.bracketAfter = bracketAfter_;
		this.index = index_;
		this.previousDelimiter = previousDelimiter_;
	});
	Context = $pkg.Context = $newType(0, $kindStruct, "parse.Context", true, "lute/parse", true, function(Tree_, Option_, LinkRefDefs_, FootnotesDefs_, Tip_, oldtip_, currentLine_, currentLineLen_, lineNum_, offset_, column_, nextNonspace_, nextNonspaceColumn_, indent_, indented_, blank_, partiallyConsumedTab_, allClosed_, lastMatchedContainer_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Tree = ptrType$3.nil;
			this.Option = ptrType$7.nil;
			this.LinkRefDefs = false;
			this.FootnotesDefs = sliceType$4.nil;
			this.Tip = ptrType.nil;
			this.oldtip = ptrType.nil;
			this.currentLine = sliceType.nil;
			this.currentLineLen = 0;
			this.lineNum = 0;
			this.offset = 0;
			this.column = 0;
			this.nextNonspace = 0;
			this.nextNonspaceColumn = 0;
			this.indent = 0;
			this.indented = false;
			this.blank = false;
			this.partiallyConsumedTab = false;
			this.allClosed = false;
			this.lastMatchedContainer = ptrType.nil;
			return;
		}
		this.Tree = Tree_;
		this.Option = Option_;
		this.LinkRefDefs = LinkRefDefs_;
		this.FootnotesDefs = FootnotesDefs_;
		this.Tip = Tip_;
		this.oldtip = oldtip_;
		this.currentLine = currentLine_;
		this.currentLineLen = currentLineLen_;
		this.lineNum = lineNum_;
		this.offset = offset_;
		this.column = column_;
		this.nextNonspace = nextNonspace_;
		this.nextNonspaceColumn = nextNonspaceColumn_;
		this.indent = indent_;
		this.indented = indented_;
		this.blank = blank_;
		this.partiallyConsumedTab = partiallyConsumedTab_;
		this.allClosed = allClosed_;
		this.lastMatchedContainer = lastMatchedContainer_;
	});
	InlineContext = $pkg.InlineContext = $newType(0, $kindStruct, "parse.InlineContext", true, "lute/parse", true, function(tokens_, tokensLen_, pos_, lineNum_, columnNum_, delimiters_, brackets_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.tokens = sliceType.nil;
			this.tokensLen = 0;
			this.pos = 0;
			this.lineNum = 0;
			this.columnNum = 0;
			this.delimiters = ptrType$2.nil;
			this.brackets = ptrType$2.nil;
			return;
		}
		this.tokens = tokens_;
		this.tokensLen = tokensLen_;
		this.pos = pos_;
		this.lineNum = lineNum_;
		this.columnNum = columnNum_;
		this.delimiters = delimiters_;
		this.brackets = brackets_;
	});
	Tree = $pkg.Tree = $newType(0, $kindStruct, "parse.Tree", true, "lute/parse", true, function(Name_, Root_, Context_, lexer_, inlineContext_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Name = "";
			this.Root = ptrType.nil;
			this.Context = ptrType$4.nil;
			this.lexer = ptrType$5.nil;
			this.inlineContext = ptrType$6.nil;
			return;
		}
		this.Name = Name_;
		this.Root = Root_;
		this.Context = Context_;
		this.lexer = lexer_;
		this.inlineContext = inlineContext_;
	});
	Options = $pkg.Options = $newType(0, $kindStruct, "parse.Options", true, "lute/parse", true, function(GFMTable_, GFMTaskListItem_, GFMTaskListItemClass_, GFMStrikethrough_, GFMAutoLink_, SoftBreak2HardBreak_, CodeSyntaxHighlight_, CodeSyntaxHighlightDetectLang_, CodeSyntaxHighlightInlineStyle_, CodeSyntaxHighlightLineNum_, CodeSyntaxHighlightStyleName_, Footnotes_, ToC_, HeadingID_, AutoSpace_, FixTermTypo_, ChinesePunct_, Emoji_, AliasEmoji_, EmojiAlias_, EmojiSite_, HeadingAnchor_, Terms_, VditorWYSIWYG_, VditorIR_, InlineMathAllowDigitAfterOpenMarker_, LinkBase_, VditorCodeBlockPreview_, RenderListMarker_, Setext_, Sanitize_, ImageLazyLoading_, ChineseParagraphBeginningSpace_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.GFMTable = false;
			this.GFMTaskListItem = false;
			this.GFMTaskListItemClass = "";
			this.GFMStrikethrough = false;
			this.GFMAutoLink = false;
			this.SoftBreak2HardBreak = false;
			this.CodeSyntaxHighlight = false;
			this.CodeSyntaxHighlightDetectLang = false;
			this.CodeSyntaxHighlightInlineStyle = false;
			this.CodeSyntaxHighlightLineNum = false;
			this.CodeSyntaxHighlightStyleName = "";
			this.Footnotes = false;
			this.ToC = false;
			this.HeadingID = false;
			this.AutoSpace = false;
			this.FixTermTypo = false;
			this.ChinesePunct = false;
			this.Emoji = false;
			this.AliasEmoji = false;
			this.EmojiAlias = false;
			this.EmojiSite = "";
			this.HeadingAnchor = false;
			this.Terms = false;
			this.VditorWYSIWYG = false;
			this.VditorIR = false;
			this.InlineMathAllowDigitAfterOpenMarker = false;
			this.LinkBase = "";
			this.VditorCodeBlockPreview = false;
			this.RenderListMarker = false;
			this.Setext = false;
			this.Sanitize = false;
			this.ImageLazyLoading = "";
			this.ChineseParagraphBeginningSpace = false;
			return;
		}
		this.GFMTable = GFMTable_;
		this.GFMTaskListItem = GFMTaskListItem_;
		this.GFMTaskListItemClass = GFMTaskListItemClass_;
		this.GFMStrikethrough = GFMStrikethrough_;
		this.GFMAutoLink = GFMAutoLink_;
		this.SoftBreak2HardBreak = SoftBreak2HardBreak_;
		this.CodeSyntaxHighlight = CodeSyntaxHighlight_;
		this.CodeSyntaxHighlightDetectLang = CodeSyntaxHighlightDetectLang_;
		this.CodeSyntaxHighlightInlineStyle = CodeSyntaxHighlightInlineStyle_;
		this.CodeSyntaxHighlightLineNum = CodeSyntaxHighlightLineNum_;
		this.CodeSyntaxHighlightStyleName = CodeSyntaxHighlightStyleName_;
		this.Footnotes = Footnotes_;
		this.ToC = ToC_;
		this.HeadingID = HeadingID_;
		this.AutoSpace = AutoSpace_;
		this.FixTermTypo = FixTermTypo_;
		this.ChinesePunct = ChinesePunct_;
		this.Emoji = Emoji_;
		this.AliasEmoji = AliasEmoji_;
		this.EmojiAlias = EmojiAlias_;
		this.EmojiSite = EmojiSite_;
		this.HeadingAnchor = HeadingAnchor_;
		this.Terms = Terms_;
		this.VditorWYSIWYG = VditorWYSIWYG_;
		this.VditorIR = VditorIR_;
		this.InlineMathAllowDigitAfterOpenMarker = InlineMathAllowDigitAfterOpenMarker_;
		this.LinkBase = LinkBase_;
		this.VditorCodeBlockPreview = VditorCodeBlockPreview_;
		this.RenderListMarker = RenderListMarker_;
		this.Setext = Setext_;
		this.Sanitize = Sanitize_;
		this.ImageLazyLoading = ImageLazyLoading_;
		this.ChineseParagraphBeginningSpace = ChineseParagraphBeginningSpace_;
	});
	sliceType = $sliceType($Uint8);
	sliceType$1 = $sliceType(sliceType);
	sliceType$2 = $sliceType(blockStartFunc);
	ptrType = $ptrType(ast.Node);
	ptrType$1 = $ptrType(ast.ListData);
	sliceType$3 = $sliceType($Int);
	sliceType$4 = $sliceType(ptrType);
	sliceType$5 = $sliceType($Int32);
	ptrType$2 = $ptrType(delimiter);
	ptrType$3 = $ptrType(Tree);
	ptrType$4 = $ptrType(Context);
	ptrType$5 = $ptrType(lex.Lexer);
	ptrType$6 = $ptrType(InlineContext);
	ptrType$7 = $ptrType(Options);
	sliceType$6 = $sliceType(sliceType$4);
	mapType = $mapType($String, ptrType);
	mapType$1 = $mapType($String, $String);
	Tree.ptr.prototype.parseGFMAutoEmailLink = function(node) {
		var child, next, node, t;
		t = this;
		child = node.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			next = child.Next;
			if ((16 === child.Type) && !(ptrType.nil === child.Parent) && !((33 === child.Parent.Type))) {
				t.parseGFMAutoEmailLink0(child);
			} else {
				t.parseGFMAutoEmailLink(child);
			}
			child = next;
		}
	};
	Tree.prototype.parseGFMAutoEmailLink = function(node) { return this.$val.parseGFMAutoEmailLink(node); };
	Tree.ptr.prototype.parseGFMAutoLink = function(node) {
		var child, next, node, t;
		t = this;
		child = node.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			next = child.Next;
			if (16 === child.Type) {
				t.parseGFMAutoLink0(child);
			} else {
				t.parseGFMAutoLink(child);
			}
			child = next;
		}
	};
	Tree.prototype.parseGFMAutoLink = function(node) { return this.$val.parseGFMAutoLink(node); };
	Tree.ptr.prototype.parseGFMAutoEmailLink0 = function(node) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, atIndex, group, i, item, j, k, lastIndex, length, link, link$1, node, t, token, tokens;
		t = this;
		tokens = node.Tokens;
		if (0 >= bytes.IndexByte(tokens, 64)) {
			return;
		}
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		_tmp$3 = 0;
		i = _tmp;
		j = _tmp$1;
		k = _tmp$2;
		atIndex = _tmp$3;
		token = 0;
		length = tokens.$length;
		loopPart:
		while (true) {
			if (!(i < length)) { break; }
			group = sliceType.nil;
			atIndex = 0;
			j = i;
			while (true) {
				if (!(j < length)) { break; }
				token = ((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j]);
				if (!lex.IsWhitespace(token)) {
					group = $append(group, ((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j]));
					if (64 === token) {
						atIndex = j - i >> 0;
					}
					j = j + (1) >> 0;
					continue;
				}
				break;
			}
			if (i === j) {
				t.addPreviousText(node, new sliceType([((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j])]));
				i = i + (1) >> 0;
				continue;
			}
			i = j;
			if (0 >= atIndex) {
				t.addPreviousText(node, group);
				continue;
			}
			k = 0;
			while (true) {
				if (!(k < atIndex)) { break; }
				token = ((k < 0 || k >= group.$length) ? ($throwRuntimeError("index out of range"), undefined) : group.$array[group.$offset + k]);
				if (!t.isValidEmailSegment1(token)) {
					t.addPreviousText(node, group);
					continue loopPart;
				}
				k = k + (1) >> 0;
			}
			k = k + (1) >> 0;
			item = 0;
			while (true) {
				if (!(k < group.$length)) { break; }
				item = ((k < 0 || k >= group.$length) ? ($throwRuntimeError("index out of range"), undefined) : group.$array[group.$offset + k]);
				token = ((k < 0 || k >= group.$length) ? ($throwRuntimeError("index out of range"), undefined) : group.$array[group.$offset + k]);
				if (!t.isValidEmailSegment2(token)) {
					t.addPreviousText(node, group);
					continue loopPart;
				}
				k = k + (1) >> 0;
			}
			if (46 === token) {
				lastIndex = group.$length - 1 >> 0;
				group = $subslice(group, 0, lastIndex);
				link = t.newLink(33, group, $appendSlice(mailto, group), sliceType.nil, 2);
				node.InsertBefore(link);
				t.addPreviousText(node, new sliceType([item]));
			} else if ((45 === token) || (95 === token)) {
				t.addPreviousText(node, group);
				continue loopPart;
			} else {
				link$1 = new ast.Node.ptr(33, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 2, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				link$1.AppendChild(new ast.Node.ptr(40, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, group, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
				link$1.AppendChild(new ast.Node.ptr(41, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $appendSlice(mailto, group), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
				node.InsertBefore(link$1);
			}
		}
		node.Unlink();
		return;
	};
	Tree.prototype.parseGFMAutoEmailLink0 = function(node) { return this.$val.parseGFMAutoEmailLink0(node); };
	Tree.ptr.prototype.isValidEmailSegment1 = function(token) {
		var t, token;
		t = this;
		return lex.IsASCIILetterNumHyphen(token) || (46 === token) || (43 === token) || (95 === token);
	};
	Tree.prototype.isValidEmailSegment1 = function(token) { return this.$val.isValidEmailSegment1(token); };
	Tree.ptr.prototype.isValidEmailSegment2 = function(token) {
		var t, token;
		t = this;
		return lex.IsASCIILetterNumHyphen(token) || (46 === token) || (95 === token);
	};
	Tree.prototype.isValidEmailSegment2 = function(token) { return this.$val.isValidEmailSegment2(token); };
	Tree.ptr.prototype.parseGFMAutoLink0 = function(node) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, addr, closeParens, dest, domain, entity, foundAmp, i, isEntity, j, k, l, lastToken, lastToken$1, length, length$1, link, minLinkLen, needUnlink, node, openParens, path, protocol, t, textEnd, textStart, tmpLen, token, tokens, trimmed, unmatches, url, www, x, x$1, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$2, x$20, x$21, x$22, x$3, x$4, x$5, x$6, x$7, x$8, x$9;
		t = this;
		tokens = node.Tokens;
		length = tokens.$length;
		minLinkLen = 10;
		if (minLinkLen > length) {
			return;
		}
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		i = _tmp;
		j = _tmp$1;
		k = _tmp$2;
		_tmp$3 = 0;
		_tmp$4 = 0;
		textStart = _tmp$3;
		textEnd = _tmp$4;
		token = 0;
		www = false;
		needUnlink = false;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			protocol = sliceType.nil;
			tmpLen = length - i >> 0;
			if (10 <= tmpLen && (119 === ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i])) && (119 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) && (119 === (x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]))) && (46 === (x$2 = i + 3 >> 0, ((x$2 < 0 || x$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$2])))) {
				protocol = httpProto;
				www = true;
			} else if (13 <= tmpLen && (104 === ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i])) && (116 === (x$3 = i + 1 >> 0, ((x$3 < 0 || x$3 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$3]))) && (116 === (x$4 = i + 2 >> 0, ((x$4 < 0 || x$4 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$4]))) && (112 === (x$5 = i + 3 >> 0, ((x$5 < 0 || x$5 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$5]))) && (58 === (x$6 = i + 4 >> 0, ((x$6 < 0 || x$6 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$6]))) && (47 === (x$7 = i + 5 >> 0, ((x$7 < 0 || x$7 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$7]))) && (47 === (x$8 = i + 6 >> 0, ((x$8 < 0 || x$8 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$8])))) {
				protocol = $subslice(tokens, i, (i + 7 >> 0));
				i = i + (7) >> 0;
			} else if (14 <= tmpLen && (104 === ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i])) && (116 === (x$9 = i + 1 >> 0, ((x$9 < 0 || x$9 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$9]))) && (116 === (x$10 = i + 2 >> 0, ((x$10 < 0 || x$10 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$10]))) && (112 === (x$11 = i + 3 >> 0, ((x$11 < 0 || x$11 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$11]))) && (115 === (x$12 = i + 4 >> 0, ((x$12 < 0 || x$12 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$12]))) && (58 === (x$13 = i + 5 >> 0, ((x$13 < 0 || x$13 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$13]))) && (47 === (x$14 = i + 6 >> 0, ((x$14 < 0 || x$14 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$14]))) && (47 === (x$15 = i + 7 >> 0, ((x$15 < 0 || x$15 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$15])))) {
				protocol = $subslice(tokens, i, (i + 8 >> 0));
				i = i + (8) >> 0;
			} else if (12 <= tmpLen && (102 === ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i])) && (116 === (x$16 = i + 1 >> 0, ((x$16 < 0 || x$16 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$16]))) && (112 === (x$17 = i + 2 >> 0, ((x$17 < 0 || x$17 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$17]))) && (58 === (x$18 = i + 3 >> 0, ((x$18 < 0 || x$18 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$18]))) && (47 === (x$19 = i + 4 >> 0, ((x$19 < 0 || x$19 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$19]))) && (47 === (x$20 = i + 5 >> 0, ((x$20 < 0 || x$20 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$20])))) {
				protocol = $subslice(tokens, i, (i + 6 >> 0));
				i = i + (6) >> 0;
			} else {
				textEnd = textEnd + (1) >> 0;
				if ((length - i >> 0) < minLinkLen) {
					if (needUnlink) {
						if (textStart < textEnd) {
							t.addPreviousText(node, $subslice(tokens, textStart));
						} else {
							t.addPreviousText(node, $subslice(tokens, textEnd));
						}
						node.Unlink();
					}
					return;
				}
				i = i + (1) >> 0;
				continue;
			}
			if (textStart < textEnd) {
				t.addPreviousText(node, $subslice(tokens, textStart, textEnd));
				needUnlink = true;
				textStart = textEnd;
			}
			url = sliceType.nil;
			j = i;
			while (true) {
				if (!(j < length)) { break; }
				token = ((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j]);
				if ((lex.IsWhitespace(token) || (60 === token)) || (!lex.IsASCIIPunct(token) && !lex.IsASCIILetterNum(token))) {
					break;
				}
				url = $append(url, token);
				j = j + (1) >> 0;
			}
			if (i === j) {
				if (128 <= token) {
					if (!www) {
						url = $appendSlice(url, protocol);
					}
					while (true) {
						if (!(i < length)) { break; }
						token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
						if (128 > token) {
							break;
						}
						url = $append(url, token);
						i = i + (1) >> 0;
					}
				} else {
					url = $append(url, token);
					i = i + (1) >> 0;
				}
				if (!(ptrType.nil === node.Previous)) {
					node.Previous.Tokens = $appendSlice(node.Previous.Tokens, url);
				}
				textStart = i;
				textEnd = i;
				continue;
			}
			i = j;
			k = 0;
			while (true) {
				if (!(k < url.$length)) { break; }
				token = ((k < 0 || k >= url.$length) ? ($throwRuntimeError("index out of range"), undefined) : url.$array[url.$offset + k]);
				if (47 === token) {
					break;
				}
				k = k + (1) >> 0;
			}
			domain = $subslice(url, 0, k);
			if (!t.isValidDomain(domain)) {
				t.addPreviousText(node, $subslice(tokens, textStart, i));
				needUnlink = true;
				textStart = i;
				textEnd = i;
				continue;
			}
			_tmp$5 = 0;
			_tmp$6 = 0;
			openParens = _tmp$5;
			closeParens = _tmp$6;
			path = $subslice(url, k);
			length$1 = path.$length;
			if (0 < length$1) {
				l = 0;
				l = 0;
				while (true) {
					if (!(l < length$1)) { break; }
					token = ((l < 0 || l >= path.$length) ? ($throwRuntimeError("index out of range"), undefined) : path.$array[path.$offset + l]);
					if (40 === token) {
						openParens = openParens + (1) >> 0;
					} else if (41 === token) {
						closeParens = closeParens + (1) >> 0;
					}
					l = l + (1) >> 0;
				}
				trimmed = false;
				lastToken = (x$21 = length$1 - 1 >> 0, ((x$21 < 0 || x$21 >= path.$length) ? ($throwRuntimeError("index out of range"), undefined) : path.$array[path.$offset + x$21]));
				if (41 === lastToken) {
					unmatches = closeParens - openParens >> 0;
					if (0 < unmatches) {
						l = length$1 - 1 >> 0;
						while (true) {
							if (!(0 < unmatches)) { break; }
							token = ((l < 0 || l >= path.$length) ? ($throwRuntimeError("index out of range"), undefined) : path.$array[path.$offset + l]);
							if (!((41 === token))) {
								break;
							}
							unmatches = unmatches - (1) >> 0;
							i = i - (1) >> 0;
							l = l - (1) >> 0;
						}
						path = $subslice(path, 0, (l + 1 >> 0));
						trimmed = true;
					} else {
						trimmed = true;
					}
				} else if (59 === lastToken) {
					foundAmp = false;
					l = length$1 - 1 >> 0;
					while (true) {
						if (!(0 <= l)) { break; }
						token = ((l < 0 || l >= path.$length) ? ($throwRuntimeError("index out of range"), undefined) : path.$array[path.$offset + l]);
						if (38 === token) {
							foundAmp = true;
							break;
						}
						l = l - (1) >> 0;
					}
					if (foundAmp) {
						entity = $subslice(path, l, length$1);
						if (3 <= entity.$length) {
							isEntity = true;
							j = 1;
							while (true) {
								if (!(j < (entity.$length - 1 >> 0))) { break; }
								if (!lex.IsASCIILetterNum(((j < 0 || j >= entity.$length) ? ($throwRuntimeError("index out of range"), undefined) : entity.$array[entity.$offset + j]))) {
									isEntity = false;
									break;
								}
								j = j + (1) >> 0;
							}
							if (isEntity) {
								path = $subslice(path, 0, l);
								trimmed = true;
								i = i - ((length$1 - l >> 0)) >> 0;
							}
						}
					}
				}
				if (!trimmed && lex.IsASCIIPunct(lastToken) && !((47 === lastToken)) && !((125 === lastToken)) && !((123 === lastToken))) {
					path = $subslice(path, 0, (length$1 - 1 >> 0));
					i = i - (1) >> 0;
				}
			} else {
				length$1 = domain.$length;
				lastToken$1 = (x$22 = length$1 - 1 >> 0, ((x$22 < 0 || x$22 >= domain.$length) ? ($throwRuntimeError("index out of range"), undefined) : domain.$array[domain.$offset + x$22]));
				if (lex.IsASCIIPunct(lastToken$1)) {
					domain = $subslice(domain, 0, (length$1 - 1 >> 0));
					i = i - (1) >> 0;
				}
			}
			dest = $appendSlice(protocol, domain);
			dest = $appendSlice(dest, path);
			addr = sliceType.nil;
			if (!www) {
				addr = $appendSlice(addr, protocol);
			}
			addr = $appendSlice(addr, domain);
			addr = $appendSlice(addr, path);
			link = t.newLink(33, addr, util.EncodeDestination(dest), sliceType.nil, 2);
			node.InsertBefore(link);
			needUnlink = true;
			textStart = i;
			textEnd = i;
		}
		if (textStart < textEnd) {
			t.addPreviousText(node, $subslice(tokens, textStart, textEnd));
			needUnlink = true;
		}
		if (needUnlink) {
			node.Unlink();
		}
		return;
	};
	Tree.prototype.parseGFMAutoLink0 = function(node) { return this.$val.parseGFMAutoLink0(node); };
	Tree.ptr.prototype.isValidDomain = function(domain) {
		var domain, i, j, j$1, length, segLen, segment, segments, t, token, validSuffix;
		t = this;
		segments = lex.Split(domain, 46);
		length = segments.$length;
		if (2 > length) {
			return false;
		}
		token = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			segment = ((i < 0 || i >= segments.$length) ? ($throwRuntimeError("index out of range"), undefined) : segments.$array[segments.$offset + i]);
			segLen = segment.$length;
			if (1 > segLen) {
				i = i + (1) >> 0;
				continue;
			}
			j = 0;
			while (true) {
				if (!(j < segLen)) { break; }
				token = ((j < 0 || j >= segment.$length) ? ($throwRuntimeError("index out of range"), undefined) : segment.$array[segment.$offset + j]);
				if (!lex.IsASCIILetterNumHyphen(token)) {
					return false;
				}
				if (2 < i && ((i === (length - 2 >> 0)) || (i === (length - 1 >> 0)))) {
					if (95 === token) {
						return false;
					}
				}
				j = j + (1) >> 0;
			}
			if (i === (length - 1 >> 0)) {
				validSuffix = false;
				j$1 = 0;
				while (true) {
					if (!(j$1 < validAutoLinkDomainSuffix.$length)) { break; }
					if (bytes.Equal(segment, ((j$1 < 0 || j$1 >= validAutoLinkDomainSuffix.$length) ? ($throwRuntimeError("index out of range"), undefined) : validAutoLinkDomainSuffix.$array[validAutoLinkDomainSuffix.$offset + j$1]))) {
						validSuffix = true;
						break;
					}
					j$1 = j$1 + (1) >> 0;
				}
				if (!validSuffix) {
					return false;
				}
			}
			i = i + (1) >> 0;
		}
		return true;
	};
	Tree.prototype.isValidDomain = function(domain) { return this.$val.isValidDomain(domain); };
	Tree.ptr.prototype.parseAutoEmailLink = function(ctx) {
		var at, closed, ctx, dest, domainPart, i, length, passed, ret, t, token, tokens;
		ret = ptrType.nil;
		t = this;
		tokens = $subslice(ctx.tokens, 1);
		dest = sliceType.nil;
		token = 0;
		length = tokens.$length;
		passed = 0;
		i = 0;
		at = false;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			dest = $append(dest, ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]));
			passed = passed + (1) >> 0;
			if (64 === token) {
				at = true;
				break;
			}
			if (!lex.IsASCIILetterNumHyphen(token) && !bytes.Contains(markers, new sliceType([token]))) {
				ret = ptrType.nil;
				return ret;
			}
			i = i + (1) >> 0;
		}
		if (1 > i || !at) {
			ret = ptrType.nil;
			return ret;
		}
		domainPart = $subslice(tokens, (i + 1 >> 0));
		length = domainPart.$length;
		i = 0;
		closed = false;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= domainPart.$length) ? ($throwRuntimeError("index out of range"), undefined) : domainPart.$array[domainPart.$offset + i]);
			passed = passed + (1) >> 0;
			if (62 === token) {
				closed = true;
				break;
			}
			dest = $append(dest, ((i < 0 || i >= domainPart.$length) ? ($throwRuntimeError("index out of range"), undefined) : domainPart.$array[domainPart.$offset + i]));
			if (!lex.IsASCIILetterNumHyphen(token) && !((46 === token))) {
				ret = ptrType.nil;
				return ret;
			}
			if (63 < i) {
				ret = ptrType.nil;
				return ret;
			}
			i = i + (1) >> 0;
		}
		if (1 > i || !closed) {
			ret = ptrType.nil;
			return ret;
		}
		ctx.pos = ctx.pos + ((passed + 1 >> 0)) >> 0;
		ret = t.newLink(33, dest, $appendSlice(mailto, dest), sliceType.nil, 2);
		return ret;
	};
	Tree.prototype.parseAutoEmailLink = function(ctx) { return this.$val.parseAutoEmailLink(ctx); };
	Tree.ptr.prototype.newLink = function(typ, text, dest, title, linkType) {
		var dest, linkType, ret, t, text, title, typ;
		ret = ptrType.nil;
		t = this;
		ret = new ast.Node.ptr(typ, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, linkType, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		if (34 === typ) {
			ret.AppendChild(new ast.Node.ptr(35, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		}
		ret.AppendChild(new ast.Node.ptr(36, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		ret.AppendChild(new ast.Node.ptr(40, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, text, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		ret.AppendChild(new ast.Node.ptr(37, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		ret.AppendChild(new ast.Node.ptr(38, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		ret.AppendChild(new ast.Node.ptr(41, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, dest, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		if (!(sliceType.nil === title)) {
			ret.AppendChild(new ast.Node.ptr(42, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, title, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		}
		ret.AppendChild(new ast.Node.ptr(39, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		if (1 === linkType) {
			ret.LinkRefLabel = text;
		}
		return ret;
	};
	Tree.prototype.newLink = function(typ, text, dest, title, linkType) { return this.$val.newLink(typ, text, dest, title, linkType); };
	Tree.ptr.prototype.parseAutolink = function(ctx) {
		var ctx, dest, i, ret, scheme, schemed, t, token, x, x$1, x$2, x$3;
		ret = ptrType.nil;
		t = this;
		schemed = false;
		scheme = "";
		dest = sliceType.nil;
		token = 0;
		i = ctx.pos + 1 >> 0;
		while (true) {
			if (!(i < ctx.tokensLen && !((62 === (x = ctx.tokens, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i])))))) { break; }
			token = (x$1 = ctx.tokens, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]));
			if (32 === token) {
				ret = ptrType.nil;
				return ret;
			}
			dest = $append(dest, (x$2 = ctx.tokens, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i])));
			if (!schemed) {
				if (!((58 === token))) {
					scheme = scheme + (($encodeRune(token)));
				} else {
					schemed = true;
				}
			}
			i = i + (1) >> 0;
		}
		if (!schemed || 3 > scheme.length || (i === ctx.tokensLen)) {
			ret = ptrType.nil;
			return ret;
		}
		if (!((62 === (x$3 = ctx.tokens, ((i < 0 || i >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + i]))))) {
			ret = ptrType.nil;
			return ret;
		}
		ctx.pos = 1 + i >> 0;
		ret = t.newLink(33, dest, util.EncodeDestination(dest), sliceType.nil, 2);
		return ret;
	};
	Tree.prototype.parseAutolink = function(ctx) { return this.$val.parseAutolink(ctx); };
	Tree.ptr.prototype.addPreviousText = function(node, tokens) {
		var node, t, tokens;
		t = this;
		if (ptrType.nil === node.Previous || !((16 === node.Previous.Type))) {
			node.InsertBefore(new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			return;
		}
		node.Previous.AppendTokens(tokens);
	};
	Tree.prototype.addPreviousText = function(node, tokens) { return this.$val.addPreviousText(node, tokens); };
	BlockquoteContinue = function(blockquote, context) {
		var blockquote, context, ln, token;
		ln = context.currentLine;
		if (!context.indented && (lex.Peek(ln, context.nextNonspace) === 62)) {
			context.advanceNextNonspace();
			context.advanceOffset(1, false);
			token = lex.Peek(ln, context.offset);
			if ((32 === token) || (9 === token)) {
				context.advanceOffset(1, true);
			}
			return 0;
		}
		return 1;
	};
	$pkg.BlockquoteContinue = BlockquoteContinue;
	Tree.ptr.prototype.parseBlocks = function() {
		var line, lines, ln, t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; line = $f.line; lines = $f.lines; ln = $f.ln; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		t.Context.Tip = t.Root;
		t.Context.LinkRefDefs = $makeMap($String.keyFor, []);
		t.Context.FootnotesDefs = new sliceType$4([]);
		lines = 0;
		line = t.lexer.NextLine();
		/* while (true) { */ case 1:
			/* if (!(!(sliceType.nil === line))) { break; } */ if(!(!(sliceType.nil === line))) { $s = 2; continue; }
			if (t.Context.Option.VditorWYSIWYG) {
				ln = (new sliceType$5($stringToRunes(($bytesToString(line)))));
				if (4 < ln.$length && lex.IsDigit((((0 >= ln.$length ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + 0]) << 24 >>> 24))) && ((12289 === (1 >= ln.$length ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + 1])) || (65289 === (1 >= ln.$length ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + 1])))) {
					line = (new sliceType($stringToBytes(($encodeRune((0 >= ln.$length ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + 0]))) + ". " + ($runesToString($subslice(ln, 2))))));
				}
			}
			$r = t.incorporateLine(line); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			lines = lines + (1) >> 0;
			line = t.lexer.NextLine();
		/* } */ $s = 1; continue; case 2:
		/* while (true) { */ case 4:
			/* if (!(!(ptrType.nil === t.Context.Tip))) { break; } */ if(!(!(ptrType.nil === t.Context.Tip))) { $s = 5; continue; }
			$r = t.Context.finalize(t.Context.Tip, lines); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 4; continue; case 5:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.parseBlocks }; } $f.line = line; $f.lines = lines; $f.ln = ln; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.parseBlocks = function() { return this.$val.parseBlocks(); };
	Tree.ptr.prototype.incorporateLine = function(line) {
		var _1, _r, _r$1, _r$2, allMatched, cont, container, html, i, isFenced, lastChild, lastLineBlank, line, matchedLeaf, maybeMarker, res, startsLen, t, tokens, typ, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; allMatched = $f.allMatched; cont = $f.cont; container = $f.container; html = $f.html; i = $f.i; isFenced = $f.isFenced; lastChild = $f.lastChild; lastLineBlank = $f.lastLineBlank; line = $f.line; matchedLeaf = $f.matchedLeaf; maybeMarker = $f.maybeMarker; res = $f.res; startsLen = $f.startsLen; t = $f.t; tokens = $f.tokens; typ = $f.typ; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		t.Context.oldtip = t.Context.Tip;
		t.Context.offset = 0;
		t.Context.column = 0;
		t.Context.blank = false;
		t.Context.partiallyConsumedTab = false;
		t.Context.lineNum = t.Context.lineNum + (1) >> 0;
		t.Context.currentLine = line;
		t.Context.currentLineLen = t.Context.currentLine.$length;
		allMatched = true;
		container = ptrType.nil;
		container = t.Root;
		lastChild = container.LastChild;
		/* while (true) { */ case 1:
			/* if (!(!(ptrType.nil === lastChild) && !lastChild.Close)) { break; } */ if(!(!(ptrType.nil === lastChild) && !lastChild.Close)) { $s = 2; continue; }
			container = lastChild;
			t.Context.findNextNonspace();
				_r = _continue(container, t.Context); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_1 = _r;
				if (_1 === (0)) {
					/* break; */ $s = 3; continue;
				} else if (_1 === (1)) {
					allMatched = false;
					/* break; */ $s = 3; continue;
				} else if (_1 === (2)) {
					$s = -1; return;
				}
			case 3:
			if (!allMatched) {
				container = container.Parent;
				/* break; */ $s = 2; continue;
			}
			lastChild = container.LastChild;
		/* } */ $s = 1; continue; case 2:
		t.Context.allClosed = container === t.Context.oldtip;
		t.Context.lastMatchedContainer = container;
		matchedLeaf = !((container.Type === 1)) && container.AcceptLines();
		startsLen = blockStarts.$length;
		/* while (true) { */ case 5:
			/* if (!(!matchedLeaf)) { break; } */ if(!(!matchedLeaf)) { $s = 6; continue; }
			t.Context.findNextNonspace();
			maybeMarker = (x = t.Context.currentLine, x$1 = t.Context.nextNonspace, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			if (!t.Context.indented && !((45 === maybeMarker)) && !((42 === maybeMarker)) && !((43 === maybeMarker)) && !lex.IsDigit(maybeMarker) && !((96 === maybeMarker)) && !((126 === maybeMarker)) && !((35 === maybeMarker)) && !((62 === maybeMarker)) && !((60 === maybeMarker)) && !((95 === maybeMarker)) && !((61 === maybeMarker)) && !((36 === maybeMarker)) && !((91 === maybeMarker)) && !((226 === maybeMarker))) {
				t.Context.advanceNextNonspace();
				/* break; */ $s = 6; continue;
			}
			i = 0;
			/* while (true) { */ case 7:
				/* if (!(i < startsLen)) { break; } */ if(!(i < startsLen)) { $s = 8; continue; }
				_r$1 = ((i < 0 || i >= blockStarts.$length) ? ($throwRuntimeError("index out of range"), undefined) : blockStarts.$array[blockStarts.$offset + i])(t, container); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				res = _r$1;
				if (res === 1) {
					container = t.Context.Tip;
					/* break; */ $s = 8; continue;
				} else if (res === 2) {
					container = t.Context.Tip;
					matchedLeaf = true;
					/* break; */ $s = 8; continue;
				} else {
					i = i + (1) >> 0;
				}
			/* } */ $s = 7; continue; case 8:
			if (i === startsLen) {
				t.Context.advanceNextNonspace();
				/* break; */ $s = 6; continue;
			}
		/* } */ $s = 5; continue; case 6:
		/* */ if (!t.Context.allClosed && !t.Context.blank && (t.Context.Tip.Type === 1)) { $s = 10; continue; }
		/* */ $s = 11; continue;
		/* if (!t.Context.allClosed && !t.Context.blank && (t.Context.Tip.Type === 1)) { */ case 10:
			t.addLine();
			$s = 12; continue;
		/* } else { */ case 11:
			$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 13; case 13: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			if (t.Context.blank && !(ptrType.nil === container.LastChild)) {
				container.LastChild.LastLineBlank = true;
			}
			typ = container.Type;
			isFenced = (11 === typ) && container.IsFencedCodeBlock;
			lastLineBlank = t.Context.blank && !((typ === 500) || (typ === 5) || ((typ === 11) && isFenced) || ((typ === 300)) || ((typ === 8) && ptrType.nil === container.FirstChild));
			cont = container;
			while (true) {
				if (!(!(ptrType.nil === cont))) { break; }
				cont.LastLineBlank = lastLineBlank;
				cont = cont.Parent;
			}
			/* */ if (container.AcceptLines()) { $s = 14; continue; }
			/* */ if (t.Context.offset < t.Context.currentLineLen && !t.Context.blank) { $s = 15; continue; }
			/* */ $s = 16; continue;
			/* if (container.AcceptLines()) { */ case 14:
				t.addLine();
				/* */ if (typ === 9) { $s = 17; continue; }
				/* */ $s = 18; continue;
				/* if (typ === 9) { */ case 17:
					html = container;
					/* */ if (html.HtmlBlockType >= 1 && html.HtmlBlockType <= 5) { $s = 19; continue; }
					/* */ $s = 20; continue;
					/* if (html.HtmlBlockType >= 1 && html.HtmlBlockType <= 5) { */ case 19:
						tokens = $subslice(t.Context.currentLine, t.Context.offset);
						/* */ if (t.isHTMLBlockClose(tokens, html.HtmlBlockType)) { $s = 21; continue; }
						/* */ $s = 22; continue;
						/* if (t.isHTMLBlockClose(tokens, html.HtmlBlockType)) { */ case 21:
							$r = t.Context.finalize(container, t.Context.lineNum); /* */ $s = 23; case 23: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
						/* } */ case 22:
					/* } */ case 20:
				/* } */ case 18:
				$s = 16; continue;
			/* } else if (t.Context.offset < t.Context.currentLineLen && !t.Context.blank) { */ case 15:
				_r$2 = t.Context.addChild(1, t.Context.offset); /* */ $s = 24; case 24: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$2;
				t.Context.advanceNextNonspace();
				t.addLine();
			/* } */ case 16:
		/* } */ case 12:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.incorporateLine }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.allMatched = allMatched; $f.cont = cont; $f.container = container; $f.html = html; $f.i = i; $f.isFenced = isFenced; $f.lastChild = lastChild; $f.lastLineBlank = lastLineBlank; $f.line = line; $f.matchedLeaf = matchedLeaf; $f.maybeMarker = maybeMarker; $f.res = res; $f.startsLen = startsLen; $f.t = t; $f.tokens = tokens; $f.typ = typ; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.incorporateLine = function(line) { return this.$val.incorporateLine(line); };
	Tree.ptr.prototype.addLine = function() {
		var _r, charsToTab, t;
		t = this;
		if (t.Context.partiallyConsumedTab) {
			t.Context.offset = t.Context.offset + (1) >> 0;
			charsToTab = 4 - ((_r = t.Context.column % 4, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))) >> 0;
			t.Context.Tip.AppendTokens(bytes.Repeat(util.StrToBytes(" "), charsToTab));
		}
		t.Context.Tip.AppendTokens($subslice(t.Context.currentLine, t.Context.offset));
	};
	Tree.prototype.addLine = function() { return this.$val.addLine(); };
	_continue = function(n, context) {
		var _1, _r, _r$1, context, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; context = $f.context; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			_1 = n.Type;
			/* */ if (_1 === (11)) { $s = 2; continue; }
			/* */ if (_1 === (9)) { $s = 3; continue; }
			/* */ if (_1 === (1)) { $s = 4; continue; }
			/* */ if (_1 === (8)) { $s = 5; continue; }
			/* */ if (_1 === (5)) { $s = 6; continue; }
			/* */ if (_1 === (300)) { $s = 7; continue; }
			/* */ if (_1 === (500)) { $s = 8; continue; }
			/* */ if ((_1 === (2)) || (_1 === (4))) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (_1 === (11)) { */ case 2:
				_r = CodeBlockContinue(n, context); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$s = -1; return _r;
			/* } else if (_1 === (9)) { */ case 3:
				$s = -1; return HtmlBlockContinue(n, context);
			/* } else if (_1 === (1)) { */ case 4:
				$s = -1; return ParagraphContinue(n, context);
			/* } else if (_1 === (8)) { */ case 5:
				$s = -1; return ListItemContinue(n, context);
			/* } else if (_1 === (5)) { */ case 6:
				$s = -1; return BlockquoteContinue(n, context);
			/* } else if (_1 === (300)) { */ case 7:
				_r$1 = MathBlockContinue(n, context); /* */ $s = 12; case 12: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				$s = -1; return _r$1;
			/* } else if (_1 === (500)) { */ case 8:
				$s = -1; return FootnotesContinue(n, context);
			/* } else if ((_1 === (2)) || (_1 === (4))) { */ case 9:
				$s = -1; return 1;
			/* } */ case 10:
		case 1:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: _continue }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f.context = context; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	CodeBlockContinue = function(codeBlock, context) {
		var _tuple, closeFence, codeBlock, context, i, indent, ln, ok, token, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _tuple = $f._tuple; closeFence = $f.closeFence; codeBlock = $f.codeBlock; context = $f.context; i = $f.i; indent = $f.indent; ln = $f.ln; ok = $f.ok; token = $f.token; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ln = context.currentLine;
		indent = context.indent;
		/* */ if (codeBlock.IsFencedCodeBlock) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (codeBlock.IsFencedCodeBlock) { */ case 1:
			_tuple = context.isFencedCodeClose($subslice(ln, context.nextNonspace), codeBlock.CodeBlockFenceChar, codeBlock.CodeBlockFenceLen);
			ok = _tuple[0];
			closeFence = _tuple[1];
			/* */ if (indent <= 3 && ok) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (indent <= 3 && ok) { */ case 4:
				codeBlock.CodeBlockCloseFence = closeFence;
				$r = context.finalize(codeBlock, context.lineNum); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				$s = -1; return 2;
			/* } else { */ case 5:
				i = codeBlock.CodeBlockFenceOffset;
				token = 0;
				while (true) {
					if (!(i > 0)) { break; }
					token = lex.Peek(ln, context.offset);
					if (!((32 === token)) && !((9 === token))) {
						break;
					}
					context.advanceOffset(1, true);
					i = i - (1) >> 0;
				}
			/* } */ case 6:
			$s = 3; continue;
		/* } else { */ case 2:
			if (indent >= 4) {
				context.advanceOffset(4, true);
			} else if (context.blank) {
				context.advanceNextNonspace();
			} else {
				$s = -1; return 1;
			}
		/* } */ case 3:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: CodeBlockContinue }; } $f._tuple = _tuple; $f.closeFence = closeFence; $f.codeBlock = codeBlock; $f.context = context; $f.i = i; $f.indent = indent; $f.ln = ln; $f.ok = ok; $f.token = token; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.CodeBlockContinue = CodeBlockContinue;
	codeBlockFinalize = function(codeBlock) {
		var codeBlock, content, i, length;
		if (codeBlock.IsFencedCodeBlock) {
			content = codeBlock.Tokens;
			length = content.$length;
			if (1 > length) {
				return;
			}
			i = 0;
			while (true) {
				if (!(i < length)) { break; }
				if (10 === ((i < 0 || i >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + i])) {
					break;
				}
				i = i + (1) >> 0;
			}
			codeBlock.Tokens = $subslice(content, (i + 1 >> 0));
		} else {
			codeBlock.Tokens = lex.ReplaceNewlineSpace(codeBlock.Tokens);
		}
	};
	Tree.ptr.prototype.parseFencedCode = function() {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, codeBlockInfo, fenceChar, fenceLen, fenceOffset, i, info, infoTokens, marker, ok, openFence, t, x, x$1, x$2;
		ok = false;
		fenceChar = 0;
		fenceLen = 0;
		fenceOffset = 0;
		openFence = sliceType.nil;
		codeBlockInfo = sliceType.nil;
		t = this;
		marker = (x = t.Context.currentLine, x$1 = t.Context.nextNonspace, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (!((96 === marker)) && !((126 === marker))) {
			return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
		}
		fenceChar = marker;
		i = t.Context.nextNonspace;
		while (true) {
			if (!(i < t.Context.currentLineLen && (fenceChar === (x$2 = t.Context.currentLine, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]))))) { break; }
			fenceLen = fenceLen + (1) >> 0;
			i = i + (1) >> 0;
		}
		if (3 > fenceLen) {
			return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
		}
		openFence = $subslice(t.Context.currentLine, t.Context.nextNonspace, (t.Context.nextNonspace + fenceLen >> 0));
		info = sliceType.nil;
		infoTokens = $subslice(t.Context.currentLine, (t.Context.nextNonspace + fenceLen >> 0));
		if ((96 === marker) && bytes.Contains(infoTokens, codeBlockBacktick)) {
			return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
		}
		info = lex.TrimWhitespace(infoTokens);
		info = util.UnescapeString(info);
		_tmp = true;
		_tmp$1 = fenceChar;
		_tmp$2 = fenceLen;
		_tmp$3 = t.Context.indent;
		_tmp$4 = openFence;
		_tmp$5 = info;
		ok = _tmp;
		fenceChar = _tmp$1;
		fenceLen = _tmp$2;
		fenceOffset = _tmp$3;
		openFence = _tmp$4;
		codeBlockInfo = _tmp$5;
		return [ok, fenceChar, fenceLen, fenceOffset, openFence, codeBlockInfo];
	};
	Tree.prototype.parseFencedCode = function() { return this.$val.parseFencedCode(); };
	Context.ptr.prototype.isFencedCodeClose = function(tokens, openMarker, num) {
		var _i, _ref, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, closeFence, closeMarker, context, num, ok, openMarker, token, tokens;
		ok = false;
		closeFence = sliceType.nil;
		context = this;
		closeMarker = (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]);
		if (!((closeMarker === openMarker))) {
			_tmp = false;
			_tmp$1 = sliceType.nil;
			ok = _tmp;
			closeFence = _tmp$1;
			return [ok, closeFence];
		}
		if (num > lex.Accept(tokens, closeMarker)) {
			_tmp$2 = false;
			_tmp$3 = sliceType.nil;
			ok = _tmp$2;
			closeFence = _tmp$3;
			return [ok, closeFence];
		}
		tokens = lex.TrimWhitespace(tokens);
		if (context.Option.VditorWYSIWYG) {
			tokens = bytes.ReplaceAll(tokens, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
		}
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((token === openMarker))) {
				_tmp$4 = false;
				_tmp$5 = sliceType.nil;
				ok = _tmp$4;
				closeFence = _tmp$5;
				return [ok, closeFence];
			}
			_i++;
		}
		closeFence = tokens;
		_tmp$6 = true;
		_tmp$7 = closeFence;
		ok = _tmp$6;
		closeFence = _tmp$7;
		return [ok, closeFence];
	};
	Context.prototype.isFencedCodeClose = function(tokens, openMarker, num) { return this.$val.isFencedCodeClose(tokens, openMarker, num); };
	Tree.ptr.prototype.parseCodeSpan = function(block, ctx) {
		var backticks, block, closeMarker, ctx, endPos, n, openMarker, ret, startPos, t, textTokens, x, x$1, x$2;
		ret = ptrType.nil;
		t = this;
		startPos = ctx.pos;
		n = 0;
		while (true) {
			if (!((startPos + n >> 0) < ctx.tokensLen)) { break; }
			if (!((96 === (x = ctx.tokens, x$1 = startPos + n >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]))))) {
				break;
			}
			n = n + (1) >> 0;
		}
		backticks = $subslice(ctx.tokens, startPos, (startPos + n >> 0));
		if (ctx.tokensLen <= (startPos + n >> 0)) {
			ctx.pos = ctx.pos + (n) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, backticks, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		openMarker = new ast.Node.ptr(28, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, backticks, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		endPos = t.matchCodeSpanEnd($subslice(ctx.tokens, (startPos + n >> 0)), n);
		if (1 > endPos) {
			ctx.pos = ctx.pos + (n) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, backticks, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		endPos = (startPos + endPos >> 0) + n >> 0;
		closeMarker = new ast.Node.ptr(30, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(ctx.tokens, endPos, (endPos + n >> 0)), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		textTokens = $subslice(ctx.tokens, (startPos + n >> 0), endPos);
		textTokens = lex.ReplaceAll(textTokens, 10, 32);
		if (2 < textTokens.$length && (32 === (0 >= textTokens.$length ? ($throwRuntimeError("index out of range"), undefined) : textTokens.$array[textTokens.$offset + 0])) && (32 === (x$2 = textTokens.$length - 1 >> 0, ((x$2 < 0 || x$2 >= textTokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : textTokens.$array[textTokens.$offset + x$2]))) && !lex.IsBlankLine(textTokens)) {
			openMarker.Tokens = $append(openMarker.Tokens, (0 >= textTokens.$length ? ($throwRuntimeError("index out of range"), undefined) : textTokens.$array[textTokens.$offset + 0]));
			closeMarker.Tokens = $subslice(ctx.tokens, (endPos - 1 >> 0), (endPos + n >> 0));
			textTokens = $subslice(textTokens, 1, (textTokens.$length - 1 >> 0));
		}
		if (t.Context.Option.GFMTable) {
			if (109 === block.Type) {
				textTokens = bytes.ReplaceAll(textTokens, (new sliceType($stringToBytes("\\|"))), (new sliceType($stringToBytes("|"))));
			}
		}
		ret = new ast.Node.ptr(27, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, n, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		ret.AppendChild(openMarker);
		ret.AppendChild(new ast.Node.ptr(29, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, textTokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		ret.AppendChild(closeMarker);
		ctx.pos = endPos + n >> 0;
		return ret;
	};
	Tree.prototype.parseCodeSpan = function(block, ctx) { return this.$val.parseCodeSpan(block, ctx); };
	Tree.ptr.prototype.matchCodeSpanEnd = function(tokens, num) {
		var l, length, next, num, pos, t, tokens;
		pos = 0;
		t = this;
		length = tokens.$length;
		while (true) {
			if (!(pos < length)) { break; }
			l = lex.Accept($subslice(tokens, pos), 96);
			if (num === l) {
				next = pos + l >> 0;
				if ((length - 1 >> 0) > next && (96 === ((next < 0 || next >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + next]))) {
					continue;
				}
				pos = pos;
				return pos;
			}
			if (0 < l) {
				pos = pos + (l) >> 0;
			} else {
				pos = pos + (1) >> 0;
			}
		}
		pos = -1;
		return pos;
	};
	Tree.prototype.matchCodeSpanEnd = function(tokens, num) { return this.$val.matchCodeSpanEnd(tokens, num); };
	Tree.ptr.prototype.handleDelim = function(block, ctx) {
		var block, ctx, delim, node, startPos, t, text;
		t = this;
		startPos = ctx.pos;
		delim = t.scanDelims(ctx);
		text = $subslice(ctx.tokens, startPos, ctx.pos);
		node = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, text, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		block.AppendChild(node);
		if (delim.canOpen || delim.canClose) {
			ctx.delimiters = new delimiter.ptr(node, delim.typ, delim.num, delim.num, delim.canOpen, delim.canClose, ctx.delimiters, ptrType$2.nil, false, false, false, 0, ptrType$2.nil);
			if (!(ptrType$2.nil === ctx.delimiters.previous)) {
				ctx.delimiters.previous.next = ctx.delimiters;
			}
		}
	};
	Tree.prototype.handleDelim = function(block, ctx) { return this.$val.handleDelim(block, ctx); };
	Tree.ptr.prototype.processEmphasis = function(stackBottom, ctx) {
		var _entry, _key, _key$1, _key$2, _key$3, _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, closeMarker, closer, closerInl, closerTokens, closercc, ctx, emStrongDel, next, oddMatch, oldCloser, openMarker, opener, openerFound, openerInl, openerTokens, openersBottom, stackBottom, t, tempStack, text, tmp, useDelims;
		t = this;
		if (ptrType$2.nil === ctx.delimiters) {
			return;
		}
		_tmp = ptrType$2.nil;
		_tmp$1 = ptrType$2.nil;
		_tmp$2 = ptrType$2.nil;
		opener = _tmp;
		closer = _tmp$1;
		oldCloser = _tmp$2;
		_tmp$3 = ptrType.nil;
		_tmp$4 = ptrType.nil;
		openerInl = _tmp$3;
		closerInl = _tmp$4;
		tempStack = ptrType$2.nil;
		useDelims = 0;
		openerFound = false;
		openersBottom = $makeMap($Uint8.keyFor, []);
		oddMatch = false;
		_key = 95; (openersBottom || $throwRuntimeError("assignment to entry in nil map"))[$Uint8.keyFor(_key)] = { k: _key, v: stackBottom };
		_key$1 = 42; (openersBottom || $throwRuntimeError("assignment to entry in nil map"))[$Uint8.keyFor(_key$1)] = { k: _key$1, v: stackBottom };
		_key$2 = 126; (openersBottom || $throwRuntimeError("assignment to entry in nil map"))[$Uint8.keyFor(_key$2)] = { k: _key$2, v: stackBottom };
		closer = ctx.delimiters;
		while (true) {
			if (!(!(ptrType$2.nil === closer) && !(closer.previous === stackBottom))) { break; }
			closer = closer.previous;
		}
		while (true) {
			if (!(!(ptrType$2.nil === closer))) { break; }
			closercc = closer.typ;
			if (!closer.canClose) {
				closer = closer.next;
				continue;
			}
			opener = closer.previous;
			openerFound = false;
			while (true) {
				if (!(!(ptrType$2.nil === opener) && !(opener === stackBottom) && !(opener === (_entry = openersBottom[$Uint8.keyFor(closercc)], _entry !== undefined ? _entry.v : ptrType$2.nil)))) { break; }
				oddMatch = (closer.canOpen || opener.canClose) && !(((_r = closer.originalNum % 3, _r === _r ? _r : $throwRuntimeError("integer divide by zero")) === 0)) && ((_r$1 = ((opener.originalNum + closer.originalNum >> 0)) % 3, _r$1 === _r$1 ? _r$1 : $throwRuntimeError("integer divide by zero")) === 0);
				if ((opener.typ === closer.typ) && opener.canOpen && !oddMatch) {
					openerFound = true;
					break;
				}
				opener = opener.previous;
			}
			oldCloser = closer;
			if (!openerFound) {
				closer = closer.next;
			} else {
				if (closer.num >= 2 && opener.num >= 2) {
					useDelims = 2;
				} else {
					useDelims = 1;
				}
				openerInl = opener.node;
				closerInl = closer.node;
				if (t.Context.Option.GFMStrikethrough && (126 === closercc) && !((opener.num === closer.num))) {
					break;
				}
				opener.num = opener.num - (useDelims) >> 0;
				closer.num = closer.num - (useDelims) >> 0;
				openerTokens = $subslice(openerInl.Tokens, (openerInl.Tokens.$length - useDelims >> 0));
				text = $subslice(openerInl.Tokens, 0, (openerInl.Tokens.$length - useDelims >> 0));
				openerInl.Tokens = text;
				closerTokens = $subslice(closerInl.Tokens, (closerInl.Tokens.$length - useDelims >> 0));
				text = $subslice(closerInl.Tokens, 0, (closerInl.Tokens.$length - useDelims >> 0));
				closerInl.Tokens = text;
				openMarker = new ast.Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, openerTokens, true, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				emStrongDel = new ast.Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, true, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				closeMarker = new ast.Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, closerTokens, true, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				if (1 === useDelims) {
					if (42 === closercc) {
						emStrongDel.Type = 17;
						openMarker.Type = 18;
						closeMarker.Type = 19;
					} else if (95 === closercc) {
						emStrongDel.Type = 17;
						openMarker.Type = 20;
						closeMarker.Type = 21;
					} else if (126 === closercc) {
						if (t.Context.Option.GFMStrikethrough) {
							emStrongDel.Type = 101;
							openMarker.Type = 102;
							closeMarker.Type = 103;
						}
					}
				} else {
					if (42 === closercc) {
						emStrongDel.Type = 22;
						openMarker.Type = 23;
						closeMarker.Type = 24;
					} else if (95 === closercc) {
						emStrongDel.Type = 22;
						openMarker.Type = 25;
						closeMarker.Type = 26;
					} else if (126 === closercc) {
						if (t.Context.Option.GFMStrikethrough) {
							emStrongDel.Type = 101;
							openMarker.Type = 104;
							closeMarker.Type = 105;
						}
					}
				}
				tmp = openerInl.Next;
				while (true) {
					if (!(!(ptrType.nil === tmp) && !(tmp === closerInl))) { break; }
					next = tmp.Next;
					tmp.Unlink();
					emStrongDel.AppendChild(tmp);
					tmp = next;
				}
				emStrongDel.PrependChild(openMarker);
				emStrongDel.AppendChild(closeMarker);
				openerInl.InsertAfter(emStrongDel);
				if (!(opener.next === closer)) {
					opener.next = closer;
					closer.previous = opener;
				}
				if (opener.num === 0) {
					openerInl.Unlink();
					t.removeDelimiter(opener, ctx);
				}
				if (closer.num === 0) {
					closerInl.Unlink();
					tempStack = closer.next;
					t.removeDelimiter(closer, ctx);
					closer = tempStack;
				}
			}
			if (!openerFound && !oddMatch) {
				_key$3 = closercc; (openersBottom || $throwRuntimeError("assignment to entry in nil map"))[$Uint8.keyFor(_key$3)] = { k: _key$3, v: oldCloser.previous };
				if (!oldCloser.canOpen) {
					t.removeDelimiter(oldCloser, ctx);
				}
			}
		}
		while (true) {
			if (!(!(ptrType$2.nil === ctx.delimiters) && !(ctx.delimiters === stackBottom))) { break; }
			t.removeDelimiter(ctx.delimiters, ctx);
		}
	};
	Tree.prototype.processEmphasis = function(stackBottom, ctx) { return this.$val.processEmphasis(stackBottom, ctx); };
	Tree.ptr.prototype.scanDelims = function(ctx) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, afterIsPunct, afterIsWhitespace, beforeIsPunct, beforeIsWhitespace, canClose, canOpen, ctx, delimitersCount, i, isLeftFlanking, isRightFlanking, startPos, t, t$1, t$2, token, tokenAfter, tokenBefore, x, x$1, x$2, x$3, x$4, x$5;
		t = this;
		startPos = ctx.pos;
		token = (x = ctx.tokens, ((startPos < 0 || startPos >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + startPos]));
		delimitersCount = 0;
		i = ctx.pos;
		while (true) {
			if (!(i < ctx.tokensLen && (token === (x$1 = ctx.tokens, ((i < 0 || i >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + i]))))) { break; }
			delimitersCount = delimitersCount + (1) >> 0;
			ctx.pos = ctx.pos + (1) >> 0;
			i = i + (1) >> 0;
		}
		_tmp = 10;
		_tmp$1 = 10;
		tokenBefore = _tmp;
		tokenAfter = _tmp$1;
		if (0 < startPos) {
			t$1 = (x$2 = ctx.tokens, x$3 = startPos - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
			if (t$1 >= 128) {
				_tuple = utf8.DecodeLastRune($subslice(ctx.tokens, 0, startPos));
				tokenBefore = _tuple[0];
			} else {
				tokenBefore = ((t$1 >> 0));
			}
		}
		if (ctx.tokensLen > ctx.pos) {
			t$2 = (x$4 = ctx.tokens, x$5 = ctx.pos, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5]));
			if (t$2 >= 128) {
				_tuple$1 = utf8.DecodeRune($subslice(ctx.tokens, ctx.pos));
				tokenAfter = _tuple$1[0];
			} else {
				tokenAfter = ((t$2 >> 0));
			}
		}
		afterIsWhitespace = lex.IsUnicodeWhitespace(tokenAfter);
		afterIsPunct = unicode.IsPunct(tokenAfter) || unicode.IsSymbol(tokenAfter);
		if (((42 === token) && (126 === tokenAfter)) || ((126 === token) && (42 === tokenAfter))) {
			afterIsPunct = false;
		}
		beforeIsWhitespace = lex.IsUnicodeWhitespace(tokenBefore);
		beforeIsPunct = unicode.IsPunct(tokenBefore) || unicode.IsSymbol(tokenBefore);
		if (((42 === token) && (126 === tokenBefore)) || ((126 === token) && (42 === tokenBefore))) {
			beforeIsPunct = false;
		}
		if (t.Context.Option.VditorWYSIWYG) {
			if ("\xE2\x80\xB8" === ($encodeRune(tokenBefore))) {
				beforeIsPunct = false;
			}
		}
		isLeftFlanking = !afterIsWhitespace && (!afterIsPunct || beforeIsWhitespace || beforeIsPunct);
		isRightFlanking = !beforeIsWhitespace && (!beforeIsPunct || afterIsWhitespace || afterIsPunct);
		_tmp$2 = false;
		_tmp$3 = false;
		canOpen = _tmp$2;
		canClose = _tmp$3;
		if (95 === token) {
			canOpen = isLeftFlanking && (!isRightFlanking || beforeIsPunct);
			canClose = isRightFlanking && (!isLeftFlanking || afterIsPunct);
		} else {
			canOpen = isLeftFlanking;
			canClose = isRightFlanking;
		}
		return new delimiter.ptr(ptrType.nil, token, delimitersCount, 0, canOpen, canClose, ptrType$2.nil, ptrType$2.nil, true, false, false, 0, ptrType$2.nil);
	};
	Tree.prototype.scanDelims = function(ctx) { return this.$val.scanDelims(ctx); };
	Tree.ptr.prototype.removeDelimiter = function(delim, ctx) {
		var ctx, delim, ret, t;
		ret = ptrType$2.nil;
		t = this;
		if (!(ptrType$2.nil === delim.previous)) {
			delim.previous.next = delim.next;
		}
		if (ptrType$2.nil === delim.next) {
			ctx.delimiters = delim.previous;
		} else {
			delim.next.previous = delim.previous;
		}
		return ret;
	};
	Tree.prototype.removeDelimiter = function(delim, ctx) { return this.$val.removeDelimiter(delim, ctx); };
	Tree.ptr.prototype.emoji = function(node) {
		var child, next, node, t;
		t = this;
		child = node.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			next = child.Next;
			if (16 === child.Type) {
				t.emoji0(child);
			} else {
				t.emoji(child);
			}
			child = next;
		}
	};
	Tree.prototype.emoji = function(node) { return this.$val.emoji(node); };
	Tree.ptr.prototype.emoji0 = function(node) {
		var _entry, _tuple, alias, alias$1, emoji, emojiNode, emojiTokens, emojiUnicodeOrImg, first, i, length, matchCloseColon, maybeEmoji, node, ok, pos, src, suffix, t, text, token, tokens;
		t = this;
		first = node;
		tokens = node.Tokens;
		node.Tokens = new sliceType([]);
		length = tokens.$length;
		token = 0;
		maybeEmoji = sliceType.nil;
		pos = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (i === (length - 1 >> 0)) {
				node.Tokens = $appendSlice(node.Tokens, $subslice(tokens, pos));
				break;
			}
			if (!((58 === token))) {
				i = i + (1) >> 0;
				continue;
			}
			node.Tokens = $appendSlice(node.Tokens, $subslice(tokens, pos, i));
			matchCloseColon = false;
			pos = i + 1 >> 0;
			while (true) {
				if (!(pos < length)) { break; }
				token = ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]);
				if (lex.IsWhitespace(token)) {
					break;
				}
				if (58 === token) {
					matchCloseColon = true;
					break;
				}
				pos = pos + (1) >> 0;
			}
			if (!matchCloseColon) {
				node.Tokens = $appendSlice(node.Tokens, $subslice(tokens, i, pos));
				i = i + (1) >> 0;
				continue;
			}
			maybeEmoji = $subslice(tokens, (i + 1 >> 0), pos);
			if (1 > maybeEmoji.$length) {
				node.Tokens = $append(node.Tokens, ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]));
				i = i + (1) >> 0;
				continue;
			}
			_tuple = (_entry = t.Context.Option.AliasEmoji[$String.keyFor(util.BytesToStr(maybeEmoji))], _entry !== undefined ? [_entry.v, true] : ["", false]);
			emoji = _tuple[0];
			ok = _tuple[1];
			if (ok) {
				emojiNode = new ast.Node.ptr(200, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				emojiUnicodeOrImg = new ast.Node.ptr(201, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				emojiNode.AppendChild(emojiUnicodeOrImg);
				emojiTokens = util.StrToBytes(emoji);
				if (bytes.Contains(emojiTokens, $pkg.EmojiSitePlaceholder)) {
					alias = util.BytesToStr(maybeEmoji);
					suffix = ".png";
					if ("huaji" === alias) {
						suffix = ".gif";
					}
					src = t.Context.Option.EmojiSite + "/" + alias + suffix;
					emojiUnicodeOrImg.Type = 202;
					emojiUnicodeOrImg.Tokens = t.EmojiImgTokens(alias, src);
				} else if (bytes.Contains(emojiTokens, emojiDot)) {
					alias$1 = util.BytesToStr(maybeEmoji);
					emojiUnicodeOrImg.Type = 202;
					emojiUnicodeOrImg.Tokens = t.EmojiImgTokens(alias$1, emoji);
				} else {
					emojiUnicodeOrImg.Tokens = emojiTokens;
				}
				emojiUnicodeOrImg.AppendChild(new ast.Node.ptr(203, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(tokens, i, (pos + 1 >> 0)), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
				node.InsertAfter(emojiNode);
				if ((pos + 1 >> 0) < length) {
					text = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, new sliceType([]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
					emojiNode.InsertAfter(text);
					node = text;
				}
			} else {
				node.Tokens = $appendSlice(node.Tokens, $subslice(tokens, i, (pos + 1 >> 0)));
			}
			pos = pos + (1) >> 0;
			i = pos;
		}
		if (1 > first.Tokens.$length) {
			first.Unlink();
		}
		if (1 > node.Tokens.$length) {
			node.Unlink();
		}
	};
	Tree.prototype.emoji0 = function(node) { return this.$val.emoji0(node); };
	Tree.ptr.prototype.EmojiImgTokens = function(alias, src) {
		var alias, src, t;
		t = this;
		return util.StrToBytes("<img alt=\"" + alias + "\" class=\"emoji\" src=\"" + src + "\" title=\"" + alias + "\" />");
	};
	Tree.prototype.EmojiImgTokens = function(alias, src) { return this.$val.EmojiImgTokens(alias, src); };
	NewEmojis = function() {
		var _entry, _i, _key, _key$1, _keys, _ref, aliasEmoji, emojiAlias, k, v, x, x$1;
		emojiAlias = false;
		aliasEmoji = false;
		emojiAlias = (x = $keys(aliasUnicodeEmojiMap).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		aliasEmoji = (x$1 = $keys(aliasUnicodeEmojiMap).length, ((x$1 < 0 || x$1 > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		_ref = aliasUnicodeEmojiMap;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = k; (emojiAlias || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_key$1 = v; (aliasEmoji || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: k };
			_i++;
		}
		return [emojiAlias, aliasEmoji];
	};
	$pkg.NewEmojis = NewEmojis;
	init = function() {
		var _entry, _i, _key, _keys, _ref, k, v, x;
		unicodeAliasEmojiMap = (x = $keys(aliasUnicodeEmojiMap).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		_ref = aliasUnicodeEmojiMap;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = v; (unicodeAliasEmojiMap || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: k };
			_i++;
		}
	};
	FootnotesContinue = function(footnotesDef, context) {
		var context, footnotesDef;
		if (context.blank) {
			return 0;
		}
		if (4 > context.indent) {
			return 1;
		}
		context.advanceOffset(4, true);
		return 0;
	};
	$pkg.FootnotesContinue = FootnotesContinue;
	Context.ptr.prototype.FindFootnotesDef = function(label) {
		var _i, _ref, context, i, label, n;
		context = this;
		_ref = context.FootnotesDefs;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (bytes.EqualFold(label, n.Tokens)) {
				return [i + 1 >> 0, n];
			}
			_i++;
		}
		return [-1, ptrType.nil];
	};
	Context.prototype.FindFootnotesDef = function(label) { return this.$val.FindFootnotesDef(label); };
	Tree.ptr.prototype.parseATXHeading = function() {
		var _i, _ref, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, closingCrosshatchIndex, content, endCaret, id, inCaret, level, marker, markers$1, ok, startCaret, t, token, tokens;
		ok = false;
		markers$1 = sliceType.nil;
		content = sliceType.nil;
		level = 0;
		id = sliceType.nil;
		t = this;
		tokens = $subslice(t.Context.currentLine, t.Context.nextNonspace);
		startCaret = false;
		if (t.Context.Option.VditorWYSIWYG && bytes.HasPrefix(tokens, (new sliceType($stringToBytes("\xE2\x80\xB8"))))) {
			tokens = bytes.ReplaceAll(tokens, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
			startCaret = true;
		}
		marker = (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]);
		if (!((35 === marker))) {
			return [ok, markers$1, content, level, id];
		}
		inCaret = false;
		if (t.Context.Option.VditorWYSIWYG && bytes.Contains(tokens, (new sliceType($stringToBytes("#\xE2\x80\xB8#"))))) {
			tokens = bytes.ReplaceAll(tokens, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
			inCaret = true;
		}
		level = lex.Accept(tokens, 35);
		if (6 < level) {
			return [ok, markers$1, content, level, id];
		}
		endCaret = false;
		if (t.Context.Option.VditorWYSIWYG && bytes.HasPrefix($subslice(tokens, level), (new sliceType($stringToBytes("\xE2\x80\xB8"))))) {
			tokens = bytes.ReplaceAll(tokens, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
			endCaret = true;
		}
		if (level < tokens.$length && !lex.IsWhitespace(((level < 0 || level >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + level]))) {
			return [ok, markers$1, content, level, id];
		}
		markers$1 = $subslice(t.Context.currentLine, t.Context.nextNonspace, ((t.Context.nextNonspace + level >> 0) + 1 >> 0));
		content = $makeSlice(sliceType, 0, 256);
		_tuple = lex.TrimLeft(tokens);
		tokens = _tuple[1];
		_tuple$1 = lex.TrimLeft($subslice(tokens, level));
		tokens = _tuple$1[1];
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (10 === token) {
				break;
			}
			content = $append(content, token);
			_i++;
		}
		_tuple$2 = lex.TrimRight(content);
		content = _tuple$2[1];
		closingCrosshatchIndex = content.$length - 1 >> 0;
		while (true) {
			if (!(0 <= closingCrosshatchIndex)) { break; }
			if (35 === ((closingCrosshatchIndex < 0 || closingCrosshatchIndex >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + closingCrosshatchIndex])) {
				closingCrosshatchIndex = closingCrosshatchIndex - (1) >> 0;
				continue;
			}
			if (32 === ((closingCrosshatchIndex < 0 || closingCrosshatchIndex >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + closingCrosshatchIndex])) {
				break;
			} else {
				closingCrosshatchIndex = content.$length;
				break;
			}
			closingCrosshatchIndex = closingCrosshatchIndex - (1) >> 0;
		}
		if (0 >= closingCrosshatchIndex) {
			content = $makeSlice(sliceType, 0, 0);
		} else if (0 < closingCrosshatchIndex) {
			content = $subslice(content, 0, closingCrosshatchIndex);
			_tuple$3 = lex.TrimRight(content);
			content = _tuple$3[1];
		}
		if (t.Context.Option.VditorWYSIWYG) {
			if (startCaret || inCaret || endCaret) {
				content = $appendSlice((new sliceType($stringToBytes("\xE2\x80\xB8"))), content);
			}
			if ("\xE2\x80\xB8" === ($bytesToString(content)) || "" === ($bytesToString(content))) {
				return [ok, markers$1, content, level, id];
			}
		}
		if (t.Context.Option.HeadingID) {
			id = t.parseHeadingID(content);
			if (!(sliceType.nil === id)) {
				content = bytes.ReplaceAll(content, (new sliceType($stringToBytes("{" + util.BytesToStr(id) + "}"))), sliceType.nil);
				_tuple$4 = lex.TrimRight(content);
				content = _tuple$4[1];
			}
		}
		ok = true;
		return [ok, markers$1, content, level, id];
	};
	Tree.prototype.parseATXHeading = function() { return this.$val.parseATXHeading(); };
	Tree.ptr.prototype.parseSetextHeading = function() {
		var caretInLn, length, level, ln, marker, start, t, token;
		level = 0;
		t = this;
		ln = lex.TrimWhitespace(t.Context.currentLine);
		start = 0;
		marker = ((start < 0 || start >= ln.$length) ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + start]);
		if (!((61 === marker)) && !((45 === marker))) {
			return level;
		}
		caretInLn = false;
		if (t.Context.Option.VditorWYSIWYG) {
			if (bytes.Contains(ln, (new sliceType($stringToBytes("\xE2\x80\xB8"))))) {
				caretInLn = true;
				ln = bytes.ReplaceAll(ln, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
			}
		}
		length = ln.$length;
		while (true) {
			if (!(start < length)) { break; }
			token = ((start < 0 || start >= ln.$length) ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + start]);
			if (!((61 === token)) && !((45 === token))) {
				return level;
			}
			if (!((0 === marker))) {
				if (!((marker === token))) {
					return level;
				}
			} else {
				marker = token;
			}
			start = start + (1) >> 0;
		}
		level = 1;
		if (45 === marker) {
			level = 2;
		}
		if (t.Context.Option.VditorWYSIWYG && caretInLn) {
			t.Context.oldtip.Tokens = lex.TrimWhitespace(t.Context.oldtip.Tokens);
			t.Context.oldtip.AppendTokens((new sliceType($stringToBytes("\xE2\x80\xB8"))));
		}
		return level;
	};
	Tree.prototype.parseSetextHeading = function() { return this.$val.parseSetextHeading(); };
	Tree.ptr.prototype.parseHeadingID = function(content) {
		var content, curlyBracesStart, id, length, t, x;
		id = sliceType.nil;
		t = this;
		if (t.Context.Option.VditorWYSIWYG) {
			content = bytes.ReplaceAll(content, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
		}
		length = content.$length;
		if (3 > length) {
			id = sliceType.nil;
			return id;
		}
		if (!((125 === (x = length - 1 >> 0, ((x < 0 || x >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + x]))))) {
			id = sliceType.nil;
			return id;
		}
		curlyBracesStart = bytes.Index(content, (new sliceType($stringToBytes("{"))));
		if (1 > curlyBracesStart) {
			id = sliceType.nil;
			return id;
		}
		id = $subslice(content, (curlyBracesStart + 1 >> 0), (length - 1 >> 0));
		return id;
	};
	Tree.prototype.parseHeadingID = function(content) { return this.$val.parseHeadingID(content); };
	HtmlBlockContinue = function(html, context) {
		var context, html;
		if (context.blank && ((html.HtmlBlockType === 6) || (html.HtmlBlockType === 7))) {
			return 1;
		}
		return 0;
	};
	$pkg.HtmlBlockContinue = HtmlBlockContinue;
	htmlBlockFinalize = function(html) {
		var _tuple, html;
		_tuple = lex.TrimRight(lex.ReplaceNewlineSpace(html.Tokens));
		html.Tokens = _tuple[1];
	};
	Tree.ptr.prototype.isHTMLBlockClose = function(tokens, htmlType) {
		var _1, htmlType, i, i$1, i$2, length, pos, t, tokens, x, x$1, x$2, x$3;
		t = this;
		length = tokens.$length;
		_1 = htmlType;
		if (_1 === (1)) {
			pos = lex.AcceptTokenss(tokens, htmlBlockCloseTags1);
			if (0 <= pos) {
				return true;
			}
			return false;
		} else if (_1 === (2)) {
			i = 0;
			while (true) {
				if (!(i < (length - 3 >> 0))) { break; }
				if ((45 === ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i])) && (45 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) && (62 === (x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1])))) {
					return true;
				}
				i = i + (1) >> 0;
			}
		} else if (_1 === (3)) {
			i$1 = 0;
			while (true) {
				if (!(i$1 < (length - 2 >> 0))) { break; }
				if ((63 === ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1])) && (62 === (x$2 = i$1 + 1 >> 0, ((x$2 < 0 || x$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$2])))) {
					return true;
				}
				i$1 = i$1 + (1) >> 0;
			}
		} else if (_1 === (4)) {
			return bytes.Contains(tokens, htmlBlockGreater);
		} else if (_1 === (5)) {
			i$2 = 0;
			while (true) {
				if (!(i$2 < (length - 2 >> 0))) { break; }
				if ((93 === ((i$2 < 0 || i$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$2])) && (93 === (x$3 = i$2 + 1 >> 0, ((x$3 < 0 || x$3 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$3])))) {
					return true;
				}
				i$2 = i$2 + (1) >> 0;
			}
		}
		return false;
	};
	Tree.prototype.isHTMLBlockClose = function(tokens, htmlType) { return this.$val.isHTMLBlockClose(tokens, htmlType); };
	Tree.ptr.prototype.parseHTML = function(tokens) {
		var _tuple, following, isCloseTag, isOpenTag, length, pos, pos$1, t, tag, tokens, typ, x;
		typ = 0;
		t = this;
		_tuple = lex.TrimLeft(tokens);
		tokens = _tuple[1];
		length = tokens.$length;
		if (3 > length) {
			return typ;
		}
		if (!((60 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return typ;
		}
		typ = 1;
		pos = lex.AcceptTokenss(tokens, htmlBlockTags1);
		if (0 <= pos) {
			if (lex.IsWhitespace(((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos])) || (62 === ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos]))) {
				return typ;
			}
		}
		pos$1 = lex.AcceptTokenss(tokens, htmlBlockTags6);
		if (0 <= pos$1) {
			if (lex.IsWhitespace(((pos$1 < 0 || pos$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos$1])) || (62 === ((pos$1 < 0 || pos$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos$1]))) {
				typ = 6;
				return typ;
			}
			if ((47 === ((pos$1 < 0 || pos$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos$1])) && (62 === (x = pos$1 + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))) {
				typ = 6;
				return typ;
			}
		}
		tag = lex.TrimWhitespace(tokens);
		isOpenTag = t.isOpenTag(tag);
		if (isOpenTag && !((t.Context.Tip.Type === 1))) {
			typ = 7;
			return typ;
		}
		isCloseTag = t.isCloseTag(tag);
		if (isCloseTag && !((t.Context.Tip.Type === 1))) {
			typ = 7;
			return typ;
		}
		if (0 === bytes.Index(tokens, util.StrToBytes("<!--"))) {
			typ = 2;
			return typ;
		}
		if (0 === bytes.Index(tokens, util.StrToBytes("<?"))) {
			typ = 3;
			return typ;
		}
		if (2 < tokens.$length && (0 === bytes.Index(tokens, util.StrToBytes("<!")))) {
			following = $subslice(tokens, 2);
			if (65 <= (0 >= following.$length ? ($throwRuntimeError("index out of range"), undefined) : following.$array[following.$offset + 0]) && 90 >= (0 >= following.$length ? ($throwRuntimeError("index out of range"), undefined) : following.$array[following.$offset + 0])) {
				typ = 4;
				return typ;
			}
			if (0 === bytes.Index(following, util.StrToBytes("[CDATA["))) {
				typ = 5;
				return typ;
			}
		}
		typ = 0;
		return typ;
	};
	Tree.prototype.parseHTML = function(tokens) { return this.$val.parseHTML(tokens); };
	Tree.ptr.prototype.isOpenTag = function(tokens) {
		var _i, _i$1, _i$2, _ref, _ref$1, _ref$2, attr, attrs, isOpenTag, length, n, n$1, name, name$1, nameAndAttrs, nameAndValue, t, tokens, value, x, x$1;
		isOpenTag = false;
		t = this;
		length = tokens.$length;
		if (3 > length) {
			return isOpenTag;
		}
		if (!((60 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return isOpenTag;
		}
		if (!((62 === (x = length - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))))) {
			return isOpenTag;
		}
		if (47 === (x$1 = length - 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]))) {
			tokens = $subslice(tokens, 1, (length - 2 >> 0));
		} else {
			tokens = $subslice(tokens, 1, (length - 1 >> 0));
		}
		length = tokens.$length;
		if (0 === length) {
			return isOpenTag;
		}
		if (lex.IsWhitespace((0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) {
			return isOpenTag;
		}
		nameAndAttrs = lex.SplitWhitespace(tokens);
		name = (0 >= nameAndAttrs.$length ? ($throwRuntimeError("index out of range"), undefined) : nameAndAttrs.$array[nameAndAttrs.$offset + 0]);
		if (!lex.IsASCIILetter((0 >= name.$length ? ($throwRuntimeError("index out of range"), undefined) : name.$array[name.$offset + 0]))) {
			return isOpenTag;
		}
		if (1 < name.$length) {
			name = $subslice(name, 1);
			_ref = name;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (!lex.IsASCIILetterNumHyphen(n)) {
					return isOpenTag;
				}
				_i++;
			}
		}
		attrs = $subslice(nameAndAttrs, 1);
		_ref$1 = attrs;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			attr = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			if (1 >= attr.$length) {
				_i$1++;
				continue;
			}
			nameAndValue = lex.Split(attr, 61);
			name$1 = (0 >= nameAndValue.$length ? ($throwRuntimeError("index out of range"), undefined) : nameAndValue.$array[nameAndValue.$offset + 0]);
			if (1 > name$1.$length) {
				_i$1++;
				continue;
			}
			if (!lex.IsASCIILetter((0 >= name$1.$length ? ($throwRuntimeError("index out of range"), undefined) : name$1.$array[name$1.$offset + 0])) && !((95 === (0 >= name$1.$length ? ($throwRuntimeError("index out of range"), undefined) : name$1.$array[name$1.$offset + 0]))) && !((58 === (0 >= name$1.$length ? ($throwRuntimeError("index out of range"), undefined) : name$1.$array[name$1.$offset + 0])))) {
				return isOpenTag;
			}
			if (1 < name$1.$length) {
				name$1 = $subslice(name$1, 1);
				_ref$2 = name$1;
				_i$2 = 0;
				while (true) {
					if (!(_i$2 < _ref$2.$length)) { break; }
					n$1 = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
					if (!lex.IsASCIILetter(n$1) && !lex.IsDigit(n$1) && !((95 === n$1)) && !((46 === n$1)) && !((58 === n$1)) && !((45 === n$1))) {
						return isOpenTag;
					}
					_i$2++;
				}
			}
			if (1 < nameAndValue.$length) {
				value = (1 >= nameAndValue.$length ? ($throwRuntimeError("index out of range"), undefined) : nameAndValue.$array[nameAndValue.$offset + 1]);
				if (bytes.HasPrefix(value, htmlBlockSinglequote) && bytes.HasSuffix(value, htmlBlockSinglequote)) {
					value = $subslice(value, 1);
					value = $subslice(value, 0, (value.$length - 1 >> 0));
					isOpenTag = !bytes.Contains(value, htmlBlockSinglequote);
					return isOpenTag;
				}
				if (bytes.HasPrefix(value, htmlBlockDoublequote) && bytes.HasSuffix(value, htmlBlockDoublequote)) {
					value = $subslice(value, 1);
					value = $subslice(value, 0, (value.$length - 1 >> 0));
					isOpenTag = !bytes.Contains(value, htmlBlockDoublequote);
					return isOpenTag;
				}
				isOpenTag = !bytes.ContainsAny(value, " \t\n") && !bytes.ContainsAny(value, "\"'=<>`");
				return isOpenTag;
			}
			_i$1++;
		}
		isOpenTag = true;
		return isOpenTag;
	};
	Tree.prototype.isOpenTag = function(tokens) { return this.$val.isOpenTag(tokens); };
	Tree.ptr.prototype.isCloseTag = function(tokens) {
		var _i, _ref, length, n, name, t, tokens, x;
		t = this;
		tokens = lex.TrimWhitespace(tokens);
		length = tokens.$length;
		if (4 > length) {
			return false;
		}
		if (!((60 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((47 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1])))) {
			return false;
		}
		if (!((62 === (x = length - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))))) {
			return false;
		}
		tokens = $subslice(tokens, 2, (length - 1 >> 0));
		length = tokens.$length;
		if (0 === length) {
			return false;
		}
		name = $subslice(tokens, 0);
		if (!lex.IsASCIILetter((0 >= name.$length ? ($throwRuntimeError("index out of range"), undefined) : name.$array[name.$offset + 0]))) {
			return false;
		}
		if (1 < name.$length) {
			name = $subslice(name, 1);
			_ref = name;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				n = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (!lex.IsASCIILetterNumHyphen(n)) {
					return false;
				}
				_i++;
			}
		}
		return true;
	};
	Tree.prototype.isCloseTag = function(tokens) { return this.$val.isCloseTag(tokens); };
	Tree.ptr.prototype.parseBang = function(ctx) {
		var ctx, ret, startPos, t, x, x$1;
		ret = ptrType.nil;
		t = this;
		startPos = ctx.pos;
		ctx.pos = ctx.pos + (1) >> 0;
		if (ctx.pos < ctx.tokensLen && (91 === (x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])))) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(ctx.tokens, startPos, ctx.pos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			t.addBracket(ret, startPos + 2 >> 0, true, ctx);
			return ret;
		}
		ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(ctx.tokens, startPos, ctx.pos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		return ret;
	};
	Tree.prototype.parseBang = function(ctx) { return this.$val.parseBang(ctx); };
	Tree.ptr.prototype.parseInline = function(block, ctx) {
		var _1, _r, block, ctx, n, t, token, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; block = $f.block; ctx = $f.ctx; n = $f.n; t = $f.t; token = $f.token; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		/* while (true) { */ case 1:
			/* if (!(ctx.pos < ctx.tokensLen)) { break; } */ if(!(ctx.pos < ctx.tokensLen)) { $s = 2; continue; }
			token = (x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			n = ptrType.nil;
				_1 = token;
				/* */ if (_1 === (92)) { $s = 4; continue; }
				/* */ if (_1 === (96)) { $s = 5; continue; }
				/* */ if ((_1 === (42)) || (_1 === (95)) || (_1 === (126))) { $s = 6; continue; }
				/* */ if (_1 === (10)) { $s = 7; continue; }
				/* */ if (_1 === (60)) { $s = 8; continue; }
				/* */ if (_1 === (91)) { $s = 9; continue; }
				/* */ if (_1 === (93)) { $s = 10; continue; }
				/* */ if (_1 === (38)) { $s = 11; continue; }
				/* */ if (_1 === (33)) { $s = 12; continue; }
				/* */ if (_1 === (36)) { $s = 13; continue; }
				/* */ $s = 14; continue;
				/* if (_1 === (92)) { */ case 4:
					n = t.parseBackslash(block, ctx);
					$s = 15; continue;
				/* } else if (_1 === (96)) { */ case 5:
					n = t.parseCodeSpan(block, ctx);
					$s = 15; continue;
				/* } else if ((_1 === (42)) || (_1 === (95)) || (_1 === (126))) { */ case 6:
					t.handleDelim(block, ctx);
					$s = 15; continue;
				/* } else if (_1 === (10)) { */ case 7:
					n = t.parseNewline(block, ctx);
					$s = 15; continue;
				/* } else if (_1 === (60)) { */ case 8:
					n = t.parseAutolink(ctx);
					if (ptrType.nil === n) {
						n = t.parseAutoEmailLink(ctx);
						if (ptrType.nil === n) {
							n = t.parseInlineHTML(ctx);
						}
					}
					$s = 15; continue;
				/* } else if (_1 === (91)) { */ case 9:
					n = t.parseOpenBracket(ctx);
					$s = 15; continue;
				/* } else if (_1 === (93)) { */ case 10:
					_r = t.parseCloseBracket(ctx); /* */ $s = 16; case 16: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					n = _r;
					$s = 15; continue;
				/* } else if (_1 === (38)) { */ case 11:
					n = t.parseEntity(ctx);
					$s = 15; continue;
				/* } else if (_1 === (33)) { */ case 12:
					n = t.parseBang(ctx);
					$s = 15; continue;
				/* } else if (_1 === (36)) { */ case 13:
					n = t.parseInlineMath(ctx);
					$s = 15; continue;
				/* } else { */ case 14:
					n = t.parseText(ctx);
				/* } */ case 15:
			case 3:
			if (!(ptrType.nil === n)) {
				block.AppendChild(n);
			}
		/* } */ $s = 1; continue; case 2:
		block.Tokens = sliceType.nil;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.parseInline }; } $f._1 = _1; $f._r = _r; $f.block = block; $f.ctx = ctx; $f.n = n; $f.t = t; $f.token = token; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.parseInline = function(block, ctx) { return this.$val.parseInline(block, ctx); };
	Tree.ptr.prototype.parseEntity = function(ctx) {
		var and, ctx, endWithSemicolon, entityName, entityNameLen, i, numeric, ret, start, t, token, v, x, x$1, x$2, x$3, x$4;
		ret = ptrType.nil;
		t = this;
		and = new sliceType([(x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]))]);
		if (2 > ctx.tokensLen || ctx.tokensLen <= (ctx.pos + 1 >> 0)) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		start = ctx.pos;
		numeric = false;
		if (3 < ctx.tokensLen) {
			numeric = 35 === (x$2 = ctx.tokens, x$3 = start + 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3]));
		}
		i = ctx.pos;
		token = 0;
		endWithSemicolon = false;
		while (true) {
			if (!(i < ctx.tokensLen)) { break; }
			token = (x$4 = ctx.tokens, ((i < 0 || i >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + i]));
			if (lex.IsWhitespace(token)) {
				break;
			}
			if (59 === token) {
				i = i + (1) >> 0;
				endWithSemicolon = true;
				break;
			}
			i = i + (1) >> 0;
		}
		if (!endWithSemicolon) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		entityName = util.BytesToStr($subslice(ctx.tokens, start, i));
		if (numeric) {
			entityNameLen = entityName.length;
			if (10 < entityNameLen || 4 > entityNameLen) {
				ctx.pos = ctx.pos + (1) >> 0;
				ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				return ret;
			}
			if (((120 === entityName.charCodeAt(2)) || (88 === entityName.charCodeAt(2))) && 5 > entityNameLen) {
				ctx.pos = ctx.pos + (1) >> 0;
				ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				return ret;
			}
		}
		v = util.HtmlUnescapeString(entityName);
		if (v === entityName) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, and, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		ctx.pos = ctx.pos + ((i - start >> 0)) >> 0;
		ret = new ast.Node.ptr(44, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, util.StrToBytes(v), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, util.StrToBytes(entityName));
		return ret;
	};
	Tree.prototype.parseEntity = function(ctx) { return this.$val.parseEntity(ctx); };
	Tree.ptr.prototype.parseCloseBracket = function(ctx) {
		var _entry, _r, _r$1, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tmp$8, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, beforelabel, closeBracket, closeParen, ctx, dest, footnotesDef, idx, isImage, isLink, label, link, linkType, matched, n, next, node, openParen, opener, passed, ref, refId, reflabel, refsLen, remains, savepos, space, start, startPos, t, title, titleNode, tmp, validTitle, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _r$1 = $f._r$1; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tmp$6 = $f._tmp$6; _tmp$7 = $f._tmp$7; _tmp$8 = $f._tmp$8; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; beforelabel = $f.beforelabel; closeBracket = $f.closeBracket; closeParen = $f.closeParen; ctx = $f.ctx; dest = $f.dest; footnotesDef = $f.footnotesDef; idx = $f.idx; isImage = $f.isImage; isLink = $f.isLink; label = $f.label; link = $f.link; linkType = $f.linkType; matched = $f.matched; n = $f.n; next = $f.next; node = $f.node; openParen = $f.openParen; opener = $f.opener; passed = $f.passed; ref = $f.ref; refId = $f.refId; reflabel = $f.reflabel; refsLen = $f.refsLen; remains = $f.remains; savepos = $f.savepos; space = $f.space; start = $f.start; startPos = $f.startPos; t = $f.t; title = $f.title; titleNode = $f.titleNode; tmp = $f.tmp; validTitle = $f.validTitle; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		closeBracket = new sliceType([(x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]))]);
		ctx.pos = ctx.pos + (1) >> 0;
		startPos = ctx.pos;
		opener = ctx.brackets;
		if (ptrType$2.nil === opener) {
			$s = -1; return new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, closeBracket, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		}
		if (!opener.active) {
			t.removeBracket(ctx);
			$s = -1; return new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, closeBracket, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		}
		isImage = opener.image;
		_tmp = sliceType.nil;
		_tmp$1 = sliceType.nil;
		_tmp$2 = sliceType.nil;
		_tmp$3 = sliceType.nil;
		_tmp$4 = sliceType.nil;
		openParen = _tmp;
		dest = _tmp$1;
		space = _tmp$2;
		title = _tmp$3;
		closeParen = _tmp$4;
		savepos = ctx.pos;
		matched = false;
		if ((ctx.pos + 1 >> 0) < ctx.tokensLen && (40 === (x$2 = ctx.tokens, x$3 = ctx.pos, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])))) {
			ctx.pos = ctx.pos + (1) >> 0;
			isLink = false;
			_tmp$5 = sliceType.nil;
			_tmp$6 = sliceType.nil;
			passed = _tmp$5;
			remains = _tmp$6;
			while (true) {
				_tuple = lex.Spnl($subslice(ctx.tokens, (ctx.pos - 1 >> 0)));
				isLink = _tuple[0];
				passed = _tuple[1];
				remains = _tuple[2];
				if (!isLink) {
					break;
				}
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				_tuple$1 = t.Context.parseInlineLinkDest(remains);
				passed = _tuple$1[0];
				remains = _tuple$1[1];
				dest = _tuple$1[2];
				if (sliceType.nil === passed) {
					break;
				}
				if (t.Context.Option.VditorWYSIWYG) {
					if (!isImage && ptrType.nil === opener.node.Next) {
						break;
					}
				}
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				openParen = $subslice(passed, 0, 1);
				closeParen = $subslice(passed, (passed.$length - 1 >> 0));
				matched = 41 === (x$4 = passed.$length - 1 >> 0, ((x$4 < 0 || x$4 >= passed.$length) ? ($throwRuntimeError("index out of range"), undefined) : passed.$array[passed.$offset + x$4]));
				if (matched) {
					ctx.pos = ctx.pos - (1) >> 0;
					break;
				}
				if (1 > remains.$length || !lex.IsWhitespace((0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0]))) {
					break;
				}
				_tuple$2 = lex.Spnl(remains);
				isLink = _tuple$2[0];
				passed = _tuple$2[1];
				remains = _tuple$2[2];
				if (!isLink) {
					break;
				}
				space = passed;
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				matched = 41 === (0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0]);
				closeParen = $subslice(remains, 0, 1);
				if (matched) {
					break;
				}
				ctx.pos = ctx.pos + (1) >> 0;
				validTitle = false;
				_tuple$3 = t.Context.parseLinkTitle(remains);
				validTitle = _tuple$3[0];
				passed = _tuple$3[1];
				remains = _tuple$3[2];
				title = _tuple$3[3];
				if (!validTitle) {
					break;
				}
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				_tuple$4 = lex.Spnl(remains);
				isLink = _tuple$4[0];
				passed = _tuple$4[1];
				remains = _tuple$4[2];
				ctx.pos = ctx.pos + (passed.$length) >> 0;
				matched = isLink && 0 < remains.$length;
				if (matched) {
					if (t.Context.Option.VditorWYSIWYG) {
						if (bytes.HasPrefix(remains, (new sliceType($stringToBytes("\xE2\x80\xB8)"))))) {
							if (0 < title.$length) {
								remains = $subslice(remains, (new sliceType($stringToBytes("\xE2\x80\xB8)"))).$length);
								remains = $appendSlice((new sliceType($stringToBytes(")\xE2\x80\xB8"))), remains);
								$copySlice($subslice(ctx.tokens, (ctx.pos - 1 >> 0)), remains);
							} else {
								title = (new sliceType($stringToBytes("\xE2\x80\xB8")));
								remains = $subslice(remains, (new sliceType($stringToBytes("\xE2\x80\xB8"))).$length);
								ctx.pos = ctx.pos + (3) >> 0;
							}
						} else if (bytes.HasPrefix(remains, (new sliceType($stringToBytes(")\xE2\x80\xB8"))))) {
							if (0 === title.$length) {
								title = (new sliceType($stringToBytes("\xE2\x80\xB8")));
								remains = bytes.ReplaceAll(remains, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
								ctx.pos = ctx.pos + (3) >> 0;
							}
						}
					}
					matched = 41 === (0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0]);
				}
				closeParen = $subslice(remains, 0);
				break;
			}
			if (!matched) {
				ctx.pos = savepos;
			}
		}
		reflabel = sliceType.nil;
		linkType = 0;
		/* */ if (!matched) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!matched) { */ case 1:
			beforelabel = ctx.pos;
			_tuple$5 = t.Context.parseLinkLabel($subslice(ctx.tokens, beforelabel));
			n = _tuple$5[0];
			label = _tuple$5[2];
			if (2 < n) {
				reflabel = label;
				ctx.pos = ctx.pos + (n) >> 0;
			} else if (!opener.bracketAfter) {
				start = opener.index;
				if (91 === (x$5 = ctx.tokens, ((start < 0 || start >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + start]))) {
					start = start + (1) >> 0;
				}
				reflabel = $subslice(ctx.tokens, start, (startPos - 1 >> 0));
				ctx.pos = ctx.pos + (2) >> 0;
			}
			if (0 === n) {
				ctx.pos = startPos;
			}
			/* */ if (!(sliceType.nil === reflabel)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (!(sliceType.nil === reflabel)) { */ case 3:
				/* */ if (t.Context.Option.Footnotes) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (t.Context.Option.Footnotes) { */ case 5:
					_tuple$6 = t.Context.FindFootnotesDef(reflabel);
					idx = _tuple$6[0];
					footnotesDef = _tuple$6[1];
					/* */ if (!(ptrType.nil === footnotesDef)) { $s = 7; continue; }
					/* */ $s = 8; continue;
					/* if (!(ptrType.nil === footnotesDef)) { */ case 7:
						t.removeBracket(ctx);
						opener.node.Next.Unlink();
						opener.node.Unlink();
						refId = strconv.Itoa(idx);
						refsLen = footnotesDef.FootnotesRefs.$length;
						if (0 < refsLen) {
							refId = refId + (":" + strconv.Itoa(refsLen + 1 >> 0));
						}
						_r = bytes.ToLower(reflabel); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						ref = new ast.Node.ptr(501, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, _r, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, reflabel, refId, sliceType$4.nil, sliceType.nil);
						footnotesDef.FootnotesRefs = $append(footnotesDef.FootnotesRefs, ref);
						$s = -1; return ref;
					/* } */ case 8:
				/* } */ case 6:
				_r$1 = strings.ToLower(util.BytesToStr(reflabel)); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				link = (_entry = t.Context.LinkRefDefs[$String.keyFor(_r$1)], _entry !== undefined ? _entry.v : ptrType.nil);
				if (!(ptrType.nil === link)) {
					dest = link.ChildByType(41).Tokens;
					titleNode = link.ChildByType(42);
					if (!(ptrType.nil === titleNode)) {
						title = titleNode.Tokens;
					}
					matched = true;
					linkType = 3;
				}
			/* } */ case 4:
		/* } */ case 2:
		if (matched) {
			node = new ast.Node.ptr(33, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, linkType, reflabel, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			if (isImage) {
				node.Type = 34;
				node.AppendChild(new ast.Node.ptr(35, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(opener.node.Tokens, 0, 1), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
				opener.node.Tokens = $subslice(opener.node.Tokens, 1);
			}
			node.AppendChild(new ast.Node.ptr(36, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, opener.node.Tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			_tmp$7 = ptrType.nil;
			_tmp$8 = ptrType.nil;
			tmp = _tmp$7;
			next = _tmp$8;
			tmp = opener.node.Next;
			while (true) {
				if (!(!(ptrType.nil === tmp))) { break; }
				next = tmp.Next;
				tmp.Unlink();
				if (16 === tmp.Type) {
					tmp.Type = 40;
				}
				node.AppendChild(tmp);
				tmp = next;
			}
			node.AppendChild(new ast.Node.ptr(37, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, closeBracket, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			node.AppendChild(new ast.Node.ptr(38, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, openParen, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			node.AppendChild(new ast.Node.ptr(41, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, dest, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			if (!(sliceType.nil === space)) {
				node.AppendChild(new ast.Node.ptr(43, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, space, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			}
			if (0 < title.$length) {
				node.AppendChild(new ast.Node.ptr(42, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, title, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			}
			node.AppendChild(new ast.Node.ptr(39, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, closeParen, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			t.processEmphasis(opener.previousDelimiter, ctx);
			t.removeBracket(ctx);
			opener.node.Unlink();
			if (!isImage) {
				opener = ctx.brackets;
				while (true) {
					if (!(!(ptrType$2.nil === opener))) { break; }
					if (!opener.image) {
						opener.active = false;
					}
					opener = opener.previous;
				}
			}
			$s = -1; return node;
		} else {
			t.removeBracket(ctx);
			ctx.pos = startPos;
			$s = -1; return new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, closeBracket, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		}
		$s = -1; return ptrType.nil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.parseCloseBracket }; } $f._entry = _entry; $f._r = _r; $f._r$1 = _r$1; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tmp$6 = _tmp$6; $f._tmp$7 = _tmp$7; $f._tmp$8 = _tmp$8; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f.beforelabel = beforelabel; $f.closeBracket = closeBracket; $f.closeParen = closeParen; $f.ctx = ctx; $f.dest = dest; $f.footnotesDef = footnotesDef; $f.idx = idx; $f.isImage = isImage; $f.isLink = isLink; $f.label = label; $f.link = link; $f.linkType = linkType; $f.matched = matched; $f.n = n; $f.next = next; $f.node = node; $f.openParen = openParen; $f.opener = opener; $f.passed = passed; $f.ref = ref; $f.refId = refId; $f.reflabel = reflabel; $f.refsLen = refsLen; $f.remains = remains; $f.savepos = savepos; $f.space = space; $f.start = start; $f.startPos = startPos; $f.t = t; $f.title = title; $f.titleNode = titleNode; $f.tmp = tmp; $f.validTitle = validTitle; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.parseCloseBracket = function(ctx) { return this.$val.parseCloseBracket(ctx); };
	Tree.ptr.prototype.parseOpenBracket = function(ctx) {
		var ctx, ret, startPos, t;
		ret = ptrType.nil;
		t = this;
		startPos = ctx.pos;
		ctx.pos = ctx.pos + (1) >> 0;
		ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(ctx.tokens, startPos, ctx.pos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		t.addBracket(ret, ctx.pos - 1 >> 0, false, ctx);
		return ret;
	};
	Tree.prototype.parseOpenBracket = function(ctx) { return this.$val.parseOpenBracket(ctx); };
	Tree.ptr.prototype.addBracket = function(node, index, image, ctx) {
		var ctx, image, index, node, t;
		t = this;
		if (!(ptrType$2.nil === ctx.brackets)) {
			ctx.brackets.bracketAfter = true;
		}
		ctx.brackets = new delimiter.ptr(node, 0, 0, 0, false, false, ctx.brackets, ptrType$2.nil, true, image, false, index, ctx.delimiters);
	};
	Tree.prototype.addBracket = function(node, index, image, ctx) { return this.$val.addBracket(node, index, image, ctx); };
	Tree.ptr.prototype.removeBracket = function(ctx) {
		var ctx, t;
		t = this;
		ctx.brackets = ctx.brackets.previous;
	};
	Tree.prototype.removeBracket = function(ctx) { return this.$val.removeBracket(ctx); };
	Tree.ptr.prototype.parseInlineHTML = function(ctx) {
		var _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, attr, cdata, comment, ctx, decl, ins, length, remains, remains$1, remains$2, remains$3, remains$4, remains$5, remains$6, ret, startPos, t, tagName, tagName$1, tags, tokens, valid, valid$1, valid$2, valid$3, valid$4, vditor, whitespaces, x, x$1, x$2;
		ret = ptrType.nil;
		t = this;
		tokens = ctx.tokens;
		startPos = ctx.pos;
		ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, new sliceType([(x = ctx.pos, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		if (3 > ctx.tokensLen || ctx.tokensLen <= (startPos + 1 >> 0)) {
			ctx.pos = ctx.pos + (1) >> 0;
			return ret;
		}
		tags = sliceType.nil;
		tags = $append(tags, ((startPos < 0 || startPos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + startPos]));
		if ((47 === (x$1 = startPos + 1 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]))) && 1 < (ctx.tokensLen - ((startPos + 1 >> 0)) >> 0)) {
			tags = $append(tags, (x$2 = startPos + 1 >> 0, ((x$2 < 0 || x$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$2])));
			_tuple = t.parseTagName($subslice(tokens, (ctx.pos + 2 >> 0)));
			remains = _tuple[0];
			tagName = _tuple[1];
			if (1 > tagName.$length) {
				ctx.pos = ctx.pos + (1) >> 0;
				return ret;
			}
			tags = $appendSlice(tags, tagName);
			tokens = remains;
		} else {
			_tuple$1 = t.parseTagName($subslice(tokens, (ctx.pos + 1 >> 0)));
			remains$1 = _tuple$1[0];
			tagName$1 = _tuple$1[1];
			if (0 < tagName$1.$length) {
				tags = $appendSlice(tags, tagName$1);
				tokens = remains$1;
				while (true) {
					_tuple$2 = t.parseTagAttr(tokens);
					valid = _tuple$2[0];
					remains$2 = _tuple$2[1];
					attr = _tuple$2[2];
					if (!valid) {
						ctx.pos = ctx.pos + (1) >> 0;
						return ret;
					}
					tokens = remains$2;
					tags = $appendSlice(tags, attr);
					if (1 > attr.$length) {
						break;
					}
				}
			} else {
				_tuple$3 = t.parseHTMLComment($subslice(tokens, (ctx.pos + 1 >> 0)));
				valid$1 = _tuple$3[0];
				remains$3 = _tuple$3[1];
				comment = _tuple$3[2];
				if (valid$1) {
					tags = $appendSlice(tags, comment);
					tokens = remains$3;
					ctx.pos = ctx.pos + (tags.$length) >> 0;
					ret = new ast.Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
					return ret;
				} else {
					_tuple$4 = t.parseProcessingInstruction($subslice(tokens, (ctx.pos + 1 >> 0)));
					valid$2 = _tuple$4[0];
					remains$4 = _tuple$4[1];
					ins = _tuple$4[2];
					if (valid$2) {
						tags = $appendSlice(tags, ins);
						tokens = remains$4;
						ctx.pos = ctx.pos + (tags.$length) >> 0;
						ret = new ast.Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
						return ret;
					} else {
						_tuple$5 = t.parseDeclaration($subslice(tokens, (ctx.pos + 1 >> 0)));
						valid$3 = _tuple$5[0];
						remains$5 = _tuple$5[1];
						decl = _tuple$5[2];
						if (valid$3) {
							tags = $appendSlice(tags, decl);
							tokens = remains$5;
							ctx.pos = ctx.pos + (tags.$length) >> 0;
							ret = new ast.Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
							return ret;
						} else {
							_tuple$6 = t.parseCDATA($subslice(tokens, (ctx.pos + 1 >> 0)));
							valid$4 = _tuple$6[0];
							remains$6 = _tuple$6[1];
							cdata = _tuple$6[2];
							if (valid$4) {
								tags = $appendSlice(tags, cdata);
								tokens = remains$6;
								ctx.pos = ctx.pos + (tags.$length) >> 0;
								ret = new ast.Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
								return ret;
							} else {
								ctx.pos = ctx.pos + (1) >> 0;
								return ret;
							}
						}
					}
				}
			}
		}
		length = tokens.$length;
		if (1 > length) {
			ctx.pos = startPos + 1 >> 0;
			return ret;
		}
		_tuple$7 = lex.TrimLeft(tokens);
		whitespaces = _tuple$7[0];
		tokens = _tuple$7[1];
		vditor = t.Context.Option.VditorWYSIWYG && bytes.HasPrefix(tokens, (new sliceType($stringToBytes("\xE2\x80\xB8")))) && (bytes.HasSuffix(tokens, (new sliceType($stringToBytes("/>")))) || bytes.HasSuffix(tokens, (new sliceType($stringToBytes(">")))));
		if (((62 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || (1 < ctx.tokensLen && (47 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) && (62 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) || vditor) {
			tags = $appendSlice(tags, whitespaces);
			if (vditor) {
				tags = $appendSlice(tags, $subslice(tokens, 0, (new sliceType($stringToBytes("\xE2\x80\xB8"))).$length));
				if (bytes.HasSuffix(tokens, (new sliceType($stringToBytes("/>"))))) {
					tags = $appendSlice(tags, (new sliceType($stringToBytes("/>"))));
				} else {
					tags = $appendSlice(tags, (new sliceType($stringToBytes(">"))));
				}
			} else {
				tags = $append(tags, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]));
			}
			if (47 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) {
				tags = $append(tags, (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]));
			}
			ctx.pos = ctx.pos + (tags.$length) >> 0;
			ret = new ast.Node.ptr(10, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tags, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		ctx.pos = startPos + 1 >> 0;
		return ret;
	};
	Tree.prototype.parseInlineHTML = function(ctx) { return this.$val.parseInlineHTML(ctx); };
	Tree.ptr.prototype.parseCDATA = function(tokens) {
		var content, i, length, remains, t, token, tokens, valid, x, x$1;
		valid = false;
		remains = sliceType.nil;
		content = sliceType.nil;
		t = this;
		remains = tokens;
		if (8 > tokens.$length) {
			return [valid, remains, content];
		}
		if (!((33 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [valid, remains, content];
		}
		if (!((91 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1])))) {
			return [valid, remains, content];
		}
		if (!((67 === (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2]))) || !((68 === (3 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 3]))) || !((65 === (4 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 4]))) || !((84 === (5 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 5]))) || !((65 === (6 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 6])))) {
			return [valid, remains, content];
		}
		if (!((91 === (7 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 7])))) {
			return [valid, remains, content];
		}
		content = $appendSlice(content, $subslice(tokens, 0, 7));
		tokens = $subslice(tokens, 7);
		token = 0;
		i = 0;
		length = tokens.$length;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			content = $append(content, token);
			if (i <= (length - 3 >> 0) && (93 === token) && (93 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) && (62 === (x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1])))) {
				break;
			}
			i = i + (1) >> 0;
		}
		tokens = $subslice(tokens, i);
		if (!((93 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((93 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) || !((62 === (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2])))) {
			return [valid, remains, content];
		}
		content = $append(content, (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]), (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2]));
		valid = true;
		remains = $subslice(tokens, 3);
		return [valid, remains, content];
	};
	Tree.prototype.parseCDATA = function(tokens) { return this.$val.parseCDATA(tokens); };
	Tree.ptr.prototype.parseDeclaration = function(tokens) {
		var _i, _ref, content, i, length, remains, t, token, tokens, valid;
		valid = false;
		remains = sliceType.nil;
		content = sliceType.nil;
		t = this;
		remains = tokens;
		if (2 > tokens.$length) {
			return [valid, remains, content];
		}
		if (!((33 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [valid, remains, content];
		}
		token = 0;
		i = 0;
		_ref = $subslice(tokens, 1);
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (lex.IsWhitespace(token)) {
				break;
			}
			if (!(65 <= token && 90 >= token)) {
				return [valid, remains, content];
			}
			_i++;
		}
		content = $append(content, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]), (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]));
		tokens = $subslice(tokens, 2);
		length = tokens.$length;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			content = $append(content, token);
			if (62 === token) {
				break;
			}
			i = i + (1) >> 0;
		}
		tokens = $subslice(tokens, i);
		if (!((62 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [valid, remains, content];
		}
		valid = true;
		remains = $subslice(tokens, 1);
		return [valid, remains, content];
	};
	Tree.prototype.parseDeclaration = function(tokens) { return this.$val.parseDeclaration(tokens); };
	Tree.ptr.prototype.parseProcessingInstruction = function(tokens) {
		var content, i, length, remains, t, token, tokens, valid, x;
		valid = false;
		remains = sliceType.nil;
		content = sliceType.nil;
		t = this;
		remains = tokens;
		if (!((63 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [valid, remains, content];
		}
		content = $append(content, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]));
		tokens = $subslice(tokens, 1);
		token = 0;
		i = 0;
		length = tokens.$length;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			content = $append(content, token);
			if (i <= (length - 2 >> 0) && (63 === token) && (62 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))) {
				break;
			}
			i = i + (1) >> 0;
		}
		tokens = $subslice(tokens, i);
		if (1 > tokens.$length) {
			return [valid, remains, content];
		}
		if (!((63 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((62 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1])))) {
			return [valid, remains, content];
		}
		content = $append(content, (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]));
		valid = true;
		remains = $subslice(tokens, 2);
		return [valid, remains, content];
	};
	Tree.prototype.parseProcessingInstruction = function(tokens) { return this.$val.parseProcessingInstruction(tokens); };
	Tree.ptr.prototype.parseHTMLComment = function(tokens) {
		var comment, i, length, remains, t, token, tokens, valid, x, x$1, x$2;
		valid = false;
		remains = sliceType.nil;
		comment = sliceType.nil;
		t = this;
		remains = tokens;
		if (3 > tokens.$length) {
			return [valid, remains, comment];
		}
		if (!((33 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((45 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) || !((45 === (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2])))) {
			return [valid, remains, comment];
		}
		comment = $append(comment, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]), (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]), (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2]));
		tokens = $subslice(tokens, 3);
		if (62 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) {
			return [valid, remains, comment];
		}
		if ((45 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) && (62 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) {
			return [valid, remains, comment];
		}
		token = 0;
		i = 0;
		length = tokens.$length;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			comment = $append(comment, token);
			if (i <= (length - 2 >> 0) && (45 === token) && (45 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))) {
				break;
			}
			if (i <= (length - 3 >> 0) && (45 === token) && (45 === (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]))) && (62 === (x$2 = i + 2 >> 0, ((x$2 < 0 || x$2 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$2])))) {
				break;
			}
			i = i + (1) >> 0;
		}
		tokens = $subslice(tokens, i);
		if (!((45 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) || !((45 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]))) || !((62 === (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2])))) {
			return [valid, remains, comment];
		}
		comment = $append(comment, (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]), (2 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 2]));
		valid = true;
		remains = $subslice(tokens, 3);
		return [valid, remains, comment];
	};
	Tree.prototype.parseHTMLComment = function(tokens) { return this.$val.parseHTMLComment(tokens); };
	Tree.ptr.prototype.parseTagAttr = function(tokens) {
		var _i, _ref, _tuple, _tuple$1, attr, attrName, i, remains, t, token, tokens, valSpec, valid, whitespaces;
		valid = false;
		remains = sliceType.nil;
		attr = sliceType.nil;
		t = this;
		valid = true;
		remains = tokens;
		whitespaces = sliceType.nil;
		i = 0;
		token = 0;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!lex.IsWhitespace(token)) {
				break;
			}
			whitespaces = $append(whitespaces, token);
			_i++;
		}
		if (1 > whitespaces.$length) {
			return [valid, remains, attr];
		}
		tokens = $subslice(tokens, i);
		attrName = sliceType.nil;
		_tuple = t.parseAttrName(tokens);
		tokens = _tuple[0];
		attrName = _tuple[1];
		if (1 > attrName.$length) {
			return [valid, remains, attr];
		}
		valSpec = sliceType.nil;
		_tuple$1 = t.parseAttrValSpec(tokens);
		valid = _tuple$1[0];
		tokens = _tuple$1[1];
		valSpec = _tuple$1[2];
		if (!valid) {
			return [valid, remains, attr];
		}
		remains = tokens;
		attr = $appendSlice(attr, whitespaces);
		attr = $appendSlice(attr, attrName);
		attr = $appendSlice(attr, valSpec);
		return [valid, remains, attr];
	};
	Tree.prototype.parseTagAttr = function(tokens) { return this.$val.parseTagAttr(tokens); };
	Tree.ptr.prototype.parseAttrValSpec = function(tokens) {
		var _i, _i$1, _i$2, _i$3, _i$4, _ref, _ref$1, _ref$2, _ref$3, _ref$4, closed, i, remains, t, token, tokens, valSpec, valid;
		valid = false;
		remains = sliceType.nil;
		valSpec = sliceType.nil;
		t = this;
		valid = true;
		remains = tokens;
		i = 0;
		token = 0;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!lex.IsWhitespace(token)) {
				break;
			}
			valSpec = $append(valSpec, token);
			_i++;
		}
		if (!((61 === token))) {
			valSpec = sliceType.nil;
			return [valid, remains, valSpec];
		}
		valSpec = $append(valSpec, token);
		tokens = $subslice(tokens, (i + 1 >> 0));
		_ref$1 = tokens;
		_i$1 = 0;
		while (true) {
			if (!(_i$1 < _ref$1.$length)) { break; }
			i = _i$1;
			token = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
			if (!lex.IsWhitespace(token)) {
				break;
			}
			valSpec = $append(valSpec, token);
			_i$1++;
		}
		token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
		valSpec = $append(valSpec, token);
		tokens = $subslice(tokens, (i + 1 >> 0));
		closed = false;
		if (34 === token) {
			_ref$2 = tokens;
			_i$2 = 0;
			while (true) {
				if (!(_i$2 < _ref$2.$length)) { break; }
				i = _i$2;
				token = ((_i$2 < 0 || _i$2 >= _ref$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$2.$array[_ref$2.$offset + _i$2]);
				valSpec = $append(valSpec, token);
				if (34 === token) {
					closed = true;
					break;
				}
				_i$2++;
			}
		} else if (39 === token) {
			_ref$3 = tokens;
			_i$3 = 0;
			while (true) {
				if (!(_i$3 < _ref$3.$length)) { break; }
				i = _i$3;
				token = ((_i$3 < 0 || _i$3 >= _ref$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$3.$array[_ref$3.$offset + _i$3]);
				valSpec = $append(valSpec, token);
				if (39 === token) {
					closed = true;
					break;
				}
				_i$3++;
			}
		} else {
			_ref$4 = tokens;
			_i$4 = 0;
			while (true) {
				if (!(_i$4 < _ref$4.$length)) { break; }
				i = _i$4;
				token = ((_i$4 < 0 || _i$4 >= _ref$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$4.$array[_ref$4.$offset + _i$4]);
				if (62 === token) {
					i = i - (1) >> 0;
					break;
				}
				valSpec = $append(valSpec, token);
				if (lex.IsWhitespace(token)) {
					break;
				}
				if ((34 === token) || (39 === token) || (61 === token) || (60 === token) || (62 === token) || (96 === token)) {
					closed = false;
					break;
				}
				closed = true;
				_i$4++;
			}
		}
		if (!closed) {
			valid = false;
			valSpec = sliceType.nil;
			return [valid, remains, valSpec];
		}
		remains = $subslice(tokens, (i + 1 >> 0));
		return [valid, remains, valSpec];
	};
	Tree.prototype.parseAttrValSpec = function(tokens) { return this.$val.parseAttrValSpec(tokens); };
	Tree.ptr.prototype.parseAttrName = function(tokens) {
		var _i, _ref, attrName, i, remains, t, token, tokens;
		remains = sliceType.nil;
		attrName = sliceType.nil;
		t = this;
		remains = tokens;
		if (!lex.IsASCIILetter((0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) && !((95 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]))) && !((58 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [remains, attrName];
		}
		attrName = $append(attrName, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]));
		tokens = $subslice(tokens, 1);
		i = 0;
		token = 0;
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!lex.IsASCIILetterNumHyphen(token) && !((95 === token)) && !((46 === token)) && !((58 === token))) {
				break;
			}
			attrName = $append(attrName, token);
			_i++;
		}
		if (1 > attrName.$length) {
			return [remains, attrName];
		}
		remains = $subslice(tokens, i);
		return [remains, attrName];
	};
	Tree.prototype.parseAttrName = function(tokens) { return this.$val.parseAttrName(tokens); };
	Tree.ptr.prototype.parseTagName = function(tokens) {
		var _tmp, _tmp$1, caretIndex, i, idx, remains, t, tagName, token, tokens;
		remains = sliceType.nil;
		tagName = sliceType.nil;
		t = this;
		caretIndex = 0;
		if (t.Context.Option.VditorWYSIWYG) {
			caretIndex = bytes.Index(tokens, (new sliceType($stringToBytes("\xE2\x80\xB8"))));
			if (-1 < caretIndex) {
				tokens = bytes.ReplaceAll(tokens, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
			}
		}
		if (1 > tokens.$length) {
			return [remains, tagName];
		}
		i = 0;
		token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
		if (!lex.IsASCIILetter(token)) {
			_tmp = tokens;
			_tmp$1 = sliceType.nil;
			remains = _tmp;
			tagName = _tmp$1;
			return [remains, tagName];
		}
		tagName = $append(tagName, token);
		i = 1;
		while (true) {
			if (!(i < tokens.$length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!lex.IsASCIILetterNumHyphen(token)) {
				break;
			}
			tagName = $append(tagName, token);
			i = i + (1) >> 0;
		}
		remains = $subslice(tokens, i);
		if (t.Context.Option.VditorWYSIWYG && -1 < caretIndex) {
			if (i <= caretIndex) {
				idx = caretIndex - i >> 0;
				remains = $appendSlice($subslice(remains, 0, idx), $appendSlice((new sliceType($stringToBytes("\xE2\x80\xB8"))), $subslice(remains, idx)));
			} else {
				tagName = $appendSlice($subslice(tagName, 0, caretIndex), $appendSlice((new sliceType($stringToBytes("\xE2\x80\xB8"))), $subslice(tagName, caretIndex)));
			}
		}
		return [remains, tagName];
	};
	Tree.prototype.parseTagName = function(tokens) { return this.$val.parseTagName(tokens); };
	Context.ptr.prototype.parseInlineLinkDest = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tuple, _tuple$1, context, dest, dest$1, destStarted, destination, i, i$1, isPointyBrackets, length, matchEnd, openParens, passed, r, r$1, remains, runes, runes$1, size, size$1, token, token$1, tokens, x, x$1;
		passed = sliceType.nil;
		remains = sliceType.nil;
		destination = sliceType.nil;
		context = this;
		remains = tokens;
		length = tokens.$length;
		if (2 > length) {
			return [passed, remains, destination];
		}
		passed = $makeSlice(sliceType, 0, 256);
		destination = $makeSlice(sliceType, 0, 256);
		isPointyBrackets = 60 === (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]);
		if (isPointyBrackets) {
			matchEnd = false;
			passed = $append(passed, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]), (1 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 1]));
			i = 2;
			size = 1;
			r = 0;
			_tmp = sliceType.nil;
			_tmp$1 = sliceType.nil;
			dest = _tmp;
			runes = _tmp$1;
			while (true) {
				if (!(i < length)) { break; }
				size = 1;
				token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
				if (10 === token) {
					passed = sliceType.nil;
					return [passed, remains, destination];
				}
				if (token < 128) {
					passed = $append(passed, token);
					dest = new sliceType([token]);
				} else {
					dest = new sliceType([]);
					_tuple = utf8.DecodeRune($subslice(tokens, i));
					r = _tuple[0];
					size = _tuple[1];
					runes = util.StrToBytes(($encodeRune(r)));
					passed = $appendSlice(passed, runes);
					dest = $appendSlice(dest, runes);
				}
				destination = $appendSlice(destination, dest);
				if ((62 === token) && !lex.IsBackslashEscapePunct(tokens, i)) {
					destination = $subslice(destination, 0, (destination.$length - 1 >> 0));
					matchEnd = true;
					break;
				}
				i = i + (size) >> 0;
			}
			if (!matchEnd || (length > i && !((41 === (x = i + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))))) {
				passed = sliceType.nil;
				return [passed, remains, destination];
			}
			passed = $append(passed, (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1])));
			remains = $subslice(tokens, (i + 2 >> 0));
		} else {
			openParens = 0;
			i$1 = 0;
			size$1 = 1;
			r$1 = 0;
			_tmp$2 = sliceType.nil;
			_tmp$3 = sliceType.nil;
			dest$1 = _tmp$2;
			runes$1 = _tmp$3;
			destStarted = false;
			while (true) {
				if (!(i$1 < length)) { break; }
				size$1 = 1;
				token$1 = ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1]);
				if (token$1 < 128) {
					passed = $append(passed, token$1);
					dest$1 = new sliceType([token$1]);
				} else {
					dest$1 = new sliceType([]);
					_tuple$1 = utf8.DecodeRune($subslice(tokens, i$1));
					r$1 = _tuple$1[0];
					size$1 = _tuple$1[1];
					runes$1 = util.StrToBytes(($encodeRune(r$1)));
					passed = $appendSlice(passed, runes$1);
					dest$1 = $appendSlice(dest$1, runes$1);
				}
				destination = $appendSlice(destination, dest$1);
				if (!destStarted && !lex.IsWhitespace(token$1) && 0 < i$1) {
					destStarted = true;
					destination = $subslice(destination, 1);
					destination = lex.TrimWhitespace(destination);
				}
				if (destStarted && (lex.IsWhitespace(token$1) || lex.IsControl(token$1))) {
					destination = $subslice(destination, 0, (destination.$length - size$1 >> 0));
					passed = $subslice(passed, 0, (passed.$length - 1 >> 0));
					openParens = openParens - (1) >> 0;
					break;
				}
				if ((40 === token$1) && !lex.IsBackslashEscapePunct(tokens, i$1)) {
					openParens = openParens + (1) >> 0;
				}
				if ((41 === token$1) && !lex.IsBackslashEscapePunct(tokens, i$1)) {
					openParens = openParens - (1) >> 0;
					if (1 > openParens) {
						if (40 === (0 >= destination.$length ? ($throwRuntimeError("index out of range"), undefined) : destination.$array[destination.$offset + 0])) {
							destination = $subslice(destination, 1);
						}
						destination = $subslice(destination, 0, (destination.$length - 1 >> 0));
						break;
					}
				}
				i$1 = i$1 + (size$1) >> 0;
			}
			remains = $subslice(tokens, i$1);
			if (length > i$1 && (!((41 === ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1]))) && !((32 === ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1]))) && !((10 === ((i$1 < 0 || i$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i$1]))))) {
				passed = sliceType.nil;
				return [passed, remains, destination];
			}
			if (!((0 === openParens))) {
				passed = sliceType.nil;
				return [passed, remains, destination];
			}
		}
		if (!(sliceType.nil === passed)) {
			if (!context.Option.VditorWYSIWYG) {
				destination = util.EncodeDestination(util.UnescapeString(destination));
			}
		}
		return [passed, remains, destination];
	};
	Context.prototype.parseInlineLinkDest = function(tokens) { return this.$val.parseInlineLinkDest(tokens); };
	Context.ptr.prototype.RelativePath = function(dest) {
		var context, dest, linkBase, ret;
		context = this;
		if ("" === context.Option.LinkBase) {
			return dest;
		}
		dest = bytes.ReplaceAll(dest, (new sliceType($stringToBytes("%5C"))), (new sliceType($stringToBytes("\\"))));
		if (!context.isRelativePath(dest)) {
			return dest;
		}
		linkBase = util.StrToBytes(context.Option.LinkBase);
		ret = $appendSlice(linkBase, dest);
		if (bytes.Equal(linkBase, ret)) {
			return (new sliceType($stringToBytes("")));
		}
		return ret;
	};
	Context.prototype.RelativePath = function(dest) { return this.$val.RelativePath(dest); };
	Context.ptr.prototype.isRelativePath = function(dest) {
		var context, dest;
		context = this;
		if (1 > dest.$length) {
			return true;
		}
		if (47 === (0 >= dest.$length ? ($throwRuntimeError("index out of range"), undefined) : dest.$array[dest.$offset + 0])) {
			return false;
		}
		return !bytes.Contains(dest, (new sliceType($stringToBytes(":/")))) && !bytes.Contains(dest, (new sliceType($stringToBytes(":\\"))));
	};
	Context.prototype.isRelativePath = function(dest) { return this.$val.isRelativePath(dest); };
	Tree.ptr.prototype.parseInlineMath = function(ctx) {
		var blockEndPos, blockStartPos, ctx, dollars, endPos, matchBlock, ret, startPos, t, token, tokens, x, x$1, x$2, x$3, x$4, x$5;
		ret = ptrType.nil;
		t = this;
		if (3 > ctx.tokensLen) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, dollar, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		startPos = ctx.pos;
		blockStartPos = startPos;
		dollars = 0;
		while (true) {
			if (!(blockStartPos < ctx.tokensLen && (36 === (x = ctx.tokens, ((blockStartPos < 0 || blockStartPos >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + blockStartPos]))))) { break; }
			dollars = dollars + (1) >> 0;
			blockStartPos = blockStartPos + (1) >> 0;
		}
		if (2 <= dollars) {
			matchBlock = false;
			blockEndPos = blockStartPos + dollars >> 0;
			token = 0;
			while (true) {
				if (!(blockEndPos < ctx.tokensLen)) { break; }
				token = (x$1 = ctx.tokens, ((blockEndPos < 0 || blockEndPos >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + blockEndPos]));
				if ((36 === token) && blockEndPos < (ctx.tokensLen - 1 >> 0) && (36 === (x$2 = ctx.tokens, x$3 = blockEndPos + 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])))) {
					matchBlock = true;
					break;
				}
				blockEndPos = blockEndPos + (1) >> 0;
			}
			if (matchBlock) {
				ret = new ast.Node.ptr(300, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				ret.AppendChild(new ast.Node.ptr(301, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
				ret.AppendChild(new ast.Node.ptr(302, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(ctx.tokens, blockStartPos, blockEndPos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
				ret.AppendChild(new ast.Node.ptr(303, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
				ctx.pos = blockEndPos + 2 >> 0;
				return ret;
			}
		}
		if (!t.Context.Option.InlineMathAllowDigitAfterOpenMarker && ctx.tokensLen > (startPos + 1 >> 0) && lex.IsDigit((x$4 = ctx.tokens, x$5 = startPos + 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5])))) {
			ctx.pos = ctx.pos + (3) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(ctx.tokens, startPos, (startPos + 3 >> 0)), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		endPos = t.matchInlineMathEnd($subslice(ctx.tokens, (startPos + 1 >> 0)));
		if (1 > endPos) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, dollar, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		endPos = (startPos + endPos >> 0) + 2 >> 0;
		tokens = $subslice(ctx.tokens, (startPos + 1 >> 0), (endPos - 1 >> 0));
		if (1 > lex.TrimWhitespace(tokens).$length) {
			ctx.pos = ctx.pos + (1) >> 0;
			ret = new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, dollar, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			return ret;
		}
		ret = new ast.Node.ptr(304, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		ret.AppendChild(new ast.Node.ptr(305, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		ret.AppendChild(new ast.Node.ptr(306, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		ret.AppendChild(new ast.Node.ptr(307, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		ctx.pos = endPos;
		return ret;
	};
	Tree.prototype.parseInlineMath = function(ctx) { return this.$val.parseInlineMath(ctx); };
	Tree.ptr.prototype.matchInlineMathEnd = function(tokens) {
		var length, pos, t, tokens, x;
		pos = 0;
		t = this;
		length = tokens.$length;
		while (true) {
			if (!(pos < length)) { break; }
			if (36 === ((pos < 0 || pos >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + pos])) {
				if (pos < (length - 1 >> 0)) {
					if (!lex.IsDigit((x = pos + 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])))) {
						pos = pos;
						return pos;
					}
				} else {
					pos = pos;
					return pos;
				}
			}
			pos = pos + (1) >> 0;
		}
		pos = -1;
		return pos;
	};
	Tree.prototype.matchInlineMathEnd = function(tokens) { return this.$val.matchInlineMathEnd(tokens); };
	Tree.ptr.prototype.parseInlines = function() {
		var t, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		$r = t.walkParseInline(t.Root); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.parseInlines }; } $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.parseInlines = function() { return this.$val.parseInlines(); };
	Tree.ptr.prototype.walkParseInline = function(node) {
		var child, closeMarker, code, code$1, ctx, info, length, next, node, openMarker, t, tokens, typ, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; child = $f.child; closeMarker = $f.closeMarker; code = $f.code; code$1 = $f.code$1; ctx = $f.ctx; info = $f.info; length = $f.length; next = $f.next; node = $f.node; openMarker = $f.openMarker; t = $f.t; tokens = $f.tokens; typ = $f.typ; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		t = this;
		if (ptrType.nil === node) {
			$s = -1; return;
		}
		typ = node.Type;
		/* */ if ((1 === typ) || (2 === typ) || (109 === typ)) { $s = 1; continue; }
		/* */ if (11 === typ) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if ((1 === typ) || (2 === typ) || (109 === typ)) { */ case 1:
			tokens = node.Tokens;
			if ((1 === typ) && sliceType.nil === tokens) {
				next = node.Next;
				node.Unlink();
				node.Next = next;
				$s = -1; return;
			}
			length = tokens.$length;
			if (1 > length) {
				$s = -1; return;
			}
			ctx = new InlineContext.ptr(tokens, length, 0, 0, 0, ptrType$2.nil, ptrType$2.nil);
			$r = t.parseInline(node, ctx); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			t.processEmphasis(ptrType$2.nil, ctx);
			t.mergeText(node);
			if (t.Context.Option.GFMAutoLink && !t.Context.Option.VditorWYSIWYG) {
				t.parseGFMAutoEmailLink(node);
				t.parseGFMAutoLink(node);
			}
			if (t.Context.Option.Emoji) {
				t.emoji(node);
			}
			$s = -1; return;
		/* } else if (11 === typ) { */ case 2:
			if (node.IsFencedCodeBlock) {
				openMarker = new ast.Node.ptr(12, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, node.CodeBlockOpenFence, false, false, false, 0, false, 0, node.CodeBlockFenceLen, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				node.PrependChild(openMarker);
				info = new ast.Node.ptr(14, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, node.CodeBlockInfo, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				node.AppendChild(info);
				code = new ast.Node.ptr(15, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, node.Tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				node.AppendChild(code);
				if (sliceType.nil === node.CodeBlockCloseFence) {
					node.CodeBlockCloseFence = node.CodeBlockOpenFence;
				}
				closeMarker = new ast.Node.ptr(13, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, node.CodeBlockCloseFence, false, false, false, 0, false, 0, node.CodeBlockFenceLen, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				node.AppendChild(closeMarker);
			} else {
				code$1 = new ast.Node.ptr(15, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, node.Tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
				node.AppendChild(code$1);
			}
			node.Tokens = sliceType.nil;
		/* } */ case 3:
		child = node.FirstChild;
		/* while (true) { */ case 5:
			/* if (!(!(ptrType.nil === child))) { break; } */ if(!(!(ptrType.nil === child))) { $s = 6; continue; }
			$r = t.walkParseInline(child); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			child = child.Next;
		/* } */ $s = 5; continue; case 6:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Tree.ptr.prototype.walkParseInline }; } $f.child = child; $f.closeMarker = closeMarker; $f.code = code; $f.code$1 = code$1; $f.ctx = ctx; $f.info = info; $f.length = length; $f.next = next; $f.node = node; $f.openMarker = openMarker; $f.t = t; $f.tokens = tokens; $f.typ = typ; $f.$s = $s; $f.$r = $r; return $f;
	};
	Tree.prototype.walkParseInline = function(node) { return this.$val.walkParseInline(node); };
	Context.ptr.prototype.parseLinkRefDef = function(tokens) {
		var _entry, _key, _r, _tuple, _tuple$1, _tuple$10, _tuple$11, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7, _tuple$8, _tuple$9, context, destination, label, length, link, linkDest, lowerCaseLabel, n, newlines, ok, remains, spaces1, spaces2, tabs1, tabs2, title, titleLine, tokens, validTitle, whitespaces, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; _r = $f._r; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; _tuple$10 = $f._tuple$10; _tuple$11 = $f._tuple$11; _tuple$2 = $f._tuple$2; _tuple$3 = $f._tuple$3; _tuple$4 = $f._tuple$4; _tuple$5 = $f._tuple$5; _tuple$6 = $f._tuple$6; _tuple$7 = $f._tuple$7; _tuple$8 = $f._tuple$8; _tuple$9 = $f._tuple$9; context = $f.context; destination = $f.destination; label = $f.label; length = $f.length; link = $f.link; linkDest = $f.linkDest; lowerCaseLabel = $f.lowerCaseLabel; n = $f.n; newlines = $f.newlines; ok = $f.ok; remains = $f.remains; spaces1 = $f.spaces1; spaces2 = $f.spaces2; tabs1 = $f.tabs1; tabs2 = $f.tabs2; title = $f.title; titleLine = $f.titleLine; tokens = $f.tokens; validTitle = $f.validTitle; whitespaces = $f.whitespaces; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		context = this;
		_tuple = lex.TrimLeft(tokens);
		tokens = _tuple[1];
		if (1 > tokens.$length) {
			$s = -1; return sliceType.nil;
		}
		_tuple$1 = context.parseLinkLabel(tokens);
		n = _tuple$1[0];
		remains = _tuple$1[1];
		label = _tuple$1[2];
		if (2 > n || 1 > label.$length) {
			$s = -1; return sliceType.nil;
		}
		length = remains.$length;
		if (1 > length) {
			$s = -1; return sliceType.nil;
		}
		if (!((58 === (0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0])))) {
			$s = -1; return sliceType.nil;
		}
		remains = $subslice(remains, 1);
		_tuple$2 = lex.TrimLeft(remains);
		whitespaces = _tuple$2[0];
		remains = _tuple$2[1];
		_tuple$3 = lex.StatWhitespace(whitespaces);
		newlines = _tuple$3[0];
		if (1 < newlines) {
			$s = -1; return sliceType.nil;
		}
		tokens = remains;
		_tuple$4 = context.parseLinkDest(tokens);
		linkDest = _tuple$4[0];
		remains = _tuple$4[1];
		destination = _tuple$4[2];
		if (sliceType.nil === linkDest) {
			$s = -1; return sliceType.nil;
		}
		_tuple$5 = lex.TrimLeft(remains);
		whitespaces = _tuple$5[0];
		remains = _tuple$5[1];
		if (sliceType.nil === whitespaces && 0 < remains.$length) {
			$s = -1; return sliceType.nil;
		}
		_tuple$6 = lex.StatWhitespace(whitespaces);
		newlines = _tuple$6[0];
		spaces1 = _tuple$6[1];
		tabs1 = _tuple$6[2];
		if (1 < newlines) {
			$s = -1; return sliceType.nil;
		}
		_tuple$7 = lex.TrimLeft(remains);
		tokens = _tuple$7[1];
		_tuple$8 = context.parseLinkTitle(tokens);
		validTitle = _tuple$8[0];
		remains = _tuple$8[2];
		title = _tuple$8[3];
		if (!validTitle && 1 > newlines) {
			$s = -1; return sliceType.nil;
		}
		if (0 < (spaces1 + tabs1 >> 0) && !lex.IsBlankLine(remains) && !((10 === (0 >= remains.$length ? ($throwRuntimeError("index out of range"), undefined) : remains.$array[remains.$offset + 0])))) {
			$s = -1; return sliceType.nil;
		}
		titleLine = tokens;
		_tuple$9 = lex.TrimLeft(remains);
		whitespaces = _tuple$9[0];
		tokens = _tuple$9[1];
		_tuple$10 = lex.StatWhitespace(whitespaces);
		spaces2 = _tuple$10[1];
		tabs2 = _tuple$10[2];
		if (!lex.IsBlankLine(tokens) && 0 < (spaces2 + tabs2 >> 0)) {
			remains = titleLine;
		} else {
			remains = tokens;
		}
		link = context.Tree.newLink(33, label, destination, title, 1);
		_r = bytes.ToLower(label); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		lowerCaseLabel = _r;
		_tuple$11 = (_entry = context.LinkRefDefs[$String.keyFor(util.BytesToStr(lowerCaseLabel))], _entry !== undefined ? [_entry.v, true] : [ptrType.nil, false]);
		ok = _tuple$11[1];
		if (!ok) {
			_key = util.BytesToStr(lowerCaseLabel); (context.LinkRefDefs || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: link };
		}
		$s = -1; return remains;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.parseLinkRefDef }; } $f._entry = _entry; $f._key = _key; $f._r = _r; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f._tuple$10 = _tuple$10; $f._tuple$11 = _tuple$11; $f._tuple$2 = _tuple$2; $f._tuple$3 = _tuple$3; $f._tuple$4 = _tuple$4; $f._tuple$5 = _tuple$5; $f._tuple$6 = _tuple$6; $f._tuple$7 = _tuple$7; $f._tuple$8 = _tuple$8; $f._tuple$9 = _tuple$9; $f.context = context; $f.destination = destination; $f.label = label; $f.length = length; $f.link = link; $f.linkDest = linkDest; $f.lowerCaseLabel = lowerCaseLabel; $f.n = n; $f.newlines = newlines; $f.ok = ok; $f.remains = remains; $f.spaces1 = spaces1; $f.spaces2 = spaces2; $f.tabs1 = tabs1; $f.tabs2 = tabs2; $f.title = title; $f.titleLine = titleLine; $f.tokens = tokens; $f.validTitle = validTitle; $f.whitespaces = whitespaces; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.parseLinkRefDef = function(tokens) { return this.$val.parseLinkRefDef(tokens); };
	Context.ptr.prototype.parseLinkTitle = function(tokens) {
		var _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tmp$6, _tmp$7, _tuple, _tuple$1, _tuple$2, context, passed, remains, title, tokens, validTitle;
		validTitle = false;
		passed = sliceType.nil;
		remains = sliceType.nil;
		title = sliceType.nil;
		context = this;
		if (1 > tokens.$length) {
			_tmp = true;
			_tmp$1 = sliceType.nil;
			_tmp$2 = tokens;
			_tmp$3 = sliceType.nil;
			validTitle = _tmp;
			passed = _tmp$1;
			remains = _tmp$2;
			title = _tmp$3;
			return [validTitle, passed, remains, title];
		}
		if (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])) {
			_tmp$4 = true;
			_tmp$5 = sliceType.nil;
			_tmp$6 = tokens;
			_tmp$7 = sliceType.nil;
			validTitle = _tmp$4;
			passed = _tmp$5;
			remains = _tmp$6;
			title = _tmp$7;
			return [validTitle, passed, remains, title];
		}
		_tuple = context.parseLinkTitleMatch(34, 34, tokens);
		validTitle = _tuple[0];
		passed = _tuple[1];
		remains = _tuple[2];
		title = _tuple[3];
		if (!validTitle) {
			_tuple$1 = context.parseLinkTitleMatch(39, 39, tokens);
			validTitle = _tuple$1[0];
			passed = _tuple$1[1];
			remains = _tuple$1[2];
			title = _tuple$1[3];
			if (!validTitle) {
				_tuple$2 = context.parseLinkTitleMatch(40, 41, tokens);
				validTitle = _tuple$2[0];
				passed = _tuple$2[1];
				remains = _tuple$2[2];
				title = _tuple$2[3];
			}
		}
		if (!(sliceType.nil === title)) {
			if (!context.Option.VditorWYSIWYG) {
				title = util.UnescapeString(title);
			}
		}
		return [validTitle, passed, remains, title];
	};
	Context.prototype.parseLinkTitle = function(tokens) { return this.$val.parseLinkTitle(tokens); };
	Context.ptr.prototype.parseLinkTitleMatch = function(opener, closer, tokens) {
		var _tuple, closed, closer, context, i, j, length, line, opener, passed, r, remains, size, title, token, tokens, validTitle, x;
		validTitle = false;
		passed = sliceType.nil;
		remains = sliceType.nil;
		title = sliceType.nil;
		context = this;
		remains = tokens;
		length = tokens.$length;
		if (2 > length) {
			return [validTitle, passed, remains, title];
		}
		if (!((opener === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [validTitle, passed, remains, title];
		}
		line = tokens;
		length = line.$length;
		closed = false;
		i = 1;
		size = 0;
		r = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + i]);
			passed = $append(passed, token);
			_tuple = utf8.DecodeRune($subslice(line, i));
			r = _tuple[0];
			size = _tuple[1];
			j = 1;
			while (true) {
				if (!(j < size)) { break; }
				passed = $append(passed, (x = i + j >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])));
				j = j + (1) >> 0;
			}
			title = $appendSlice(title, util.StrToBytes(($encodeRune(r))));
			if ((closer === token) && !lex.IsBackslashEscapePunct(tokens, i)) {
				closed = true;
				title = $subslice(title, 0, (title.$length - 1 >> 0));
				break;
			}
			i = i + (size) >> 0;
		}
		if (!closed) {
			passed = sliceType.nil;
			return [validTitle, passed, remains, title];
		}
		validTitle = true;
		remains = $subslice(tokens, (i + 1 >> 0));
		return [validTitle, passed, remains, title];
	};
	Context.prototype.parseLinkTitleMatch = function(opener, closer, tokens) { return this.$val.parseLinkTitleMatch(opener, closer, tokens); };
	Context.ptr.prototype.parseLinkDest = function(tokens) {
		var _tuple, _tuple$1, context, destination, remains, ret, tokens;
		ret = sliceType.nil;
		remains = sliceType.nil;
		destination = sliceType.nil;
		context = this;
		_tuple = context.parseLinkDest1(tokens);
		ret = _tuple[0];
		remains = _tuple[1];
		destination = _tuple[2];
		if (sliceType.nil === ret) {
			_tuple$1 = context.parseLinkDest2(tokens);
			ret = _tuple$1[0];
			remains = _tuple$1[1];
			destination = _tuple$1[2];
		}
		if (!(sliceType.nil === ret)) {
			if (!context.Option.VditorWYSIWYG) {
				destination = util.EncodeDestination(util.UnescapeString(destination));
			}
		}
		return [ret, remains, destination];
	};
	Context.prototype.parseLinkDest = function(tokens) { return this.$val.parseLinkDest(tokens); };
	Context.ptr.prototype.parseLinkDest2 = function(tokens) {
		var _tuple, context, destination, i, j, length, openParens, r, remains, ret, size, token, tokens, x;
		ret = sliceType.nil;
		remains = sliceType.nil;
		destination = sliceType.nil;
		context = this;
		remains = tokens;
		length = tokens.$length;
		if (1 > length) {
			return [ret, remains, destination];
		}
		ret = $makeSlice(sliceType, 0, 256);
		destination = $makeSlice(sliceType, 0, 256);
		openParens = 0;
		i = 0;
		size = 0;
		r = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			ret = $append(ret, token);
			_tuple = utf8.DecodeRune($subslice(tokens, i));
			r = _tuple[0];
			size = _tuple[1];
			j = 1;
			while (true) {
				if (!(j < size)) { break; }
				ret = $append(ret, (x = i + j >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])));
				j = j + (1) >> 0;
			}
			destination = $appendSlice(destination, util.StrToBytes(($encodeRune(r))));
			if (lex.IsWhitespace(token) || lex.IsControl(token)) {
				destination = $subslice(destination, 0, (destination.$length - 1 >> 0));
				ret = $subslice(ret, 0, (ret.$length - 1 >> 0));
				break;
			}
			if ((40 === token) && !lex.IsBackslashEscapePunct(tokens, i)) {
				openParens = openParens + (1) >> 0;
			}
			if ((41 === token) && !lex.IsBackslashEscapePunct(tokens, i)) {
				openParens = openParens - (1) >> 0;
				if (1 > openParens) {
					i = i + (1) >> 0;
					break;
				}
			}
			i = i + (size) >> 0;
		}
		remains = $subslice(tokens, i);
		if (length > i && !lex.IsWhitespace(((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]))) {
			ret = sliceType.nil;
			return [ret, remains, destination];
		}
		return [ret, remains, destination];
	};
	Context.prototype.parseLinkDest2 = function(tokens) { return this.$val.parseLinkDest2(tokens); };
	Context.ptr.prototype.parseLinkDest1 = function(tokens) {
		var _tuple, closed, context, destination, i, j, length, r, remains, ret, size, token, tokens, x;
		ret = sliceType.nil;
		remains = sliceType.nil;
		destination = sliceType.nil;
		context = this;
		remains = tokens;
		length = tokens.$length;
		if (2 > length) {
			return [ret, remains, destination];
		}
		if (!((60 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [ret, remains, destination];
		}
		ret = $makeSlice(sliceType, 0, 256);
		destination = $makeSlice(sliceType, 0, 256);
		closed = false;
		i = 0;
		size = 0;
		r = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			ret = $append(ret, token);
			size = 1;
			if (0 < i) {
				_tuple = utf8.DecodeRune($subslice(tokens, i));
				r = _tuple[0];
				size = _tuple[1];
				j = 1;
				while (true) {
					if (!(j < size)) { break; }
					ret = $append(ret, (x = i + j >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])));
					j = j + (1) >> 0;
				}
				destination = $appendSlice(destination, util.StrToBytes(($encodeRune(r))));
				if ((60 === token) && !lex.IsBackslashEscapePunct(tokens, i)) {
					ret = sliceType.nil;
					return [ret, remains, destination];
				}
			}
			if ((62 === token) && !lex.IsBackslashEscapePunct(tokens, i)) {
				closed = true;
				destination = $subslice(destination, 0, (destination.$length - 1 >> 0));
				break;
			}
			i = i + (size) >> 0;
		}
		if (!closed) {
			ret = sliceType.nil;
			return [ret, remains, destination];
		}
		remains = $subslice(tokens, (i + 1 >> 0));
		return [ret, remains, destination];
	};
	Context.prototype.parseLinkDest1 = function(tokens) { return this.$val.parseLinkDest1(tokens); };
	Context.ptr.prototype.parseLinkLabel = function(tokens) {
		var _tuple, closed, context, i, i$1, j, label, length, length$1, n, passed, r, remains, size, token, token$1, tokens, x, x$1;
		n = 0;
		remains = sliceType.nil;
		label = sliceType.nil;
		context = this;
		length = tokens.$length;
		if (2 > length) {
			return [n, remains, label];
		}
		if (!((91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) {
			return [n, remains, label];
		}
		passed = $makeSlice(sliceType, 0, tokens.$length);
		passed = $append(passed, (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]));
		closed = false;
		i = 1;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			passed = $append(passed, token);
			_tuple = utf8.DecodeRune($subslice(tokens, i));
			r = _tuple[0];
			size = _tuple[1];
			j = 1;
			while (true) {
				if (!(j < size)) { break; }
				passed = $append(passed, (x = i + j >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x])));
				j = j + (1) >> 0;
			}
			label = $appendSlice(label, util.StrToBytes(($encodeRune(r))));
			if ((93 === token) && !lex.IsBackslashEscapePunct(tokens, i)) {
				closed = true;
				label = $subslice(label, 0, (label.$length - 1 >> 0));
				remains = $subslice(tokens, (i + 1 >> 0));
				break;
			}
			if ((91 === token) && !lex.IsBackslashEscapePunct(tokens, i)) {
				passed = sliceType.nil;
				return [n, remains, label];
			}
			i = i + (size) >> 0;
		}
		if (!closed || sliceType.nil === lex.TrimWhitespace(label) || 999 < label.$length) {
			passed = sliceType.nil;
			return [n, remains, label];
		}
		label = lex.TrimWhitespace(label);
		if (!context.Option.VditorWYSIWYG) {
			label = lex.ReplaceAll(label, 10, 32);
			length$1 = label.$length;
			token$1 = 0;
			i$1 = 0;
			while (true) {
				if (!(i$1 < length$1)) { break; }
				token$1 = ((i$1 < 0 || i$1 >= label.$length) ? ($throwRuntimeError("index out of range"), undefined) : label.$array[label.$offset + i$1]);
				if ((token$1 === 32) && i$1 < (length$1 - 1 >> 0) && ((x$1 = i$1 + 1 >> 0, ((x$1 < 0 || x$1 >= label.$length) ? ($throwRuntimeError("index out of range"), undefined) : label.$array[label.$offset + x$1])) === 32)) {
					label = $appendSlice($subslice(label, 0, i$1), $subslice(label, (i$1 + 1 >> 0)));
					length$1 = length$1 - (1) >> 0;
				}
				i$1 = i$1 + (1) >> 0;
			}
		}
		n = passed.$length;
		return [n, remains, label];
	};
	Context.prototype.parseLinkLabel = function(tokens) { return this.$val.parseLinkLabel(tokens); };
	listFinalize = function(list) {
		var item, list, subitem;
		item = list.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === item))) { break; }
			if (endsWithBlankLine(item) && !(ptrType.nil === item.Next)) {
				list.ListData.Tight = false;
				break;
			}
			subitem = item.FirstChild;
			while (true) {
				if (!(!(ptrType.nil === subitem))) { break; }
				if (endsWithBlankLine(subitem) && (!(ptrType.nil === item.Next) || !(ptrType.nil === subitem.Next))) {
					list.ListData.Tight = false;
					break;
				}
				subitem = subitem.Next;
			}
			item = item.Next;
		}
	};
	Tree.ptr.prototype.parseListMarker = function(container) {
		var _tuple, _tuple$1, container, content, data, delim, isBlankItem, ln, marker, markerLength, spacesAfterMarker, spacesStartCol, spacesStartOffset, t, token, tokens, x;
		t = this;
		if (t.Context.indent >= 4) {
			return ptrType$1.nil;
		}
		ln = t.Context.currentLine;
		tokens = $subslice(ln, t.Context.nextNonspace);
		data = new ast.ListData.ptr(0, true, 0, 0, 0, 0, t.Context.indent, false, sliceType.nil, -1);
		markerLength = 1;
		marker = new sliceType([(0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])]);
		delim = 0;
		if ((43 === (0 >= marker.$length ? ($throwRuntimeError("index out of range"), undefined) : marker.$array[marker.$offset + 0])) || (45 === (0 >= marker.$length ? ($throwRuntimeError("index out of range"), undefined) : marker.$array[marker.$offset + 0])) || (42 === (0 >= marker.$length ? ($throwRuntimeError("index out of range"), undefined) : marker.$array[marker.$offset + 0]))) {
			data.BulletChar = (0 >= marker.$length ? ($throwRuntimeError("index out of range"), undefined) : marker.$array[marker.$offset + 0]);
		} else {
			_tuple = t.parseOrderedListMarker(tokens);
			marker = _tuple[0];
			delim = _tuple[1];
			if (!(sliceType.nil === marker)) {
				if (!((container.Type === 1)) || bytes.Equal(items1, marker)) {
					data.Typ = 1;
					_tuple$1 = strconv.Atoi(util.BytesToStr(marker));
					data.Start = _tuple$1[0];
					markerLength = marker.$length + 1 >> 0;
					data.Delimiter = delim;
				} else {
					return ptrType$1.nil;
				}
			} else {
				return ptrType$1.nil;
			}
		}
		data.Marker = marker;
		token = (x = t.Context.nextNonspace + markerLength >> 0, ((x < 0 || x >= ln.$length) ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + x]));
		if (!lex.IsWhitespace(token)) {
			return ptrType$1.nil;
		}
		if ((container.Type === 1) && (10 === token)) {
			return ptrType$1.nil;
		}
		t.Context.advanceNextNonspace();
		t.Context.advanceOffset(markerLength, true);
		spacesStartCol = t.Context.column;
		spacesStartOffset = t.Context.offset;
		while (true) {
			t.Context.advanceOffset(1, true);
			token = lex.Peek(ln, t.Context.offset);
			if ((t.Context.column - spacesStartCol >> 0) >= 5 || (0 === (token)) || (!((32 === token)) && !((9 === token)))) {
				break;
			}
		}
		token = lex.Peek(ln, t.Context.offset);
		isBlankItem = (0 === token) || (10 === token);
		spacesAfterMarker = t.Context.column - spacesStartCol >> 0;
		if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || isBlankItem) {
			data.Padding = markerLength + 1 >> 0;
			t.Context.column = spacesStartCol;
			t.Context.offset = spacesStartOffset;
			token = lex.Peek(ln, t.Context.offset);
			if ((32 === token) || (9 === token)) {
				t.Context.advanceOffset(1, true);
			}
		} else {
			data.Padding = markerLength + spacesAfterMarker >> 0;
		}
		if (!isBlankItem) {
			content = $subslice(ln, t.Context.offset);
			if (t.Context.Option.VditorWYSIWYG) {
				content = bytes.ReplaceAll(content, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
			}
			if (3 <= content.$length) {
				if ((91 === (0 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 0])) && ((120 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1])) || (88 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1])) || (32 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1]))) && (93 === (2 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 2]))) {
					data.Typ = 3;
					data.Checked = (120 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1])) || (88 === (1 >= content.$length ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + 1]));
				}
			}
		}
		return data;
	};
	Tree.prototype.parseListMarker = function(container) { return this.$val.parseListMarker(container); };
	Tree.ptr.prototype.parseOrderedListMarker = function(tokens) {
		var _tmp, _tmp$1, delimiter$1, i, length, marker, t, token, tokens;
		marker = sliceType.nil;
		delimiter$1 = 0;
		t = this;
		length = tokens.$length;
		i = 0;
		token = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			if (!lex.IsDigit(token) || 8 < i) {
				delimiter$1 = token;
				break;
			}
			marker = $append(marker, token);
			i = i + (1) >> 0;
		}
		if (1 > marker.$length || (!((46 === delimiter$1)) && !((41 === delimiter$1)))) {
			_tmp = sliceType.nil;
			_tmp$1 = 0;
			marker = _tmp;
			delimiter$1 = _tmp$1;
			return [marker, delimiter$1];
		}
		return [marker, delimiter$1];
	};
	Tree.prototype.parseOrderedListMarker = function(tokens) { return this.$val.parseOrderedListMarker(tokens); };
	endsWithBlankLine = function(block) {
		var block, t;
		while (true) {
			if (!(!(ptrType.nil === block))) { break; }
			if (block.LastLineBlank) {
				return true;
			}
			t = block.Type;
			if (!block.LastLineChecked && ((t === 7) || (t === 8))) {
				block.LastLineChecked = true;
				block = block.LastChild;
			} else {
				block.LastLineChecked = true;
				break;
			}
		}
		return false;
	};
	ListItemContinue = function(listItem, context) {
		var context, listItem;
		if (context.blank) {
			if (ptrType.nil === listItem.FirstChild) {
				return 1;
			}
			context.advanceNextNonspace();
		} else if (context.indent >= (listItem.ListData.MarkerOffset + listItem.ListData.Padding >> 0)) {
			context.advanceOffset(listItem.ListData.MarkerOffset + listItem.ListData.Padding >> 0, true);
		} else {
			return 1;
		}
		return 0;
	};
	$pkg.ListItemContinue = ListItemContinue;
	MathBlockContinue = function(mathBlock, context) {
		var context, i, indent, ln, mathBlock, token, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; context = $f.context; i = $f.i; indent = $f.indent; ln = $f.ln; mathBlock = $f.mathBlock; token = $f.token; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ln = context.currentLine;
		indent = context.indent;
		/* */ if (indent <= 3 && isMathBlockClose($subslice(ln, context.nextNonspace))) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (indent <= 3 && isMathBlockClose($subslice(ln, context.nextNonspace))) { */ case 1:
			$r = context.finalize(mathBlock, context.lineNum); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = -1; return 2;
		/* } else { */ case 2:
			i = mathBlock.MathBlockDollarOffset;
			token = 0;
			while (true) {
				if (!(i > 0)) { break; }
				token = lex.Peek(ln, context.offset);
				if (!((32 === token)) && !((9 === token))) {
					break;
				}
				context.advanceOffset(1, true);
				i = i - (1) >> 0;
			}
		/* } */ case 3:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: MathBlockContinue }; } $f.context = context; $f.i = i; $f.indent = indent; $f.ln = ln; $f.mathBlock = mathBlock; $f.token = token; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.MathBlockContinue = MathBlockContinue;
	mathBlockFinalize = function(mathBlock) {
		var mathBlock, tokens;
		tokens = $subslice(mathBlock.Tokens, 2);
		tokens = lex.TrimWhitespace(tokens);
		if (bytes.HasSuffix(tokens, $pkg.MathBlockMarker)) {
			tokens = $subslice(tokens, 0, (tokens.$length - 2 >> 0));
		}
		mathBlock.Tokens = sliceType.nil;
		mathBlock.AppendChild(new ast.Node.ptr(301, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		mathBlock.AppendChild(new ast.Node.ptr(302, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
		mathBlock.AppendChild(new ast.Node.ptr(303, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
	};
	Tree.ptr.prototype.parseMathBlock = function() {
		var _tmp, _tmp$1, fenceChar, fenceLength, i, marker, mathBlockDollarOffset, ok, t, x, x$1, x$2;
		ok = false;
		mathBlockDollarOffset = 0;
		t = this;
		marker = (x = t.Context.currentLine, x$1 = t.Context.nextNonspace, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (!((36 === marker))) {
			return [ok, mathBlockDollarOffset];
		}
		fenceChar = marker;
		fenceLength = 0;
		i = t.Context.nextNonspace;
		while (true) {
			if (!(i < t.Context.currentLineLen && (fenceChar === (x$2 = t.Context.currentLine, ((i < 0 || i >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + i]))))) { break; }
			fenceLength = fenceLength + (1) >> 0;
			i = i + (1) >> 0;
		}
		if (2 > fenceLength) {
			return [ok, mathBlockDollarOffset];
		}
		_tmp = true;
		_tmp$1 = t.Context.indent;
		ok = _tmp;
		mathBlockDollarOffset = _tmp$1;
		return [ok, mathBlockDollarOffset];
	};
	Tree.prototype.parseMathBlock = function() { return this.$val.parseMathBlock(); };
	isMathBlockClose = function(tokens) {
		var _i, _ref, closeMarker, token, tokens;
		closeMarker = (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0]);
		if (!((closeMarker === 36))) {
			return false;
		}
		if (2 > lex.Accept(tokens, closeMarker)) {
			return false;
		}
		tokens = lex.TrimWhitespace(tokens);
		_ref = tokens;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			token = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (!((token === 36))) {
				return false;
			}
			_i++;
		}
		return true;
	};
	ParagraphContinue = function(p, context) {
		var context, p;
		if (context.blank) {
			return 1;
		}
		return 0;
	};
	$pkg.ParagraphContinue = ParagraphContinue;
	paragraphFinalize = function(p, context) {
		var _r, _r$1, _r$2, _tmp, _tmp$1, _tmp$2, _tuple, caretAfterCloseBracket, caretInBracket, caretStartText, closeBracket, context, hasReferenceDefs, insertTable, isTaskListItem, listItem, nextTr, p, paragraph, table, taskListItemMarker, toc, tokens, tokens$1, tr, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tuple = $f._tuple; caretAfterCloseBracket = $f.caretAfterCloseBracket; caretInBracket = $f.caretInBracket; caretStartText = $f.caretStartText; closeBracket = $f.closeBracket; context = $f.context; hasReferenceDefs = $f.hasReferenceDefs; insertTable = $f.insertTable; isTaskListItem = $f.isTaskListItem; listItem = $f.listItem; nextTr = $f.nextTr; p = $f.p; paragraph = $f.paragraph; table = $f.table; taskListItemMarker = $f.taskListItemMarker; toc = $f.toc; tokens = $f.tokens; tokens$1 = $f.tokens$1; tr = $f.tr; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		insertTable = false;
		p.Tokens = lex.TrimWhitespace(p.Tokens);
		hasReferenceDefs = false;
		tokens = p.Tokens;
		/* while (true) { */ case 1:
			/* if (!(0 < tokens.$length && (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) { break; } */ if(!(0 < tokens.$length && (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) { $s = 2; continue; }
			_r = context.parseLinkRefDef(tokens); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tokens = _r;
			if (!(sliceType.nil === tokens)) {
				p.Tokens = tokens;
				hasReferenceDefs = true;
				tokens = p.Tokens;
				/* continue; */ $s = 1; continue;
			}
			/* break; */ $s = 2; continue;
		/* } */ $s = 1; continue; case 2:
		if (hasReferenceDefs && lex.IsBlankLine(p.Tokens)) {
			p.Unlink();
		}
		/* */ if (context.Option.GFMTaskListItem) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (context.Option.GFMTaskListItem) { */ case 4:
			listItem = p.Parent;
			/* */ if (!(ptrType.nil === listItem) && (8 === listItem.Type) && listItem.FirstChild === p) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (!(ptrType.nil === listItem) && (8 === listItem.Type) && listItem.FirstChild === p) { */ case 6:
				/* */ if (3 === listItem.ListData.Typ) { $s = 8; continue; }
				/* */ $s = 9; continue;
				/* if (3 === listItem.ListData.Typ) { */ case 8:
					isTaskListItem = false;
					if (!context.Option.VditorWYSIWYG) {
						isTaskListItem = 3 < p.Tokens.$length && lex.IsWhitespace((x = p.Tokens, (3 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 3])));
					} else {
						isTaskListItem = 3 <= p.Tokens.$length;
					}
					/* */ if (isTaskListItem) { $s = 10; continue; }
					/* */ $s = 11; continue;
					/* if (isTaskListItem) { */ case 10:
						tokens$1 = p.Tokens;
						_tmp = false;
						_tmp$1 = false;
						_tmp$2 = false;
						caretStartText = _tmp;
						caretAfterCloseBracket = _tmp$1;
						caretInBracket = _tmp$2;
						if (context.Option.VditorWYSIWYG) {
							closeBracket = bytes.IndexByte(tokens$1, 93);
							if (bytes.HasPrefix(tokens$1, (new sliceType($stringToBytes("\xE2\x80\xB8"))))) {
								tokens$1 = bytes.ReplaceAll(tokens$1, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
								caretStartText = true;
							} else if (bytes.HasPrefix($subslice(tokens$1, (closeBracket + 1 >> 0)), (new sliceType($stringToBytes("\xE2\x80\xB8"))))) {
								tokens$1 = bytes.ReplaceAll(tokens$1, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
								caretAfterCloseBracket = true;
							} else if (bytes.Contains($subslice(tokens$1, 1, closeBracket), (new sliceType($stringToBytes("\xE2\x80\xB8"))))) {
								tokens$1 = bytes.ReplaceAll(tokens$1, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
								caretInBracket = true;
							}
						}
						taskListItemMarker = new ast.Node.ptr(100, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(tokens$1, 0, 3), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, listItem.ListData.Checked, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
						p.PrependChild(taskListItemMarker);
						p.Tokens = $subslice(tokens$1, 3);
						/* */ if (context.Option.VditorWYSIWYG) { $s = 12; continue; }
						/* */ $s = 13; continue;
						/* if (context.Option.VditorWYSIWYG) { */ case 12:
							_r$1 = bytes.TrimSpace(p.Tokens); /* */ $s = 14; case 14: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
							p.Tokens = _r$1;
							if (caretStartText || caretAfterCloseBracket || caretInBracket) {
								p.Tokens = $appendSlice((new sliceType($stringToBytes(" \xE2\x80\xB8"))), p.Tokens);
							} else {
								p.Tokens = $appendSlice((new sliceType($stringToBytes(" "))), p.Tokens);
							}
						/* } */ case 13:
					/* } */ case 11:
				/* } */ case 9:
			/* } */ case 7:
		/* } */ case 5:
		if (context.Option.GFMTable) {
			_tuple = context.parseTable(p);
			paragraph = _tuple[0];
			table = _tuple[1];
			if (!(ptrType.nil === table)) {
				if (!(ptrType.nil === paragraph)) {
					p.Tokens = paragraph.Tokens;
					p.InsertAfter(table);
					table.Close = true;
					context.Tip = table;
					insertTable = true;
					$s = -1; return insertTable;
				} else {
					p.Type = 106;
					p.TableAligns = table.TableAligns;
					tr = table.FirstChild;
					while (true) {
						if (!(!(ptrType.nil === tr))) { break; }
						nextTr = tr.Next;
						p.AppendChild(tr);
						tr = nextTr;
					}
					p.Tokens = sliceType.nil;
				}
				$s = -1; return insertTable;
			}
		}
		/* */ if (context.Option.ToC) { $s = 15; continue; }
		/* */ $s = 16; continue;
		/* if (context.Option.ToC) { */ case 15:
			_r$2 = context.parseToC(p); /* */ $s = 17; case 17: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			toc = _r$2;
			if (!(ptrType.nil === toc)) {
				p.Type = 600;
				p.Tokens = toc.Tokens;
				$s = -1; return insertTable;
			}
		/* } */ case 16:
		$s = -1; return insertTable;
		/* */ } return; } if ($f === undefined) { $f = { $blk: paragraphFinalize }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tuple = _tuple; $f.caretAfterCloseBracket = caretAfterCloseBracket; $f.caretInBracket = caretInBracket; $f.caretStartText = caretStartText; $f.closeBracket = closeBracket; $f.context = context; $f.hasReferenceDefs = hasReferenceDefs; $f.insertTable = insertTable; $f.isTaskListItem = isTaskListItem; $f.listItem = listItem; $f.nextTr = nextTr; $f.p = p; $f.paragraph = paragraph; $f.table = table; $f.taskListItemMarker = taskListItemMarker; $f.toc = toc; $f.tokens = tokens; $f.tokens$1 = tokens$1; $f.tr = tr; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	Parse = function(name, markdown, options) {
		var markdown, name, options, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; markdown = $f.markdown; name = $f.name; options = $f.options; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		tree = ptrType$3.nil;
		tree = new Tree.ptr(name, ptrType.nil, new Context.ptr(ptrType$3.nil, options, false, sliceType$4.nil, ptrType.nil, ptrType.nil, sliceType.nil, 0, 0, 0, 0, 0, 0, 0, false, false, false, false, ptrType.nil), ptrType$5.nil, ptrType$6.nil);
		tree.Context.Tree = tree;
		tree.lexer = lex.NewLexer(markdown);
		tree.Root = new ast.Node.ptr(0, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		$r = tree.parseBlocks(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = tree.parseInlines(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		tree.lexer = ptrType$5.nil;
		$s = -1; return tree;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Parse }; } $f.markdown = markdown; $f.name = name; $f.options = options; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.Parse = Parse;
	Context.ptr.prototype.advanceOffset = function(count, columns) {
		var _r, _tmp, _tmp$1, c, charsToAdvance, charsToTab, columns, context, count, currentLine, x;
		context = this;
		currentLine = context.currentLine;
		_tmp = 0;
		_tmp$1 = 0;
		charsToTab = _tmp;
		charsToAdvance = _tmp$1;
		c = 0;
		while (true) {
			if (!(0 < count)) { break; }
			c = (x = context.offset, ((x < 0 || x >= currentLine.$length) ? ($throwRuntimeError("index out of range"), undefined) : currentLine.$array[currentLine.$offset + x]));
			if (9 === c) {
				charsToTab = 4 - ((_r = context.column % 4, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))) >> 0;
				if (columns) {
					context.partiallyConsumedTab = charsToTab > count;
					if (context.partiallyConsumedTab) {
						charsToAdvance = count;
					} else {
						charsToAdvance = charsToTab;
						context.offset = context.offset + (1) >> 0;
					}
					context.column = context.column + (charsToAdvance) >> 0;
					count = count - (charsToAdvance) >> 0;
				} else {
					context.partiallyConsumedTab = false;
					context.column = context.column + (charsToTab) >> 0;
					context.offset = context.offset + (1) >> 0;
					count = count - (1) >> 0;
				}
			} else {
				context.partiallyConsumedTab = false;
				context.offset = context.offset + (1) >> 0;
				context.column = context.column + (1) >> 0;
				count = count - (1) >> 0;
			}
		}
	};
	Context.prototype.advanceOffset = function(count, columns) { return this.$val.advanceOffset(count, columns); };
	Context.ptr.prototype.advanceNextNonspace = function() {
		var context;
		context = this;
		context.offset = context.nextNonspace;
		context.column = context.nextNonspaceColumn;
		context.partiallyConsumedTab = false;
	};
	Context.prototype.advanceNextNonspace = function() { return this.$val.advanceNextNonspace(); };
	Context.ptr.prototype.findNextNonspace = function() {
		var _r, cols, context, i, token, x;
		context = this;
		i = context.offset;
		cols = context.column;
		token = 0;
		while (true) {
			token = (x = context.currentLine, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
			if (32 === token) {
				i = i + (1) >> 0;
				cols = cols + (1) >> 0;
			} else if (9 === token) {
				i = i + (1) >> 0;
				cols = cols + ((4 - ((_r = cols % 4, _r === _r ? _r : $throwRuntimeError("integer divide by zero"))) >> 0)) >> 0;
			} else {
				break;
			}
		}
		context.blank = 10 === token;
		context.nextNonspace = i;
		context.nextNonspaceColumn = cols;
		context.indent = context.nextNonspaceColumn - context.column >> 0;
		context.indented = context.indent >= 4;
	};
	Context.prototype.findNextNonspace = function() { return this.$val.findNextNonspace(); };
	Context.ptr.prototype.closeUnmatchedBlocks = function() {
		var context, parent, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; context = $f.context; parent = $f.parent; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		context = this;
		/* */ if (!context.allClosed) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (!context.allClosed) { */ case 1:
			/* while (true) { */ case 3:
				/* if (!(!(context.oldtip === context.lastMatchedContainer))) { break; } */ if(!(!(context.oldtip === context.lastMatchedContainer))) { $s = 4; continue; }
				parent = context.oldtip.Parent;
				$r = context.finalize(context.oldtip, context.lineNum - 1 >> 0); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				context.oldtip = parent;
			/* } */ $s = 3; continue; case 4:
			context.allClosed = true;
		/* } */ case 2:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.closeUnmatchedBlocks }; } $f.context = context; $f.parent = parent; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.closeUnmatchedBlocks = function() { return this.$val.closeUnmatchedBlocks(); };
	Context.ptr.prototype.finalize = function(block, lineNum) {
		var _1, _r, block, context, insertTable, lineNum, parent, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; block = $f.block; context = $f.context; insertTable = $f.insertTable; lineNum = $f.lineNum; parent = $f.parent; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		context = this;
		parent = block.Parent;
		block.Close = true;
			_1 = block.Type;
			/* */ if (_1 === (11)) { $s = 2; continue; }
			/* */ if (_1 === (9)) { $s = 3; continue; }
			/* */ if (_1 === (1)) { $s = 4; continue; }
			/* */ if (_1 === (300)) { $s = 5; continue; }
			/* */ if (_1 === (7)) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if (_1 === (11)) { */ case 2:
				codeBlockFinalize(block);
				$s = 7; continue;
			/* } else if (_1 === (9)) { */ case 3:
				htmlBlockFinalize(block);
				$s = 7; continue;
			/* } else if (_1 === (1)) { */ case 4:
				_r = paragraphFinalize(block, context); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				insertTable = _r;
				if (insertTable) {
					$s = -1; return;
				}
				$s = 7; continue;
			/* } else if (_1 === (300)) { */ case 5:
				mathBlockFinalize(block);
				$s = 7; continue;
			/* } else if (_1 === (7)) { */ case 6:
				listFinalize(block);
			/* } */ case 7:
		case 1:
		context.Tip = parent;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.finalize }; } $f._1 = _1; $f._r = _r; $f.block = block; $f.context = context; $f.insertTable = insertTable; $f.lineNum = lineNum; $f.parent = parent; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.finalize = function(block, lineNum) { return this.$val.finalize(block, lineNum); };
	Context.ptr.prototype.addChildMarker = function(nodeType, tokens) {
		var context, nodeType, ret, tokens;
		ret = ptrType.nil;
		context = this;
		ret = new ast.Node.ptr(nodeType, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tokens, true, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		context.Tip.AppendChild(ret);
		ret = ret;
		return ret;
	};
	Context.prototype.addChildMarker = function(nodeType, tokens) { return this.$val.addChildMarker(nodeType, tokens); };
	Context.ptr.prototype.addChild = function(nodeType, offset) {
		var context, nodeType, offset, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; context = $f.context; nodeType = $f.nodeType; offset = $f.offset; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = ptrType.nil;
		context = this;
		/* while (true) { */ case 1:
			/* if (!(!context.Tip.CanContain(nodeType))) { break; } */ if(!(!context.Tip.CanContain(nodeType))) { $s = 2; continue; }
			$r = context.finalize(context.Tip, context.lineNum - 1 >> 0); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ $s = 1; continue; case 2:
		ret = new ast.Node.ptr(nodeType, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		context.Tip.AppendChild(ret);
		context.Tip = ret;
		ret = ret;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.addChild }; } $f.context = context; $f.nodeType = nodeType; $f.offset = offset; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.addChild = function(nodeType, offset) { return this.$val.addChild(nodeType, offset); };
	Context.ptr.prototype.listsMatch = function(listData, itemData) {
		var context, itemData, listData;
		context = this;
		return (listData.Typ === itemData.Typ) && (((0 === listData.Delimiter) && (0 === itemData.Delimiter)) || (listData.Delimiter === itemData.Delimiter)) && (listData.BulletChar === itemData.BulletChar);
	};
	Context.prototype.listsMatch = function(listData, itemData) { return this.$val.listsMatch(listData, itemData); };
	Context.ptr.prototype.ParentTip = function() {
		var context, tip;
		context = this;
		tip = context.Tip.Parent;
		if (!(ptrType.nil === tip)) {
			context.Tip = context.Tip.Parent;
		}
	};
	Context.prototype.ParentTip = function() { return this.$val.ParentTip(); };
	Context.ptr.prototype.parseTable = function(paragraph) {
		var context, i, length, lineCnt, paragraph, retParagraph, retTable, table, tokens, x;
		retParagraph = ptrType.nil;
		retTable = ptrType.nil;
		context = this;
		tokens = sliceType.nil;
		length = paragraph.Tokens.$length;
		lineCnt = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			if ((10 === (x = paragraph.Tokens, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]))) || (0 === i)) {
				if (0 === i) {
					tokens = $subslice(paragraph.Tokens, i);
				} else {
					tokens = $subslice(paragraph.Tokens, (i + 1 >> 0));
				}
				table = context.parseTable0(tokens);
				if (!(ptrType.nil === table)) {
					if (0 < lineCnt) {
						retParagraph = new ast.Node.ptr(1, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(paragraph.Tokens, 0, i), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
					}
					retTable = table;
					break;
				}
			}
			lineCnt = lineCnt + (1) >> 0;
			i = i + (1) >> 0;
		}
		return [retParagraph, retTable];
	};
	Context.prototype.parseTable = function(paragraph) { return this.$val.parseTable(paragraph); };
	Context.ptr.prototype.parseTable0 = function(tokens) {
		var aligns, cells, col, context, headRow, i, length, lines, maxWidth, maxWidthContent, n, n$1, ret, row, row$1, tableRow, tokens, x, x$1, x$2, x$3, x$4, x$5, x$6;
		ret = ptrType.nil;
		context = this;
		lines = lex.Split(tokens, 10);
		length = lines.$length;
		if (2 > length) {
			return ret;
		}
		aligns = context.parseTableDelimRow(lex.TrimWhitespace((1 >= lines.$length ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + 1])));
		if (sliceType$3.nil === aligns) {
			return ret;
		}
		if ((2 === length) && (1 === aligns.$length) && (0 === (0 >= aligns.$length ? ($throwRuntimeError("index out of range"), undefined) : aligns.$array[aligns.$offset + 0])) && !bytes.Contains(tokens, (new sliceType($stringToBytes("|"))))) {
			return ret;
		}
		headRow = context.parseTableRow(lex.TrimWhitespace((0 >= lines.$length ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + 0])), aligns, true);
		if (ptrType.nil === headRow) {
			return ret;
		}
		cells = sliceType$6.nil;
		cells = $append(cells, new sliceType$4([]));
		n = headRow.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === n))) { break; }
			(0 >= cells.$length ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + 0] = $append((0 >= cells.$length ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + 0]), n));
			n = n.Next;
		}
		ret = new ast.Node.ptr(106, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, aligns, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		ret.TableAligns = aligns;
		ret.AppendChild(context.newTableHead(headRow));
		i = 2;
		while (true) {
			if (!(i < length)) { break; }
			tableRow = context.parseTableRow(lex.TrimWhitespace(((i < 0 || i >= lines.$length) ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + i])), aligns, false);
			if (ptrType.nil === tableRow) {
				return ret;
			}
			ret.AppendChild(tableRow);
			cells = $append(cells, new sliceType$4([]));
			n$1 = tableRow.FirstChild;
			while (true) {
				if (!(!(ptrType.nil === n$1))) { break; }
				(x$1 = i - 1 >> 0, ((x$1 < 0 || x$1 >= cells.$length) ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + x$1] = $append((x = i - 1 >> 0, ((x < 0 || x >= cells.$length) ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + x])), n$1)));
				n$1 = n$1.Next;
			}
			i = i + (1) >> 0;
		}
		maxWidth = 0;
		maxWidthContent = sliceType.nil;
		col = 0;
		while (true) {
			if (!(col < (0 >= cells.$length ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + 0]).$length)) { break; }
			row = 0;
			while (true) {
				if (!(row < cells.$length)) { break; }
				if (maxWidth < (x$2 = ((row < 0 || row >= cells.$length) ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + row]), ((col < 0 || col >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + col])).TableCellContentWidth) {
					maxWidth = (x$3 = ((row < 0 || row >= cells.$length) ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + row]), ((col < 0 || col >= x$3.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$3.$array[x$3.$offset + col])).TableCellContentWidth;
					maxWidthContent = (x$4 = ((row < 0 || row >= cells.$length) ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + row]), ((col < 0 || col >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + col])).Tokens;
				}
				row = row + (1) >> 0;
			}
			row$1 = 0;
			while (true) {
				if (!(row$1 < cells.$length)) { break; }
				(x$5 = ((row$1 < 0 || row$1 >= cells.$length) ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + row$1]), ((col < 0 || col >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + col])).TableCellContentMaxWidth = maxWidth;
				(x$6 = ((row$1 < 0 || row$1 >= cells.$length) ? ($throwRuntimeError("index out of range"), undefined) : cells.$array[cells.$offset + row$1]), ((col < 0 || col >= x$6.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$6.$array[x$6.$offset + col])).TableCellMaxWidthContent = maxWidthContent;
				row$1 = row$1 + (1) >> 0;
			}
			maxWidth = 0;
			maxWidthContent = sliceType.nil;
			col = col + (1) >> 0;
		}
		return ret;
	};
	Context.prototype.parseTable0 = function(tokens) { return this.$val.parseTable0(tokens); };
	Context.ptr.prototype.newTableHead = function(headRow) {
		var c, context, headRow, next, ret, tr;
		context = this;
		ret = new ast.Node.ptr(107, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		tr = new ast.Node.ptr(108, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		ret.AppendChild(tr);
		c = headRow.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === c))) { break; }
			next = c.Next;
			tr.AppendChild(c);
			c = next;
		}
		return ret;
	};
	Context.prototype.newTableHead = function(headRow) { return this.$val.newTableHead(headRow); };
	Context.ptr.prototype.parseTableRow = function(line, aligns, isHead) {
		var aligns, alignsLen, cell, cell$1, col, cols, colsLen, context, i, isHead, line, ret, width, x;
		ret = ptrType.nil;
		context = this;
		ret = new ast.Node.ptr(108, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, aligns, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		cols = lex.SplitWithoutBackslashEscape(line, 124);
		if (1 > cols.$length) {
			ret = ptrType.nil;
			return ret;
		}
		if (lex.IsBlank((0 >= cols.$length ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + 0]))) {
			cols = $subslice(cols, 1);
		}
		if (cols.$length > 0 && lex.IsBlank((x = cols.$length - 1 >> 0, ((x < 0 || x >= cols.$length) ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + x])))) {
			cols = $subslice(cols, 0, (cols.$length - 1 >> 0));
		}
		colsLen = cols.$length;
		alignsLen = aligns.$length;
		if (isHead && colsLen > alignsLen) {
			ret = ptrType.nil;
			return ret;
		}
		i = 0;
		col = sliceType.nil;
		while (true) {
			if (!(i < colsLen && i < alignsLen)) { break; }
			col = lex.TrimWhitespace(((i < 0 || i >= cols.$length) ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + i]));
			width = col.$length;
			cell = new ast.Node.ptr(109, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, ((i < 0 || i >= aligns.$length) ? ($throwRuntimeError("index out of range"), undefined) : aligns.$array[aligns.$offset + i]), width, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			cell.Tokens = col;
			cell.TableCellContent = col;
			ret.AppendChild(cell);
			i = i + (1) >> 0;
		}
		while (true) {
			if (!(i < alignsLen)) { break; }
			cell$1 = new ast.Node.ptr(109, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, ((i < 0 || i >= aligns.$length) ? ($throwRuntimeError("index out of range"), undefined) : aligns.$array[aligns.$offset + i]), 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			ret.AppendChild(cell$1);
			i = i + (1) >> 0;
		}
		return ret;
	};
	Context.prototype.parseTableRow = function(line, aligns, isHead) { return this.$val.parseTableRow(line, aligns, isHead); };
	Context.ptr.prototype.parseTableDelimRow = function(line) {
		var _i, _ref, align, alignments, aligns, col, cols, context, i, length, line, token, x;
		aligns = sliceType$3.nil;
		context = this;
		length = line.$length;
		if (1 > length) {
			aligns = sliceType$3.nil;
			return aligns;
		}
		token = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			token = ((i < 0 || i >= line.$length) ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + i]);
			if (!((124 === token)) && !((45 === token)) && !((58 === token)) && !((32 === token))) {
				aligns = sliceType$3.nil;
				return aligns;
			}
			i = i + (1) >> 0;
		}
		cols = lex.SplitWithoutBackslashEscape(line, 124);
		if (lex.IsBlank((0 >= cols.$length ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + 0]))) {
			cols = $subslice(cols, 1);
		}
		if (cols.$length > 0 && lex.IsBlank((x = cols.$length - 1 >> 0, ((x < 0 || x >= cols.$length) ? ($throwRuntimeError("index out of range"), undefined) : cols.$array[cols.$offset + x])))) {
			cols = $subslice(cols, 0, (cols.$length - 1 >> 0));
		}
		alignments = sliceType$3.nil;
		_ref = cols;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			col = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			col = lex.TrimWhitespace(col);
			if (1 > length || sliceType.nil === col) {
				aligns = sliceType$3.nil;
				return aligns;
			}
			align = context.tableDelimAlign(col);
			if (-1 === align) {
				aligns = sliceType$3.nil;
				return aligns;
			}
			alignments = $append(alignments, align);
			_i++;
		}
		aligns = alignments;
		return aligns;
	};
	Context.prototype.parseTableDelimRow = function(line) { return this.$val.parseTableDelimRow(line); };
	Context.ptr.prototype.tableDelimAlign = function(col) {
		var _tmp, _tmp$1, col, context, first, i, last, left, length, right, token, x;
		context = this;
		length = col.$length;
		if (1 > length) {
			return -1;
		}
		_tmp = false;
		_tmp$1 = false;
		left = _tmp;
		right = _tmp$1;
		first = (0 >= col.$length ? ($throwRuntimeError("index out of range"), undefined) : col.$array[col.$offset + 0]);
		left = 58 === first;
		last = (x = length - 1 >> 0, ((x < 0 || x >= col.$length) ? ($throwRuntimeError("index out of range"), undefined) : col.$array[col.$offset + x]));
		right = 58 === last;
		i = 1;
		token = 0;
		while (true) {
			if (!(i < (length - 1 >> 0))) { break; }
			token = ((i < 0 || i >= col.$length) ? ($throwRuntimeError("index out of range"), undefined) : col.$array[col.$offset + i]);
			if (!((45 === token))) {
				return -1;
			}
			i = i + (1) >> 0;
		}
		if (left && right) {
			return 2;
		}
		if (left) {
			return 1;
		}
		if (right) {
			return 3;
		}
		return 0;
	};
	Context.prototype.tableDelimAlign = function(col) { return this.$val.tableDelimAlign(col); };
	Tree.ptr.prototype.parseText = function(ctx) {
		var ctx, start, t, x, x$1;
		t = this;
		start = ctx.pos;
		while (true) {
			if (!(ctx.pos < ctx.tokensLen)) { break; }
			if (t.isMarker((x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1])))) {
				break;
			}
			ctx.pos = ctx.pos + (1) >> 0;
		}
		return new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, $subslice(ctx.tokens, start, ctx.pos), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
	};
	Tree.prototype.parseText = function(ctx) { return this.$val.parseText(ctx); };
	Tree.ptr.prototype.isMarker = function(token) {
		var _1, t, token;
		t = this;
		_1 = token;
		if ((_1 === (42)) || (_1 === (95)) || (_1 === (91)) || (_1 === (33)) || (_1 === (10)) || (_1 === (92)) || (_1 === (96)) || (_1 === (60)) || (_1 === (93)) || (_1 === (38)) || (_1 === (126)) || (_1 === (36))) {
			return true;
		} else {
			return false;
		}
	};
	Tree.prototype.isMarker = function(token) { return this.$val.isMarker(token); };
	Tree.ptr.prototype.parseBackslash = function(block, ctx) {
		var block, ctx, n, t, token, x, x$1;
		t = this;
		if (ctx.pos === (ctx.tokensLen - 1 >> 0)) {
			ctx.pos = ctx.pos + (1) >> 0;
			return new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, backslash, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		}
		ctx.pos = ctx.pos + (1) >> 0;
		token = (x = ctx.tokens, x$1 = ctx.pos, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
		if (10 === token) {
			ctx.pos = ctx.pos + (1) >> 0;
			return new ast.Node.ptr(31, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, new sliceType([token]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		}
		if (lex.IsASCIIPunct(token)) {
			ctx.pos = ctx.pos + (1) >> 0;
			n = new ast.Node.ptr(400, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
			block.AppendChild(n);
			n.AppendChild(new ast.Node.ptr(401, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, new sliceType([token]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil));
			return ptrType.nil;
		}
		return new ast.Node.ptr(16, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, backslash, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
	};
	Tree.prototype.parseBackslash = function(block, ctx) { return this.$val.parseBackslash(block, ctx); };
	Tree.ptr.prototype.parseNewline = function(block, ctx) {
		var _tuple, block, ctx, isHardBreak, lastc, pos, ret, t, tokens, valueLen, x, x$1, x$2;
		ret = ptrType.nil;
		t = this;
		pos = ctx.pos;
		ctx.pos = ctx.pos + (1) >> 0;
		isHardBreak = false;
		lastc = block.LastChild;
		if (!(ptrType.nil === lastc) && (16 === lastc.Type)) {
			tokens = lastc.Tokens;
			valueLen = tokens.$length;
			if (32 === (x = valueLen - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]))) {
				_tuple = lex.TrimRight(tokens);
				lastc.Tokens = _tuple[1];
				if (1 < valueLen) {
					isHardBreak = 32 === (x$1 = tokens.$length - 2 >> 0, ((x$1 < 0 || x$1 >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x$1]));
				}
			}
		}
		ret = new ast.Node.ptr(32, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, new sliceType([(x$2 = ctx.tokens, ((pos < 0 || pos >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + pos]))]), false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		if (isHardBreak) {
			ret.Type = 31;
		}
		return ret;
	};
	Tree.prototype.parseNewline = function(block, ctx) { return this.$val.parseNewline(block, ctx); };
	Tree.ptr.prototype.mergeText = function(node) {
		var child, next, node, t;
		t = this;
		child = node.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			next = child.Next;
			if (16 === child.Type) {
				while (true) {
					if (!(!(ptrType.nil === next) && (16 === next.Type))) { break; }
					child.AppendTokens(next.Tokens);
					next.Unlink();
					next = child.Next;
				}
			} else {
				t.mergeText(child);
			}
			child = next;
		}
	};
	Tree.prototype.mergeText = function(node) { return this.$val.mergeText(node); };
	Tree.ptr.prototype.parseThematicBreak = function() {
		var _tmp, _tmp$1, caretInLn, caretTokens, i, length, ln, marker, markerCnt, ok, t, token;
		ok = false;
		caretTokens = sliceType.nil;
		t = this;
		markerCnt = 0;
		marker = 0;
		ln = t.Context.currentLine;
		caretInLn = false;
		length = ln.$length;
		i = t.Context.nextNonspace;
		while (true) {
			if (!(i < (length - 1 >> 0))) { break; }
			token = ((i < 0 || i >= ln.$length) ? ($throwRuntimeError("index out of range"), undefined) : ln.$array[ln.$offset + i]);
			if ((32 === token) || (9 === token)) {
				i = i + (1) >> 0;
				continue;
			}
			if (!((45 === token)) && !((95 === token)) && !((42 === token))) {
				return [ok, caretTokens];
			}
			if (!((0 === marker))) {
				if (!((marker === token))) {
					return [ok, caretTokens];
				}
			} else {
				marker = token;
			}
			markerCnt = markerCnt + (1) >> 0;
			i = i + (1) >> 0;
		}
		if (t.Context.Option.VditorWYSIWYG && caretInLn) {
			caretTokens = (new sliceType($stringToBytes("\xE2\x80\xB8")));
		}
		_tmp = 3 <= markerCnt;
		_tmp$1 = caretTokens;
		ok = _tmp;
		caretTokens = _tmp$1;
		return [ok, caretTokens];
	};
	Tree.prototype.parseThematicBreak = function() { return this.$val.parseThematicBreak(); };
	Context.ptr.prototype.parseToC = function(paragraph) {
		var _r, content, context, lines, paragraph, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; content = $f.content; context = $f.context; lines = $f.lines; paragraph = $f.paragraph; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		context = this;
		lines = lex.Split(paragraph.Tokens, 10);
		if (!((1 === lines.$length))) {
			$s = -1; return ptrType.nil;
		}
		_r = bytes.TrimSpace((0 >= lines.$length ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + 0])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		content = _r;
		tokens = content;
		if (context.Option.VditorWYSIWYG) {
			content = bytes.ReplaceAll(content, (new sliceType($stringToBytes("\xE2\x80\xB8"))), sliceType.nil);
		}
		if (!bytes.EqualFold(content, (new sliceType($stringToBytes("[toc]"))))) {
			$s = -1; return ptrType.nil;
		}
		$s = -1; return new ast.Node.ptr(600, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, tokens, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Context.ptr.prototype.parseToC }; } $f._r = _r; $f.content = content; $f.context = context; $f.lines = lines; $f.paragraph = paragraph; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	Context.prototype.parseToC = function(paragraph) { return this.$val.parseToC(paragraph); };
	ptrType$4.methods = [{prop: "isFencedCodeClose", name: "isFencedCodeClose", pkg: "lute/parse", typ: $funcType([sliceType, $Uint8, $Int], [$Bool, sliceType], false)}, {prop: "FindFootnotesDef", name: "FindFootnotesDef", pkg: "", typ: $funcType([sliceType], [$Int, ptrType], false)}, {prop: "parseInlineLinkDest", name: "parseInlineLinkDest", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType, sliceType, sliceType], false)}, {prop: "RelativePath", name: "RelativePath", pkg: "", typ: $funcType([sliceType], [sliceType], false)}, {prop: "isRelativePath", name: "isRelativePath", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool], false)}, {prop: "parseLinkRefDef", name: "parseLinkRefDef", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType], false)}, {prop: "parseLinkTitle", name: "parseLinkTitle", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool, sliceType, sliceType, sliceType], false)}, {prop: "parseLinkTitleMatch", name: "parseLinkTitleMatch", pkg: "lute/parse", typ: $funcType([$Uint8, $Uint8, sliceType], [$Bool, sliceType, sliceType, sliceType], false)}, {prop: "parseLinkDest", name: "parseLinkDest", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType, sliceType, sliceType], false)}, {prop: "parseLinkDest2", name: "parseLinkDest2", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType, sliceType, sliceType], false)}, {prop: "parseLinkDest1", name: "parseLinkDest1", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType, sliceType, sliceType], false)}, {prop: "parseLinkLabel", name: "parseLinkLabel", pkg: "lute/parse", typ: $funcType([sliceType], [$Int, sliceType, sliceType], false)}, {prop: "advanceOffset", name: "advanceOffset", pkg: "lute/parse", typ: $funcType([$Int, $Bool], [], false)}, {prop: "advanceNextNonspace", name: "advanceNextNonspace", pkg: "lute/parse", typ: $funcType([], [], false)}, {prop: "findNextNonspace", name: "findNextNonspace", pkg: "lute/parse", typ: $funcType([], [], false)}, {prop: "closeUnmatchedBlocks", name: "closeUnmatchedBlocks", pkg: "lute/parse", typ: $funcType([], [], false)}, {prop: "finalize", name: "finalize", pkg: "lute/parse", typ: $funcType([ptrType, $Int], [], false)}, {prop: "addChildMarker", name: "addChildMarker", pkg: "lute/parse", typ: $funcType([ast.NodeType, sliceType], [ptrType], false)}, {prop: "addChild", name: "addChild", pkg: "lute/parse", typ: $funcType([ast.NodeType, $Int], [ptrType], false)}, {prop: "listsMatch", name: "listsMatch", pkg: "lute/parse", typ: $funcType([ptrType$1, ptrType$1], [$Bool], false)}, {prop: "ParentTip", name: "ParentTip", pkg: "", typ: $funcType([], [], false)}, {prop: "parseTable", name: "parseTable", pkg: "lute/parse", typ: $funcType([ptrType], [ptrType, ptrType], false)}, {prop: "parseTable0", name: "parseTable0", pkg: "lute/parse", typ: $funcType([sliceType], [ptrType], false)}, {prop: "newTableHead", name: "newTableHead", pkg: "lute/parse", typ: $funcType([ptrType], [ptrType], false)}, {prop: "parseTableRow", name: "parseTableRow", pkg: "lute/parse", typ: $funcType([sliceType, sliceType$3, $Bool], [ptrType], false)}, {prop: "parseTableDelimRow", name: "parseTableDelimRow", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType$3], false)}, {prop: "tableDelimAlign", name: "tableDelimAlign", pkg: "lute/parse", typ: $funcType([sliceType], [$Int], false)}, {prop: "parseToC", name: "parseToC", pkg: "lute/parse", typ: $funcType([ptrType], [ptrType], false)}];
	ptrType$3.methods = [{prop: "parseGFMAutoEmailLink", name: "parseGFMAutoEmailLink", pkg: "lute/parse", typ: $funcType([ptrType], [], false)}, {prop: "parseGFMAutoLink", name: "parseGFMAutoLink", pkg: "lute/parse", typ: $funcType([ptrType], [], false)}, {prop: "parseGFMAutoEmailLink0", name: "parseGFMAutoEmailLink0", pkg: "lute/parse", typ: $funcType([ptrType], [], false)}, {prop: "isValidEmailSegment1", name: "isValidEmailSegment1", pkg: "lute/parse", typ: $funcType([$Uint8], [$Bool], false)}, {prop: "isValidEmailSegment2", name: "isValidEmailSegment2", pkg: "lute/parse", typ: $funcType([$Uint8], [$Bool], false)}, {prop: "parseGFMAutoLink0", name: "parseGFMAutoLink0", pkg: "lute/parse", typ: $funcType([ptrType], [], false)}, {prop: "isValidDomain", name: "isValidDomain", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool], false)}, {prop: "parseAutoEmailLink", name: "parseAutoEmailLink", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "newLink", name: "newLink", pkg: "lute/parse", typ: $funcType([ast.NodeType, sliceType, sliceType, sliceType, $Int], [ptrType], false)}, {prop: "parseAutolink", name: "parseAutolink", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "addPreviousText", name: "addPreviousText", pkg: "lute/parse", typ: $funcType([ptrType, sliceType], [], false)}, {prop: "parseBlocks", name: "parseBlocks", pkg: "lute/parse", typ: $funcType([], [], false)}, {prop: "incorporateLine", name: "incorporateLine", pkg: "lute/parse", typ: $funcType([sliceType], [], false)}, {prop: "addLine", name: "addLine", pkg: "lute/parse", typ: $funcType([], [], false)}, {prop: "parseFencedCode", name: "parseFencedCode", pkg: "lute/parse", typ: $funcType([], [$Bool, $Uint8, $Int, $Int, sliceType, sliceType], false)}, {prop: "parseCodeSpan", name: "parseCodeSpan", pkg: "lute/parse", typ: $funcType([ptrType, ptrType$6], [ptrType], false)}, {prop: "matchCodeSpanEnd", name: "matchCodeSpanEnd", pkg: "lute/parse", typ: $funcType([sliceType, $Int], [$Int], false)}, {prop: "handleDelim", name: "handleDelim", pkg: "lute/parse", typ: $funcType([ptrType, ptrType$6], [], false)}, {prop: "processEmphasis", name: "processEmphasis", pkg: "lute/parse", typ: $funcType([ptrType$2, ptrType$6], [], false)}, {prop: "scanDelims", name: "scanDelims", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType$2], false)}, {prop: "removeDelimiter", name: "removeDelimiter", pkg: "lute/parse", typ: $funcType([ptrType$2, ptrType$6], [ptrType$2], false)}, {prop: "emoji", name: "emoji", pkg: "lute/parse", typ: $funcType([ptrType], [], false)}, {prop: "emoji0", name: "emoji0", pkg: "lute/parse", typ: $funcType([ptrType], [], false)}, {prop: "EmojiImgTokens", name: "EmojiImgTokens", pkg: "", typ: $funcType([$String, $String], [sliceType], false)}, {prop: "parseATXHeading", name: "parseATXHeading", pkg: "lute/parse", typ: $funcType([], [$Bool, sliceType, sliceType, $Int, sliceType], false)}, {prop: "parseSetextHeading", name: "parseSetextHeading", pkg: "lute/parse", typ: $funcType([], [$Int], false)}, {prop: "parseHeadingID", name: "parseHeadingID", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType], false)}, {prop: "isHTMLBlockClose", name: "isHTMLBlockClose", pkg: "lute/parse", typ: $funcType([sliceType, $Int], [$Bool], false)}, {prop: "parseHTML", name: "parseHTML", pkg: "lute/parse", typ: $funcType([sliceType], [$Int], false)}, {prop: "isOpenTag", name: "isOpenTag", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool], false)}, {prop: "isCloseTag", name: "isCloseTag", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool], false)}, {prop: "parseBang", name: "parseBang", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "parseInline", name: "parseInline", pkg: "lute/parse", typ: $funcType([ptrType, ptrType$6], [], false)}, {prop: "parseEntity", name: "parseEntity", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "parseCloseBracket", name: "parseCloseBracket", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "parseOpenBracket", name: "parseOpenBracket", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "addBracket", name: "addBracket", pkg: "lute/parse", typ: $funcType([ptrType, $Int, $Bool, ptrType$6], [], false)}, {prop: "removeBracket", name: "removeBracket", pkg: "lute/parse", typ: $funcType([ptrType$6], [], false)}, {prop: "parseInlineHTML", name: "parseInlineHTML", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "parseCDATA", name: "parseCDATA", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseDeclaration", name: "parseDeclaration", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseProcessingInstruction", name: "parseProcessingInstruction", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseHTMLComment", name: "parseHTMLComment", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseTagAttr", name: "parseTagAttr", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseAttrValSpec", name: "parseAttrValSpec", pkg: "lute/parse", typ: $funcType([sliceType], [$Bool, sliceType, sliceType], false)}, {prop: "parseAttrName", name: "parseAttrName", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType, sliceType], false)}, {prop: "parseTagName", name: "parseTagName", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType, sliceType], false)}, {prop: "parseInlineMath", name: "parseInlineMath", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "matchInlineMathEnd", name: "matchInlineMathEnd", pkg: "lute/parse", typ: $funcType([sliceType], [$Int], false)}, {prop: "parseInlines", name: "parseInlines", pkg: "lute/parse", typ: $funcType([], [], false)}, {prop: "walkParseInline", name: "walkParseInline", pkg: "lute/parse", typ: $funcType([ptrType], [], false)}, {prop: "parseListMarker", name: "parseListMarker", pkg: "lute/parse", typ: $funcType([ptrType], [ptrType$1], false)}, {prop: "parseOrderedListMarker", name: "parseOrderedListMarker", pkg: "lute/parse", typ: $funcType([sliceType], [sliceType, $Uint8], false)}, {prop: "parseMathBlock", name: "parseMathBlock", pkg: "lute/parse", typ: $funcType([], [$Bool, $Int], false)}, {prop: "parseText", name: "parseText", pkg: "lute/parse", typ: $funcType([ptrType$6], [ptrType], false)}, {prop: "isMarker", name: "isMarker", pkg: "lute/parse", typ: $funcType([$Uint8], [$Bool], false)}, {prop: "parseBackslash", name: "parseBackslash", pkg: "lute/parse", typ: $funcType([ptrType, ptrType$6], [ptrType], false)}, {prop: "parseNewline", name: "parseNewline", pkg: "lute/parse", typ: $funcType([ptrType, ptrType$6], [ptrType], false)}, {prop: "mergeText", name: "mergeText", pkg: "lute/parse", typ: $funcType([ptrType], [], false)}, {prop: "parseThematicBreak", name: "parseThematicBreak", pkg: "lute/parse", typ: $funcType([], [$Bool, sliceType], false)}];
	blockStartFunc.init([ptrType$3, ptrType], [$Int], false);
	delimiter.init("lute/parse", [{prop: "node", name: "node", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "typ", name: "typ", embedded: false, exported: false, typ: $Uint8, tag: ""}, {prop: "num", name: "num", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "originalNum", name: "originalNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "canOpen", name: "canOpen", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "canClose", name: "canClose", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "previous", name: "previous", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "next", name: "next", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "active", name: "active", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "image", name: "image", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "bracketAfter", name: "bracketAfter", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "index", name: "index", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "previousDelimiter", name: "previousDelimiter", embedded: false, exported: false, typ: ptrType$2, tag: ""}]);
	Context.init("lute/parse", [{prop: "Tree", name: "Tree", embedded: false, exported: true, typ: ptrType$3, tag: ""}, {prop: "Option", name: "Option", embedded: false, exported: true, typ: ptrType$7, tag: ""}, {prop: "LinkRefDefs", name: "LinkRefDefs", embedded: false, exported: true, typ: mapType, tag: ""}, {prop: "FootnotesDefs", name: "FootnotesDefs", embedded: false, exported: true, typ: sliceType$4, tag: ""}, {prop: "Tip", name: "Tip", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "oldtip", name: "oldtip", embedded: false, exported: false, typ: ptrType, tag: ""}, {prop: "currentLine", name: "currentLine", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "currentLineLen", name: "currentLineLen", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lineNum", name: "lineNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "offset", name: "offset", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "column", name: "column", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "nextNonspace", name: "nextNonspace", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "nextNonspaceColumn", name: "nextNonspaceColumn", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "indent", name: "indent", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "indented", name: "indented", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "blank", name: "blank", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "partiallyConsumedTab", name: "partiallyConsumedTab", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "allClosed", name: "allClosed", embedded: false, exported: false, typ: $Bool, tag: ""}, {prop: "lastMatchedContainer", name: "lastMatchedContainer", embedded: false, exported: false, typ: ptrType, tag: ""}]);
	InlineContext.init("lute/parse", [{prop: "tokens", name: "tokens", embedded: false, exported: false, typ: sliceType, tag: ""}, {prop: "tokensLen", name: "tokensLen", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "pos", name: "pos", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "lineNum", name: "lineNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "columnNum", name: "columnNum", embedded: false, exported: false, typ: $Int, tag: ""}, {prop: "delimiters", name: "delimiters", embedded: false, exported: false, typ: ptrType$2, tag: ""}, {prop: "brackets", name: "brackets", embedded: false, exported: false, typ: ptrType$2, tag: ""}]);
	Tree.init("lute/parse", [{prop: "Name", name: "Name", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Root", name: "Root", embedded: false, exported: true, typ: ptrType, tag: ""}, {prop: "Context", name: "Context", embedded: false, exported: true, typ: ptrType$4, tag: ""}, {prop: "lexer", name: "lexer", embedded: false, exported: false, typ: ptrType$5, tag: ""}, {prop: "inlineContext", name: "inlineContext", embedded: false, exported: false, typ: ptrType$6, tag: ""}]);
	Options.init("", [{prop: "GFMTable", name: "GFMTable", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "GFMTaskListItem", name: "GFMTaskListItem", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "GFMTaskListItemClass", name: "GFMTaskListItemClass", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "GFMStrikethrough", name: "GFMStrikethrough", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "GFMAutoLink", name: "GFMAutoLink", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "SoftBreak2HardBreak", name: "SoftBreak2HardBreak", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlight", name: "CodeSyntaxHighlight", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlightDetectLang", name: "CodeSyntaxHighlightDetectLang", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlightInlineStyle", name: "CodeSyntaxHighlightInlineStyle", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlightLineNum", name: "CodeSyntaxHighlightLineNum", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "CodeSyntaxHighlightStyleName", name: "CodeSyntaxHighlightStyleName", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "Footnotes", name: "Footnotes", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "ToC", name: "ToC", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "HeadingID", name: "HeadingID", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "AutoSpace", name: "AutoSpace", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "FixTermTypo", name: "FixTermTypo", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "ChinesePunct", name: "ChinesePunct", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "Emoji", name: "Emoji", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "AliasEmoji", name: "AliasEmoji", embedded: false, exported: true, typ: mapType$1, tag: ""}, {prop: "EmojiAlias", name: "EmojiAlias", embedded: false, exported: true, typ: mapType$1, tag: ""}, {prop: "EmojiSite", name: "EmojiSite", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "HeadingAnchor", name: "HeadingAnchor", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "Terms", name: "Terms", embedded: false, exported: true, typ: mapType$1, tag: ""}, {prop: "VditorWYSIWYG", name: "VditorWYSIWYG", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "VditorIR", name: "VditorIR", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "InlineMathAllowDigitAfterOpenMarker", name: "InlineMathAllowDigitAfterOpenMarker", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "LinkBase", name: "LinkBase", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "VditorCodeBlockPreview", name: "VditorCodeBlockPreview", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "RenderListMarker", name: "RenderListMarker", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "Setext", name: "Setext", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "Sanitize", name: "Sanitize", embedded: false, exported: true, typ: $Bool, tag: ""}, {prop: "ImageLazyLoading", name: "ImageLazyLoading", embedded: false, exported: true, typ: $String, tag: ""}, {prop: "ChineseParagraphBeginningSpace", name: "ChineseParagraphBeginningSpace", embedded: false, exported: true, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = ast.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = lex.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = util.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		unicodeAliasEmojiMap = false;
		mailto = util.StrToBytes("mailto:");
		httpProto = util.StrToBytes("http://");
		validAutoLinkDomainSuffix = new sliceType$1([util.StrToBytes("top"), util.StrToBytes("com"), util.StrToBytes("net"), util.StrToBytes("org"), util.StrToBytes("edu"), util.StrToBytes("gov"), util.StrToBytes("cn"), util.StrToBytes("io"), util.StrToBytes("me"), util.StrToBytes("biz"), util.StrToBytes("co"), util.StrToBytes("live"), util.StrToBytes("pro"), util.StrToBytes("xyz"), util.StrToBytes("win"), util.StrToBytes("club"), util.StrToBytes("tv"), util.StrToBytes("wiki"), util.StrToBytes("site"), util.StrToBytes("tech"), util.StrToBytes("space"), util.StrToBytes("cc"), util.StrToBytes("name"), util.StrToBytes("social"), util.StrToBytes("band"), util.StrToBytes("pub"), util.StrToBytes("info")]);
		markers = util.StrToBytes(".!#$%&'*+/=?^_`{|}~");
		codeBlockBacktick = util.StrToBytes("`");
		$pkg.EmojiSitePlaceholder = util.StrToBytes("${emojiSite}");
		emojiDot = util.StrToBytes(".");
		aliasUnicodeEmojiMap = $makeMap($String.keyFor, [{ k: "+1", v: "\xF0\x9F\x91\x8D" }, { k: "-1", v: "\xF0\x9F\x91\x8E" }, { k: "100", v: "\xF0\x9F\x92\xAF" }, { k: "1234", v: "\xF0\x9F\x94\xA2" }, { k: "1st_place_medal", v: "\xF0\x9F\xA5\x87" }, { k: "2nd_place_medal", v: "\xF0\x9F\xA5\x88" }, { k: "3rd_place_medal", v: "\xF0\x9F\xA5\x89" }, { k: "8ball", v: "\xF0\x9F\x8E\xB1" }, { k: "a", v: "\xF0\x9F\x85\xB0\xEF\xB8\x8F" }, { k: "ab", v: "\xF0\x9F\x86\x8E" }, { k: "abc", v: "\xF0\x9F\x94\xA4" }, { k: "abcd", v: "\xF0\x9F\x94\xA1" }, { k: "Accept", v: "\xF0\x9F\x89\x91" }, { k: "aerial_tramway", v: "\xF0\x9F\x9A\xA1" }, { k: "afghanistan", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xAB" }, { k: "airplane", v: "\xE2\x9C\x88\xEF\xB8\x8F" }, { k: "aland_islands", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xBD" }, { k: "alarm_clock", v: "\xE2\x8F\xB0" }, { k: "albania", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB1" }, { k: "alembic", v: "\xE2\x9A\x97\xEF\xB8\x8F" }, { k: "algeria", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xBF" }, { k: "alien", v: "\xF0\x9F\x91\xBD" }, { k: "ambulance", v: "\xF0\x9F\x9A\x91" }, { k: "american_samoa", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB8" }, { k: "amphora", v: "\xF0\x9F\x8F\xBA" }, { k: "anchor", v: "\xE2\x9A\x93\xEF\xB8\x8F" }, { k: "andorra", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xA9" }, { k: "angel", v: "\xF0\x9F\x91\xBC" }, { k: "anger", v: "\xF0\x9F\x92\xA2" }, { k: "angola", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB4" }, { k: "angry", v: "\xF0\x9F\x98\xA0" }, { k: "anguilla", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xAE" }, { k: "anguished", v: "\xF0\x9F\x98\xA7" }, { k: "ant", v: "\xF0\x9F\x90\x9C" }, { k: "antarctica", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB6" }, { k: "antigua_barbuda", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xAC" }, { k: "apple", v: "\xF0\x9F\x8D\x8E" }, { k: "aquarius", v: "\xE2\x99\x92\xEF\xB8\x8F" }, { k: "argentina", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB7" }, { k: "aries", v: "\xE2\x99\x88\xEF\xB8\x8F" }, { k: "armenia", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB2" }, { k: "arrow_backward", v: "\xE2\x97\x80\xEF\xB8\x8F" }, { k: "arrow_double_down", v: "\xE2\x8F\xAC" }, { k: "arrow_double_up", v: "\xE2\x8F\xAB" }, { k: "arrow_down", v: "\xE2\xAC\x87\xEF\xB8\x8F" }, { k: "arrow_down_small", v: "\xF0\x9F\x94\xBD" }, { k: "arrow_forward", v: "\xE2\x96\xB6\xEF\xB8\x8F" }, { k: "arrow_heading_down", v: "\xE2\xA4\xB5\xEF\xB8\x8F" }, { k: "arrow_heading_up", v: "\xE2\xA4\xB4\xEF\xB8\x8F" }, { k: "arrow_left", v: "\xE2\xAC\x85\xEF\xB8\x8F" }, { k: "arrow_lower_left", v: "\xE2\x86\x99\xEF\xB8\x8F" }, { k: "arrow_lower_right", v: "\xE2\x86\x98\xEF\xB8\x8F" }, { k: "arrow_right", v: "\xE2\x9E\xA1\xEF\xB8\x8F" }, { k: "arrow_right_hook", v: "\xE2\x86\xAA\xEF\xB8\x8F" }, { k: "arrow_up", v: "\xE2\xAC\x86\xEF\xB8\x8F" }, { k: "arrow_up_down", v: "\xE2\x86\x95\xEF\xB8\x8F" }, { k: "arrow_up_small", v: "\xF0\x9F\x94\xBC" }, { k: "arrow_upper_left", v: "\xE2\x86\x96\xEF\xB8\x8F" }, { k: "arrow_upper_right", v: "\xE2\x86\x97\xEF\xB8\x8F" }, { k: "arrows_clockwise", v: "\xF0\x9F\x94\x83" }, { k: "arrows_counterclockwise", v: "\xF0\x9F\x94\x84" }, { k: "art", v: "\xF0\x9F\x8E\xA8" }, { k: "articulated_lorry", v: "\xF0\x9F\x9A\x9B" }, { k: "artificial_satellite", v: "\xF0\x9F\x9B\xB0" }, { k: "aruba", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xBC" }, { k: "asterisk", v: "*\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "astonished", v: "\xF0\x9F\x98\xB2" }, { k: "athletic_shoe", v: "\xF0\x9F\x91\x9F" }, { k: "atm", v: "\xF0\x9F\x8F\xA7" }, { k: "atom_symbol", v: "\xE2\x9A\x9B\xEF\xB8\x8F" }, { k: "australia", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xBA" }, { k: "austria", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xB9" }, { k: "avocado", v: "\xF0\x9F\xA5\x91" }, { k: "azerbaijan", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xBF" }, { k: "b", v: "\xF0\x9F\x85\xB1\xEF\xB8\x8F" }, { k: "b3log", v: "${emojiSite}/b3log.png" }, { k: "baby", v: "\xF0\x9F\x91\xB6" }, { k: "baby_bottle", v: "\xF0\x9F\x8D\xBC" }, { k: "baby_chick", v: "\xF0\x9F\x90\xA4" }, { k: "baby_symbol", v: "\xF0\x9F\x9A\xBC" }, { k: "back", v: "\xF0\x9F\x94\x99" }, { k: "bacon", v: "\xF0\x9F\xA5\x93" }, { k: "badminton", v: "\xF0\x9F\x8F\xB8" }, { k: "baggage_claim", v: "\xF0\x9F\x9B\x84" }, { k: "baguette_bread", v: "\xF0\x9F\xA5\x96" }, { k: "bahamas", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB8" }, { k: "bahrain", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAD" }, { k: "balance_scale", v: "\xE2\x9A\x96\xEF\xB8\x8F" }, { k: "balloon", v: "\xF0\x9F\x8E\x88" }, { k: "ballot_box", v: "\xF0\x9F\x97\xB3" }, { k: "ballot_box_with_check", v: "\xE2\x98\x91\xEF\xB8\x8F" }, { k: "bamboo", v: "\xF0\x9F\x8E\x8D" }, { k: "banana", v: "\xF0\x9F\x8D\x8C" }, { k: "bangbang", v: "\xE2\x80\xBC\xEF\xB8\x8F" }, { k: "bangladesh", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xA9" }, { k: "bank", v: "\xF0\x9F\x8F\xA6" }, { k: "bar_chart", v: "\xF0\x9F\x93\x8A" }, { k: "barbados", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xA7" }, { k: "barber", v: "\xF0\x9F\x92\x88" }, { k: "baseball", v: "\xE2\x9A\xBE\xEF\xB8\x8F" }, { k: "basketball", v: "\xF0\x9F\x8F\x80" }, { k: "basketball_man", v: "\xE2\x9B\xB9" }, { k: "basketball_woman", v: "\xE2\x9B\xB9\xEF\xB8\x8F\xE2\x80\x8D\xE2\x99\x80\xEF\xB8\x8F" }, { k: "bat", v: "\xF0\x9F\xA6\x87" }, { k: "bath", v: "\xF0\x9F\x9B\x80" }, { k: "bathtub", v: "\xF0\x9F\x9B\x81" }, { k: "battery", v: "\xF0\x9F\x94\x8B" }, { k: "beach_umbrella", v: "\xF0\x9F\x8F\x96" }, { k: "bear", v: "\xF0\x9F\x90\xBB" }, { k: "bed", v: "\xF0\x9F\x9B\x8F" }, { k: "bee", v: "\xF0\x9F\x90\x9D" }, { k: "beer", v: "\xF0\x9F\x8D\xBA" }, { k: "beers", v: "\xF0\x9F\x8D\xBB" }, { k: "beetle", v: "\xF0\x9F\x90\x9E" }, { k: "beginner", v: "\xF0\x9F\x94\xB0" }, { k: "belarus", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xBE" }, { k: "belgium", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAA" }, { k: "belize", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xBF" }, { k: "bell", v: "\xF0\x9F\x94\x94" }, { k: "bellhop_bell", v: "\xF0\x9F\x9B\x8E" }, { k: "benin", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAF" }, { k: "bento", v: "\xF0\x9F\x8D\xB1" }, { k: "bermuda", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB2" }, { k: "bhutan", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB9" }, { k: "bicyclist", v: "\xF0\x9F\x9A\xB4" }, { k: "bike", v: "\xF0\x9F\x9A\xB2" }, { k: "biking_man", v: "\xF0\x9F\x9A\xB4" }, { k: "biking_woman", v: "\xF0\x9F\x9A\xB4\xE2\x80\x8D\xE2\x99\x80" }, { k: "bikini", v: "\xF0\x9F\x91\x99" }, { k: "biohazard", v: "\xE2\x98\xA3\xEF\xB8\x8F" }, { k: "bird", v: "\xF0\x9F\x90\xA6" }, { k: "birthday", v: "\xF0\x9F\x8E\x82" }, { k: "black_circle", v: "\xE2\x9A\xAB\xEF\xB8\x8F" }, { k: "black_flag", v: "\xF0\x9F\x8F\xB4" }, { k: "black_heart", v: "\xF0\x9F\x96\xA4" }, { k: "black_joker", v: "\xF0\x9F\x83\x8F" }, { k: "black_large_square", v: "\xE2\xAC\x9B\xEF\xB8\x8F" }, { k: "black_medium_small_square", v: "\xE2\x97\xBE\xEF\xB8\x8F" }, { k: "black_medium_square", v: "\xE2\x97\xBC\xEF\xB8\x8F" }, { k: "black_nib", v: "\xE2\x9C\x92\xEF\xB8\x8F" }, { k: "black_small_square", v: "\xE2\x96\xAA\xEF\xB8\x8F" }, { k: "black_square_button", v: "\xF0\x9F\x94\xB2" }, { k: "blonde_man", v: "\xF0\x9F\x91\xB1" }, { k: "blonde_woman", v: "\xF0\x9F\x91\xB1\xE2\x80\x8D\xE2\x99\x80" }, { k: "blossom", v: "\xF0\x9F\x8C\xBC" }, { k: "blowfish", v: "\xF0\x9F\x90\xA1" }, { k: "blue_book", v: "\xF0\x9F\x93\x98" }, { k: "blue_car", v: "\xF0\x9F\x9A\x99" }, { k: "blue_heart", v: "\xF0\x9F\x92\x99" }, { k: "blush", v: "\xF0\x9F\x98\x8A" }, { k: "boar", v: "\xF0\x9F\x90\x97" }, { k: "boat", v: "\xE2\x9B\xB5\xEF\xB8\x8F" }, { k: "bolivia", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB4" }, { k: "bomb", v: "\xF0\x9F\x92\xA3" }, { k: "book", v: "\xF0\x9F\x93\x96" }, { k: "bookmark", v: "\xF0\x9F\x94\x96" }, { k: "bookmark_tabs", v: "\xF0\x9F\x93\x91" }, { k: "books", v: "\xF0\x9F\x93\x9A" }, { k: "boom", v: "\xF0\x9F\x92\xA5" }, { k: "boot", v: "\xF0\x9F\x91\xA2" }, { k: "bosnia_herzegovina", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xA6" }, { k: "botswana", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xBC" }, { k: "bouquet", v: "\xF0\x9F\x92\x90" }, { k: "bow", v: "\xF0\x9F\x99\x87" }, { k: "bow_and_arrow", v: "\xF0\x9F\x8F\xB9" }, { k: "bowing_man", v: "\xF0\x9F\x99\x87" }, { k: "bowing_woman", v: "\xF0\x9F\x99\x87\xE2\x80\x8D\xE2\x99\x80" }, { k: "bowling", v: "\xF0\x9F\x8E\xB3" }, { k: "boxing_glove", v: "\xF0\x9F\xA5\x8A" }, { k: "boy", v: "\xF0\x9F\x91\xA6" }, { k: "brazil", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB7" }, { k: "bread", v: "\xF0\x9F\x8D\x9E" }, { k: "bride_with_veil", v: "\xF0\x9F\x91\xB0" }, { k: "bridge_at_night", v: "\xF0\x9F\x8C\x89" }, { k: "briefcase", v: "\xF0\x9F\x92\xBC" }, { k: "british_indian_ocean_territory", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB4" }, { k: "british_virgin_islands", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xAC" }, { k: "broken_heart", v: "\xF0\x9F\x92\x94" }, { k: "brunei", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB3" }, { k: "bug", v: "\xF0\x9F\x90\x9B" }, { k: "building_construction", v: "\xF0\x9F\x8F\x97" }, { k: "bulb", v: "\xF0\x9F\x92\xA1" }, { k: "bulgaria", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAC" }, { k: "bullettrain_front", v: "\xF0\x9F\x9A\x85" }, { k: "bullettrain_side", v: "\xF0\x9F\x9A\x84" }, { k: "burkina_faso", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAB" }, { k: "burrito", v: "\xF0\x9F\x8C\xAF" }, { k: "burundi", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xAE" }, { k: "bus", v: "\xF0\x9F\x9A\x8C" }, { k: "business_suit_levitating", v: "\xF0\x9F\x95\xB4" }, { k: "busstop", v: "\xF0\x9F\x9A\x8F" }, { k: "bust_in_silhouette", v: "\xF0\x9F\x91\xA4" }, { k: "busts_in_silhouette", v: "\xF0\x9F\x91\xA5" }, { k: "butterfly", v: "\xF0\x9F\xA6\x8B" }, { k: "cactus", v: "\xF0\x9F\x8C\xB5" }, { k: "cake", v: "\xF0\x9F\x8D\xB0" }, { k: "calendar", v: "\xF0\x9F\x93\x86" }, { k: "call_me_hand", v: "\xF0\x9F\xA4\x99" }, { k: "calling", v: "\xF0\x9F\x93\xB2" }, { k: "cambodia", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xAD" }, { k: "camel", v: "\xF0\x9F\x90\xAB" }, { k: "camera", v: "\xF0\x9F\x93\xB7" }, { k: "camera_flash", v: "\xF0\x9F\x93\xB8" }, { k: "cameroon", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB2" }, { k: "camping", v: "\xF0\x9F\x8F\x95" }, { k: "canada", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xA6" }, { k: "canary_islands", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xA8" }, { k: "cancer", v: "\xE2\x99\x8B\xEF\xB8\x8F" }, { k: "candle", v: "\xF0\x9F\x95\xAF" }, { k: "candy", v: "\xF0\x9F\x8D\xAC" }, { k: "canoe", v: "\xF0\x9F\x9B\xB6" }, { k: "cape_verde", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBB" }, { k: "capital_abcd", v: "\xF0\x9F\x94\xA0" }, { k: "capricorn", v: "\xE2\x99\x91\xEF\xB8\x8F" }, { k: "car", v: "\xF0\x9F\x9A\x97" }, { k: "card_file_box", v: "\xF0\x9F\x97\x83" }, { k: "card_index", v: "\xF0\x9F\x93\x87" }, { k: "card_index_dividers", v: "\xF0\x9F\x97\x82" }, { k: "caribbean_netherlands", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB6" }, { k: "carousel_horse", v: "\xF0\x9F\x8E\xA0" }, { k: "carrot", v: "\xF0\x9F\xA5\x95" }, { k: "cat", v: "\xF0\x9F\x90\xB1" }, { k: "cat2", v: "\xF0\x9F\x90\x88" }, { k: "cayman_islands", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xBE" }, { k: "cd", v: "\xF0\x9F\x92\xBF" }, { k: "central_african_republic", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xAB" }, { k: "chad", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xA9" }, { k: "chainbook", v: "${emojiSite}/chainbook.png" }, { k: "chains", v: "\xE2\x9B\x93" }, { k: "champagne", v: "\xF0\x9F\x8D\xBE" }, { k: "chart", v: "\xF0\x9F\x92\xB9" }, { k: "chart_with_downwards_trend", v: "\xF0\x9F\x93\x89" }, { k: "chart_with_upwards_trend", v: "\xF0\x9F\x93\x88" }, { k: "checkered_flag", v: "\xF0\x9F\x8F\x81" }, { k: "cheese", v: "\xF0\x9F\xA7\x80" }, { k: "cherries", v: "\xF0\x9F\x8D\x92" }, { k: "cherry_blossom", v: "\xF0\x9F\x8C\xB8" }, { k: "chestnut", v: "\xF0\x9F\x8C\xB0" }, { k: "chicken", v: "\xF0\x9F\x90\x94" }, { k: "children_crossing", v: "\xF0\x9F\x9A\xB8" }, { k: "chile", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB1" }, { k: "chipmunk", v: "\xF0\x9F\x90\xBF" }, { k: "chocolate_bar", v: "\xF0\x9F\x8D\xAB" }, { k: "christmas_island", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBD" }, { k: "christmas_tree", v: "\xF0\x9F\x8E\x84" }, { k: "church", v: "\xE2\x9B\xAA\xEF\xB8\x8F" }, { k: "cinema", v: "\xF0\x9F\x8E\xA6" }, { k: "circus_tent", v: "\xF0\x9F\x8E\xAA" }, { k: "city_sunrise", v: "\xF0\x9F\x8C\x87" }, { k: "city_sunset", v: "\xF0\x9F\x8C\x86" }, { k: "cityscape", v: "\xF0\x9F\x8F\x99" }, { k: "cl", v: "\xF0\x9F\x86\x91" }, { k: "clamp", v: "\xF0\x9F\x97\x9C" }, { k: "clap", v: "\xF0\x9F\x91\x8F" }, { k: "clapper", v: "\xF0\x9F\x8E\xAC" }, { k: "classical_building", v: "\xF0\x9F\x8F\x9B" }, { k: "clinking_glasses", v: "\xF0\x9F\xA5\x82" }, { k: "clipboard", v: "\xF0\x9F\x93\x8B" }, { k: "clock1", v: "\xF0\x9F\x95\x90" }, { k: "clock10", v: "\xF0\x9F\x95\x99" }, { k: "clock1030", v: "\xF0\x9F\x95\xA5" }, { k: "clock11", v: "\xF0\x9F\x95\x9A" }, { k: "clock1130", v: "\xF0\x9F\x95\xA6" }, { k: "clock12", v: "\xF0\x9F\x95\x9B" }, { k: "clock1230", v: "\xF0\x9F\x95\xA7" }, { k: "clock130", v: "\xF0\x9F\x95\x9C" }, { k: "clock2", v: "\xF0\x9F\x95\x91" }, { k: "clock230", v: "\xF0\x9F\x95\x9D" }, { k: "clock3", v: "\xF0\x9F\x95\x92" }, { k: "clock330", v: "\xF0\x9F\x95\x9E" }, { k: "clock4", v: "\xF0\x9F\x95\x93" }, { k: "clock430", v: "\xF0\x9F\x95\x9F" }, { k: "clock5", v: "\xF0\x9F\x95\x94" }, { k: "clock530", v: "\xF0\x9F\x95\xA0" }, { k: "clock6", v: "\xF0\x9F\x95\x95" }, { k: "clock630", v: "\xF0\x9F\x95\xA1" }, { k: "clock7", v: "\xF0\x9F\x95\x96" }, { k: "clock730", v: "\xF0\x9F\x95\xA2" }, { k: "clock8", v: "\xF0\x9F\x95\x97" }, { k: "clock830", v: "\xF0\x9F\x95\xA3" }, { k: "clock9", v: "\xF0\x9F\x95\x98" }, { k: "clock930", v: "\xF0\x9F\x95\xA4" }, { k: "closed_book", v: "\xF0\x9F\x93\x95" }, { k: "closed_lock_with_key", v: "\xF0\x9F\x94\x90" }, { k: "closed_umbrella", v: "\xF0\x9F\x8C\x82" }, { k: "cloud", v: "\xE2\x98\x81\xEF\xB8\x8F" }, { k: "cloud_with_lightning", v: "\xF0\x9F\x8C\xA9" }, { k: "cloud_with_lightning_and_rain", v: "\xE2\x9B\x88" }, { k: "cloud_with_rain", v: "\xF0\x9F\x8C\xA7" }, { k: "cloud_with_snow", v: "\xF0\x9F\x8C\xA8" }, { k: "clown_face", v: "\xF0\x9F\xA4\xA1" }, { k: "clubs", v: "\xE2\x99\xA3\xEF\xB8\x8F" }, { k: "cn", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB3" }, { k: "cocktail", v: "\xF0\x9F\x8D\xB8" }, { k: "cocos_islands", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xA8" }, { k: "coffee", v: "\xE2\x98\x95\xEF\xB8\x8F" }, { k: "coffin", v: "\xE2\x9A\xB0\xEF\xB8\x8F" }, { k: "cold_sweat", v: "\xF0\x9F\x98\xB0" }, { k: "collision", v: "\xF0\x9F\x92\xA5" }, { k: "colombia", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB4" }, { k: "comet", v: "\xE2\x98\x84" }, { k: "comoros", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xB2" }, { k: "computer", v: "\xF0\x9F\x92\xBB" }, { k: "computer_mouse", v: "\xF0\x9F\x96\xB1" }, { k: "confetti_ball", v: "\xF0\x9F\x8E\x8A" }, { k: "confounded", v: "\xF0\x9F\x98\x96" }, { k: "confused", v: "\xF0\x9F\x98\x95" }, { k: "congo_brazzaville", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xAC" }, { k: "congo_kinshasa", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xA9" }, { k: "congratulations", v: "\xE3\x8A\x97\xEF\xB8\x8F" }, { k: "construction", v: "\xF0\x9F\x9A\xA7" }, { k: "construction_worker", v: "\xF0\x9F\x91\xB7" }, { k: "construction_worker_man", v: "\xF0\x9F\x91\xB7" }, { k: "construction_worker_woman", v: "\xF0\x9F\x91\xB7\xE2\x80\x8D\xE2\x99\x80" }, { k: "control_knobs", v: "\xF0\x9F\x8E\x9B" }, { k: "convenience_store", v: "\xF0\x9F\x8F\xAA" }, { k: "cook_islands", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB0" }, { k: "cookie", v: "\xF0\x9F\x8D\xAA" }, { k: "cool", v: "\xF0\x9F\x86\x92" }, { k: "cop", v: "\xF0\x9F\x91\xAE" }, { k: "copyright", v: "\xC2\xA9\xEF\xB8\x8F" }, { k: "corn", v: "\xF0\x9F\x8C\xBD" }, { k: "costa_rica", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xB7" }, { k: "cote_divoire", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xAE" }, { k: "couch_and_lamp", v: "\xF0\x9F\x9B\x8B" }, { k: "couple", v: "\xF0\x9F\x91\xAB" }, { k: "couple_with_heart", v: "\xF0\x9F\x92\x91" }, { k: "couple_with_heart_man_man", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9D\xA4\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x91\xA8" }, { k: "couple_with_heart_woman_man", v: "\xF0\x9F\x92\x91" }, { k: "couple_with_heart_woman_woman", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9D\xA4\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x91\xA9" }, { k: "couplekiss_man_man", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9D\xA4\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x92\x8B\xE2\x80\x8D\xF0\x9F\x91\xA8" }, { k: "couplekiss_man_woman", v: "\xF0\x9F\x92\x8F" }, { k: "couplekiss_woman_woman", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9D\xA4\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x92\x8B\xE2\x80\x8D\xF0\x9F\x91\xA9" }, { k: "cow", v: "\xF0\x9F\x90\xAE" }, { k: "cow2", v: "\xF0\x9F\x90\x84" }, { k: "cowboy_hat_face", v: "\xF0\x9F\xA4\xA0" }, { k: "crab", v: "\xF0\x9F\xA6\x80" }, { k: "crayon", v: "\xF0\x9F\x96\x8D" }, { k: "credit_card", v: "\xF0\x9F\x92\xB3" }, { k: "crescent_moon", v: "\xF0\x9F\x8C\x99" }, { k: "cricket", v: "\xF0\x9F\x8F\x8F" }, { k: "croatia", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xB7" }, { k: "crocodile", v: "\xF0\x9F\x90\x8A" }, { k: "croissant", v: "\xF0\x9F\xA5\x90" }, { k: "crossed_fingers", v: "\xF0\x9F\xA4\x9E" }, { k: "crossed_flags", v: "\xF0\x9F\x8E\x8C" }, { k: "crossed_swords", v: "\xE2\x9A\x94\xEF\xB8\x8F" }, { k: "crown", v: "\xF0\x9F\x91\x91" }, { k: "cry", v: "\xF0\x9F\x98\xA2" }, { k: "crying_cat_face", v: "\xF0\x9F\x98\xBF" }, { k: "crystal_ball", v: "\xF0\x9F\x94\xAE" }, { k: "cuba", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBA" }, { k: "cucumber", v: "\xF0\x9F\xA5\x92" }, { k: "cupid", v: "\xF0\x9F\x92\x98" }, { k: "curacao", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBC" }, { k: "curly_loop", v: "\xE2\x9E\xB0" }, { k: "currency_exchange", v: "\xF0\x9F\x92\xB1" }, { k: "curry", v: "\xF0\x9F\x8D\x9B" }, { k: "custard", v: "\xF0\x9F\x8D\xAE" }, { k: "customs", v: "\xF0\x9F\x9B\x83" }, { k: "cyclone", v: "\xF0\x9F\x8C\x80" }, { k: "cyprus", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBE" }, { k: "czech_republic", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xBF" }, { k: "dagger", v: "\xF0\x9F\x97\xA1" }, { k: "dancer", v: "\xF0\x9F\x92\x83" }, { k: "dancers", v: "\xF0\x9F\x91\xAF" }, { k: "dancing_men", v: "\xF0\x9F\x91\xAF\xE2\x80\x8D\xE2\x99\x82" }, { k: "dancing_women", v: "\xF0\x9F\x91\xAF" }, { k: "dango", v: "\xF0\x9F\x8D\xA1" }, { k: "dark_sunglasses", v: "\xF0\x9F\x95\xB6" }, { k: "dart", v: "\xF0\x9F\x8E\xAF" }, { k: "dash", v: "\xF0\x9F\x92\xA8" }, { k: "date", v: "\xF0\x9F\x93\x85" }, { k: "de", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xAA" }, { k: "deciduous_tree", v: "\xF0\x9F\x8C\xB3" }, { k: "deer", v: "\xF0\x9F\xA6\x8C" }, { k: "denmark", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xB0" }, { k: "department_store", v: "\xF0\x9F\x8F\xAC" }, { k: "derelict_house", v: "\xF0\x9F\x8F\x9A" }, { k: "desert", v: "\xF0\x9F\x8F\x9C" }, { k: "desert_island", v: "\xF0\x9F\x8F\x9D" }, { k: "desktop_computer", v: "\xF0\x9F\x96\xA5" }, { k: "detective", v: "\xF0\x9F\x95\xB5" }, { k: "diamond_shape_with_a_dot_inside", v: "\xF0\x9F\x92\xA0" }, { k: "diamonds", v: "\xE2\x99\xA6\xEF\xB8\x8F" }, { k: "disappointed", v: "\xF0\x9F\x98\x9E" }, { k: "disappointed_relieved", v: "\xF0\x9F\x98\xA5" }, { k: "dizzy", v: "\xF0\x9F\x92\xAB" }, { k: "dizzy_face", v: "\xF0\x9F\x98\xB5" }, { k: "djibouti", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xAF" }, { k: "do_not_litter", v: "\xF0\x9F\x9A\xAF" }, { k: "dog", v: "\xF0\x9F\x90\xB6" }, { k: "dog2", v: "\xF0\x9F\x90\x95" }, { k: "doge", v: "${emojiSite}/doge.png" }, { k: "dollar", v: "\xF0\x9F\x92\xB5" }, { k: "dolls", v: "\xF0\x9F\x8E\x8E" }, { k: "dolphin", v: "\xF0\x9F\x90\xAC" }, { k: "dominica", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xB2" }, { k: "dominican_republic", v: "\xF0\x9F\x87\xA9\xF0\x9F\x87\xB4" }, { k: "door", v: "\xF0\x9F\x9A\xAA" }, { k: "doughnut", v: "\xF0\x9F\x8D\xA9" }, { k: "dove", v: "\xF0\x9F\x95\x8A" }, { k: "dragon", v: "\xF0\x9F\x90\x89" }, { k: "dragon_face", v: "\xF0\x9F\x90\xB2" }, { k: "dress", v: "\xF0\x9F\x91\x97" }, { k: "dromedary_camel", v: "\xF0\x9F\x90\xAA" }, { k: "drooling_face", v: "\xF0\x9F\xA4\xA4" }, { k: "droplet", v: "\xF0\x9F\x92\xA7" }, { k: "drum", v: "\xF0\x9F\xA5\x81" }, { k: "duck", v: "\xF0\x9F\xA6\x86" }, { k: "dvd", v: "\xF0\x9F\x93\x80" }, { k: "e-mail", v: "\xF0\x9F\x93\xA7" }, { k: "eagle", v: "\xF0\x9F\xA6\x85" }, { k: "ear", v: "\xF0\x9F\x91\x82" }, { k: "ear_of_rice", v: "\xF0\x9F\x8C\xBE" }, { k: "earth_africa", v: "\xF0\x9F\x8C\x8D" }, { k: "earth_americas", v: "\xF0\x9F\x8C\x8E" }, { k: "earth_asia", v: "\xF0\x9F\x8C\x8F" }, { k: "ecuador", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xA8" }, { k: "egg", v: "\xF0\x9F\xA5\x9A" }, { k: "eggplant", v: "\xF0\x9F\x8D\x86" }, { k: "egypt", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xAC" }, { k: "eight", v: "8\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "eight_pointed_black_star", v: "\xE2\x9C\xB4\xEF\xB8\x8F" }, { k: "eight_spoked_asterisk", v: "\xE2\x9C\xB3\xEF\xB8\x8F" }, { k: "el_salvador", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xBB" }, { k: "electric_plug", v: "\xF0\x9F\x94\x8C" }, { k: "elephant", v: "\xF0\x9F\x90\x98" }, { k: "email", v: "\xE2\x9C\x89\xEF\xB8\x8F" }, { k: "end", v: "\xF0\x9F\x94\x9A" }, { k: "envelope", v: "\xE2\x9C\x89\xEF\xB8\x8F" }, { k: "envelope_with_arrow", v: "\xF0\x9F\x93\xA9" }, { k: "equatorial_guinea", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB6" }, { k: "eritrea", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xB7" }, { k: "es", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xB8" }, { k: "estonia", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xAA" }, { k: "ethiopia", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xB9" }, { k: "eu", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xBA" }, { k: "euro", v: "\xF0\x9F\x92\xB6" }, { k: "european_castle", v: "\xF0\x9F\x8F\xB0" }, { k: "european_post_office", v: "\xF0\x9F\x8F\xA4" }, { k: "european_union", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xBA" }, { k: "evergreen_tree", v: "\xF0\x9F\x8C\xB2" }, { k: "exclamation", v: "\xE2\x9D\x97\xEF\xB8\x8F" }, { k: "expressionless", v: "\xF0\x9F\x98\x91" }, { k: "eye", v: "\xF0\x9F\x91\x81" }, { k: "eye_speech_bubble", v: "\xF0\x9F\x91\x81\xE2\x80\x8D\xF0\x9F\x97\xA8" }, { k: "eyeglasses", v: "\xF0\x9F\x91\x93" }, { k: "eyes", v: "\xF0\x9F\x91\x80" }, { k: "face_with_head_bandage", v: "\xF0\x9F\xA4\x95" }, { k: "face_with_thermometer", v: "\xF0\x9F\xA4\x92" }, { k: "facepunch", v: "\xF0\x9F\x91\x8A" }, { k: "factory", v: "\xF0\x9F\x8F\xAD" }, { k: "falkland_islands", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xB0" }, { k: "fallen_leaf", v: "\xF0\x9F\x8D\x82" }, { k: "family", v: "\xF0\x9F\x91\xAA" }, { k: "family_man_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_boy_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_girl_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_girl_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_man_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_man_boy_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_man_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_man_girl_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_man_girl_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_woman_boy", v: "\xF0\x9F\x91\xAA" }, { k: "family_man_woman_boy_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_woman_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_man_woman_girl_boy", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_man_woman_girl_girl", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_woman_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_boy_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_girl", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_woman_girl_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_girl_girl", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_woman_woman_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_woman_boy_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA6\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_woman_girl", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "family_woman_woman_girl_boy", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA6" }, { k: "family_woman_woman_girl_girl", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x91\xA7\xE2\x80\x8D\xF0\x9F\x91\xA7" }, { k: "faroe_islands", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xB4" }, { k: "fast_forward", v: "\xE2\x8F\xA9" }, { k: "fax", v: "\xF0\x9F\x93\xA0" }, { k: "fearful", v: "\xF0\x9F\x98\xA8" }, { k: "feet", v: "\xF0\x9F\x90\xBE" }, { k: "female_detective", v: "\xF0\x9F\x95\xB5\xEF\xB8\x8F\xE2\x80\x8D\xE2\x99\x80\xEF\xB8\x8F" }, { k: "ferris_wheel", v: "\xF0\x9F\x8E\xA1" }, { k: "ferry", v: "\xE2\x9B\xB4" }, { k: "field_hockey", v: "\xF0\x9F\x8F\x91" }, { k: "fiji", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xAF" }, { k: "file_cabinet", v: "\xF0\x9F\x97\x84" }, { k: "file_folder", v: "\xF0\x9F\x93\x81" }, { k: "film_projector", v: "\xF0\x9F\x93\xBD" }, { k: "film_strip", v: "\xF0\x9F\x8E\x9E" }, { k: "finland", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xAE" }, { k: "fire", v: "\xF0\x9F\x94\xA5" }, { k: "fire_engine", v: "\xF0\x9F\x9A\x92" }, { k: "fireworks", v: "\xF0\x9F\x8E\x86" }, { k: "first_quarter_moon", v: "\xF0\x9F\x8C\x93" }, { k: "first_quarter_moon_with_face", v: "\xF0\x9F\x8C\x9B" }, { k: "fish", v: "\xF0\x9F\x90\x9F" }, { k: "fish_cake", v: "\xF0\x9F\x8D\xA5" }, { k: "fishing_pole_and_fish", v: "\xF0\x9F\x8E\xA3" }, { k: "fist", v: "\xE2\x9C\x8A" }, { k: "fist_left", v: "\xF0\x9F\xA4\x9B" }, { k: "fist_oncoming", v: "\xF0\x9F\x91\x8A" }, { k: "fist_raised", v: "\xE2\x9C\x8A" }, { k: "fist_right", v: "\xF0\x9F\xA4\x9C" }, { k: "five", v: "5\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "flags", v: "\xF0\x9F\x8E\x8F" }, { k: "flashlight", v: "\xF0\x9F\x94\xA6" }, { k: "fleur_de_lis", v: "\xE2\x9A\x9C\xEF\xB8\x8F" }, { k: "flight_arrival", v: "\xF0\x9F\x9B\xAC" }, { k: "flight_departure", v: "\xF0\x9F\x9B\xAB" }, { k: "flipper", v: "\xF0\x9F\x90\xAC" }, { k: "floppy_disk", v: "\xF0\x9F\x92\xBE" }, { k: "flower_playing_cards", v: "\xF0\x9F\x8E\xB4" }, { k: "flushed", v: "\xF0\x9F\x98\xB3" }, { k: "fog", v: "\xF0\x9F\x8C\xAB" }, { k: "foggy", v: "\xF0\x9F\x8C\x81" }, { k: "football", v: "\xF0\x9F\x8F\x88" }, { k: "footprints", v: "\xF0\x9F\x91\xA3" }, { k: "fork_and_knife", v: "\xF0\x9F\x8D\xB4" }, { k: "fountain", v: "\xE2\x9B\xB2\xEF\xB8\x8F" }, { k: "fountain_pen", v: "\xF0\x9F\x96\x8B" }, { k: "four", v: "4\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "four_leaf_clover", v: "\xF0\x9F\x8D\x80" }, { k: "fox_face", v: "\xF0\x9F\xA6\x8A" }, { k: "fr", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xB7" }, { k: "framed_picture", v: "\xF0\x9F\x96\xBC" }, { k: "free", v: "\xF0\x9F\x86\x93" }, { k: "french_guiana", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAB" }, { k: "french_polynesia", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xAB" }, { k: "french_southern_territories", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xAB" }, { k: "fried_egg", v: "\xF0\x9F\x8D\xB3" }, { k: "fried_shrimp", v: "\xF0\x9F\x8D\xA4" }, { k: "fries", v: "\xF0\x9F\x8D\x9F" }, { k: "frog", v: "\xF0\x9F\x90\xB8" }, { k: "frowning", v: "\xF0\x9F\x98\xA6" }, { k: "frowning_face", v: "\xE2\x98\xB9\xEF\xB8\x8F" }, { k: "frowning_man", v: "\xF0\x9F\x99\x8D\xE2\x80\x8D\xE2\x99\x82" }, { k: "frowning_woman", v: "\xF0\x9F\x99\x8D" }, { k: "fu", v: "\xF0\x9F\x96\x95" }, { k: "fuelpump", v: "\xE2\x9B\xBD\xEF\xB8\x8F" }, { k: "full_moon", v: "\xF0\x9F\x8C\x95" }, { k: "full_moon_with_face", v: "\xF0\x9F\x8C\x9D" }, { k: "funeral_urn", v: "\xE2\x9A\xB1\xEF\xB8\x8F" }, { k: "gabon", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xA6" }, { k: "gambia", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB2" }, { k: "game_die", v: "\xF0\x9F\x8E\xB2" }, { k: "gb", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xA7" }, { k: "gear", v: "\xE2\x9A\x99\xEF\xB8\x8F" }, { k: "gem", v: "\xF0\x9F\x92\x8E" }, { k: "gemini", v: "\xE2\x99\x8A\xEF\xB8\x8F" }, { k: "georgia", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAA" }, { k: "ghana", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAD" }, { k: "ghost", v: "\xF0\x9F\x91\xBB" }, { k: "gibraltar", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAE" }, { k: "gift", v: "\xF0\x9F\x8E\x81" }, { k: "gift_heart", v: "\xF0\x9F\x92\x9D" }, { k: "girl", v: "\xF0\x9F\x91\xA7" }, { k: "globe_with_meridians", v: "\xF0\x9F\x8C\x90" }, { k: "goal_net", v: "\xF0\x9F\xA5\x85" }, { k: "goat", v: "\xF0\x9F\x90\x90" }, { k: "golf", v: "\xE2\x9B\xB3\xEF\xB8\x8F" }, { k: "golfing_man", v: "\xF0\x9F\x8F\x8C" }, { k: "golfing_woman", v: "\xF0\x9F\x8F\x8C\xEF\xB8\x8F\xE2\x80\x8D\xE2\x99\x80\xEF\xB8\x8F" }, { k: "gorilla", v: "\xF0\x9F\xA6\x8D" }, { k: "grapes", v: "\xF0\x9F\x8D\x87" }, { k: "greece", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB7" }, { k: "green_apple", v: "\xF0\x9F\x8D\x8F" }, { k: "green_book", v: "\xF0\x9F\x93\x97" }, { k: "green_heart", v: "\xF0\x9F\x92\x9A" }, { k: "green_salad", v: "\xF0\x9F\xA5\x97" }, { k: "greenland", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB1" }, { k: "grenada", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xA9" }, { k: "grey_exclamation", v: "\xE2\x9D\x95" }, { k: "grey_question", v: "\xE2\x9D\x94" }, { k: "grimacing", v: "\xF0\x9F\x98\xAC" }, { k: "grin", v: "\xF0\x9F\x98\x81" }, { k: "grinning", v: "\xF0\x9F\x98\x80" }, { k: "guadeloupe", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB5" }, { k: "guam", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xBA" }, { k: "guardsman", v: "\xF0\x9F\x92\x82" }, { k: "guardswoman", v: "\xF0\x9F\x92\x82\xE2\x80\x8D\xE2\x99\x80" }, { k: "guatemala", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB9" }, { k: "guernsey", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xAC" }, { k: "guinea", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB3" }, { k: "guinea_bissau", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xBC" }, { k: "guitar", v: "\xF0\x9F\x8E\xB8" }, { k: "gun", v: "\xF0\x9F\x94\xAB" }, { k: "guyana", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xBE" }, { k: "hacpai", v: "${emojiSite}/hacpai.png" }, { k: "haircut", v: "\xF0\x9F\x92\x87" }, { k: "haircut_man", v: "\xF0\x9F\x92\x87\xE2\x80\x8D\xE2\x99\x82" }, { k: "haircut_woman", v: "\xF0\x9F\x92\x87" }, { k: "haiti", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xB9" }, { k: "hamburger", v: "\xF0\x9F\x8D\x94" }, { k: "hammer", v: "\xF0\x9F\x94\xA8" }, { k: "hammer_and_pick", v: "\xE2\x9A\x92" }, { k: "hammer_and_wrench", v: "\xF0\x9F\x9B\xA0" }, { k: "hamster", v: "\xF0\x9F\x90\xB9" }, { k: "hand", v: "\xE2\x9C\x8B" }, { k: "handbag", v: "\xF0\x9F\x91\x9C" }, { k: "handshake", v: "\xF0\x9F\xA4\x9D" }, { k: "hankey", v: "\xF0\x9F\x92\xA9" }, { k: "hash", v: "#\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "hatched_chick", v: "\xF0\x9F\x90\xA5" }, { k: "hatching_chick", v: "\xF0\x9F\x90\xA3" }, { k: "headphones", v: "\xF0\x9F\x8E\xA7" }, { k: "hear_no_evil", v: "\xF0\x9F\x99\x89" }, { k: "heart", v: "\xE2\x9D\xA4\xEF\xB8\x8F" }, { k: "heart_decoration", v: "\xF0\x9F\x92\x9F" }, { k: "heart_eyes", v: "\xF0\x9F\x98\x8D" }, { k: "heart_eyes_cat", v: "\xF0\x9F\x98\xBB" }, { k: "heartbeat", v: "\xF0\x9F\x92\x93" }, { k: "heartpulse", v: "\xF0\x9F\x92\x97" }, { k: "hearts", v: "\xE2\x99\xA5\xEF\xB8\x8F" }, { k: "heavy_check_mark", v: "\xE2\x9C\x94\xEF\xB8\x8F" }, { k: "heavy_division_sign", v: "\xE2\x9E\x97" }, { k: "heavy_dollar_sign", v: "\xF0\x9F\x92\xB2" }, { k: "heavy_exclamation_mark", v: "\xE2\x9D\x97\xEF\xB8\x8F" }, { k: "heavy_heart_exclamation", v: "\xE2\x9D\xA3\xEF\xB8\x8F" }, { k: "heavy_minus_sign", v: "\xE2\x9E\x96" }, { k: "heavy_multiplication_x", v: "\xE2\x9C\x96\xEF\xB8\x8F" }, { k: "heavy_plus_sign", v: "\xE2\x9E\x95" }, { k: "helicopter", v: "\xF0\x9F\x9A\x81" }, { k: "herb", v: "\xF0\x9F\x8C\xBF" }, { k: "hibiscus", v: "\xF0\x9F\x8C\xBA" }, { k: "high_brightness", v: "\xF0\x9F\x94\x86" }, { k: "high_heel", v: "\xF0\x9F\x91\xA0" }, { k: "hocho", v: "\xF0\x9F\x94\xAA" }, { k: "hole", v: "\xF0\x9F\x95\xB3" }, { k: "honduras", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xB3" }, { k: "honey_pot", v: "\xF0\x9F\x8D\xAF" }, { k: "honeybee", v: "\xF0\x9F\x90\x9D" }, { k: "hong_kong", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xB0" }, { k: "horse", v: "\xF0\x9F\x90\xB4" }, { k: "horse_racing", v: "\xF0\x9F\x8F\x87" }, { k: "hospital", v: "\xF0\x9F\x8F\xA5" }, { k: "hot_pepper", v: "\xF0\x9F\x8C\xB6" }, { k: "hotdog", v: "\xF0\x9F\x8C\xAD" }, { k: "hotel", v: "\xF0\x9F\x8F\xA8" }, { k: "hotsprings", v: "\xE2\x99\xA8\xEF\xB8\x8F" }, { k: "hourglass", v: "\xE2\x8C\x9B\xEF\xB8\x8F" }, { k: "hourglass_flowing_sand", v: "\xE2\x8F\xB3" }, { k: "house", v: "\xF0\x9F\x8F\xA0" }, { k: "house_with_garden", v: "\xF0\x9F\x8F\xA1" }, { k: "houses", v: "\xF0\x9F\x8F\x98" }, { k: "huaji", v: "${emojiSite}/huaji.gif" }, { k: "hugs", v: "\xF0\x9F\xA4\x97" }, { k: "hungary", v: "\xF0\x9F\x87\xAD\xF0\x9F\x87\xBA" }, { k: "hushed", v: "\xF0\x9F\x98\xAF" }, { k: "ice_cream", v: "\xF0\x9F\x8D\xA8" }, { k: "ice_hockey", v: "\xF0\x9F\x8F\x92" }, { k: "ice_skate", v: "\xE2\x9B\xB8" }, { k: "icecream", v: "\xF0\x9F\x8D\xA6" }, { k: "iceland", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB8" }, { k: "id", v: "\xF0\x9F\x86\x94" }, { k: "ideograph_advantage", v: "\xF0\x9F\x89\x90" }, { k: "imp", v: "\xF0\x9F\x91\xBF" }, { k: "inbox_tray", v: "\xF0\x9F\x93\xA5" }, { k: "incoming_envelope", v: "\xF0\x9F\x93\xA8" }, { k: "india", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB3" }, { k: "indonesia", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xA9" }, { k: "information_desk_person", v: "\xF0\x9F\x92\x81" }, { k: "information_source", v: "\xE2\x84\xB9\xEF\xB8\x8F" }, { k: "innocent", v: "\xF0\x9F\x98\x87" }, { k: "interrobang", v: "\xE2\x81\x89\xEF\xB8\x8F" }, { k: "iphone", v: "\xF0\x9F\x93\xB1" }, { k: "iran", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB7" }, { k: "iraq", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB6" }, { k: "ireland", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xAA" }, { k: "isle_of_man", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB2" }, { k: "israel", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB1" }, { k: "it", v: "\xF0\x9F\x87\xAE\xF0\x9F\x87\xB9" }, { k: "izakaya_lantern", v: "\xF0\x9F\x8F\xAE" }, { k: "jack_o_lantern", v: "\xF0\x9F\x8E\x83" }, { k: "jamaica", v: "\xF0\x9F\x87\xAF\xF0\x9F\x87\xB2" }, { k: "japan", v: "\xF0\x9F\x97\xBE" }, { k: "japanese_castle", v: "\xF0\x9F\x8F\xAF" }, { k: "japanese_goblin", v: "\xF0\x9F\x91\xBA" }, { k: "japanese_ogre", v: "\xF0\x9F\x91\xB9" }, { k: "jeans", v: "\xF0\x9F\x91\x96" }, { k: "jersey", v: "\xF0\x9F\x87\xAF\xF0\x9F\x87\xAA" }, { k: "jordan", v: "\xF0\x9F\x87\xAF\xF0\x9F\x87\xB4" }, { k: "joy", v: "\xF0\x9F\x98\x82" }, { k: "joy_cat", v: "\xF0\x9F\x98\xB9" }, { k: "joystick", v: "\xF0\x9F\x95\xB9" }, { k: "jp", v: "\xF0\x9F\x87\xAF\xF0\x9F\x87\xB5" }, { k: "kaaba", v: "\xF0\x9F\x95\x8B" }, { k: "kazakhstan", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xBF" }, { k: "kenya", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xAA" }, { k: "key", v: "\xF0\x9F\x94\x91" }, { k: "keyboard", v: "\xE2\x8C\xA8\xEF\xB8\x8F" }, { k: "keycap_ten", v: "\xF0\x9F\x94\x9F" }, { k: "kick_scooter", v: "\xF0\x9F\x9B\xB4" }, { k: "kimono", v: "\xF0\x9F\x91\x98" }, { k: "kiribati", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xAE" }, { k: "kiss", v: "\xF0\x9F\x92\x8B" }, { k: "kissing", v: "\xF0\x9F\x98\x97" }, { k: "kissing_cat", v: "\xF0\x9F\x98\xBD" }, { k: "kissing_closed_eyes", v: "\xF0\x9F\x98\x9A" }, { k: "kissing_heart", v: "\xF0\x9F\x98\x98" }, { k: "kissing_smiling_eyes", v: "\xF0\x9F\x98\x99" }, { k: "kiwi_fruit", v: "\xF0\x9F\xA5\x9D" }, { k: "knife", v: "\xF0\x9F\x94\xAA" }, { k: "koala", v: "\xF0\x9F\x90\xA8" }, { k: "koko", v: "\xF0\x9F\x88\x81" }, { k: "kosovo", v: "\xF0\x9F\x87\xBD\xF0\x9F\x87\xB0" }, { k: "kr", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xB7" }, { k: "kuwait", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xBC" }, { k: "kyrgyzstan", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xAC" }, { k: "label", v: "\xF0\x9F\x8F\xB7" }, { k: "lantern", v: "\xF0\x9F\x8F\xAE" }, { k: "laos", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xA6" }, { k: "large_blue_circle", v: "\xF0\x9F\x94\xB5" }, { k: "large_blue_diamond", v: "\xF0\x9F\x94\xB7" }, { k: "large_orange_diamond", v: "\xF0\x9F\x94\xB6" }, { k: "last_quarter_moon", v: "\xF0\x9F\x8C\x97" }, { k: "last_quarter_moon_with_face", v: "\xF0\x9F\x8C\x9C" }, { k: "latin_cross", v: "\xE2\x9C\x9D\xEF\xB8\x8F" }, { k: "latke", v: "${emojiSite}/latke.png" }, { k: "latvia", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xBB" }, { k: "laughing", v: "\xF0\x9F\x98\x86" }, { k: "leaves", v: "\xF0\x9F\x8D\x83" }, { k: "lebanon", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xA7" }, { k: "ledger", v: "\xF0\x9F\x93\x92" }, { k: "left_luggage", v: "\xF0\x9F\x9B\x85" }, { k: "left_right_arrow", v: "\xE2\x86\x94\xEF\xB8\x8F" }, { k: "leftwards_arrow_with_hook", v: "\xE2\x86\xA9\xEF\xB8\x8F" }, { k: "lemon", v: "\xF0\x9F\x8D\x8B" }, { k: "leo", v: "\xE2\x99\x8C\xEF\xB8\x8F" }, { k: "leopard", v: "\xF0\x9F\x90\x86" }, { k: "lesotho", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xB8" }, { k: "level_slider", v: "\xF0\x9F\x8E\x9A" }, { k: "liberia", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xB7" }, { k: "libra", v: "\xE2\x99\x8E\xEF\xB8\x8F" }, { k: "libya", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xBE" }, { k: "liechtenstein", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xAE" }, { k: "light_rail", v: "\xF0\x9F\x9A\x88" }, { k: "link", v: "\xF0\x9F\x94\x97" }, { k: "lion", v: "\xF0\x9F\xA6\x81" }, { k: "lips", v: "\xF0\x9F\x91\x84" }, { k: "lipstick", v: "\xF0\x9F\x92\x84" }, { k: "lithuania", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xB9" }, { k: "lizard", v: "\xF0\x9F\xA6\x8E" }, { k: "lock", v: "\xF0\x9F\x94\x92" }, { k: "lock_with_ink_pen", v: "\xF0\x9F\x94\x8F" }, { k: "lollipop", v: "\xF0\x9F\x8D\xAD" }, { k: "loop", v: "\xE2\x9E\xBF" }, { k: "loud_sound", v: "\xF0\x9F\x94\x8A" }, { k: "loudspeaker", v: "\xF0\x9F\x93\xA2" }, { k: "love_hotel", v: "\xF0\x9F\x8F\xA9" }, { k: "love_letter", v: "\xF0\x9F\x92\x8C" }, { k: "low_brightness", v: "\xF0\x9F\x94\x85" }, { k: "lute", v: "${emojiSite}/lute.png" }, { k: "luxembourg", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xBA" }, { k: "lying_face", v: "\xF0\x9F\xA4\xA5" }, { k: "m", v: "\xE2\x93\x82\xEF\xB8\x8F" }, { k: "macau", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB4" }, { k: "macedonia", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB0" }, { k: "madagascar", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xAC" }, { k: "mag", v: "\xF0\x9F\x94\x8D" }, { k: "mag_right", v: "\xF0\x9F\x94\x8E" }, { k: "mahjong", v: "\xF0\x9F\x80\x84\xEF\xB8\x8F" }, { k: "mailbox", v: "\xF0\x9F\x93\xAB" }, { k: "mailbox_closed", v: "\xF0\x9F\x93\xAA" }, { k: "mailbox_with_mail", v: "\xF0\x9F\x93\xAC" }, { k: "mailbox_with_no_mail", v: "\xF0\x9F\x93\xAD" }, { k: "malawi", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBC" }, { k: "malaysia", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBE" }, { k: "maldives", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBB" }, { k: "male_detective", v: "\xF0\x9F\x95\xB5" }, { k: "mali", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB1" }, { k: "malta", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB9" }, { k: "man", v: "\xF0\x9F\x91\xA8" }, { k: "man_artist", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8E\xA8" }, { k: "man_astronaut", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x9A\x80" }, { k: "man_cartwheeling", v: "\xF0\x9F\xA4\xB8\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_cook", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8D\xB3" }, { k: "man_dancing", v: "\xF0\x9F\x95\xBA" }, { k: "man_facepalming", v: "\xF0\x9F\xA4\xA6\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_factory_worker", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8F\xAD" }, { k: "man_farmer", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8C\xBE" }, { k: "man_firefighter", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x9A\x92" }, { k: "man_health_worker", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9A\x95" }, { k: "man_in_tuxedo", v: "\xF0\x9F\xA4\xB5" }, { k: "man_judge", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9A\x96" }, { k: "man_juggling", v: "\xF0\x9F\xA4\xB9\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_mechanic", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x94\xA7" }, { k: "man_office_worker", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x92\xBC" }, { k: "man_pilot", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xE2\x9C\x88" }, { k: "man_playing_handball", v: "\xF0\x9F\xA4\xBE\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_playing_water_polo", v: "\xF0\x9F\xA4\xBD\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_scientist", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x94\xAC" }, { k: "man_shrugging", v: "\xF0\x9F\xA4\xB7\xE2\x80\x8D\xE2\x99\x82" }, { k: "man_singer", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8E\xA4" }, { k: "man_student", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8E\x93" }, { k: "man_teacher", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x8F\xAB" }, { k: "man_technologist", v: "\xF0\x9F\x91\xA8\xE2\x80\x8D\xF0\x9F\x92\xBB" }, { k: "man_with_gua_pi_mao", v: "\xF0\x9F\x91\xB2" }, { k: "man_with_turban", v: "\xF0\x9F\x91\xB3" }, { k: "mandarin", v: "\xF0\x9F\x8D\x8A" }, { k: "mans_shoe", v: "\xF0\x9F\x91\x9E" }, { k: "mantelpiece_clock", v: "\xF0\x9F\x95\xB0" }, { k: "maple_leaf", v: "\xF0\x9F\x8D\x81" }, { k: "marshall_islands", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xAD" }, { k: "martial_arts_uniform", v: "\xF0\x9F\xA5\x8B" }, { k: "martinique", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB6" }, { k: "mask", v: "\xF0\x9F\x98\xB7" }, { k: "massage", v: "\xF0\x9F\x92\x86" }, { k: "massage_man", v: "\xF0\x9F\x92\x86\xE2\x80\x8D\xE2\x99\x82" }, { k: "massage_woman", v: "\xF0\x9F\x92\x86" }, { k: "mauritania", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB7" }, { k: "mauritius", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBA" }, { k: "mayotte", v: "\xF0\x9F\x87\xBE\xF0\x9F\x87\xB9" }, { k: "meat_on_bone", v: "\xF0\x9F\x8D\x96" }, { k: "medal_military", v: "\xF0\x9F\x8E\x96" }, { k: "medal_sports", v: "\xF0\x9F\x8F\x85" }, { k: "mega", v: "\xF0\x9F\x93\xA3" }, { k: "melon", v: "\xF0\x9F\x8D\x88" }, { k: "memo", v: "\xF0\x9F\x93\x9D" }, { k: "men_wrestling", v: "\xF0\x9F\xA4\xBC\xE2\x80\x8D\xE2\x99\x82" }, { k: "menorah", v: "\xF0\x9F\x95\x8E" }, { k: "mens", v: "\xF0\x9F\x9A\xB9" }, { k: "metal", v: "\xF0\x9F\xA4\x98" }, { k: "metro", v: "\xF0\x9F\x9A\x87" }, { k: "mexico", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBD" }, { k: "micronesia", v: "\xF0\x9F\x87\xAB\xF0\x9F\x87\xB2" }, { k: "microphone", v: "\xF0\x9F\x8E\xA4" }, { k: "microscope", v: "\xF0\x9F\x94\xAC" }, { k: "middle_finger", v: "\xF0\x9F\x96\x95" }, { k: "milk_glass", v: "\xF0\x9F\xA5\x9B" }, { k: "milky_way", v: "\xF0\x9F\x8C\x8C" }, { k: "minibus", v: "\xF0\x9F\x9A\x90" }, { k: "minidisc", v: "\xF0\x9F\x92\xBD" }, { k: "mobile_phone_off", v: "\xF0\x9F\x93\xB4" }, { k: "moldova", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xA9" }, { k: "monaco", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xA8" }, { k: "money_mouth_face", v: "\xF0\x9F\xA4\x91" }, { k: "money_with_wings", v: "\xF0\x9F\x92\xB8" }, { k: "moneybag", v: "\xF0\x9F\x92\xB0" }, { k: "mongolia", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB3" }, { k: "monkey", v: "\xF0\x9F\x90\x92" }, { k: "monkey_face", v: "\xF0\x9F\x90\xB5" }, { k: "monorail", v: "\xF0\x9F\x9A\x9D" }, { k: "montenegro", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xAA" }, { k: "montserrat", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB8" }, { k: "moon", v: "\xF0\x9F\x8C\x94" }, { k: "morocco", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xA6" }, { k: "mortar_board", v: "\xF0\x9F\x8E\x93" }, { k: "mosque", v: "\xF0\x9F\x95\x8C" }, { k: "motor_boat", v: "\xF0\x9F\x9B\xA5" }, { k: "motor_scooter", v: "\xF0\x9F\x9B\xB5" }, { k: "motorcycle", v: "\xF0\x9F\x8F\x8D" }, { k: "motorway", v: "\xF0\x9F\x9B\xA3" }, { k: "mount_fuji", v: "\xF0\x9F\x97\xBB" }, { k: "mountain", v: "\xE2\x9B\xB0" }, { k: "mountain_bicyclist", v: "\xF0\x9F\x9A\xB5" }, { k: "mountain_biking_man", v: "\xF0\x9F\x9A\xB5" }, { k: "mountain_biking_woman", v: "\xF0\x9F\x9A\xB5\xE2\x80\x8D\xE2\x99\x80" }, { k: "mountain_cableway", v: "\xF0\x9F\x9A\xA0" }, { k: "mountain_railway", v: "\xF0\x9F\x9A\x9E" }, { k: "mountain_snow", v: "\xF0\x9F\x8F\x94" }, { k: "mouse", v: "\xF0\x9F\x90\xAD" }, { k: "mouse2", v: "\xF0\x9F\x90\x81" }, { k: "movie_camera", v: "\xF0\x9F\x8E\xA5" }, { k: "moyai", v: "\xF0\x9F\x97\xBF" }, { k: "mozambique", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xBF" }, { k: "mrs_claus", v: "\xF0\x9F\xA4\xB6" }, { k: "muscle", v: "\xF0\x9F\x92\xAA" }, { k: "mushroom", v: "\xF0\x9F\x8D\x84" }, { k: "musical_keyboard", v: "\xF0\x9F\x8E\xB9" }, { k: "musical_note", v: "\xF0\x9F\x8E\xB5" }, { k: "musical_score", v: "\xF0\x9F\x8E\xBC" }, { k: "mute", v: "\xF0\x9F\x94\x87" }, { k: "myanmar", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB2" }, { k: "nail_care", v: "\xF0\x9F\x92\x85" }, { k: "name_badge", v: "\xF0\x9F\x93\x9B" }, { k: "namibia", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xA6" }, { k: "national_park", v: "\xF0\x9F\x8F\x9E" }, { k: "nauru", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xB7" }, { k: "nauseated_face", v: "\xF0\x9F\xA4\xA2" }, { k: "necktie", v: "\xF0\x9F\x91\x94" }, { k: "negative_squared_cross_mark", v: "\xE2\x9D\x8E" }, { k: "nepal", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xB5" }, { k: "nerd_face", v: "\xF0\x9F\xA4\x93" }, { k: "netherlands", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xB1" }, { k: "neutral_face", v: "\xF0\x9F\x98\x90" }, { k: "new", v: "\xF0\x9F\x86\x95" }, { k: "new_caledonia", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xA8" }, { k: "new_moon", v: "\xF0\x9F\x8C\x91" }, { k: "new_moon_with_face", v: "\xF0\x9F\x8C\x9A" }, { k: "new_zealand", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xBF" }, { k: "newspaper", v: "\xF0\x9F\x93\xB0" }, { k: "newspaper_roll", v: "\xF0\x9F\x97\x9E" }, { k: "next_track_button", v: "\xE2\x8F\xAD" }, { k: "ng", v: "\xF0\x9F\x86\x96" }, { k: "ng_man", v: "\xF0\x9F\x99\x85\xE2\x80\x8D\xE2\x99\x82" }, { k: "ng_woman", v: "\xF0\x9F\x99\x85" }, { k: "nicaragua", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xAE" }, { k: "niger", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xAA" }, { k: "nigeria", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xAC" }, { k: "night_with_stars", v: "\xF0\x9F\x8C\x83" }, { k: "nine", v: "9\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "niue", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xBA" }, { k: "no_bell", v: "\xF0\x9F\x94\x95" }, { k: "no_bicycles", v: "\xF0\x9F\x9A\xB3" }, { k: "no_entry", v: "\xE2\x9B\x94\xEF\xB8\x8F" }, { k: "no_entry_sign", v: "\xF0\x9F\x9A\xAB" }, { k: "no_good", v: "\xF0\x9F\x99\x85" }, { k: "no_good_man", v: "\xF0\x9F\x99\x85\xE2\x80\x8D\xE2\x99\x82" }, { k: "no_good_woman", v: "\xF0\x9F\x99\x85" }, { k: "no_mobile_phones", v: "\xF0\x9F\x93\xB5" }, { k: "no_mouth", v: "\xF0\x9F\x98\xB6" }, { k: "no_pedestrians", v: "\xF0\x9F\x9A\xB7" }, { k: "no_smoking", v: "\xF0\x9F\x9A\xAD" }, { k: "non-potable_water", v: "\xF0\x9F\x9A\xB1" }, { k: "norfolk_island", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xAB" }, { k: "north_korea", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xB5" }, { k: "northern_mariana_islands", v: "\xF0\x9F\x87\xB2\xF0\x9F\x87\xB5" }, { k: "norway", v: "\xF0\x9F\x87\xB3\xF0\x9F\x87\xB4" }, { k: "nose", v: "\xF0\x9F\x91\x83" }, { k: "notebook", v: "\xF0\x9F\x93\x93" }, { k: "notebook_with_decorative_cover", v: "\xF0\x9F\x93\x94" }, { k: "notes", v: "\xF0\x9F\x8E\xB6" }, { k: "nut_and_bolt", v: "\xF0\x9F\x94\xA9" }, { k: "o", v: "\xE2\xAD\x95\xEF\xB8\x8F" }, { k: "o2", v: "\xF0\x9F\x85\xBE\xEF\xB8\x8F" }, { k: "ocean", v: "\xF0\x9F\x8C\x8A" }, { k: "octocat", v: "${emojiSite}/octocat.png" }, { k: "octopus", v: "\xF0\x9F\x90\x99" }, { k: "oden", v: "\xF0\x9F\x8D\xA2" }, { k: "office", v: "\xF0\x9F\x8F\xA2" }, { k: "oil_drum", v: "\xF0\x9F\x9B\xA2" }, { k: "ok", v: "\xF0\x9F\x86\x97" }, { k: "ok_hand", v: "\xF0\x9F\x91\x8C" }, { k: "ok_man", v: "\xF0\x9F\x99\x86\xE2\x80\x8D\xE2\x99\x82" }, { k: "ok_woman", v: "\xF0\x9F\x99\x86" }, { k: "old_key", v: "\xF0\x9F\x97\x9D" }, { k: "older_man", v: "\xF0\x9F\x91\xB4" }, { k: "older_woman", v: "\xF0\x9F\x91\xB5" }, { k: "om", v: "\xF0\x9F\x95\x89" }, { k: "oman", v: "\xF0\x9F\x87\xB4\xF0\x9F\x87\xB2" }, { k: "on", v: "\xF0\x9F\x94\x9B" }, { k: "oncoming_automobile", v: "\xF0\x9F\x9A\x98" }, { k: "oncoming_bus", v: "\xF0\x9F\x9A\x8D" }, { k: "oncoming_police_car", v: "\xF0\x9F\x9A\x94" }, { k: "oncoming_taxi", v: "\xF0\x9F\x9A\x96" }, { k: "one", v: "1\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "open_book", v: "\xF0\x9F\x93\x96" }, { k: "open_file_folder", v: "\xF0\x9F\x93\x82" }, { k: "open_hands", v: "\xF0\x9F\x91\x90" }, { k: "open_mouth", v: "\xF0\x9F\x98\xAE" }, { k: "open_umbrella", v: "\xE2\x98\x82\xEF\xB8\x8F" }, { k: "ophiuchus", v: "\xE2\x9B\x8E" }, { k: "orange", v: "\xF0\x9F\x8D\x8A" }, { k: "orange_book", v: "\xF0\x9F\x93\x99" }, { k: "orthodox_cross", v: "\xE2\x98\xA6\xEF\xB8\x8F" }, { k: "outbox_tray", v: "\xF0\x9F\x93\xA4" }, { k: "owl", v: "\xF0\x9F\xA6\x89" }, { k: "ox", v: "\xF0\x9F\x90\x82" }, { k: "package", v: "\xF0\x9F\x93\xA6" }, { k: "page_facing_up", v: "\xF0\x9F\x93\x84" }, { k: "page_with_curl", v: "\xF0\x9F\x93\x83" }, { k: "pager", v: "\xF0\x9F\x93\x9F" }, { k: "paintbrush", v: "\xF0\x9F\x96\x8C" }, { k: "pakistan", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB0" }, { k: "palau", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xBC" }, { k: "palestinian_territories", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB8" }, { k: "palm_tree", v: "\xF0\x9F\x8C\xB4" }, { k: "panama", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xA6" }, { k: "pancakes", v: "\xF0\x9F\xA5\x9E" }, { k: "panda_face", v: "\xF0\x9F\x90\xBC" }, { k: "paperclip", v: "\xF0\x9F\x93\x8E" }, { k: "paperclips", v: "\xF0\x9F\x96\x87" }, { k: "papua_new_guinea", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xAC" }, { k: "paraguay", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xBE" }, { k: "parasol_on_ground", v: "\xE2\x9B\xB1" }, { k: "parking", v: "\xF0\x9F\x85\xBF\xEF\xB8\x8F" }, { k: "part_alternation_mark", v: "\xE3\x80\xBD\xEF\xB8\x8F" }, { k: "partly_sunny", v: "\xE2\x9B\x85\xEF\xB8\x8F" }, { k: "passenger_ship", v: "\xF0\x9F\x9B\xB3" }, { k: "passport_control", v: "\xF0\x9F\x9B\x82" }, { k: "pause_button", v: "\xE2\x8F\xB8" }, { k: "paw_prints", v: "\xF0\x9F\x90\xBE" }, { k: "peace_symbol", v: "\xE2\x98\xAE\xEF\xB8\x8F" }, { k: "peach", v: "\xF0\x9F\x8D\x91" }, { k: "peanuts", v: "\xF0\x9F\xA5\x9C" }, { k: "pear", v: "\xF0\x9F\x8D\x90" }, { k: "pen", v: "\xF0\x9F\x96\x8A" }, { k: "pencil", v: "\xF0\x9F\x93\x9D" }, { k: "pencil2", v: "\xE2\x9C\x8F\xEF\xB8\x8F" }, { k: "penguin", v: "\xF0\x9F\x90\xA7" }, { k: "pensive", v: "\xF0\x9F\x98\x94" }, { k: "performing_arts", v: "\xF0\x9F\x8E\xAD" }, { k: "persevere", v: "\xF0\x9F\x98\xA3" }, { k: "person_fencing", v: "\xF0\x9F\xA4\xBA" }, { k: "person_frowning", v: "\xF0\x9F\x99\x8D" }, { k: "person_with_blond_hair", v: "\xF0\x9F\x91\xB1" }, { k: "person_with_pouting_face", v: "\xF0\x9F\x99\x8E" }, { k: "peru", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xAA" }, { k: "philippines", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xAD" }, { k: "phone", v: "\xE2\x98\x8E\xEF\xB8\x8F" }, { k: "pick", v: "\xE2\x9B\x8F" }, { k: "pig", v: "\xF0\x9F\x90\xB7" }, { k: "pig2", v: "\xF0\x9F\x90\x96" }, { k: "pig_nose", v: "\xF0\x9F\x90\xBD" }, { k: "pill", v: "\xF0\x9F\x92\x8A" }, { k: "pineapple", v: "\xF0\x9F\x8D\x8D" }, { k: "ping_pong", v: "\xF0\x9F\x8F\x93" }, { k: "pipe", v: "${emojiSite}/pipe.png" }, { k: "pisces", v: "\xE2\x99\x93\xEF\xB8\x8F" }, { k: "pitcairn_islands", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB3" }, { k: "pizza", v: "\xF0\x9F\x8D\x95" }, { k: "place_of_worship", v: "\xF0\x9F\x9B\x90" }, { k: "plate_with_cutlery", v: "\xF0\x9F\x8D\xBD" }, { k: "play_or_pause_button", v: "\xE2\x8F\xAF" }, { k: "point_down", v: "\xF0\x9F\x91\x87" }, { k: "point_left", v: "\xF0\x9F\x91\x88" }, { k: "point_right", v: "\xF0\x9F\x91\x89" }, { k: "point_up", v: "\xE2\x98\x9D\xEF\xB8\x8F" }, { k: "point_up_2", v: "\xF0\x9F\x91\x86" }, { k: "poland", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB1" }, { k: "police_car", v: "\xF0\x9F\x9A\x93" }, { k: "policeman", v: "\xF0\x9F\x91\xAE" }, { k: "policewoman", v: "\xF0\x9F\x91\xAE\xE2\x80\x8D\xE2\x99\x80" }, { k: "poodle", v: "\xF0\x9F\x90\xA9" }, { k: "poop", v: "\xF0\x9F\x92\xA9" }, { k: "popcorn", v: "\xF0\x9F\x8D\xBF" }, { k: "portugal", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB9" }, { k: "post_office", v: "\xF0\x9F\x8F\xA3" }, { k: "postal_horn", v: "\xF0\x9F\x93\xAF" }, { k: "postbox", v: "\xF0\x9F\x93\xAE" }, { k: "potable_water", v: "\xF0\x9F\x9A\xB0" }, { k: "potato", v: "\xF0\x9F\xA5\x94" }, { k: "pouch", v: "\xF0\x9F\x91\x9D" }, { k: "poultry_leg", v: "\xF0\x9F\x8D\x97" }, { k: "pound", v: "\xF0\x9F\x92\xB7" }, { k: "pout", v: "\xF0\x9F\x98\xA1" }, { k: "pouting_cat", v: "\xF0\x9F\x98\xBE" }, { k: "pouting_man", v: "\xF0\x9F\x99\x8E\xE2\x80\x8D\xE2\x99\x82" }, { k: "pouting_woman", v: "\xF0\x9F\x99\x8E" }, { k: "pray", v: "\xF0\x9F\x99\x8F" }, { k: "prayer_beads", v: "\xF0\x9F\x93\xBF" }, { k: "pregnant_woman", v: "\xF0\x9F\xA4\xB0" }, { k: "previous_track_button", v: "\xE2\x8F\xAE" }, { k: "prince", v: "\xF0\x9F\xA4\xB4" }, { k: "princess", v: "\xF0\x9F\x91\xB8" }, { k: "printer", v: "\xF0\x9F\x96\xA8" }, { k: "puerto_rico", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB7" }, { k: "punch", v: "\xF0\x9F\x91\x8A" }, { k: "purple_heart", v: "\xF0\x9F\x92\x9C" }, { k: "purse", v: "\xF0\x9F\x91\x9B" }, { k: "pushpin", v: "\xF0\x9F\x93\x8C" }, { k: "put_litter_in_its_place", v: "\xF0\x9F\x9A\xAE" }, { k: "qatar", v: "\xF0\x9F\x87\xB6\xF0\x9F\x87\xA6" }, { k: "question", v: "\xE2\x9D\x93" }, { k: "rabbit", v: "\xF0\x9F\x90\xB0" }, { k: "rabbit2", v: "\xF0\x9F\x90\x87" }, { k: "racehorse", v: "\xF0\x9F\x90\x8E" }, { k: "racing_car", v: "\xF0\x9F\x8F\x8E" }, { k: "radio", v: "\xF0\x9F\x93\xBB" }, { k: "radio_button", v: "\xF0\x9F\x94\x98" }, { k: "radioactive", v: "\xE2\x98\xA2\xEF\xB8\x8F" }, { k: "rage", v: "\xF0\x9F\x98\xA1" }, { k: "railway_car", v: "\xF0\x9F\x9A\x83" }, { k: "railway_track", v: "\xF0\x9F\x9B\xA4" }, { k: "rainbow", v: "\xF0\x9F\x8C\x88" }, { k: "rainbow_flag", v: "\xF0\x9F\x8F\xB3\xEF\xB8\x8F\xE2\x80\x8D\xF0\x9F\x8C\x88" }, { k: "raised_back_of_hand", v: "\xF0\x9F\xA4\x9A" }, { k: "raised_hand", v: "\xE2\x9C\x8B" }, { k: "raised_hand_with_fingers_splayed", v: "\xF0\x9F\x96\x90" }, { k: "raised_hands", v: "\xF0\x9F\x99\x8C" }, { k: "raising_hand", v: "\xF0\x9F\x99\x8B" }, { k: "raising_hand_man", v: "\xF0\x9F\x99\x8B\xE2\x80\x8D\xE2\x99\x82" }, { k: "raising_hand_woman", v: "\xF0\x9F\x99\x8B" }, { k: "ram", v: "\xF0\x9F\x90\x8F" }, { k: "ramen", v: "\xF0\x9F\x8D\x9C" }, { k: "rat", v: "\xF0\x9F\x90\x80" }, { k: "record_button", v: "\xE2\x8F\xBA" }, { k: "recycle", v: "\xE2\x99\xBB\xEF\xB8\x8F" }, { k: "red_car", v: "\xF0\x9F\x9A\x97" }, { k: "red_circle", v: "\xF0\x9F\x94\xB4" }, { k: "registered", v: "\xC2\xAE\xEF\xB8\x8F" }, { k: "relaxed", v: "\xE2\x98\xBA\xEF\xB8\x8F" }, { k: "relieved", v: "\xF0\x9F\x98\x8C" }, { k: "reminder_ribbon", v: "\xF0\x9F\x8E\x97" }, { k: "repeat", v: "\xF0\x9F\x94\x81" }, { k: "repeat_one", v: "\xF0\x9F\x94\x82" }, { k: "rescue_worker_helmet", v: "\xE2\x9B\x91" }, { k: "restroom", v: "\xF0\x9F\x9A\xBB" }, { k: "reunion", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xAA" }, { k: "revolving_hearts", v: "\xF0\x9F\x92\x9E" }, { k: "rewind", v: "\xE2\x8F\xAA" }, { k: "rhinoceros", v: "\xF0\x9F\xA6\x8F" }, { k: "ribbon", v: "\xF0\x9F\x8E\x80" }, { k: "rice", v: "\xF0\x9F\x8D\x9A" }, { k: "rice_ball", v: "\xF0\x9F\x8D\x99" }, { k: "rice_cracker", v: "\xF0\x9F\x8D\x98" }, { k: "rice_scene", v: "\xF0\x9F\x8E\x91" }, { k: "right_anger_bubble", v: "\xF0\x9F\x97\xAF" }, { k: "ring", v: "\xF0\x9F\x92\x8D" }, { k: "robot", v: "\xF0\x9F\xA4\x96" }, { k: "rocket", v: "\xF0\x9F\x9A\x80" }, { k: "rofl", v: "\xF0\x9F\xA4\xA3" }, { k: "roll_eyes", v: "\xF0\x9F\x99\x84" }, { k: "roller_coaster", v: "\xF0\x9F\x8E\xA2" }, { k: "romania", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xB4" }, { k: "rooster", v: "\xF0\x9F\x90\x93" }, { k: "rose", v: "\xF0\x9F\x8C\xB9" }, { k: "rosette", v: "\xF0\x9F\x8F\xB5" }, { k: "rotating_light", v: "\xF0\x9F\x9A\xA8" }, { k: "round_pushpin", v: "\xF0\x9F\x93\x8D" }, { k: "rowboat", v: "\xF0\x9F\x9A\xA3" }, { k: "rowing_man", v: "\xF0\x9F\x9A\xA3" }, { k: "rowing_woman", v: "\xF0\x9F\x9A\xA3\xE2\x80\x8D\xE2\x99\x80" }, { k: "ru", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xBA" }, { k: "rugby_football", v: "\xF0\x9F\x8F\x89" }, { k: "runner", v: "\xF0\x9F\x8F\x83" }, { k: "running", v: "\xF0\x9F\x8F\x83" }, { k: "running_man", v: "\xF0\x9F\x8F\x83" }, { k: "running_shirt_with_sash", v: "\xF0\x9F\x8E\xBD" }, { k: "running_woman", v: "\xF0\x9F\x8F\x83\xE2\x80\x8D\xE2\x99\x80" }, { k: "rwanda", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xBC" }, { k: "sa", v: "\xF0\x9F\x88\x82\xEF\xB8\x8F" }, { k: "sagittarius", v: "\xE2\x99\x90\xEF\xB8\x8F" }, { k: "sailboat", v: "\xE2\x9B\xB5\xEF\xB8\x8F" }, { k: "sake", v: "\xF0\x9F\x8D\xB6" }, { k: "samoa", v: "\xF0\x9F\x87\xBC\xF0\x9F\x87\xB8" }, { k: "san_marino", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB2" }, { k: "sandal", v: "\xF0\x9F\x91\xA1" }, { k: "santa", v: "\xF0\x9F\x8E\x85" }, { k: "sao_tome_principe", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB9" }, { k: "sassy_man", v: "\xF0\x9F\x92\x81\xE2\x80\x8D\xE2\x99\x82" }, { k: "sassy_woman", v: "\xF0\x9F\x92\x81" }, { k: "satellite", v: "\xF0\x9F\x93\xA1" }, { k: "satisfied", v: "\xF0\x9F\x98\x86" }, { k: "saudi_arabia", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xA6" }, { k: "saxophone", v: "\xF0\x9F\x8E\xB7" }, { k: "school", v: "\xF0\x9F\x8F\xAB" }, { k: "school_satchel", v: "\xF0\x9F\x8E\x92" }, { k: "scissors", v: "\xE2\x9C\x82\xEF\xB8\x8F" }, { k: "scorpion", v: "\xF0\x9F\xA6\x82" }, { k: "scorpius", v: "\xE2\x99\x8F\xEF\xB8\x8F" }, { k: "scream", v: "\xF0\x9F\x98\xB1" }, { k: "scream_cat", v: "\xF0\x9F\x99\x80" }, { k: "scroll", v: "\xF0\x9F\x93\x9C" }, { k: "seat", v: "\xF0\x9F\x92\xBA" }, { k: "secret", v: "\xE3\x8A\x99\xEF\xB8\x8F" }, { k: "see_no_evil", v: "\xF0\x9F\x99\x88" }, { k: "seedling", v: "\xF0\x9F\x8C\xB1" }, { k: "selfie", v: "\xF0\x9F\xA4\xB3" }, { k: "senegal", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB3" }, { k: "serbia", v: "\xF0\x9F\x87\xB7\xF0\x9F\x87\xB8" }, { k: "seven", v: "7\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "seychelles", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xA8" }, { k: "shallow_pan_of_food", v: "\xF0\x9F\xA5\x98" }, { k: "shamrock", v: "\xE2\x98\x98\xEF\xB8\x8F" }, { k: "shark", v: "\xF0\x9F\xA6\x88" }, { k: "shaved_ice", v: "\xF0\x9F\x8D\xA7" }, { k: "sheep", v: "\xF0\x9F\x90\x91" }, { k: "shell", v: "\xF0\x9F\x90\x9A" }, { k: "shield", v: "\xF0\x9F\x9B\xA1" }, { k: "shinto_shrine", v: "\xE2\x9B\xA9" }, { k: "ship", v: "\xF0\x9F\x9A\xA2" }, { k: "shirt", v: "\xF0\x9F\x91\x95" }, { k: "shit", v: "\xF0\x9F\x92\xA9" }, { k: "shoe", v: "\xF0\x9F\x91\x9E" }, { k: "shopping", v: "\xF0\x9F\x9B\x8D" }, { k: "shopping_cart", v: "\xF0\x9F\x9B\x92" }, { k: "shower", v: "\xF0\x9F\x9A\xBF" }, { k: "shrimp", v: "\xF0\x9F\xA6\x90" }, { k: "sierra_leone", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB1" }, { k: "signal_strength", v: "\xF0\x9F\x93\xB6" }, { k: "singapore", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xAC" }, { k: "sint_maarten", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xBD" }, { k: "six", v: "6\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "six_pointed_star", v: "\xF0\x9F\x94\xAF" }, { k: "ski", v: "\xF0\x9F\x8E\xBF" }, { k: "skier", v: "\xE2\x9B\xB7" }, { k: "skull", v: "\xF0\x9F\x92\x80" }, { k: "skull_and_crossbones", v: "\xE2\x98\xA0\xEF\xB8\x8F" }, { k: "sleeping", v: "\xF0\x9F\x98\xB4" }, { k: "sleeping_bed", v: "\xF0\x9F\x9B\x8C" }, { k: "sleepy", v: "\xF0\x9F\x98\xAA" }, { k: "slightly_frowning_face", v: "\xF0\x9F\x99\x81" }, { k: "slightly_smiling_face", v: "\xF0\x9F\x99\x82" }, { k: "slot_machine", v: "\xF0\x9F\x8E\xB0" }, { k: "slovakia", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB0" }, { k: "slovenia", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xAE" }, { k: "small_airplane", v: "\xF0\x9F\x9B\xA9" }, { k: "small_blue_diamond", v: "\xF0\x9F\x94\xB9" }, { k: "small_orange_diamond", v: "\xF0\x9F\x94\xB8" }, { k: "small_red_triangle", v: "\xF0\x9F\x94\xBA" }, { k: "small_red_triangle_down", v: "\xF0\x9F\x94\xBB" }, { k: "smile", v: "\xF0\x9F\x98\x84" }, { k: "smile_cat", v: "\xF0\x9F\x98\xB8" }, { k: "smiley", v: "\xF0\x9F\x98\x83" }, { k: "smiley_cat", v: "\xF0\x9F\x98\xBA" }, { k: "smiling_imp", v: "\xF0\x9F\x98\x88" }, { k: "smirk", v: "\xF0\x9F\x98\x8F" }, { k: "smirk_cat", v: "\xF0\x9F\x98\xBC" }, { k: "smoking", v: "\xF0\x9F\x9A\xAC" }, { k: "snail", v: "\xF0\x9F\x90\x8C" }, { k: "snake", v: "\xF0\x9F\x90\x8D" }, { k: "sneezing_face", v: "\xF0\x9F\xA4\xA7" }, { k: "snowboarder", v: "\xF0\x9F\x8F\x82" }, { k: "snowflake", v: "\xE2\x9D\x84\xEF\xB8\x8F" }, { k: "snowman", v: "\xE2\x9B\x84\xEF\xB8\x8F" }, { k: "snowman_with_snow", v: "\xE2\x98\x83\xEF\xB8\x8F" }, { k: "sob", v: "\xF0\x9F\x98\xAD" }, { k: "soccer", v: "\xE2\x9A\xBD\xEF\xB8\x8F" }, { k: "solo", v: "${emojiSite}/solo.png" }, { k: "solomon_islands", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xA7" }, { k: "somalia", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB4" }, { k: "soon", v: "\xF0\x9F\x94\x9C" }, { k: "sos", v: "\xF0\x9F\x86\x98" }, { k: "sound", v: "\xF0\x9F\x94\x89" }, { k: "south_africa", v: "\xF0\x9F\x87\xBF\xF0\x9F\x87\xA6" }, { k: "south_georgia_south_sandwich_islands", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xB8" }, { k: "south_sudan", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB8" }, { k: "space_invader", v: "\xF0\x9F\x91\xBE" }, { k: "spades", v: "\xE2\x99\xA0\xEF\xB8\x8F" }, { k: "spaghetti", v: "\xF0\x9F\x8D\x9D" }, { k: "sparkle", v: "\xE2\x9D\x87\xEF\xB8\x8F" }, { k: "sparkler", v: "\xF0\x9F\x8E\x87" }, { k: "sparkles", v: "\xE2\x9C\xA8" }, { k: "sparkling_heart", v: "\xF0\x9F\x92\x96" }, { k: "speak_no_evil", v: "\xF0\x9F\x99\x8A" }, { k: "speaker", v: "\xF0\x9F\x94\x88" }, { k: "speaking_head", v: "\xF0\x9F\x97\xA3" }, { k: "speech_balloon", v: "\xF0\x9F\x92\xAC" }, { k: "speedboat", v: "\xF0\x9F\x9A\xA4" }, { k: "spider", v: "\xF0\x9F\x95\xB7" }, { k: "spider_web", v: "\xF0\x9F\x95\xB8" }, { k: "spiral_calendar", v: "\xF0\x9F\x97\x93" }, { k: "spiral_notepad", v: "\xF0\x9F\x97\x92" }, { k: "spoon", v: "\xF0\x9F\xA5\x84" }, { k: "squid", v: "\xF0\x9F\xA6\x91" }, { k: "sri_lanka", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xB0" }, { k: "st_barthelemy", v: "\xF0\x9F\x87\xA7\xF0\x9F\x87\xB1" }, { k: "st_helena", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xAD" }, { k: "st_kitts_nevis", v: "\xF0\x9F\x87\xB0\xF0\x9F\x87\xB3" }, { k: "st_lucia", v: "\xF0\x9F\x87\xB1\xF0\x9F\x87\xA8" }, { k: "st_pierre_miquelon", v: "\xF0\x9F\x87\xB5\xF0\x9F\x87\xB2" }, { k: "st_vincent_grenadines", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xA8" }, { k: "stadium", v: "\xF0\x9F\x8F\x9F" }, { k: "star", v: "\xE2\xAD\x90\xEF\xB8\x8F" }, { k: "star2", v: "\xF0\x9F\x8C\x9F" }, { k: "star_and_crescent", v: "\xE2\x98\xAA\xEF\xB8\x8F" }, { k: "star_of_david", v: "\xE2\x9C\xA1\xEF\xB8\x8F" }, { k: "stars", v: "\xF0\x9F\x8C\xA0" }, { k: "station", v: "\xF0\x9F\x9A\x89" }, { k: "statue_of_liberty", v: "\xF0\x9F\x97\xBD" }, { k: "steam_locomotive", v: "\xF0\x9F\x9A\x82" }, { k: "stew", v: "\xF0\x9F\x8D\xB2" }, { k: "stop_button", v: "\xE2\x8F\xB9" }, { k: "stop_sign", v: "\xF0\x9F\x9B\x91" }, { k: "stopwatch", v: "\xE2\x8F\xB1" }, { k: "straight_ruler", v: "\xF0\x9F\x93\x8F" }, { k: "strawberry", v: "\xF0\x9F\x8D\x93" }, { k: "stuck_out_tongue", v: "\xF0\x9F\x98\x9B" }, { k: "stuck_out_tongue_closed_eyes", v: "\xF0\x9F\x98\x9D" }, { k: "stuck_out_tongue_winking_eye", v: "\xF0\x9F\x98\x9C" }, { k: "studio_microphone", v: "\xF0\x9F\x8E\x99" }, { k: "stuffed_flatbread", v: "\xF0\x9F\xA5\x99" }, { k: "sudan", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xA9" }, { k: "sun_behind_large_cloud", v: "\xF0\x9F\x8C\xA5" }, { k: "sun_behind_rain_cloud", v: "\xF0\x9F\x8C\xA6" }, { k: "sun_behind_small_cloud", v: "\xF0\x9F\x8C\xA4" }, { k: "sun_with_face", v: "\xF0\x9F\x8C\x9E" }, { k: "sunflower", v: "\xF0\x9F\x8C\xBB" }, { k: "sunglasses", v: "\xF0\x9F\x98\x8E" }, { k: "sunny", v: "\xE2\x98\x80\xEF\xB8\x8F" }, { k: "sunrise", v: "\xF0\x9F\x8C\x85" }, { k: "sunrise_over_mountains", v: "\xF0\x9F\x8C\x84" }, { k: "surfer", v: "\xF0\x9F\x8F\x84" }, { k: "surfing_man", v: "\xF0\x9F\x8F\x84" }, { k: "surfing_woman", v: "\xF0\x9F\x8F\x84\xE2\x80\x8D\xE2\x99\x80" }, { k: "suriname", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xB7" }, { k: "sushi", v: "\xF0\x9F\x8D\xA3" }, { k: "suspension_railway", v: "\xF0\x9F\x9A\x9F" }, { k: "swaziland", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xBF" }, { k: "sweat", v: "\xF0\x9F\x98\x93" }, { k: "sweat_drops", v: "\xF0\x9F\x92\xA6" }, { k: "sweat_smile", v: "\xF0\x9F\x98\x85" }, { k: "sweden", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xAA" }, { k: "sweet_potato", v: "\xF0\x9F\x8D\xA0" }, { k: "swimmer", v: "\xF0\x9F\x8F\x8A" }, { k: "swimming_man", v: "\xF0\x9F\x8F\x8A" }, { k: "swimming_woman", v: "\xF0\x9F\x8F\x8A\xE2\x80\x8D\xE2\x99\x80" }, { k: "switzerland", v: "\xF0\x9F\x87\xA8\xF0\x9F\x87\xAD" }, { k: "sym", v: "${emojiSite}/sym.png" }, { k: "symbols", v: "\xF0\x9F\x94\xA3" }, { k: "synagogue", v: "\xF0\x9F\x95\x8D" }, { k: "syria", v: "\xF0\x9F\x87\xB8\xF0\x9F\x87\xBE" }, { k: "syringe", v: "\xF0\x9F\x92\x89" }, { k: "taco", v: "\xF0\x9F\x8C\xAE" }, { k: "tada", v: "\xF0\x9F\x8E\x89" }, { k: "taiwan", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xBC" }, { k: "tajikistan", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xAF" }, { k: "tanabata_tree", v: "\xF0\x9F\x8E\x8B" }, { k: "tangerine", v: "\xF0\x9F\x8D\x8A" }, { k: "tanzania", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xBF" }, { k: "taurus", v: "\xE2\x99\x89\xEF\xB8\x8F" }, { k: "taxi", v: "\xF0\x9F\x9A\x95" }, { k: "tea", v: "\xF0\x9F\x8D\xB5" }, { k: "telephone", v: "\xE2\x98\x8E\xEF\xB8\x8F" }, { k: "telephone_receiver", v: "\xF0\x9F\x93\x9E" }, { k: "telescope", v: "\xF0\x9F\x94\xAD" }, { k: "tennis", v: "\xF0\x9F\x8E\xBE" }, { k: "tent", v: "\xE2\x9B\xBA\xEF\xB8\x8F" }, { k: "thailand", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xAD" }, { k: "thermometer", v: "\xF0\x9F\x8C\xA1" }, { k: "thinking", v: "\xF0\x9F\xA4\x94" }, { k: "thought_balloon", v: "\xF0\x9F\x92\xAD" }, { k: "three", v: "3\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "thumbsdown", v: "\xF0\x9F\x91\x8E" }, { k: "thumbsup", v: "\xF0\x9F\x91\x8D" }, { k: "ticket", v: "\xF0\x9F\x8E\xAB" }, { k: "tickets", v: "\xF0\x9F\x8E\x9F" }, { k: "tiger", v: "\xF0\x9F\x90\xAF" }, { k: "tiger2", v: "\xF0\x9F\x90\x85" }, { k: "timer_clock", v: "\xE2\x8F\xB2" }, { k: "timor_leste", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB1" }, { k: "tipping_hand_man", v: "\xF0\x9F\x92\x81\xE2\x80\x8D\xE2\x99\x82" }, { k: "tipping_hand_woman", v: "\xF0\x9F\x92\x81" }, { k: "tired_face", v: "\xF0\x9F\x98\xAB" }, { k: "tm", v: "\xE2\x84\xA2\xEF\xB8\x8F" }, { k: "togo", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xAC" }, { k: "toilet", v: "\xF0\x9F\x9A\xBD" }, { k: "tokelau", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB0" }, { k: "tokyo_tower", v: "\xF0\x9F\x97\xBC" }, { k: "tomato", v: "\xF0\x9F\x8D\x85" }, { k: "tonga", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB4" }, { k: "tongue", v: "\xF0\x9F\x91\x85" }, { k: "top", v: "\xF0\x9F\x94\x9D" }, { k: "tophat", v: "\xF0\x9F\x8E\xA9" }, { k: "tornado", v: "\xF0\x9F\x8C\xAA" }, { k: "tr", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB7" }, { k: "trackball", v: "\xF0\x9F\x96\xB2" }, { k: "tractor", v: "\xF0\x9F\x9A\x9C" }, { k: "traffic_light", v: "\xF0\x9F\x9A\xA5" }, { k: "train", v: "\xF0\x9F\x9A\x8B" }, { k: "train2", v: "\xF0\x9F\x9A\x86" }, { k: "tram", v: "\xF0\x9F\x9A\x8A" }, { k: "triangular_flag_on_post", v: "\xF0\x9F\x9A\xA9" }, { k: "triangular_ruler", v: "\xF0\x9F\x93\x90" }, { k: "trident", v: "\xF0\x9F\x94\xB1" }, { k: "trinidad_tobago", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB9" }, { k: "triumph", v: "\xF0\x9F\x98\xA4" }, { k: "trolleybus", v: "\xF0\x9F\x9A\x8E" }, { k: "trollface", v: "${emojiSite}/trollface.png" }, { k: "trophy", v: "\xF0\x9F\x8F\x86" }, { k: "tropical_drink", v: "\xF0\x9F\x8D\xB9" }, { k: "tropical_fish", v: "\xF0\x9F\x90\xA0" }, { k: "truck", v: "\xF0\x9F\x9A\x9A" }, { k: "trumpet", v: "\xF0\x9F\x8E\xBA" }, { k: "tshirt", v: "\xF0\x9F\x91\x95" }, { k: "tulip", v: "\xF0\x9F\x8C\xB7" }, { k: "tumbler_glass", v: "\xF0\x9F\xA5\x83" }, { k: "tunisia", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB3" }, { k: "turkey", v: "\xF0\x9F\xA6\x83" }, { k: "turkmenistan", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xB2" }, { k: "turks_caicos_islands", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xA8" }, { k: "turtle", v: "\xF0\x9F\x90\xA2" }, { k: "tuvalu", v: "\xF0\x9F\x87\xB9\xF0\x9F\x87\xBB" }, { k: "tv", v: "\xF0\x9F\x93\xBA" }, { k: "twisted_rightwards_arrows", v: "\xF0\x9F\x94\x80" }, { k: "two", v: "2\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "two_hearts", v: "\xF0\x9F\x92\x95" }, { k: "two_men_holding_hands", v: "\xF0\x9F\x91\xAC" }, { k: "two_women_holding_hands", v: "\xF0\x9F\x91\xAD" }, { k: "u5272", v: "\xF0\x9F\x88\xB9" }, { k: "u5408", v: "\xF0\x9F\x88\xB4" }, { k: "u55b6", v: "\xF0\x9F\x88\xBA" }, { k: "u6307", v: "\xF0\x9F\x88\xAF\xEF\xB8\x8F" }, { k: "u6708", v: "\xF0\x9F\x88\xB7\xEF\xB8\x8F" }, { k: "u6709", v: "\xF0\x9F\x88\xB6" }, { k: "u6e80", v: "\xF0\x9F\x88\xB5" }, { k: "u7121", v: "\xF0\x9F\x88\x9A\xEF\xB8\x8F" }, { k: "u7533", v: "\xF0\x9F\x88\xB8" }, { k: "u7981", v: "\xF0\x9F\x88\xB2" }, { k: "u7a7a", v: "\xF0\x9F\x88\xB3" }, { k: "uganda", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xAC" }, { k: "uk", v: "\xF0\x9F\x87\xAC\xF0\x9F\x87\xA7" }, { k: "ukraine", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xA6" }, { k: "umbrella", v: "\xE2\x98\x94\xEF\xB8\x8F" }, { k: "unamused", v: "\xF0\x9F\x98\x92" }, { k: "underage", v: "\xF0\x9F\x94\x9E" }, { k: "unicorn", v: "\xF0\x9F\xA6\x84" }, { k: "united_arab_emirates", v: "\xF0\x9F\x87\xA6\xF0\x9F\x87\xAA" }, { k: "unlock", v: "\xF0\x9F\x94\x93" }, { k: "up", v: "\xF0\x9F\x86\x99" }, { k: "upside_down_face", v: "\xF0\x9F\x99\x83" }, { k: "uruguay", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xBE" }, { k: "us", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xB8" }, { k: "us_virgin_islands", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xAE" }, { k: "uzbekistan", v: "\xF0\x9F\x87\xBA\xF0\x9F\x87\xBF" }, { k: "v", v: "\xE2\x9C\x8C\xEF\xB8\x8F" }, { k: "vanuatu", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xBA" }, { k: "vatican_city", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xA6" }, { k: "vditor", v: "${emojiSite}/vditor.png" }, { k: "venezuela", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xAA" }, { k: "vertical_traffic_light", v: "\xF0\x9F\x9A\xA6" }, { k: "vhs", v: "\xF0\x9F\x93\xBC" }, { k: "vibration_mode", v: "\xF0\x9F\x93\xB3" }, { k: "video_camera", v: "\xF0\x9F\x93\xB9" }, { k: "video_game", v: "\xF0\x9F\x8E\xAE" }, { k: "vietnam", v: "\xF0\x9F\x87\xBB\xF0\x9F\x87\xB3" }, { k: "violin", v: "\xF0\x9F\x8E\xBB" }, { k: "virgo", v: "\xE2\x99\x8D\xEF\xB8\x8F" }, { k: "volcano", v: "\xF0\x9F\x8C\x8B" }, { k: "volleyball", v: "\xF0\x9F\x8F\x90" }, { k: "vs", v: "\xF0\x9F\x86\x9A" }, { k: "vulcan_salute", v: "\xF0\x9F\x96\x96" }, { k: "walking", v: "\xF0\x9F\x9A\xB6" }, { k: "walking_man", v: "\xF0\x9F\x9A\xB6" }, { k: "walking_woman", v: "\xF0\x9F\x9A\xB6\xE2\x80\x8D\xE2\x99\x80" }, { k: "wallis_futuna", v: "\xF0\x9F\x87\xBC\xF0\x9F\x87\xAB" }, { k: "waning_crescent_moon", v: "\xF0\x9F\x8C\x98" }, { k: "waning_gibbous_moon", v: "\xF0\x9F\x8C\x96" }, { k: "warning", v: "\xE2\x9A\xA0\xEF\xB8\x8F" }, { k: "wastebasket", v: "\xF0\x9F\x97\x91" }, { k: "watch", v: "\xE2\x8C\x9A\xEF\xB8\x8F" }, { k: "water_buffalo", v: "\xF0\x9F\x90\x83" }, { k: "watermelon", v: "\xF0\x9F\x8D\x89" }, { k: "wave", v: "\xF0\x9F\x91\x8B" }, { k: "wavy_dash", v: "\xE3\x80\xB0\xEF\xB8\x8F" }, { k: "waxing_crescent_moon", v: "\xF0\x9F\x8C\x92" }, { k: "waxing_gibbous_moon", v: "\xF0\x9F\x8C\x94" }, { k: "wc", v: "\xF0\x9F\x9A\xBE" }, { k: "weary", v: "\xF0\x9F\x98\xA9" }, { k: "wedding", v: "\xF0\x9F\x92\x92" }, { k: "weight_lifting_man", v: "\xF0\x9F\x8F\x8B" }, { k: "weight_lifting_woman", v: "\xF0\x9F\x8F\x8B\xEF\xB8\x8F\xE2\x80\x8D\xE2\x99\x80\xEF\xB8\x8F" }, { k: "western_sahara", v: "\xF0\x9F\x87\xAA\xF0\x9F\x87\xAD" }, { k: "whale", v: "\xF0\x9F\x90\xB3" }, { k: "whale2", v: "\xF0\x9F\x90\x8B" }, { k: "wheel_of_dharma", v: "\xE2\x98\xB8\xEF\xB8\x8F" }, { k: "wheelchair", v: "\xE2\x99\xBF\xEF\xB8\x8F" }, { k: "white_check_mark", v: "\xE2\x9C\x85" }, { k: "white_circle", v: "\xE2\x9A\xAA\xEF\xB8\x8F" }, { k: "white_flag", v: "\xF0\x9F\x8F\xB3\xEF\xB8\x8F" }, { k: "white_flower", v: "\xF0\x9F\x92\xAE" }, { k: "white_large_square", v: "\xE2\xAC\x9C\xEF\xB8\x8F" }, { k: "white_medium_small_square", v: "\xE2\x97\xBD\xEF\xB8\x8F" }, { k: "white_medium_square", v: "\xE2\x97\xBB\xEF\xB8\x8F" }, { k: "white_small_square", v: "\xE2\x96\xAB\xEF\xB8\x8F" }, { k: "white_square_button", v: "\xF0\x9F\x94\xB3" }, { k: "wide", v: "${emojiSite}/wide.png" }, { k: "wilted_flower", v: "\xF0\x9F\xA5\x80" }, { k: "wind_chime", v: "\xF0\x9F\x8E\x90" }, { k: "wind_face", v: "\xF0\x9F\x8C\xAC" }, { k: "wine_glass", v: "\xF0\x9F\x8D\xB7" }, { k: "wink", v: "\xF0\x9F\x98\x89" }, { k: "wolf", v: "\xF0\x9F\x90\xBA" }, { k: "woman", v: "\xF0\x9F\x91\xA9" }, { k: "woman_artist", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8E\xA8" }, { k: "woman_astronaut", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x9A\x80" }, { k: "woman_cartwheeling", v: "\xF0\x9F\xA4\xB8\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_cook", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8D\xB3" }, { k: "woman_facepalming", v: "\xF0\x9F\xA4\xA6\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_factory_worker", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8F\xAD" }, { k: "woman_farmer", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8C\xBE" }, { k: "woman_firefighter", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x9A\x92" }, { k: "woman_health_worker", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9A\x95" }, { k: "woman_judge", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9A\x96" }, { k: "woman_juggling", v: "\xF0\x9F\xA4\xB9\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_mechanic", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x94\xA7" }, { k: "woman_office_worker", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x92\xBC" }, { k: "woman_pilot", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xE2\x9C\x88" }, { k: "woman_playing_handball", v: "\xF0\x9F\xA4\xBE\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_playing_water_polo", v: "\xF0\x9F\xA4\xBD\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_scientist", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x94\xAC" }, { k: "woman_shrugging", v: "\xF0\x9F\xA4\xB7\xE2\x80\x8D\xE2\x99\x80" }, { k: "woman_singer", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8E\xA4" }, { k: "woman_student", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8E\x93" }, { k: "woman_teacher", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x8F\xAB" }, { k: "woman_technologist", v: "\xF0\x9F\x91\xA9\xE2\x80\x8D\xF0\x9F\x92\xBB" }, { k: "woman_with_turban", v: "\xF0\x9F\x91\xB3\xE2\x80\x8D\xE2\x99\x80" }, { k: "womans_clothes", v: "\xF0\x9F\x91\x9A" }, { k: "womans_hat", v: "\xF0\x9F\x91\x92" }, { k: "women_wrestling", v: "\xF0\x9F\xA4\xBC\xE2\x80\x8D\xE2\x99\x80" }, { k: "womens", v: "\xF0\x9F\x9A\xBA" }, { k: "world_map", v: "\xF0\x9F\x97\xBA" }, { k: "worried", v: "\xF0\x9F\x98\x9F" }, { k: "wrench", v: "\xF0\x9F\x94\xA7" }, { k: "writing_hand", v: "\xE2\x9C\x8D\xEF\xB8\x8F" }, { k: "wulian", v: "${emojiSite}/wulian.png" }, { k: "x", v: "\xE2\x9D\x8C" }, { k: "yellow_heart", v: "\xF0\x9F\x92\x9B" }, { k: "yemen", v: "\xF0\x9F\x87\xBE\xF0\x9F\x87\xAA" }, { k: "yen", v: "\xF0\x9F\x92\xB4" }, { k: "yin_yang", v: "\xE2\x98\xAF\xEF\xB8\x8F" }, { k: "yum", v: "\xF0\x9F\x98\x8B" }, { k: "zambia", v: "\xF0\x9F\x87\xBF\xF0\x9F\x87\xB2" }, { k: "zap", v: "\xE2\x9A\xA1\xEF\xB8\x8F" }, { k: "zero", v: "0\xEF\xB8\x8F\xE2\x83\xA3" }, { k: "zimbabwe", v: "\xF0\x9F\x87\xBF\xF0\x9F\x87\xBC" }, { k: "zipper_mouth_face", v: "\xF0\x9F\xA4\x90" }, { k: "zzz", v: "\xF0\x9F\x92\xA4" }]);
		htmlBlockTags1 = new sliceType$1([util.StrToBytes("<script"), util.StrToBytes("<pre"), util.StrToBytes("<style")]);
		htmlBlockCloseTags1 = new sliceType$1([util.StrToBytes("</script>"), util.StrToBytes("</pre>"), util.StrToBytes("</style>")]);
		htmlBlockTags6 = new sliceType$1([util.StrToBytes("<address"), util.StrToBytes("<article"), util.StrToBytes("<aside"), util.StrToBytes("<base"), util.StrToBytes("<basefont"), util.StrToBytes("<blockquote"), util.StrToBytes("<body"), util.StrToBytes("<caption"), util.StrToBytes("<center"), util.StrToBytes("<col"), util.StrToBytes("<colgroup"), util.StrToBytes("<dd"), util.StrToBytes("<details"), util.StrToBytes("<dialog"), util.StrToBytes("<dir"), util.StrToBytes("<div"), util.StrToBytes("<dl"), util.StrToBytes("<dt"), util.StrToBytes("<fieldset"), util.StrToBytes("<figcaption"), util.StrToBytes("<figure"), util.StrToBytes("<footer"), util.StrToBytes("<form"), util.StrToBytes("<frame"), util.StrToBytes("<frameset"), util.StrToBytes("<h1"), util.StrToBytes("<h2"), util.StrToBytes("<h3"), util.StrToBytes("<h4"), util.StrToBytes("<h5"), util.StrToBytes("<h6"), util.StrToBytes("<head"), util.StrToBytes("<header"), util.StrToBytes("<hr"), util.StrToBytes("<html"), util.StrToBytes("<iframe"), util.StrToBytes("<legend"), util.StrToBytes("<li"), util.StrToBytes("<link"), util.StrToBytes("<main"), util.StrToBytes("<menu"), util.StrToBytes("<menuitem"), util.StrToBytes("<nav"), util.StrToBytes("<noframes"), util.StrToBytes("<ol"), util.StrToBytes("<optgroup"), util.StrToBytes("<option"), util.StrToBytes("<p"), util.StrToBytes("<param"), util.StrToBytes("<section"), util.StrToBytes("<source"), util.StrToBytes("<summary"), util.StrToBytes("<table"), util.StrToBytes("<tbody"), util.StrToBytes("<td"), util.StrToBytes("<tfoot"), util.StrToBytes("<th"), util.StrToBytes("<thead"), util.StrToBytes("<title"), util.StrToBytes("<tr"), util.StrToBytes("<track"), util.StrToBytes("<ul"), util.StrToBytes("</address"), util.StrToBytes("</article"), util.StrToBytes("</aside"), util.StrToBytes("</base"), util.StrToBytes("</basefont"), util.StrToBytes("</blockquote"), util.StrToBytes("</body"), util.StrToBytes("</caption"), util.StrToBytes("</center"), util.StrToBytes("</col"), util.StrToBytes("</colgroup"), util.StrToBytes("</dd"), util.StrToBytes("</details"), util.StrToBytes("</dialog"), util.StrToBytes("</dir"), util.StrToBytes("</div"), util.StrToBytes("</dl"), util.StrToBytes("</dt"), util.StrToBytes("</fieldset"), util.StrToBytes("</figcaption"), util.StrToBytes("</figure"), util.StrToBytes("</footer"), util.StrToBytes("</form"), util.StrToBytes("</frame"), util.StrToBytes("</frameset"), util.StrToBytes("</h1"), util.StrToBytes("</h2"), util.StrToBytes("</h3"), util.StrToBytes("</h4"), util.StrToBytes("</h5"), util.StrToBytes("</h6"), util.StrToBytes("</head"), util.StrToBytes("</header"), util.StrToBytes("</hr"), util.StrToBytes("</html"), util.StrToBytes("</iframe"), util.StrToBytes("</legend"), util.StrToBytes("</li"), util.StrToBytes("</link"), util.StrToBytes("</main"), util.StrToBytes("</menu"), util.StrToBytes("</menuitem"), util.StrToBytes("</nav"), util.StrToBytes("</noframes"), util.StrToBytes("</ol"), util.StrToBytes("</optgroup"), util.StrToBytes("</option"), util.StrToBytes("</p"), util.StrToBytes("</param"), util.StrToBytes("</section"), util.StrToBytes("</source"), util.StrToBytes("</summary"), util.StrToBytes("</table"), util.StrToBytes("</tbody"), util.StrToBytes("</td"), util.StrToBytes("</tfoot"), util.StrToBytes("</th"), util.StrToBytes("</thead"), util.StrToBytes("</title"), util.StrToBytes("</tr"), util.StrToBytes("</track"), util.StrToBytes("</ul")]);
		htmlBlockSinglequote = util.StrToBytes("'");
		htmlBlockDoublequote = util.StrToBytes("\"");
		htmlBlockGreater = util.StrToBytes(">");
		dollar = util.StrToBytes("$");
		items1 = util.StrToBytes("1");
		$pkg.MathBlockMarker = util.StrToBytes("$$");
		blockStarts = new sliceType$2([(function $b(t, container) {
			var _r, _r$1, _tuple, caret, container, def, footnotesDef, i, label, lowerCaseLabel, marker, t, token, x, x$1, x$2, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; caret = $f.caret; container = $f.container; def = $f.def; footnotesDef = $f.footnotesDef; i = $f.i; label = $f.label; lowerCaseLabel = $f.lowerCaseLabel; marker = $f.marker; t = $f.t; token = $f.token; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			if (!t.Context.Option.Footnotes) {
				$s = -1; return 0;
			}
			/* */ if (!t.Context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented) { */ case 1:
				marker = lex.Peek(t.Context.currentLine, t.Context.nextNonspace);
				if (!((91 === marker))) {
					$s = -1; return 0;
				}
				caret = lex.Peek(t.Context.currentLine, t.Context.nextNonspace + 1 >> 0);
				if (!((94 === caret))) {
					$s = -1; return 0;
				}
				label = new sliceType([94]);
				token = 0;
				i = 0;
				i = t.Context.nextNonspace + 2 >> 0;
				while (true) {
					if (!(i < t.Context.currentLineLen)) { break; }
					token = (x = t.Context.currentLine, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
					if ((32 === token) || (10 === token) || (9 === token)) {
						$s = -1; return 0;
					}
					if (93 === token) {
						break;
					}
					label = $append(label, token);
					i = i + (1) >> 0;
				}
				if (i >= t.Context.currentLineLen) {
					$s = -1; return 0;
				}
				if (!((58 === (x$1 = t.Context.currentLine, x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= x$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + x$2]))))) {
					$s = -1; return 0;
				}
				t.Context.advanceOffset(1, false);
				$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				t.Context.advanceOffset(label.$length + 2 >> 0, true);
				_r = t.Context.addChild(500, t.Context.nextNonspace); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				footnotesDef = _r;
				footnotesDef.Tokens = label;
				_r$1 = bytes.ToLower(label); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				lowerCaseLabel = _r$1;
				_tuple = t.Context.FindFootnotesDef(lowerCaseLabel);
				def = _tuple[1];
				if (ptrType.nil === def) {
					t.Context.FootnotesDefs = $append(t.Context.FootnotesDefs, footnotesDef);
				}
				$s = -1; return 1;
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.caret = caret; $f.container = container; $f.def = def; $f.footnotesDef = footnotesDef; $f.i = i; $f.label = label; $f.lowerCaseLabel = lowerCaseLabel; $f.marker = marker; $f.t = t; $f.token = token; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _r$1, container, ln, marker, markers$1, t, whitespace, withSpace, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; container = $f.container; ln = $f.ln; marker = $f.marker; markers$1 = $f.markers$1; t = $f.t; whitespace = $f.whitespace; withSpace = $f.withSpace; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.Context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented) { */ case 1:
				marker = lex.Peek(t.Context.currentLine, t.Context.nextNonspace);
				/* */ if (62 === marker) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (62 === marker) { */ case 3:
					markers$1 = new sliceType([marker]);
					t.Context.advanceNextNonspace();
					t.Context.advanceOffset(1, false);
					whitespace = lex.Peek(t.Context.currentLine, t.Context.offset);
					withSpace = (32 === whitespace) || (9 === whitespace);
					if (withSpace) {
						t.Context.advanceOffset(1, true);
						markers$1 = $append(markers$1, whitespace);
					}
					/* */ if (t.Context.Option.VditorWYSIWYG) { $s = 5; continue; }
					/* */ $s = 6; continue;
					/* if (t.Context.Option.VditorWYSIWYG) { */ case 5:
						ln = util.BytesToStr($subslice(t.Context.currentLine, t.Context.offset));
						ln = strings.ReplaceAll(ln, "\xE2\x80\xB8", "");
						_r = strings.TrimSpace(ln); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						ln = _r;
						if ("" === ln) {
							$s = -1; return 0;
						}
					/* } */ case 6:
					$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r$1 = t.Context.addChild(5, t.Context.nextNonspace); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_r$1;
					t.Context.addChildMarker(6, markers$1);
					$s = -1; return 1;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._r$1 = _r$1; $f.container = container; $f.ln = ln; $f.marker = marker; $f.markers$1 = markers$1; $f.t = t; $f.whitespace = whitespace; $f.withSpace = withSpace; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _tuple, container, content, crosshatchMarker, heading, id, level, markers$1, ok, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; container = $f.container; content = $f.content; crosshatchMarker = $f.crosshatchMarker; heading = $f.heading; id = $f.id; level = $f.level; markers$1 = $f.markers$1; ok = $f.ok; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.Context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented) { */ case 1:
				_tuple = t.parseATXHeading();
				ok = _tuple[0];
				markers$1 = _tuple[1];
				content = _tuple[2];
				level = _tuple[3];
				id = _tuple[4];
				/* */ if (ok) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (ok) { */ case 3:
					t.Context.advanceNextNonspace();
					t.Context.advanceOffset(content.$length, false);
					$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.Context.addChild(2, t.Context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					heading = _r;
					heading.HeadingLevel = level;
					heading.Tokens = content;
					heading.HeadingID = id;
					crosshatchMarker = new ast.Node.ptr(3, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, markers$1, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, 0, false, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
					heading.AppendChild(crosshatchMarker);
					t.Context.advanceOffset(t.Context.currentLineLen - t.Context.offset >> 0, false);
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.container = container; $f.content = content; $f.crosshatchMarker = crosshatchMarker; $f.heading = heading; $f.id = id; $f.level = level; $f.markers$1 = markers$1; $f.ok = ok; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _tuple, codeBlockFenceChar, codeBlockFenceLen, codeBlockFenceOffset, codeBlockInfo, codeBlockOpenFence, container, container$1, ok, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; codeBlockFenceChar = $f.codeBlockFenceChar; codeBlockFenceLen = $f.codeBlockFenceLen; codeBlockFenceOffset = $f.codeBlockFenceOffset; codeBlockInfo = $f.codeBlockInfo; codeBlockOpenFence = $f.codeBlockOpenFence; container = $f.container; container$1 = $f.container$1; ok = $f.ok; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.Context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented) { */ case 1:
				_tuple = t.parseFencedCode();
				ok = _tuple[0];
				codeBlockFenceChar = _tuple[1];
				codeBlockFenceLen = _tuple[2];
				codeBlockFenceOffset = _tuple[3];
				codeBlockOpenFence = _tuple[4];
				codeBlockInfo = _tuple[5];
				/* */ if (ok) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (ok) { */ case 3:
					$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.Context.addChild(11, t.Context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					container$1 = _r;
					container$1.IsFencedCodeBlock = true;
					container$1.CodeBlockFenceLen = codeBlockFenceLen;
					container$1.CodeBlockFenceChar = codeBlockFenceChar;
					container$1.CodeBlockFenceOffset = codeBlockFenceOffset;
					container$1.CodeBlockOpenFence = codeBlockOpenFence;
					container$1.CodeBlockInfo = codeBlockInfo;
					t.Context.advanceNextNonspace();
					t.Context.advanceOffset(codeBlockFenceLen, false);
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.codeBlockFenceChar = codeBlockFenceChar; $f.codeBlockFenceLen = codeBlockFenceLen; $f.codeBlockFenceOffset = codeBlockFenceOffset; $f.codeBlockInfo = codeBlockInfo; $f.codeBlockOpenFence = codeBlockOpenFence; $f.container = container; $f.container$1 = container$1; $f.ok = ok; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, child, container, level, nextTr, remains, t, table, tokens, tr, value, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; child = $f.child; container = $f.container; level = $f.level; nextTr = $f.nextTr; remains = $f.remains; t = $f.t; table = $f.table; tokens = $f.tokens; tr = $f.tr; value = $f.value; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			if (!t.Context.Option.Setext) {
				$s = -1; return 0;
			}
			/* */ if (!t.Context.indented && (container.Type === 1)) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented && (container.Type === 1)) { */ case 1:
				level = t.parseSetextHeading();
				/* */ if (!((0 === level))) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (!((0 === level))) { */ case 3:
					if (t.Context.Option.GFMTable) {
						table = t.Context.parseTable0(container.Tokens);
						if (!(ptrType.nil === table)) {
							container.Type = 106;
							container.TableAligns = table.TableAligns;
							tr = table.FirstChild;
							while (true) {
								if (!(!(ptrType.nil === tr))) { break; }
								nextTr = tr.Next;
								container.AppendChild(tr);
								tr = nextTr;
							}
							container.Tokens = sliceType.nil;
							$s = -1; return 0;
						}
					}
					$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					tokens = container.Tokens;
					/* while (true) { */ case 6:
						/* if (!(0 < tokens.$length && (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) { break; } */ if(!(0 < tokens.$length && (91 === (0 >= tokens.$length ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + 0])))) { $s = 7; continue; }
						_r = t.Context.parseLinkRefDef(tokens); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						remains = _r;
						if (!(sliceType.nil === remains)) {
							container.Tokens = remains;
						} else {
							/* break; */ $s = 7; continue;
						}
						tokens = container.Tokens;
					/* } */ $s = 6; continue; case 7:
					value = container.Tokens;
					if (0 < value.$length) {
						child = new ast.Node.ptr(2, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, sliceType.nil, false, false, false, 0, false, 0, 0, 0, sliceType.nil, sliceType.nil, sliceType.nil, 0, ptrType$1.nil, false, sliceType$3.nil, 0, 0, 0, sliceType.nil, sliceType.nil, 0, sliceType.nil, level, true, sliceType.nil, "", 0, sliceType.nil, "", sliceType$4.nil, sliceType.nil);
						child.Tokens = lex.TrimWhitespace(value);
						container.InsertAfter(child);
						container.Unlink();
						t.Context.Tip = child;
						t.Context.advanceOffset(t.Context.currentLineLen - t.Context.offset >> 0, false);
						$s = -1; return 2;
					}
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.child = child; $f.container = container; $f.level = level; $f.nextTr = nextTr; $f.remains = remains; $f.t = t; $f.table = table; $f.tokens = tokens; $f.tr = tr; $f.value = value; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, block, container, htmlType, t, tokens, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; block = $f.block; container = $f.container; htmlType = $f.htmlType; t = $f.t; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.Context.indented && (lex.Peek(t.Context.currentLine, t.Context.nextNonspace) === 60)) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented && (lex.Peek(t.Context.currentLine, t.Context.nextNonspace) === 60)) { */ case 1:
				tokens = $subslice(t.Context.currentLine, t.Context.nextNonspace);
				htmlType = t.parseHTML(tokens);
				/* */ if (!((0 === htmlType))) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (!((0 === htmlType))) { */ case 3:
					$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.Context.addChild(9, t.Context.offset); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					block = _r;
					block.HtmlBlockType = htmlType;
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.block = block; $f.container = container; $f.htmlType = htmlType; $f.t = t; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _tuple, caretTokens, container, ok, t, thematicBreak, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; caretTokens = $f.caretTokens; container = $f.container; ok = $f.ok; t = $f.t; thematicBreak = $f.thematicBreak; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.Context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented) { */ case 1:
				_tuple = t.parseThematicBreak();
				ok = _tuple[0];
				caretTokens = _tuple[1];
				/* */ if (ok) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (ok) { */ case 3:
					$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.Context.addChild(4, t.Context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					thematicBreak = _r;
					thematicBreak.Tokens = caretTokens;
					t.Context.advanceOffset(t.Context.currentLineLen - t.Context.offset >> 0, false);
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.caretTokens = caretTokens; $f.container = container; $f.ok = ok; $f.t = t; $f.thematicBreak = thematicBreak; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _r$1, container, data, list, listItem, listsMatch, prev, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; container = $f.container; data = $f.data; list = $f.list; listItem = $f.listItem; listsMatch = $f.listsMatch; prev = $f.prev; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.Context.indented || (container.Type === 7)) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented || (container.Type === 7)) { */ case 1:
				data = t.parseListMarker(container);
				if (ptrType$1.nil === data) {
					$s = -1; return 0;
				}
				$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				listsMatch = (container.Type === 7) && t.Context.listsMatch(container.ListData, data);
				/* */ if (!((t.Context.Tip.Type === 7)) || !listsMatch) { $s = 4; continue; }
				/* */ $s = 5; continue;
				/* if (!((t.Context.Tip.Type === 7)) || !listsMatch) { */ case 4:
					_r = t.Context.addChild(7, t.Context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					list = _r;
					list.ListData = data;
				/* } */ case 5:
				_r$1 = t.Context.addChild(8, t.Context.nextNonspace); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				listItem = _r$1;
				listItem.ListData = data;
				listItem.Tokens = data.Marker;
				if ((1 === listItem.ListData.Typ) || ((3 === listItem.ListData.Typ) && (0 === listItem.ListData.BulletChar))) {
					prev = listItem.Previous;
					if (!(ptrType.nil === prev)) {
						listItem.ListData.Num = prev.ListData.Num + 1 >> 0;
					} else {
						listItem.ListData.Num = data.Start;
					}
				}
				$s = -1; return 1;
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._r$1 = _r$1; $f.container = container; $f.data = data; $f.list = list; $f.listItem = listItem; $f.listsMatch = listsMatch; $f.prev = prev; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, _tuple, block, container, mathBlockDollarOffset, ok, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; block = $f.block; container = $f.container; mathBlockDollarOffset = $f.mathBlockDollarOffset; ok = $f.ok; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (!t.Context.indented) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!t.Context.indented) { */ case 1:
				_tuple = t.parseMathBlock();
				ok = _tuple[0];
				mathBlockDollarOffset = _tuple[1];
				/* */ if (ok) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (ok) { */ case 3:
					$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					_r = t.Context.addChild(300, t.Context.nextNonspace); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					block = _r;
					block.MathBlockDollarOffset = mathBlockDollarOffset;
					t.Context.advanceNextNonspace();
					t.Context.advanceOffset(mathBlockDollarOffset, false);
					$s = -1; return 2;
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f._tuple = _tuple; $f.block = block; $f.container = container; $f.mathBlockDollarOffset = mathBlockDollarOffset; $f.ok = ok; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		}), (function $b(t, container) {
			var _r, container, t, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; container = $f.container; t = $f.t; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (t.Context.indented && !((t.Context.Tip.Type === 1)) && !t.Context.blank) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (t.Context.indented && !((t.Context.Tip.Type === 1)) && !t.Context.blank) { */ case 1:
				t.Context.advanceOffset(4, true);
				$r = t.Context.closeUnmatchedBlocks(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_r = t.Context.addChild(11, t.Context.offset); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_r;
				$s = -1; return 2;
			/* } */ case 2:
			$s = -1; return 0;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._r = _r; $f.container = container; $f.t = t; $f.$s = $s; $f.$r = $r; return $f;
		})]);
		backslash = util.StrToBytes("\\");
		init();
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute/render"] = (function() {
	var $pkg = {}, $init, bytes, io, ast, html, lex, parse, util, strconv, strings, unicode, utf8, EChartsJSONRenderer, FormatRenderer, HtmlRenderer, RendererFunc, ExtRendererFunc, BaseRenderer, VditorRenderer, VditorIRRenderer, sliceType, sliceType$1, ptrType, ptrType$1, ptrType$2, ptrType$3, sliceType$2, sliceType$3, sliceType$4, ptrType$4, ptrType$5, ptrType$6, ptrType$7, sliceType$5, sliceType$6, sliceType$7, ptrType$8, ptrType$9, sliceType$8, ptrType$10, ptrType$11, ptrType$12, mapType, mapType$1, ptrType$13, ptrType$14, commonFileTypesLen, maxCommonFileTypeLen, commonFileTypes, headingLevel, setOfElementsToSkipContent, allowedAttrs, terms, chinesePunct0, chinesePunct00, NewEChartsJSONRenderer, isFileExt, NewFormatRenderer, NewHtmlRenderer, text, needRoot, NewBaseRenderer, HeadingID, headingID0, normalizeHeadingID, sanitize, linkable, writeLinkableBuf, sanitizeAttrs, allowAttr, Space0, addSpaceAtBoundary, allowSpace, isNotTerm, NewTerms, NewVditorRenderer, NewVditorIRRenderer;
	bytes = $packages["bytes"];
	io = $packages["io"];
	ast = $packages["lute/ast"];
	html = $packages["lute/html"];
	lex = $packages["lute/lex"];
	parse = $packages["lute/parse"];
	util = $packages["lute/util"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	unicode = $packages["unicode"];
	utf8 = $packages["unicode/utf8"];
	EChartsJSONRenderer = $pkg.EChartsJSONRenderer = $newType(0, $kindStruct, "render.EChartsJSONRenderer", true, "lute/render", true, function(BaseRenderer_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$2.nil;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
	});
	FormatRenderer = $pkg.FormatRenderer = $newType(0, $kindStruct, "render.FormatRenderer", true, "lute/render", true, function(BaseRenderer_, nodeWriterStack_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$2.nil;
			this.nodeWriterStack = sliceType$2.nil;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
		this.nodeWriterStack = nodeWriterStack_;
	});
	HtmlRenderer = $pkg.HtmlRenderer = $newType(0, $kindStruct, "render.HtmlRenderer", true, "lute/render", true, function(BaseRenderer_, needRenderFootnotesDef_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$2.nil;
			this.needRenderFootnotesDef = false;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
		this.needRenderFootnotesDef = needRenderFootnotesDef_;
	});
	RendererFunc = $pkg.RendererFunc = $newType(4, $kindFunc, "render.RendererFunc", true, "lute/render", true, null);
	ExtRendererFunc = $pkg.ExtRendererFunc = $newType(4, $kindFunc, "render.ExtRendererFunc", true, "lute/render", true, null);
	BaseRenderer = $pkg.BaseRenderer = $newType(0, $kindStruct, "render.BaseRenderer", true, "lute/render", true, function(Option_, RendererFuncs_, DefaultRendererFunc_, ExtRendererFuncs_, Writer_, LastOut_, Tree_, DisableTags_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Option = ptrType$8.nil;
			this.RendererFuncs = false;
			this.DefaultRendererFunc = $throwNilPointerError;
			this.ExtRendererFuncs = false;
			this.Writer = ptrType$3.nil;
			this.LastOut = 0;
			this.Tree = ptrType$9.nil;
			this.DisableTags = 0;
			return;
		}
		this.Option = Option_;
		this.RendererFuncs = RendererFuncs_;
		this.DefaultRendererFunc = DefaultRendererFunc_;
		this.ExtRendererFuncs = ExtRendererFuncs_;
		this.Writer = Writer_;
		this.LastOut = LastOut_;
		this.Tree = Tree_;
		this.DisableTags = DisableTags_;
	});
	VditorRenderer = $pkg.VditorRenderer = $newType(0, $kindStruct, "render.VditorRenderer", true, "lute/render", true, function(BaseRenderer_, needRenderFootnotesDef_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$2.nil;
			this.needRenderFootnotesDef = false;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
		this.needRenderFootnotesDef = needRenderFootnotesDef_;
	});
	VditorIRRenderer = $pkg.VditorIRRenderer = $newType(0, $kindStruct, "render.VditorIRRenderer", true, "lute/render", true, function(BaseRenderer_, needRenderFootnotesDef_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.BaseRenderer = ptrType$2.nil;
			this.needRenderFootnotesDef = false;
			return;
		}
		this.BaseRenderer = BaseRenderer_;
		this.needRenderFootnotesDef = needRenderFootnotesDef_;
	});
	sliceType = $sliceType($String);
	sliceType$1 = $sliceType($Int32);
	ptrType = $ptrType(sliceType$1);
	ptrType$1 = $ptrType(ast.Node);
	ptrType$2 = $ptrType(BaseRenderer);
	ptrType$3 = $ptrType(bytes.Buffer);
	sliceType$2 = $sliceType(ptrType$3);
	sliceType$3 = $sliceType($Uint8);
	sliceType$4 = $sliceType(ast.NodeType);
	ptrType$4 = $ptrType(ast.ListData);
	ptrType$5 = $ptrType(parse.Context);
	ptrType$6 = $ptrType(lex.Lexer);
	ptrType$7 = $ptrType(parse.InlineContext);
	sliceType$5 = $sliceType($Int);
	sliceType$6 = $sliceType(ptrType$1);
	sliceType$7 = $sliceType(sliceType);
	ptrType$8 = $ptrType(parse.Options);
	ptrType$9 = $ptrType(parse.Tree);
	sliceType$8 = $sliceType(html.Attribute);
	ptrType$10 = $ptrType(EChartsJSONRenderer);
	ptrType$11 = $ptrType(FormatRenderer);
	ptrType$12 = $ptrType(HtmlRenderer);
	mapType = $mapType(ast.NodeType, RendererFunc);
	mapType$1 = $mapType(ast.NodeType, ExtRendererFunc);
	ptrType$13 = $ptrType(VditorRenderer);
	ptrType$14 = $ptrType(VditorIRRenderer);
	BaseRenderer.ptr.prototype.ChinesePunct = function(textNode) {
		var r, text$1, textNode;
		r = this;
		text$1 = util.BytesToStr(textNode.Tokens);
		text$1 = chinesePunct0(text$1);
		textNode.Tokens = util.StrToBytes(text$1);
	};
	BaseRenderer.prototype.ChinesePunct = function(textNode) { return this.$val.ChinesePunct(textNode); };
	chinesePunct0 = function(text$1) {
		var _i, _ref, i, length, r, ret, runes, runes$24ptr, text$1, x, x$1, x$2;
		ret = "";
		runes = (new sliceType$1($stringToRunes(text$1)));
		length = runes.$length;
		_ref = runes;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			i = _i;
			r = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			if (((46 === r) || (33 === r) || (63 === r)) && (i + 1 >> 0) < length) {
				if ((46 === (x = i + 1 >> 0, ((x < 0 || x >= runes.$length) ? ($throwRuntimeError("index out of range"), undefined) : runes.$array[runes.$offset + x]))) || (33 === (x$1 = i + 1 >> 0, ((x$1 < 0 || x$1 >= runes.$length) ? ($throwRuntimeError("index out of range"), undefined) : runes.$array[runes.$offset + x$1]))) || (63 === (x$2 = i + 1 >> 0, ((x$2 < 0 || x$2 >= runes.$length) ? ($throwRuntimeError("index out of range"), undefined) : runes.$array[runes.$offset + x$2])))) {
					ret = ret + (($encodeRune(r)));
					_i++;
					continue;
				} else if (isFileExt(i + 1 >> 0, length, (runes$24ptr || (runes$24ptr = new ptrType(function() { return runes; }, function($v) { runes = $subslice(new sliceType$1($v.$array), $v.$offset, $v.$offset + $v.$length); }))))) {
					ret = ret + (($encodeRune(r)));
					_i++;
					continue;
				}
			}
			ret = chinesePunct00(ret, r);
			_i++;
		}
		return ret;
	};
	chinesePunct00 = function(prefix, nextChar) {
		var _tuple, currentChar, nextChar, nextCharIsEnglishBang, nextCharIsEnglishColon, nextCharIsEnglishComma, nextCharIsEnglishPeriod, nextCharIsEnglishQuestion, prefix, size;
		if (0 === prefix.length) {
			return ($encodeRune(nextChar));
		}
		nextCharIsEnglishComma = 44 === nextChar;
		nextCharIsEnglishPeriod = 46 === nextChar;
		nextCharIsEnglishColon = 58 === nextChar;
		nextCharIsEnglishBang = 33 === nextChar;
		nextCharIsEnglishQuestion = 63 === nextChar;
		_tuple = utf8.DecodeLastRuneInString(prefix);
		currentChar = _tuple[0];
		size = _tuple[1];
		if ((1 === size) && ((44 === currentChar)) && unicode.Is(unicode.Han, nextChar)) {
			return $substring(prefix, 0, (prefix.length - 1 >> 0)) + "\xEF\xBC\x8C" + ($encodeRune(nextChar));
		}
		if (!nextCharIsEnglishComma && !nextCharIsEnglishPeriod && !nextCharIsEnglishColon && !nextCharIsEnglishBang && !nextCharIsEnglishQuestion) {
			return prefix + ($encodeRune(nextChar));
		}
		if (!unicode.Is(unicode.Han, currentChar)) {
			return prefix + ($encodeRune(nextChar));
		}
		if (nextCharIsEnglishComma) {
			return prefix + "\xEF\xBC\x8C";
		} else if (nextCharIsEnglishPeriod) {
			return prefix + "\xE3\x80\x82";
		} else if (nextCharIsEnglishColon) {
			return prefix + "\xEF\xBC\x9A";
		} else if (nextCharIsEnglishBang) {
			return prefix + "\xEF\xBC\x81";
		} else if (nextCharIsEnglishQuestion) {
			return prefix + "\xEF\xBC\x9F";
		}
		return prefix + ($encodeRune(nextChar));
	};
	HtmlRenderer.ptr.prototype.renderCodeBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!node.IsFencedCodeBlock) {
			r.BaseRenderer.Newline();
			r.BaseRenderer.WriteString("<pre><code>");
			r.BaseRenderer.Write(util.EscapeHTML(node.FirstChild.Tokens));
			r.BaseRenderer.WriteString("</code></pre>");
			r.BaseRenderer.Newline();
			return 0;
		}
		r.BaseRenderer.Newline();
		return 2;
	};
	HtmlRenderer.prototype.renderCodeBlock = function(node, entering) { return this.$val.renderCodeBlock(node, entering); };
	HtmlRenderer.ptr.prototype.renderCodeBlockCode = function(node, entering) {
		var _r, entering, infoWords, json, language, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; entering = $f.entering; infoWords = $f.infoWords; json = $f.json; language = $f.language; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.Newline();
			tokens = node.Tokens;
			/* */ if (0 < node.Previous.CodeBlockInfo.$length) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (0 < node.Previous.CodeBlockInfo.$length) { */ case 3:
				infoWords = lex.Split(node.Previous.CodeBlockInfo, 32);
				language = ($bytesToString((0 >= infoWords.$length ? ($throwRuntimeError("index out of range"), undefined) : infoWords.$array[infoWords.$offset + 0])));
				/* */ if ("mindmap" === language) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if ("mindmap" === language) { */ case 6:
					_r = r.BaseRenderer.renderMindmap(tokens); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					json = _r;
					r.BaseRenderer.WriteString("<pre><code data-code=\"");
					r.BaseRenderer.Write(json);
					r.BaseRenderer.WriteString("\" class=\"language-mindmap\">");
					$s = 8; continue;
				/* } else { */ case 7:
					r.BaseRenderer.WriteString("<pre><code class=\"language-" + language + "\">");
				/* } */ case 8:
				tokens = util.EscapeHTML(tokens);
				r.BaseRenderer.Write(tokens);
				$s = 5; continue;
			/* } else { */ case 4:
				r.BaseRenderer.WriteString("<pre><code>");
				tokens = util.EscapeHTML(tokens);
				r.BaseRenderer.Write(tokens);
			/* } */ case 5:
			$s = -1; return 1;
		/* } */ case 2:
		r.BaseRenderer.WriteString("</code></pre>");
		r.BaseRenderer.Newline();
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.renderCodeBlockCode }; } $f._r = _r; $f.entering = entering; $f.infoWords = infoWords; $f.json = json; $f.language = language; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.renderCodeBlockCode = function(node, entering) { return this.$val.renderCodeBlockCode(node, entering); };
	NewEChartsJSONRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$28, _key$29, _key$3, _key$30, _key$31, _key$32, _key$33, _key$34, _key$4, _key$5, _key$6, _key$7, _key$8, _key$9, ret, tree;
		ret = new EChartsJSONRenderer.ptr(NewBaseRenderer(tree));
		_key = 0; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocument") };
		_key$1 = 1; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraph") };
		_key$2 = 16; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderText") };
		_key$3 = 27; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpan") };
		_key$4 = 11; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeBlock") };
		_key$5 = 300; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderMathBlock") };
		_key$6 = 304; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderInlineMath") };
		_key$7 = 17; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderEmphasis") };
		_key$8 = 22; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderStrong") };
		_key$9 = 5; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderBlockquote") };
		_key$10 = 2; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderHeading") };
		_key$11 = 7; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderList") };
		_key$12 = 8; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderListItem") };
		_key$13 = 4; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderThematicBreak") };
		_key$14 = 31; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderHardBreak") };
		_key$15 = 32; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderSoftBreak") };
		_key$16 = 9; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderHTML") };
		_key$17 = 10; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderInlineHTML") };
		_key$18 = 33; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderLink") };
		_key$19 = 34; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderImage") };
		_key$20 = 101; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderStrikethrough") };
		_key$21 = 100; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderTaskListItemMarker") };
		_key$22 = 106; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderTable") };
		_key$23 = 107; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderTableHead") };
		_key$24 = 108; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderTableRow") };
		_key$25 = 109; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderTableCell") };
		_key$26 = 200; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderEmoji") };
		_key$27 = 201; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderEmojiUnicode") };
		_key$28 = 202; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$28)] = { k: _key$28, v: $methodVal(ret, "renderEmojiImg") };
		_key$29 = 203; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$29)] = { k: _key$29, v: $methodVal(ret, "renderEmojiAlias") };
		_key$30 = 500; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$30)] = { k: _key$30, v: $methodVal(ret, "renderFootnotesDef") };
		_key$31 = 501; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$31)] = { k: _key$31, v: $methodVal(ret, "renderFootnotesRef") };
		_key$32 = 600; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$32)] = { k: _key$32, v: $methodVal(ret, "renderToC") };
		_key$33 = 400; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$33)] = { k: _key$33, v: $methodVal(ret, "renderBackslash") };
		_key$34 = 401; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$34)] = { k: _key$34, v: $methodVal(ret, "renderBackslashContent") };
		ret.BaseRenderer.DefaultRendererFunc = $methodVal(ret, "renderDefault");
		return ret;
	};
	$pkg.NewEChartsJSONRenderer = NewEChartsJSONRenderer;
	EChartsJSONRenderer.ptr.prototype.renderDefault = function(n, entering) {
		var entering, n, r;
		r = this;
		return 0;
	};
	EChartsJSONRenderer.prototype.renderDefault = function(n, entering) { return this.$val.renderDefault(n, entering); };
	EChartsJSONRenderer.ptr.prototype.renderBackslashContent = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	EChartsJSONRenderer.prototype.renderBackslashContent = function(node, entering) { return this.$val.renderBackslashContent(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderBackslash = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Blackslash\ndiv", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderBackslash = function(node, entering) { return this.$val.renderBackslash(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderToC = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("ToC\ndiv", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderToC = function(node, entering) { return this.$val.renderToC(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderFootnotesRef = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Footnotes Ref\ndiv", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderFootnotesRef = function(node, entering) { return this.$val.renderFootnotesRef(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderFootnotesDef = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Footnotes Def\np", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderFootnotesDef = function(node, entering) { return this.$val.renderFootnotesDef(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderInlineMath = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Inline Math\nspan", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderInlineMath = function(node, entering) { return this.$val.renderInlineMath(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderMathBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Math Block\ndiv", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderMathBlock = function(node, entering) { return this.$val.renderMathBlock(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderEmojiImg = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("Emoji Img\n", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderEmojiImg = function(node, entering) { return this.$val.renderEmojiImg(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderEmojiUnicode = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("Emoji Unicode\n", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderEmojiUnicode = function(node, entering) { return this.$val.renderEmojiUnicode(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderEmojiAlias = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	EChartsJSONRenderer.prototype.renderEmojiAlias = function(node, entering) { return this.$val.renderEmojiAlias(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderEmoji = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	EChartsJSONRenderer.prototype.renderEmoji = function(node, entering) { return this.$val.renderEmoji(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTableCell = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("Table Cell\ntd", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderTableCell = function(node, entering) { return this.$val.renderTableCell(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTableRow = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("Table Row\ntr", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderTableRow = function(node, entering) { return this.$val.renderTableRow(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTableHead = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("Table Head\nthead", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderTableHead = function(node, entering) { return this.$val.renderTableHead(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTable = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("Table\ntable", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderTable = function(node, entering) { return this.$val.renderTable(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderStrikethrough = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("Strikethrough\ndel", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderStrikethrough = function(node, entering) { return this.$val.renderStrikethrough(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderImage = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Image\nimg", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderImage = function(node, entering) { return this.$val.renderImage(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderLink = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Link\na", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderLink = function(node, entering) { return this.$val.renderLink(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("HTML Block\n", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderHTML = function(node, entering) { return this.$val.renderHTML(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderInlineHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.leaf("Inline HTML\n", node);
		return 0;
	};
	EChartsJSONRenderer.prototype.renderInlineHTML = function(node, entering) { return this.$val.renderInlineHTML(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderDocument = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.WriteByte(91);
			r.openObj();
			r.val("Document", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
			r.BaseRenderer.WriteByte(93);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderDocument = function(node, entering) { return this.$val.renderDocument(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderParagraph = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Paragraph\np", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderParagraph = function(node, entering) { return this.$val.renderParagraph(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderText = function(node, entering) {
		var _i, _ref, _rune, entering, i, node, r, r$1, summary, text$1;
		r = this;
		if (entering) {
			text$1 = util.BytesToStr(node.Tokens);
			i = 0;
			summary = "";
			_ref = text$1;
			_i = 0;
			while (true) {
				if (!(_i < _ref.length)) { break; }
				_rune = $decodeRune(_ref, _i);
				r$1 = _rune[0];
				i = i + (1) >> 0;
				summary = summary + (($encodeRune(r$1)));
				if (4 < i) {
					summary = summary + ("...");
					break;
				}
				_i += _rune[1];
			}
			r.openObj();
			r.val("Text\n" + summary, node);
			r.closeObj(node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderText = function(node, entering) { return this.$val.renderText(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderCodeSpan = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Code Span\ncode", node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderCodeSpan = function(node, entering) { return this.$val.renderCodeSpan(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderEmphasis = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Emphasis\nem", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderEmphasis = function(node, entering) { return this.$val.renderEmphasis(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderStrong = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Strong\nstrong", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderStrong = function(node, entering) { return this.$val.renderStrong(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderBlockquote = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("Blockquote\nblockquote", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderBlockquote = function(node, entering) { return this.$val.renderBlockquote(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderHeading = function(node, entering) {
		var entering, h, node, r;
		r = this;
		if (entering) {
			r.openObj();
			h = "h" + $substring(headingLevel, node.HeadingLevel, (node.HeadingLevel + 1 >> 0));
			r.val("Heading\n" + h, node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderHeading = function(node, entering) { return this.$val.renderHeading(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderList = function(node, entering) {
		var entering, list, node, r;
		r = this;
		if (entering) {
			r.openObj();
			list = "ul";
			if ((1 === node.ListData.Typ) || ((3 === node.ListData.Typ) && (0 === node.ListData.BulletChar))) {
				list = "ol";
			}
			r.val("List\n" + list, node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderList = function(node, entering) { return this.$val.renderList(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderListItem = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			r.val("List Item\nli " + util.BytesToStr(node.ListData.Marker), node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderListItem = function(node, entering) { return this.$val.renderListItem(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderTaskListItemMarker = function(node, entering) {
		var check, entering, node, r;
		r = this;
		if (entering) {
			r.openObj();
			check = " ";
			if (node.TaskListItemChecked) {
				check = "X";
			}
			r.val("Task List Item Marker\n[" + check + "]", node);
			r.openChildren(node);
		} else {
			r.closeChildren(node);
			r.closeObj(node);
		}
		return 2;
	};
	EChartsJSONRenderer.prototype.renderTaskListItemMarker = function(node, entering) { return this.$val.renderTaskListItemMarker(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderThematicBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Thematic Break\nhr", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderThematicBreak = function(node, entering) { return this.$val.renderThematicBreak(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderHardBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Hard Break\nbr", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderHardBreak = function(node, entering) { return this.$val.renderHardBreak(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderSoftBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Soft Break\n", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderSoftBreak = function(node, entering) { return this.$val.renderSoftBreak(node, entering); };
	EChartsJSONRenderer.ptr.prototype.renderCodeBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.leaf("Code Block\npre.code", node);
		}
		return 0;
	};
	EChartsJSONRenderer.prototype.renderCodeBlock = function(node, entering) { return this.$val.renderCodeBlock(node, entering); };
	EChartsJSONRenderer.ptr.prototype.leaf = function(val, node) {
		var node, r, val;
		r = this;
		r.openObj();
		r.val(val, node);
		r.closeObj(node);
	};
	EChartsJSONRenderer.prototype.leaf = function(val, node) { return this.$val.leaf(val, node); };
	EChartsJSONRenderer.ptr.prototype.val = function(val, node) {
		var node, r, val;
		r = this;
		val = strings.ReplaceAll(val, "\\", "\\\\");
		val = strings.ReplaceAll(val, "\n", "\\n");
		val = strings.ReplaceAll(val, "\"", "");
		val = strings.ReplaceAll(val, "'", "");
		r.BaseRenderer.WriteString("\"name\":\"" + val + "\"");
	};
	EChartsJSONRenderer.prototype.val = function(val, node) { return this.$val.val(val, node); };
	EChartsJSONRenderer.ptr.prototype.openObj = function() {
		var r;
		r = this;
		r.BaseRenderer.WriteByte(123);
	};
	EChartsJSONRenderer.prototype.openObj = function() { return this.$val.openObj(); };
	EChartsJSONRenderer.ptr.prototype.closeObj = function(node) {
		var node, r;
		r = this;
		r.BaseRenderer.WriteByte(125);
		if (!r.ignore(node.Next)) {
			r.comma();
		}
	};
	EChartsJSONRenderer.prototype.closeObj = function(node) { return this.$val.closeObj(node); };
	EChartsJSONRenderer.ptr.prototype.openChildren = function(node) {
		var node, r;
		r = this;
		if (!(ptrType$1.nil === node.FirstChild)) {
			r.BaseRenderer.WriteString(",\"children\":[");
		}
	};
	EChartsJSONRenderer.prototype.openChildren = function(node) { return this.$val.openChildren(node); };
	EChartsJSONRenderer.ptr.prototype.closeChildren = function(node) {
		var node, r;
		r = this;
		if (!(ptrType$1.nil === node.FirstChild)) {
			r.BaseRenderer.WriteByte(93);
		}
	};
	EChartsJSONRenderer.prototype.closeChildren = function(node) { return this.$val.closeChildren(node); };
	EChartsJSONRenderer.ptr.prototype.comma = function() {
		var r;
		r = this;
		r.BaseRenderer.WriteString(",");
	};
	EChartsJSONRenderer.prototype.comma = function() { return this.$val.comma(); };
	EChartsJSONRenderer.ptr.prototype.ignore = function(node) {
		var node, r;
		r = this;
		return ptrType$1.nil === node || (6 === node.Type) || (18 === node.Type) || (19 === node.Type) || (20 === node.Type) || (21 === node.Type) || (23 === node.Type) || (24 === node.Type) || (25 === node.Type) || (26 === node.Type) || (102 === node.Type) || (103 === node.Type) || (104 === node.Type) || (105 === node.Type) || (301 === node.Type) || (302 === node.Type) || (303 === node.Type) || (305 === node.Type) || (306 === node.Type) || (307 === node.Type);
	};
	EChartsJSONRenderer.prototype.ignore = function(node) { return this.$val.ignore(node); };
	isFileExt = function(pos, length, runes) {
		var ext, j, length, max, pos, runes;
		max = pos + maxCommonFileTypeLen >> 0;
		if (max > length) {
			max = length;
		}
		ext = ($runesToString($subslice((runes.$get()), pos, max)));
		j = 0;
		while (true) {
			if (!(j < commonFileTypesLen)) { break; }
			if (strings.HasPrefix(ext, ((j < 0 || j >= commonFileTypes.$length) ? ($throwRuntimeError("index out of range"), undefined) : commonFileTypes.$array[commonFileTypes.$offset + j]))) {
				return true;
			}
			j = j + (1) >> 0;
		}
		return false;
	};
	NewFormatRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$28, _key$29, _key$3, _key$30, _key$31, _key$32, _key$33, _key$34, _key$35, _key$36, _key$37, _key$38, _key$39, _key$4, _key$40, _key$41, _key$42, _key$43, _key$44, _key$45, _key$46, _key$47, _key$48, _key$49, _key$5, _key$50, _key$51, _key$52, _key$53, _key$54, _key$55, _key$56, _key$57, _key$58, _key$59, _key$6, _key$60, _key$61, _key$62, _key$63, _key$64, _key$65, _key$66, _key$67, _key$68, _key$69, _key$7, _key$70, _key$71, _key$8, _key$9, ret, tree;
		ret = new FormatRenderer.ptr(NewBaseRenderer(tree), sliceType$2.nil);
		_key = 0; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocument") };
		_key$1 = 1; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraph") };
		_key$2 = 16; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderText") };
		_key$3 = 27; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpan") };
		_key$4 = 28; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeSpanOpenMarker") };
		_key$5 = 29; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderCodeSpanContent") };
		_key$6 = 30; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderCodeSpanCloseMarker") };
		_key$7 = 11; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderCodeBlock") };
		_key$8 = 12; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderCodeBlockOpenMarker") };
		_key$9 = 14; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderCodeBlockInfoMarker") };
		_key$10 = 15; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderCodeBlockCode") };
		_key$11 = 13; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderCodeBlockCloseMarker") };
		_key$12 = 300; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderMathBlock") };
		_key$13 = 301; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderMathBlockOpenMarker") };
		_key$14 = 302; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderMathBlockContent") };
		_key$15 = 303; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderMathBlockCloseMarker") };
		_key$16 = 304; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderInlineMath") };
		_key$17 = 305; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderInlineMathOpenMarker") };
		_key$18 = 306; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderInlineMathContent") };
		_key$19 = 307; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderInlineMathCloseMarker") };
		_key$20 = 17; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderEmphasis") };
		_key$21 = 18; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderEmAsteriskOpenMarker") };
		_key$22 = 19; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderEmAsteriskCloseMarker") };
		_key$23 = 20; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderEmUnderscoreOpenMarker") };
		_key$24 = 21; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderEmUnderscoreCloseMarker") };
		_key$25 = 22; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderStrong") };
		_key$26 = 23; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderStrongA6kOpenMarker") };
		_key$27 = 24; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderStrongA6kCloseMarker") };
		_key$28 = 25; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$28)] = { k: _key$28, v: $methodVal(ret, "renderStrongU8eOpenMarker") };
		_key$29 = 26; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$29)] = { k: _key$29, v: $methodVal(ret, "renderStrongU8eCloseMarker") };
		_key$30 = 5; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$30)] = { k: _key$30, v: $methodVal(ret, "renderBlockquote") };
		_key$31 = 6; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$31)] = { k: _key$31, v: $methodVal(ret, "renderBlockquoteMarker") };
		_key$32 = 2; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$32)] = { k: _key$32, v: $methodVal(ret, "renderHeading") };
		_key$33 = 3; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$33)] = { k: _key$33, v: $methodVal(ret, "renderHeadingC8hMarker") };
		_key$34 = 7; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$34)] = { k: _key$34, v: $methodVal(ret, "renderList") };
		_key$35 = 8; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$35)] = { k: _key$35, v: $methodVal(ret, "renderListItem") };
		_key$36 = 4; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$36)] = { k: _key$36, v: $methodVal(ret, "renderThematicBreak") };
		_key$37 = 31; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$37)] = { k: _key$37, v: $methodVal(ret, "renderHardBreak") };
		_key$38 = 32; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$38)] = { k: _key$38, v: $methodVal(ret, "renderSoftBreak") };
		_key$39 = 9; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$39)] = { k: _key$39, v: $methodVal(ret, "renderHTML") };
		_key$40 = 10; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$40)] = { k: _key$40, v: $methodVal(ret, "renderInlineHTML") };
		_key$41 = 33; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$41)] = { k: _key$41, v: $methodVal(ret, "renderLink") };
		_key$42 = 34; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$42)] = { k: _key$42, v: $methodVal(ret, "renderImage") };
		_key$43 = 35; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$43)] = { k: _key$43, v: $methodVal(ret, "renderBang") };
		_key$44 = 36; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$44)] = { k: _key$44, v: $methodVal(ret, "renderOpenBracket") };
		_key$45 = 37; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$45)] = { k: _key$45, v: $methodVal(ret, "renderCloseBracket") };
		_key$46 = 38; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$46)] = { k: _key$46, v: $methodVal(ret, "renderOpenParen") };
		_key$47 = 39; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$47)] = { k: _key$47, v: $methodVal(ret, "renderCloseParen") };
		_key$48 = 40; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$48)] = { k: _key$48, v: $methodVal(ret, "renderLinkText") };
		_key$49 = 43; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$49)] = { k: _key$49, v: $methodVal(ret, "renderLinkSpace") };
		_key$50 = 41; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$50)] = { k: _key$50, v: $methodVal(ret, "renderLinkDest") };
		_key$51 = 42; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$51)] = { k: _key$51, v: $methodVal(ret, "renderLinkTitle") };
		_key$52 = 101; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$52)] = { k: _key$52, v: $methodVal(ret, "renderStrikethrough") };
		_key$53 = 102; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$53)] = { k: _key$53, v: $methodVal(ret, "renderStrikethrough1OpenMarker") };
		_key$54 = 103; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$54)] = { k: _key$54, v: $methodVal(ret, "renderStrikethrough1CloseMarker") };
		_key$55 = 104; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$55)] = { k: _key$55, v: $methodVal(ret, "renderStrikethrough2OpenMarker") };
		_key$56 = 105; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$56)] = { k: _key$56, v: $methodVal(ret, "renderStrikethrough2CloseMarker") };
		_key$57 = 100; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$57)] = { k: _key$57, v: $methodVal(ret, "renderTaskListItemMarker") };
		_key$58 = 106; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$58)] = { k: _key$58, v: $methodVal(ret, "renderTable") };
		_key$59 = 107; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$59)] = { k: _key$59, v: $methodVal(ret, "renderTableHead") };
		_key$60 = 108; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$60)] = { k: _key$60, v: $methodVal(ret, "renderTableRow") };
		_key$61 = 109; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$61)] = { k: _key$61, v: $methodVal(ret, "renderTableCell") };
		_key$62 = 200; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$62)] = { k: _key$62, v: $methodVal(ret, "renderEmoji") };
		_key$63 = 201; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$63)] = { k: _key$63, v: $methodVal(ret, "renderEmojiUnicode") };
		_key$64 = 202; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$64)] = { k: _key$64, v: $methodVal(ret, "renderEmojiImg") };
		_key$65 = 203; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$65)] = { k: _key$65, v: $methodVal(ret, "renderEmojiAlias") };
		_key$66 = 500; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$66)] = { k: _key$66, v: $methodVal(ret, "renderFootnotesDef") };
		_key$67 = 501; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$67)] = { k: _key$67, v: $methodVal(ret, "renderFootnotesRef") };
		_key$68 = 600; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$68)] = { k: _key$68, v: $methodVal(ret, "renderToC") };
		_key$69 = 400; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$69)] = { k: _key$69, v: $methodVal(ret, "renderBackslash") };
		_key$70 = 401; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$70)] = { k: _key$70, v: $methodVal(ret, "renderBackslashContent") };
		_key$71 = 44; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$71)] = { k: _key$71, v: $methodVal(ret, "renderHtmlEntity") };
		return ret;
	};
	$pkg.NewFormatRenderer = NewFormatRenderer;
	FormatRenderer.ptr.prototype.Render = function() {
		var _entry, _i, _keys, _r, _ref, buf, dest, label, node, output, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _r = $f._r; _ref = $f._ref; buf = $f.buf; dest = $f.dest; label = $f.label; node = $f.node; output = $f.output; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		output = sliceType$3.nil;
		r = this;
		_r = r.BaseRenderer.Render(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		output = _r;
		if (1 > $keys(r.BaseRenderer.Tree.Context.LinkRefDefs).length) {
			$s = -1; return output;
		}
		buf = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
		buf.WriteByte(10);
		_ref = r.BaseRenderer.Tree.Context.LinkRefDefs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			node = _entry.v;
			label = node.LinkRefLabel;
			dest = node.ChildByType(41).Tokens;
			buf.WriteString("[" + util.BytesToStr(label) + "]: " + util.BytesToStr(dest) + "\n");
			_i++;
		}
		output = $appendSlice(output, buf.Bytes());
		$s = -1; return output;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.Render }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._r = _r; $f._ref = _ref; $f.buf = buf; $f.dest = dest; $f.label = label; $f.node = node; $f.output = output; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.Render = function() { return this.$val.Render(); };
	FormatRenderer.ptr.prototype.renderHtmlEntity = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	FormatRenderer.prototype.renderHtmlEntity = function(node, entering) { return this.$val.renderHtmlEntity(node, entering); };
	FormatRenderer.ptr.prototype.renderBackslashContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	FormatRenderer.prototype.renderBackslashContent = function(node, entering) { return this.$val.renderBackslashContent(node, entering); };
	FormatRenderer.ptr.prototype.renderBackslash = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.WriteByte(92);
		}
		return 2;
	};
	FormatRenderer.prototype.renderBackslash = function(node, entering) { return this.$val.renderBackslash(node, entering); };
	FormatRenderer.ptr.prototype.renderToC = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("[toc]\n\n");
		return 0;
	};
	FormatRenderer.prototype.renderToC = function(node, entering) { return this.$val.renderToC(node, entering); };
	FormatRenderer.ptr.prototype.renderFootnotesRef = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("[" + util.BytesToStr(node.Tokens) + "]");
		return 0;
	};
	FormatRenderer.prototype.renderFootnotesRef = function(node, entering) { return this.$val.renderFootnotesRef(node, entering); };
	FormatRenderer.ptr.prototype.renderFootnotesDef = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.WriteString("[" + util.BytesToStr(node.Tokens) + "]: ");
		}
		return 2;
	};
	FormatRenderer.prototype.renderFootnotesDef = function(node, entering) { return this.$val.renderFootnotesDef(node, entering); };
	FormatRenderer.ptr.prototype.renderEmojiAlias = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	FormatRenderer.prototype.renderEmojiAlias = function(node, entering) { return this.$val.renderEmojiAlias(node, entering); };
	FormatRenderer.ptr.prototype.renderEmojiImg = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	FormatRenderer.prototype.renderEmojiImg = function(node, entering) { return this.$val.renderEmojiImg(node, entering); };
	FormatRenderer.ptr.prototype.renderEmojiUnicode = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	FormatRenderer.prototype.renderEmojiUnicode = function(node, entering) { return this.$val.renderEmojiUnicode(node, entering); };
	FormatRenderer.ptr.prototype.renderEmoji = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	FormatRenderer.prototype.renderEmoji = function(node, entering) { return this.$val.renderEmoji(node, entering); };
	FormatRenderer.ptr.prototype.renderTableCell = function(node, entering) {
		var _1, _2, _q, _q$1, entering, node, padding, r;
		r = this;
		padding = node.TableCellContentMaxWidth - node.TableCellContentWidth >> 0;
		if (entering) {
			r.BaseRenderer.WriteByte(124);
			r.BaseRenderer.WriteByte(32);
			_1 = node.TableCellAlign;
			if (_1 === (2)) {
				r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([32]), (_q = padding / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : $throwRuntimeError("integer divide by zero"))));
			} else if (_1 === (3)) {
				r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([32]), padding));
			}
		} else {
			_2 = node.TableCellAlign;
			if (_2 === (2)) {
				r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([32]), (_q$1 = padding / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : $throwRuntimeError("integer divide by zero"))));
			} else if (_2 === (3)) {
			} else {
				r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([32]), padding));
			}
			r.BaseRenderer.WriteByte(32);
		}
		return 2;
	};
	FormatRenderer.prototype.renderTableCell = function(node, entering) { return this.$val.renderTableCell(node, entering); };
	FormatRenderer.ptr.prototype.renderTableRow = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!entering) {
			r.BaseRenderer.WriteString("|\n");
		}
		return 2;
	};
	FormatRenderer.prototype.renderTableRow = function(node, entering) { return this.$val.renderTableRow(node, entering); };
	FormatRenderer.ptr.prototype.renderTableHead = function(node, entering) {
		var _1, align, entering, headRow, node, padding, padding$1, padding$2, padding$3, r, th;
		r = this;
		if (!entering) {
			headRow = node.FirstChild;
			th = headRow.FirstChild;
			while (true) {
				if (!(!(ptrType$1.nil === th))) { break; }
				align = th.TableCellAlign;
				_1 = align;
				if (_1 === (0)) {
					r.BaseRenderer.WriteString("| -");
					padding = th.TableCellContentMaxWidth - 1 >> 0;
					if (0 < padding) {
						r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([45]), padding));
					}
					r.BaseRenderer.WriteByte(32);
				} else if (_1 === (1)) {
					r.BaseRenderer.WriteString("| :-");
					padding$1 = th.TableCellContentMaxWidth - 2 >> 0;
					if (0 < padding$1) {
						r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([45]), padding$1));
					}
					r.BaseRenderer.WriteByte(32);
				} else if (_1 === (2)) {
					r.BaseRenderer.WriteString("| :-");
					padding$2 = th.TableCellContentMaxWidth - 3 >> 0;
					if (0 < padding$2) {
						r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([45]), padding$2));
					}
					r.BaseRenderer.WriteString(": ");
				} else if (_1 === (3)) {
					r.BaseRenderer.WriteString("| -");
					padding$3 = th.TableCellContentMaxWidth - 2 >> 0;
					if (0 < padding$3) {
						r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([45]), padding$3));
					}
					r.BaseRenderer.WriteString(": ");
				}
				th = th.Next;
			}
			r.BaseRenderer.WriteString("|\n");
		}
		return 2;
	};
	FormatRenderer.prototype.renderTableHead = function(node, entering) { return this.$val.renderTableHead(node, entering); };
	FormatRenderer.ptr.prototype.renderTable = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!entering) {
			r.BaseRenderer.Newline();
			if (!r.isLastNode(r.BaseRenderer.Tree.Root, node)) {
				r.BaseRenderer.WriteByte(10);
			}
		}
		return 2;
	};
	FormatRenderer.prototype.renderTable = function(node, entering) { return this.$val.renderTable(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.TextAutoSpacePrevious(node);
		} else {
			r.BaseRenderer.TextAutoSpaceNext(node);
		}
		return 2;
	};
	FormatRenderer.prototype.renderStrikethrough = function(node, entering) { return this.$val.renderStrikethrough(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough1OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(126);
		return 0;
	};
	FormatRenderer.prototype.renderStrikethrough1OpenMarker = function(node, entering) { return this.$val.renderStrikethrough1OpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough1CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(126);
		return 0;
	};
	FormatRenderer.prototype.renderStrikethrough1CloseMarker = function(node, entering) { return this.$val.renderStrikethrough1CloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough2OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("~~");
		return 0;
	};
	FormatRenderer.prototype.renderStrikethrough2OpenMarker = function(node, entering) { return this.$val.renderStrikethrough2OpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrikethrough2CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("~~");
		return 0;
	};
	FormatRenderer.prototype.renderStrikethrough2CloseMarker = function(node, entering) { return this.$val.renderStrikethrough2CloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderLinkTitle = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("\"");
		r.BaseRenderer.Write(node.Tokens);
		r.BaseRenderer.WriteString("\"");
		return 0;
	};
	FormatRenderer.prototype.renderLinkTitle = function(node, entering) { return this.$val.renderLinkTitle(node, entering); };
	FormatRenderer.ptr.prototype.renderLinkDest = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	FormatRenderer.prototype.renderLinkDest = function(node, entering) { return this.$val.renderLinkDest(node, entering); };
	FormatRenderer.ptr.prototype.renderLinkSpace = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(32);
		return 0;
	};
	FormatRenderer.prototype.renderLinkSpace = function(node, entering) { return this.$val.renderLinkSpace(node, entering); };
	FormatRenderer.ptr.prototype.renderLinkText = function(node, entering) {
		var entering, node, r;
		r = this;
		if (r.BaseRenderer.Option.AutoSpace) {
			r.BaseRenderer.Space(node);
		}
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	FormatRenderer.prototype.renderLinkText = function(node, entering) { return this.$val.renderLinkText(node, entering); };
	FormatRenderer.ptr.prototype.renderCloseParen = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(41);
		return 0;
	};
	FormatRenderer.prototype.renderCloseParen = function(node, entering) { return this.$val.renderCloseParen(node, entering); };
	FormatRenderer.ptr.prototype.renderOpenParen = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(40);
		return 0;
	};
	FormatRenderer.prototype.renderOpenParen = function(node, entering) { return this.$val.renderOpenParen(node, entering); };
	FormatRenderer.ptr.prototype.renderCloseBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(93);
		return 0;
	};
	FormatRenderer.prototype.renderCloseBracket = function(node, entering) { return this.$val.renderCloseBracket(node, entering); };
	FormatRenderer.ptr.prototype.renderOpenBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(91);
		return 0;
	};
	FormatRenderer.prototype.renderOpenBracket = function(node, entering) { return this.$val.renderOpenBracket(node, entering); };
	FormatRenderer.ptr.prototype.renderBang = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(33);
		return 0;
	};
	FormatRenderer.prototype.renderBang = function(node, entering) { return this.$val.renderBang(node, entering); };
	FormatRenderer.ptr.prototype.renderImage = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	FormatRenderer.prototype.renderImage = function(node, entering) { return this.$val.renderImage(node, entering); };
	FormatRenderer.ptr.prototype.renderLink = function(node, entering) {
		var entering, node, r, text$1;
		r = this;
		if (entering) {
			r.BaseRenderer.LinkTextAutoSpacePrevious(node);
			if (3 === node.LinkType) {
				text$1 = node.ChildByType(40).Tokens;
				if (bytes.Equal(text$1, node.LinkRefLabel)) {
					r.BaseRenderer.WriteString("[" + util.BytesToStr(text$1) + "]");
				} else {
					r.BaseRenderer.WriteString("[" + util.BytesToStr(text$1) + "][" + util.BytesToStr(node.LinkRefLabel) + "]");
				}
				return 0;
			}
		} else {
			r.BaseRenderer.LinkTextAutoSpaceNext(node);
		}
		return 2;
	};
	FormatRenderer.prototype.renderLink = function(node, entering) { return this.$val.renderLink(node, entering); };
	FormatRenderer.ptr.prototype.renderHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Newline();
		r.BaseRenderer.Write(node.Tokens);
		r.BaseRenderer.Newline();
		if (!r.isLastNode(r.BaseRenderer.Tree.Root, node)) {
			r.BaseRenderer.WriteByte(10);
		}
		return 0;
	};
	FormatRenderer.prototype.renderHTML = function(node, entering) { return this.$val.renderHTML(node, entering); };
	FormatRenderer.ptr.prototype.renderInlineHTML = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	FormatRenderer.prototype.renderInlineHTML = function(node, entering) { return this.$val.renderInlineHTML(node, entering); };
	FormatRenderer.ptr.prototype.renderDocument = function(node, entering) {
		var _r, buf, entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; buf = $f.buf; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.Writer = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
			r.nodeWriterStack = $append(r.nodeWriterStack, r.BaseRenderer.Writer);
			$s = 3; continue;
		/* } else { */ case 2:
			r.nodeWriterStack = $subslice(r.nodeWriterStack, 0, (r.nodeWriterStack.$length - 1 >> 0));
			_r = bytes.Trim(r.BaseRenderer.Writer.Bytes(), " \t\n"); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			buf = _r;
			r.BaseRenderer.Writer.Reset();
			r.BaseRenderer.Write(buf);
			r.BaseRenderer.WriteByte(10);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderDocument }; } $f._r = _r; $f.buf = buf; $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderDocument = function(node, entering) { return this.$val.renderDocument(node, entering); };
	FormatRenderer.ptr.prototype.renderParagraph = function(node, entering) {
		var entering, inTightList, lastListItemLastPara, listItem, nextItem, nextPara, node, parent, r;
		r = this;
		if (!entering) {
			if (!node.ParentIs(109, new sliceType$4([]))) {
				r.BaseRenderer.Newline();
			}
			inTightList = false;
			lastListItemLastPara = false;
			parent = node.Parent;
			if (!(ptrType$1.nil === parent)) {
				if (8 === parent.Type) {
					listItem = parent;
					if (!(ptrType$1.nil === listItem.Parent) && !(ptrType$4.nil === listItem.Parent.ListData)) {
						inTightList = listItem.Parent.ListData.Tight;
						nextItem = listItem.Next;
						if (ptrType$1.nil === nextItem) {
							nextPara = node.Next;
							lastListItemLastPara = ptrType$1.nil === nextPara;
						}
					} else {
						inTightList = true;
					}
				}
			}
			if ((!inTightList || (lastListItemLastPara)) && !node.ParentIs(109, new sliceType$4([]))) {
				r.BaseRenderer.WriteByte(10);
			}
		}
		return 2;
	};
	FormatRenderer.prototype.renderParagraph = function(node, entering) { return this.$val.renderParagraph(node, entering); };
	FormatRenderer.ptr.prototype.renderText = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (r.BaseRenderer.Option.AutoSpace) {
			r.BaseRenderer.Space(node);
		}
		/* */ if (r.BaseRenderer.Option.FixTermTypo) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.Option.FixTermTypo) { */ case 1:
			$r = r.BaseRenderer.FixTermTypo(node); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (r.BaseRenderer.Option.ChinesePunct) {
			r.BaseRenderer.ChinesePunct(node);
		}
		r.BaseRenderer.Write(node.Tokens);
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderText }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderText = function(node, entering) { return this.$val.renderText(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeSpan = function(node, entering) {
		var _r, _r$1, _tuple, _tuple$1, entering, firstc, lastc, node, r, text$1, text$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; entering = $f.entering; firstc = $f.firstc; lastc = $f.lastc; node = $f.node; r = $f.r; text$1 = $f.text$1; text$2 = $f.text$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			/* */ if (r.BaseRenderer.Option.AutoSpace) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (r.BaseRenderer.Option.AutoSpace) { */ case 4:
				_r = node.PreviousNodeText(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				text$1 = _r;
				if (!("" === text$1)) {
					_tuple = utf8.DecodeLastRuneInString(text$1);
					lastc = _tuple[0];
					if (unicode.IsLetter(lastc) || unicode.IsDigit(lastc)) {
						r.BaseRenderer.WriteByte(32);
					}
				}
			/* } */ case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			/* */ if (r.BaseRenderer.Option.AutoSpace) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (r.BaseRenderer.Option.AutoSpace) { */ case 7:
				_r$1 = node.NextNodeText(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				text$2 = _r$1;
				if (!("" === text$2)) {
					_tuple$1 = utf8.DecodeRuneInString(text$2);
					firstc = _tuple$1[0];
					if (unicode.IsLetter(firstc) || unicode.IsDigit(firstc)) {
						r.BaseRenderer.WriteByte(32);
					}
				}
			/* } */ case 8:
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderCodeSpan }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.entering = entering; $f.firstc = firstc; $f.lastc = lastc; $f.node = node; $f.r = r; $f.text$1 = text$1; $f.text$2 = text$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderCodeSpan = function(node, entering) { return this.$val.renderCodeSpan(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeSpanOpenMarker = function(node, entering) {
		var _tuple, entering, firstc, node, r, text$1;
		r = this;
		if (node.ParentIs(109, new sliceType$4([])) && (bytes.Contains(node.Next.Tokens, (new sliceType$3($stringToBytes("|")))) || bytes.Contains(node.Next.Tokens, (new sliceType$3($stringToBytes("`")))))) {
			r.BaseRenderer.WriteString("<code>");
			return 0;
		}
		r.BaseRenderer.WriteByte(96);
		if (1 < node.Parent.CodeMarkerLen) {
			r.BaseRenderer.WriteByte(96);
			text$1 = util.BytesToStr(node.Next.Tokens);
			_tuple = utf8.DecodeRuneInString(text$1);
			firstc = _tuple[0];
			if (96 === firstc) {
				r.BaseRenderer.WriteByte(32);
			}
		}
		return 0;
	};
	FormatRenderer.prototype.renderCodeSpanOpenMarker = function(node, entering) { return this.$val.renderCodeSpanOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeSpanContent = function(node, entering) {
		var entering, node, r, tokens;
		r = this;
		tokens = node.Tokens;
		if (node.ParentIs(109, new sliceType$4([]))) {
			tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("\\|"))), (new sliceType$3($stringToBytes("|"))));
			tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("|"))), (new sliceType$3($stringToBytes("\\|"))));
			tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("<br/>"))), sliceType$3.nil);
		}
		r.BaseRenderer.Write(tokens);
		return 0;
	};
	FormatRenderer.prototype.renderCodeSpanContent = function(node, entering) { return this.$val.renderCodeSpanContent(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeSpanCloseMarker = function(node, entering) {
		var _tuple, entering, lastc, node, r, text$1;
		r = this;
		if (node.ParentIs(109, new sliceType$4([])) && (bytes.Contains(node.Previous.Tokens, (new sliceType$3($stringToBytes("|")))) || bytes.Contains(node.Previous.Tokens, (new sliceType$3($stringToBytes("`")))))) {
			r.BaseRenderer.WriteString("</code>");
			return 0;
		}
		if (1 < node.Parent.CodeMarkerLen) {
			text$1 = util.BytesToStr(node.Previous.Tokens);
			_tuple = utf8.DecodeLastRuneInString(text$1);
			lastc = _tuple[0];
			if (96 === lastc) {
				r.BaseRenderer.WriteByte(32);
			}
			r.BaseRenderer.WriteByte(96);
		}
		r.BaseRenderer.WriteByte(96);
		return 0;
	};
	FormatRenderer.prototype.renderCodeSpanCloseMarker = function(node, entering) { return this.$val.renderCodeSpanCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderInlineMathCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(36);
		return 0;
	};
	FormatRenderer.prototype.renderInlineMathCloseMarker = function(node, entering) { return this.$val.renderInlineMathCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderInlineMathContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	FormatRenderer.prototype.renderInlineMathContent = function(node, entering) { return this.$val.renderInlineMathContent(node, entering); };
	FormatRenderer.ptr.prototype.renderInlineMathOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(36);
		return 0;
	};
	FormatRenderer.prototype.renderInlineMathOpenMarker = function(node, entering) { return this.$val.renderInlineMathOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderInlineMath = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	FormatRenderer.prototype.renderInlineMath = function(node, entering) { return this.$val.renderInlineMath(node, entering); };
	FormatRenderer.ptr.prototype.renderMathBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(parse.MathBlockMarker);
		r.BaseRenderer.WriteByte(10);
		return 0;
	};
	FormatRenderer.prototype.renderMathBlockCloseMarker = function(node, entering) { return this.$val.renderMathBlockCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderMathBlockContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		r.BaseRenderer.WriteByte(10);
		return 0;
	};
	FormatRenderer.prototype.renderMathBlockContent = function(node, entering) { return this.$val.renderMathBlockContent(node, entering); };
	FormatRenderer.ptr.prototype.renderMathBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(parse.MathBlockMarker);
		r.BaseRenderer.WriteByte(10);
		return 0;
	};
	FormatRenderer.prototype.renderMathBlockOpenMarker = function(node, entering) { return this.$val.renderMathBlockOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderMathBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Newline();
		if (!entering && !r.isLastNode(r.BaseRenderer.Tree.Root, node)) {
			r.BaseRenderer.WriteByte(10);
		}
		return 2;
	};
	FormatRenderer.prototype.renderMathBlock = function(node, entering) { return this.$val.renderMathBlock(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Newline();
		r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([96]), node.CodeBlockFenceLen));
		r.BaseRenderer.Newline();
		if (!r.isLastNode(r.BaseRenderer.Tree.Root, node)) {
			r.BaseRenderer.WriteByte(10);
		}
		return 0;
	};
	FormatRenderer.prototype.renderCodeBlockCloseMarker = function(node, entering) { return this.$val.renderCodeBlockCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlockCode = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	FormatRenderer.prototype.renderCodeBlockCode = function(node, entering) { return this.$val.renderCodeBlockCode(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlockInfoMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.CodeBlockInfo);
		r.BaseRenderer.WriteByte(10);
		return 0;
	};
	FormatRenderer.prototype.renderCodeBlockInfoMarker = function(node, entering) { return this.$val.renderCodeBlockInfoMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([96]), node.CodeBlockFenceLen));
		return 0;
	};
	FormatRenderer.prototype.renderCodeBlockOpenMarker = function(node, entering) { return this.$val.renderCodeBlockOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderCodeBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.Newline();
		}
		if (!node.IsFencedCodeBlock) {
			r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([96]), 3));
			r.BaseRenderer.WriteByte(10);
			r.BaseRenderer.Write(node.FirstChild.Tokens);
			r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([96]), 3));
			r.BaseRenderer.Newline();
			if (!r.isLastNode(r.BaseRenderer.Tree.Root, node)) {
				r.BaseRenderer.WriteByte(10);
			}
			return 0;
		}
		return 2;
	};
	FormatRenderer.prototype.renderCodeBlock = function(node, entering) { return this.$val.renderCodeBlock(node, entering); };
	FormatRenderer.ptr.prototype.renderEmphasis = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.TextAutoSpacePrevious(node);
		} else {
			r.BaseRenderer.TextAutoSpaceNext(node);
		}
		return 2;
	};
	FormatRenderer.prototype.renderEmphasis = function(node, entering) { return this.$val.renderEmphasis(node, entering); };
	FormatRenderer.ptr.prototype.renderEmAsteriskOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(42);
		return 0;
	};
	FormatRenderer.prototype.renderEmAsteriskOpenMarker = function(node, entering) { return this.$val.renderEmAsteriskOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderEmAsteriskCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(42);
		return 0;
	};
	FormatRenderer.prototype.renderEmAsteriskCloseMarker = function(node, entering) { return this.$val.renderEmAsteriskCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderEmUnderscoreOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(95);
		return 0;
	};
	FormatRenderer.prototype.renderEmUnderscoreOpenMarker = function(node, entering) { return this.$val.renderEmUnderscoreOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderEmUnderscoreCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(95);
		return 0;
	};
	FormatRenderer.prototype.renderEmUnderscoreCloseMarker = function(node, entering) { return this.$val.renderEmUnderscoreCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrong = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.TextAutoSpacePrevious(node);
		} else {
			r.BaseRenderer.TextAutoSpaceNext(node);
		}
		return 2;
	};
	FormatRenderer.prototype.renderStrong = function(node, entering) { return this.$val.renderStrong(node, entering); };
	FormatRenderer.ptr.prototype.renderStrongA6kOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("**");
		return 0;
	};
	FormatRenderer.prototype.renderStrongA6kOpenMarker = function(node, entering) { return this.$val.renderStrongA6kOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrongA6kCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("**");
		return 0;
	};
	FormatRenderer.prototype.renderStrongA6kCloseMarker = function(node, entering) { return this.$val.renderStrongA6kCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrongU8eOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("__");
		return 0;
	};
	FormatRenderer.prototype.renderStrongU8eOpenMarker = function(node, entering) { return this.$val.renderStrongU8eOpenMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderStrongU8eCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("__");
		return 0;
	};
	FormatRenderer.prototype.renderStrongU8eCloseMarker = function(node, entering) { return this.$val.renderStrongU8eCloseMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderBlockquote = function(node, entering) {
		var _i, _r, _ref, blockquoteLines, buf, entering, length, line, lines, node, r, writer, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; blockquoteLines = $f.blockquoteLines; buf = $f.buf; entering = $f.entering; length = $f.length; line = $f.line; lines = $f.lines; node = $f.node; r = $f.r; writer = $f.writer; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; x$6 = $f.x$6; x$7 = $f.x$7; x$8 = $f.x$8; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.Writer = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
			r.nodeWriterStack = $append(r.nodeWriterStack, r.BaseRenderer.Writer);
			$s = 3; continue;
		/* } else { */ case 2:
			writer = (x = r.nodeWriterStack, x$1 = r.nodeWriterStack.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			r.nodeWriterStack = $subslice(r.nodeWriterStack, 0, (r.nodeWriterStack.$length - 1 >> 0));
			blockquoteLines = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
			buf = writer.Bytes();
			lines = bytes.Split(buf, new sliceType$3([10]));
			length = lines.$length;
			if (2 < length && lex.IsBlank((x$2 = length - 1 >> 0, ((x$2 < 0 || x$2 >= lines.$length) ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + x$2]))) && lex.IsBlank((x$3 = length - 2 >> 0, ((x$3 < 0 || x$3 >= lines.$length) ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + x$3])))) {
				lines = $subslice(lines, 0, (length - 1 >> 0));
			}
			if (1 === r.nodeWriterStack.$length) {
				length = lines.$length;
				if (1 < length && lex.IsBlank((x$4 = length - 1 >> 0, ((x$4 < 0 || x$4 >= lines.$length) ? ($throwRuntimeError("index out of range"), undefined) : lines.$array[lines.$offset + x$4])))) {
					lines = $subslice(lines, 0, (length - 1 >> 0));
				}
			}
			length = lines.$length;
			_ref = lines;
			_i = 0;
			/* while (true) { */ case 4:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
				line = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (0 === line.$length) {
					blockquoteLines.WriteString(">\n");
					_i++;
					/* continue; */ $s = 4; continue;
				}
				if (62 === (0 >= line.$length ? ($throwRuntimeError("index out of range"), undefined) : line.$array[line.$offset + 0])) {
					blockquoteLines.WriteString(">");
				} else {
					blockquoteLines.WriteString("> ");
				}
				blockquoteLines.Write(line);
				blockquoteLines.WriteByte(10);
				_i++;
			/* } */ $s = 4; continue; case 5:
			buf = blockquoteLines.Bytes();
			writer.Reset();
			writer.Write(buf);
			(x$5 = r.nodeWriterStack, x$6 = r.nodeWriterStack.$length - 1 >> 0, ((x$6 < 0 || x$6 >= x$5.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$5.$array[x$5.$offset + x$6])).Write(writer.Bytes());
			r.BaseRenderer.Writer = (x$7 = r.nodeWriterStack, x$8 = r.nodeWriterStack.$length - 1 >> 0, ((x$8 < 0 || x$8 >= x$7.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$7.$array[x$7.$offset + x$8]));
			_r = bytes.TrimSpace(r.BaseRenderer.Writer.Bytes()); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			buf = _r;
			r.BaseRenderer.Writer.Reset();
			r.BaseRenderer.Write(buf);
			if (!node.ParentIs(109, new sliceType$4([]))) {
				r.BaseRenderer.WriteString("\n\n");
			}
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderBlockquote }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.blockquoteLines = blockquoteLines; $f.buf = buf; $f.entering = entering; $f.length = length; $f.line = line; $f.lines = lines; $f.node = node; $f.r = r; $f.writer = writer; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.x$6 = x$6; $f.x$7 = x$7; $f.x$8 = x$8; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderBlockquote = function(node, entering) { return this.$val.renderBlockquote(node, entering); };
	FormatRenderer.ptr.prototype.renderBlockquoteMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	FormatRenderer.prototype.renderBlockquoteMarker = function(node, entering) { return this.$val.renderBlockquoteMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderHeading = function(node, entering) {
		var _i, _r, _ref, _rune, content, contentLen, entering, node, r, r$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; _rune = $f._rune; content = $f.content; contentLen = $f.contentLen; entering = $f.entering; node = $f.node; r = $f.r; r$1 = $f.r$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			if (!node.HeadingSetext) {
				r.BaseRenderer.Write(bytes.Repeat(new sliceType$3([35]), node.HeadingLevel));
				r.BaseRenderer.WriteByte(32);
			}
			$s = 3; continue;
		/* } else { */ case 2:
			/* */ if (node.HeadingSetext) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (node.HeadingSetext) { */ case 4:
				r.BaseRenderer.WriteByte(10);
				_r = node.Text(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				content = _r;
				contentLen = 0;
				_ref = content;
				_i = 0;
				while (true) {
					if (!(_i < _ref.length)) { break; }
					_rune = $decodeRune(_ref, _i);
					r$1 = _rune[0];
					if (128 <= r$1) {
						contentLen = contentLen + (2) >> 0;
					} else {
						contentLen = contentLen + (1) >> 0;
					}
					_i += _rune[1];
				}
				if (1 === node.HeadingLevel) {
					r.BaseRenderer.WriteString(strings.Repeat("=", contentLen));
				} else if (2 === node.HeadingLevel) {
					r.BaseRenderer.WriteString(strings.Repeat("-", contentLen));
				}
			/* } */ case 5:
			if (r.BaseRenderer.Option.HeadingID && !(sliceType$3.nil === node.HeadingID)) {
				r.BaseRenderer.WriteString(" {" + util.BytesToStr(node.HeadingID) + "}");
			}
			if (!node.ParentIs(109, new sliceType$4([]))) {
				r.BaseRenderer.Newline();
				r.BaseRenderer.WriteByte(10);
			}
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderHeading }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f._rune = _rune; $f.content = content; $f.contentLen = contentLen; $f.entering = entering; $f.node = node; $f.r = r; $f.r$1 = r$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderHeading = function(node, entering) { return this.$val.renderHeading(node, entering); };
	FormatRenderer.ptr.prototype.renderHeadingC8hMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	FormatRenderer.prototype.renderHeadingC8hMarker = function(node, entering) { return this.$val.renderHeadingC8hMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderList = function(node, entering) {
		var _r, buf, entering, node, r, writer, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; buf = $f.buf; entering = $f.entering; node = $f.node; r = $f.r; writer = $f.writer; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.Writer = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
			r.nodeWriterStack = $append(r.nodeWriterStack, r.BaseRenderer.Writer);
			$s = 3; continue;
		/* } else { */ case 2:
			writer = (x = r.nodeWriterStack, x$1 = r.nodeWriterStack.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			r.nodeWriterStack = $subslice(r.nodeWriterStack, 0, (r.nodeWriterStack.$length - 1 >> 0));
			(x$2 = r.nodeWriterStack, x$3 = r.nodeWriterStack.$length - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Write(writer.Bytes());
			r.BaseRenderer.Writer = (x$4 = r.nodeWriterStack, x$5 = r.nodeWriterStack.$length - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5]));
			_r = bytes.TrimSpace(r.BaseRenderer.Writer.Bytes()); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			buf = _r;
			r.BaseRenderer.Writer.Reset();
			r.BaseRenderer.Write(buf);
			if (!node.ParentIs(109, new sliceType$4([]))) {
				r.BaseRenderer.WriteString("\n\n");
			}
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderList }; } $f._r = _r; $f.buf = buf; $f.entering = entering; $f.node = node; $f.r = r; $f.writer = writer; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderList = function(node, entering) { return this.$val.renderList(node, entering); };
	FormatRenderer.ptr.prototype.renderListItem = function(node, entering) {
		var _i, _r, _ref, buf, entering, indent, indentSpaces, indentedLines, line, lines, listItemBuf, node, r, writer, x, x$1, x$2, x$3, x$4, x$5, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; buf = $f.buf; entering = $f.entering; indent = $f.indent; indentSpaces = $f.indentSpaces; indentedLines = $f.indentedLines; line = $f.line; lines = $f.lines; listItemBuf = $f.listItemBuf; node = $f.node; r = $f.r; writer = $f.writer; x = $f.x; x$1 = $f.x$1; x$2 = $f.x$2; x$3 = $f.x$3; x$4 = $f.x$4; x$5 = $f.x$5; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.Writer = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
			r.nodeWriterStack = $append(r.nodeWriterStack, r.BaseRenderer.Writer);
			$s = 3; continue;
		/* } else { */ case 2:
			writer = (x = r.nodeWriterStack, x$1 = r.nodeWriterStack.$length - 1 >> 0, ((x$1 < 0 || x$1 >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + x$1]));
			r.nodeWriterStack = $subslice(r.nodeWriterStack, 0, (r.nodeWriterStack.$length - 1 >> 0));
			indent = node.ListData.Marker.$length + 1 >> 0;
			if ((1 === node.ListData.Typ) || ((3 === node.ListData.Typ) && (0 === node.ListData.BulletChar))) {
				indent = indent + (1) >> 0;
			}
			indentSpaces = bytes.Repeat(new sliceType$3([32]), indent);
			indentedLines = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
			buf = writer.Bytes();
			lines = bytes.Split(buf, new sliceType$3([10]));
			_ref = lines;
			_i = 0;
			/* while (true) { */ case 4:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
				line = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (0 === line.$length) {
					indentedLines.WriteByte(10);
					_i++;
					/* continue; */ $s = 4; continue;
				}
				indentedLines.Write(indentSpaces);
				indentedLines.Write(line);
				indentedLines.WriteByte(10);
				_i++;
			/* } */ $s = 4; continue; case 5:
			buf = indentedLines.Bytes();
			if (indent < buf.$length) {
				buf = $subslice(buf, indent);
			}
			listItemBuf = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
			if ((1 === node.ListData.Typ) || ((3 === node.ListData.Typ) && (0 === node.ListData.BulletChar))) {
				listItemBuf.WriteString(strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter)));
			} else {
				listItemBuf.Write(node.ListData.Marker);
			}
			listItemBuf.WriteByte(32);
			buf = $appendSlice(listItemBuf.Bytes(), buf);
			if (node.ParentIs(109, new sliceType$4([]))) {
				buf = bytes.ReplaceAll(buf, (new sliceType$3($stringToBytes("\n"))), sliceType$3.nil);
			}
			writer.Reset();
			writer.Write(buf);
			buf = writer.Bytes();
			if (node.ParentIs(109, new sliceType$4([]))) {
				buf = bytes.ReplaceAll(buf, (new sliceType$3($stringToBytes("\n"))), sliceType$3.nil);
			}
			(x$2 = r.nodeWriterStack, x$3 = r.nodeWriterStack.$length - 1 >> 0, ((x$3 < 0 || x$3 >= x$2.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$2.$array[x$2.$offset + x$3])).Write(buf);
			r.BaseRenderer.Writer = (x$4 = r.nodeWriterStack, x$5 = r.nodeWriterStack.$length - 1 >> 0, ((x$5 < 0 || x$5 >= x$4.$length) ? ($throwRuntimeError("index out of range"), undefined) : x$4.$array[x$4.$offset + x$5]));
			_r = bytes.TrimSpace(r.BaseRenderer.Writer.Bytes()); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			buf = _r;
			r.BaseRenderer.Writer.Reset();
			r.BaseRenderer.Write(buf);
			if (!node.ParentIs(109, new sliceType$4([]))) {
				r.BaseRenderer.WriteString("\n");
			}
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: FormatRenderer.ptr.prototype.renderListItem }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.buf = buf; $f.entering = entering; $f.indent = indent; $f.indentSpaces = indentSpaces; $f.indentedLines = indentedLines; $f.line = line; $f.lines = lines; $f.listItemBuf = listItemBuf; $f.node = node; $f.r = r; $f.writer = writer; $f.x = x; $f.x$1 = x$1; $f.x$2 = x$2; $f.x$3 = x$3; $f.x$4 = x$4; $f.x$5 = x$5; $f.$s = $s; $f.$r = $r; return $f;
	};
	FormatRenderer.prototype.renderListItem = function(node, entering) { return this.$val.renderListItem(node, entering); };
	FormatRenderer.ptr.prototype.renderTaskListItemMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(91);
		if (node.TaskListItemChecked) {
			r.BaseRenderer.WriteByte(88);
		} else {
			r.BaseRenderer.WriteByte(32);
		}
		r.BaseRenderer.WriteByte(93);
		return 0;
	};
	FormatRenderer.prototype.renderTaskListItemMarker = function(node, entering) { return this.$val.renderTaskListItemMarker(node, entering); };
	FormatRenderer.ptr.prototype.renderThematicBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (node.ParentIs(109, new sliceType$4([]))) {
			r.BaseRenderer.WriteString("<hr/>");
		} else {
			r.BaseRenderer.WriteString("---\n\n");
		}
		return 0;
	};
	FormatRenderer.prototype.renderThematicBreak = function(node, entering) { return this.$val.renderThematicBreak(node, entering); };
	FormatRenderer.ptr.prototype.renderHardBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!r.BaseRenderer.Option.SoftBreak2HardBreak) {
			r.BaseRenderer.WriteString("\\\n");
		} else {
			if (node.ParentIs(109, new sliceType$4([]))) {
				r.BaseRenderer.WriteString("<br/>");
			} else {
				r.BaseRenderer.WriteByte(10);
			}
		}
		return 0;
	};
	FormatRenderer.prototype.renderHardBreak = function(node, entering) { return this.$val.renderHardBreak(node, entering); };
	FormatRenderer.ptr.prototype.renderSoftBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Newline();
		return 0;
	};
	FormatRenderer.prototype.renderSoftBreak = function(node, entering) { return this.$val.renderSoftBreak(node, entering); };
	FormatRenderer.ptr.prototype.isLastNode = function(treeRoot, node) {
		var n, node, r, treeRoot;
		r = this;
		if (treeRoot === node) {
			return true;
		}
		if (!(ptrType$1.nil === node.Next)) {
			return false;
		}
		if (0 === node.Parent.Type) {
			return treeRoot.LastChild === node;
		}
		n = ptrType$1.nil;
		n = node.Parent;
		while (true) {
			if (0 === n.Parent.Type) {
				break;
			}
			n = n.Parent;
		}
		return treeRoot.LastChild === n;
	};
	FormatRenderer.prototype.isLastNode = function(treeRoot, node) { return this.$val.isLastNode(treeRoot, node); };
	NewHtmlRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$28, _key$29, _key$3, _key$30, _key$31, _key$32, _key$33, _key$34, _key$35, _key$36, _key$37, _key$38, _key$39, _key$4, _key$40, _key$41, _key$42, _key$43, _key$44, _key$45, _key$46, _key$47, _key$48, _key$49, _key$5, _key$50, _key$51, _key$52, _key$53, _key$54, _key$55, _key$56, _key$57, _key$58, _key$59, _key$6, _key$60, _key$61, _key$62, _key$63, _key$64, _key$65, _key$66, _key$67, _key$68, _key$69, _key$7, _key$70, _key$71, _key$8, _key$9, ret, tree;
		ret = new HtmlRenderer.ptr(NewBaseRenderer(tree), false);
		_key = 0; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocument") };
		_key$1 = 1; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraph") };
		_key$2 = 16; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderText") };
		_key$3 = 27; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpan") };
		_key$4 = 28; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeSpanOpenMarker") };
		_key$5 = 29; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderCodeSpanContent") };
		_key$6 = 30; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderCodeSpanCloseMarker") };
		_key$7 = 11; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderCodeBlock") };
		_key$8 = 12; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderCodeBlockOpenMarker") };
		_key$9 = 14; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderCodeBlockInfoMarker") };
		_key$10 = 15; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderCodeBlockCode") };
		_key$11 = 13; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderCodeBlockCloseMarker") };
		_key$12 = 300; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderMathBlock") };
		_key$13 = 301; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderMathBlockOpenMarker") };
		_key$14 = 302; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderMathBlockContent") };
		_key$15 = 303; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderMathBlockCloseMarker") };
		_key$16 = 304; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderInlineMath") };
		_key$17 = 305; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderInlineMathOpenMarker") };
		_key$18 = 306; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderInlineMathContent") };
		_key$19 = 307; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderInlineMathCloseMarker") };
		_key$20 = 17; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderEmphasis") };
		_key$21 = 18; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderEmAsteriskOpenMarker") };
		_key$22 = 19; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderEmAsteriskCloseMarker") };
		_key$23 = 20; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderEmUnderscoreOpenMarker") };
		_key$24 = 21; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderEmUnderscoreCloseMarker") };
		_key$25 = 22; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderStrong") };
		_key$26 = 23; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderStrongA6kOpenMarker") };
		_key$27 = 24; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderStrongA6kCloseMarker") };
		_key$28 = 25; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$28)] = { k: _key$28, v: $methodVal(ret, "renderStrongU8eOpenMarker") };
		_key$29 = 26; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$29)] = { k: _key$29, v: $methodVal(ret, "renderStrongU8eCloseMarker") };
		_key$30 = 5; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$30)] = { k: _key$30, v: $methodVal(ret, "renderBlockquote") };
		_key$31 = 6; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$31)] = { k: _key$31, v: $methodVal(ret, "renderBlockquoteMarker") };
		_key$32 = 2; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$32)] = { k: _key$32, v: $methodVal(ret, "renderHeading") };
		_key$33 = 3; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$33)] = { k: _key$33, v: $methodVal(ret, "renderHeadingC8hMarker") };
		_key$34 = 7; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$34)] = { k: _key$34, v: $methodVal(ret, "renderList") };
		_key$35 = 8; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$35)] = { k: _key$35, v: $methodVal(ret, "renderListItem") };
		_key$36 = 4; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$36)] = { k: _key$36, v: $methodVal(ret, "renderThematicBreak") };
		_key$37 = 31; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$37)] = { k: _key$37, v: $methodVal(ret, "renderHardBreak") };
		_key$38 = 32; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$38)] = { k: _key$38, v: $methodVal(ret, "renderSoftBreak") };
		_key$39 = 9; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$39)] = { k: _key$39, v: $methodVal(ret, "renderHTML") };
		_key$40 = 10; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$40)] = { k: _key$40, v: $methodVal(ret, "renderInlineHTML") };
		_key$41 = 33; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$41)] = { k: _key$41, v: $methodVal(ret, "renderLink") };
		_key$42 = 34; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$42)] = { k: _key$42, v: $methodVal(ret, "renderImage") };
		_key$43 = 35; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$43)] = { k: _key$43, v: $methodVal(ret, "renderBang") };
		_key$44 = 36; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$44)] = { k: _key$44, v: $methodVal(ret, "renderOpenBracket") };
		_key$45 = 37; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$45)] = { k: _key$45, v: $methodVal(ret, "renderCloseBracket") };
		_key$46 = 38; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$46)] = { k: _key$46, v: $methodVal(ret, "renderOpenParen") };
		_key$47 = 39; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$47)] = { k: _key$47, v: $methodVal(ret, "renderCloseParen") };
		_key$48 = 40; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$48)] = { k: _key$48, v: $methodVal(ret, "renderLinkText") };
		_key$49 = 43; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$49)] = { k: _key$49, v: $methodVal(ret, "renderLinkSpace") };
		_key$50 = 41; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$50)] = { k: _key$50, v: $methodVal(ret, "renderLinkDest") };
		_key$51 = 42; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$51)] = { k: _key$51, v: $methodVal(ret, "renderLinkTitle") };
		_key$52 = 101; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$52)] = { k: _key$52, v: $methodVal(ret, "renderStrikethrough") };
		_key$53 = 102; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$53)] = { k: _key$53, v: $methodVal(ret, "renderStrikethrough1OpenMarker") };
		_key$54 = 103; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$54)] = { k: _key$54, v: $methodVal(ret, "renderStrikethrough1CloseMarker") };
		_key$55 = 104; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$55)] = { k: _key$55, v: $methodVal(ret, "renderStrikethrough2OpenMarker") };
		_key$56 = 105; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$56)] = { k: _key$56, v: $methodVal(ret, "renderStrikethrough2CloseMarker") };
		_key$57 = 100; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$57)] = { k: _key$57, v: $methodVal(ret, "renderTaskListItemMarker") };
		_key$58 = 106; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$58)] = { k: _key$58, v: $methodVal(ret, "renderTable") };
		_key$59 = 107; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$59)] = { k: _key$59, v: $methodVal(ret, "renderTableHead") };
		_key$60 = 108; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$60)] = { k: _key$60, v: $methodVal(ret, "renderTableRow") };
		_key$61 = 109; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$61)] = { k: _key$61, v: $methodVal(ret, "renderTableCell") };
		_key$62 = 200; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$62)] = { k: _key$62, v: $methodVal(ret, "renderEmoji") };
		_key$63 = 201; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$63)] = { k: _key$63, v: $methodVal(ret, "renderEmojiUnicode") };
		_key$64 = 202; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$64)] = { k: _key$64, v: $methodVal(ret, "renderEmojiImg") };
		_key$65 = 203; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$65)] = { k: _key$65, v: $methodVal(ret, "renderEmojiAlias") };
		_key$66 = 500; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$66)] = { k: _key$66, v: $methodVal(ret, "renderFootnotesDef") };
		_key$67 = 501; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$67)] = { k: _key$67, v: $methodVal(ret, "renderFootnotesRef") };
		_key$68 = 600; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$68)] = { k: _key$68, v: $methodVal(ret, "renderToC") };
		_key$69 = 400; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$69)] = { k: _key$69, v: $methodVal(ret, "renderBackslash") };
		_key$70 = 401; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$70)] = { k: _key$70, v: $methodVal(ret, "renderBackslashContent") };
		_key$71 = 44; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$71)] = { k: _key$71, v: $methodVal(ret, "renderHtmlEntity") };
		return ret;
	};
	$pkg.NewHtmlRenderer = NewHtmlRenderer;
	HtmlRenderer.ptr.prototype.renderHtmlEntity = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	HtmlRenderer.prototype.renderHtmlEntity = function(node, entering) { return this.$val.renderHtmlEntity(node, entering); };
	HtmlRenderer.ptr.prototype.renderBackslashContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	HtmlRenderer.prototype.renderBackslashContent = function(node, entering) { return this.$val.renderBackslashContent(node, entering); };
	HtmlRenderer.ptr.prototype.renderBackslash = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	HtmlRenderer.prototype.renderBackslash = function(node, entering) { return this.$val.renderBackslash(node, entering); };
	HtmlRenderer.ptr.prototype.renderToC = function(node, entering) {
		var _i, _r, _r$1, _ref, entering, heading, headings, length, level, node, r, spaces, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; entering = $f.entering; heading = $f.heading; headings = $f.headings; length = $f.length; level = $f.level; node = $f.node; r = $f.r; spaces = $f.spaces; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		headings = r.BaseRenderer.headings();
		length = headings.$length;
		if (1 > length) {
			$s = -1; return 0;
		}
		r.BaseRenderer.WriteString("<div class=\"vditor-toc\">");
		_ref = headings;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			heading = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			level = strconv.Itoa(heading.HeadingLevel);
			spaces = $imul(((heading.HeadingLevel - 1 >> 0)), 2);
			r.BaseRenderer.WriteString(strings.Repeat("&emsp;", spaces));
			r.BaseRenderer.WriteString("<span class=\"toc-h" + level + "\">");
			_r = HeadingID(heading); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			_r$1 = heading.Text(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			$r = r.BaseRenderer.WriteString("<a class=\"toc-a\" href=\"#" + _r + "\">" + _r$1 + "</a></span><br>"); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 1; continue; case 2:
		r.BaseRenderer.WriteString("</div>");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.renderToC }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f.entering = entering; $f.heading = heading; $f.headings = headings; $f.length = length; $f.level = level; $f.node = node; $f.r = r; $f.spaces = spaces; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.renderToC = function(node, entering) { return this.$val.renderToC(node, entering); };
	HtmlRenderer.ptr.prototype.RenderFootnotesDefs = function(context) {
		var _i, _r, _ref, context, def, defContent, defRenderer, gotoRef, i, lc, link, r, ref, tree, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; context = $f.context; def = $f.def; defContent = $f.defContent; defRenderer = $f.defRenderer; gotoRef = $f.gotoRef; i = $f.i; lc = $f.lc; link = $f.link; r = $f.r; ref = $f.ref; tree = $f.tree; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.BaseRenderer.WriteString("<div class=\"footnotes-defs-div\">");
		r.BaseRenderer.WriteString("<hr class=\"footnotes-defs-hr\" />\n");
		r.BaseRenderer.WriteString("<ol class=\"footnotes-defs-ol\">");
		_ref = context.FootnotesDefs;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			i = _i;
			def = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			r.BaseRenderer.WriteString("<li id=\"footnotes-def-" + strconv.Itoa(i + 1 >> 0) + "\">");
			tree = new parse.Tree.ptr("", ptrType$1.nil, context, ptrType$6.nil, ptrType$7.nil);
			tree.Context.Tree = tree;
			tree.Root = new ast.Node.ptr(0, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$3.nil, false, false, false, 0, false, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, sliceType$3.nil, 0, ptrType$4.nil, false, sliceType$5.nil, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, 0, sliceType$3.nil, 0, false, sliceType$3.nil, "", 0, sliceType$3.nil, "", sliceType$6.nil, sliceType$3.nil);
			tree.Root.AppendChild(def);
			defRenderer = NewHtmlRenderer(tree);
			lc = tree.Root.LastDeepestChild();
			i = def.FootnotesRefs.$length - 1 >> 0;
			while (true) {
				if (!(0 <= i)) { break; }
				ref = (x = def.FootnotesRefs, ((i < 0 || i >= x.$length) ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + i]));
				gotoRef = " <a href=\"#footnotes-ref-" + ref.FootnotesRefId + "\" class=\"vditor-footnotes__goto-ref\">\xE2\x86\xA9</a>";
				link = new ast.Node.ptr(10, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(gotoRef), false, false, false, 0, false, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, sliceType$3.nil, 0, ptrType$4.nil, false, sliceType$5.nil, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, 0, sliceType$3.nil, 0, false, sliceType$3.nil, "", 0, sliceType$3.nil, "", sliceType$6.nil, sliceType$3.nil);
				lc.InsertAfter(link);
				i = i - (1) >> 0;
			}
			defRenderer.needRenderFootnotesDef = true;
			_r = defRenderer.BaseRenderer.Render(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			defContent = _r;
			r.BaseRenderer.Write(defContent);
			r.BaseRenderer.WriteString("</li>\n");
			_i++;
		/* } */ $s = 1; continue; case 2:
		r.BaseRenderer.WriteString("</ol></div>");
		$s = -1; return r.BaseRenderer.Writer.Bytes();
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.RenderFootnotesDefs }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.context = context; $f.def = def; $f.defContent = defContent; $f.defRenderer = defRenderer; $f.gotoRef = gotoRef; $f.i = i; $f.lc = lc; $f.link = link; $f.r = r; $f.ref = ref; $f.tree = tree; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.RenderFootnotesDefs = function(context) { return this.$val.RenderFootnotesDefs(context); };
	HtmlRenderer.ptr.prototype.renderFootnotesRef = function(node, entering) {
		var _tuple, entering, idx, idxStr, node, r;
		r = this;
		_tuple = r.BaseRenderer.Tree.Context.FindFootnotesDef(node.Tokens);
		idx = _tuple[0];
		idxStr = strconv.Itoa(idx);
		r.tag("sup", new sliceType$7([new sliceType(["class", "footnotes-ref"]), new sliceType(["id", "footnotes-ref-" + node.FootnotesRefId])]), false);
		r.tag("a", new sliceType$7([new sliceType(["href", "#footnotes-def-" + idxStr])]), false);
		r.BaseRenderer.WriteString(idxStr);
		r.tag("/a", sliceType$7.nil, false);
		r.tag("/sup", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderFootnotesRef = function(node, entering) { return this.$val.renderFootnotesRef(node, entering); };
	HtmlRenderer.ptr.prototype.renderFootnotesDef = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!r.needRenderFootnotesDef) {
			return 0;
		}
		return 2;
	};
	HtmlRenderer.prototype.renderFootnotesDef = function(node, entering) { return this.$val.renderFootnotesDef(node, entering); };
	HtmlRenderer.ptr.prototype.renderCodeBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderCodeBlockCloseMarker = function(node, entering) { return this.$val.renderCodeBlockCloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderCodeBlockInfoMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderCodeBlockInfoMarker = function(node, entering) { return this.$val.renderCodeBlockInfoMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderCodeBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderCodeBlockOpenMarker = function(node, entering) { return this.$val.renderCodeBlockOpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmojiAlias = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderEmojiAlias = function(node, entering) { return this.$val.renderEmojiAlias(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmojiImg = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	HtmlRenderer.prototype.renderEmojiImg = function(node, entering) { return this.$val.renderEmojiImg(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmojiUnicode = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	HtmlRenderer.prototype.renderEmojiUnicode = function(node, entering) { return this.$val.renderEmojiUnicode(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmoji = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	HtmlRenderer.prototype.renderEmoji = function(node, entering) { return this.$val.renderEmoji(node, entering); };
	HtmlRenderer.ptr.prototype.renderInlineMathCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderInlineMathCloseMarker = function(node, entering) { return this.$val.renderInlineMathCloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderInlineMathContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	HtmlRenderer.prototype.renderInlineMathContent = function(node, entering) { return this.$val.renderInlineMathContent(node, entering); };
	HtmlRenderer.ptr.prototype.renderInlineMathOpenMarker = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		attrs = new sliceType$7([new sliceType(["class", "vditor-math"])]);
		r.tag("span", attrs, false);
		return 0;
	};
	HtmlRenderer.prototype.renderInlineMathOpenMarker = function(node, entering) { return this.$val.renderInlineMathOpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderInlineMath = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	HtmlRenderer.prototype.renderInlineMath = function(node, entering) { return this.$val.renderInlineMath(node, entering); };
	HtmlRenderer.ptr.prototype.renderMathBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/div", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderMathBlockCloseMarker = function(node, entering) { return this.$val.renderMathBlockCloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderMathBlockContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	HtmlRenderer.prototype.renderMathBlockContent = function(node, entering) { return this.$val.renderMathBlockContent(node, entering); };
	HtmlRenderer.ptr.prototype.renderMathBlockOpenMarker = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		attrs = new sliceType$7([new sliceType(["class", "vditor-math"])]);
		r.tag("div", attrs, false);
		return 0;
	};
	HtmlRenderer.prototype.renderMathBlockOpenMarker = function(node, entering) { return this.$val.renderMathBlockOpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderMathBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Newline();
		return 2;
	};
	HtmlRenderer.prototype.renderMathBlock = function(node, entering) { return this.$val.renderMathBlock(node, entering); };
	HtmlRenderer.ptr.prototype.renderTableCell = function(node, entering) {
		var _1, attrs, entering, node, r, tag;
		r = this;
		tag = "td";
		if (107 === node.Parent.Parent.Type) {
			tag = "th";
		}
		if (entering) {
			attrs = sliceType$7.nil;
			_1 = node.TableCellAlign;
			if (_1 === (1)) {
				attrs = $append(attrs, new sliceType(["align", "left"]));
			} else if (_1 === (2)) {
				attrs = $append(attrs, new sliceType(["align", "center"]));
			} else if (_1 === (3)) {
				attrs = $append(attrs, new sliceType(["align", "right"]));
			}
			r.tag(tag, attrs, false);
		} else {
			r.tag("/" + tag, sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		}
		return 2;
	};
	HtmlRenderer.prototype.renderTableCell = function(node, entering) { return this.$val.renderTableCell(node, entering); };
	HtmlRenderer.ptr.prototype.renderTableRow = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("tr", sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		} else {
			r.tag("/tr", sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		}
		return 2;
	};
	HtmlRenderer.prototype.renderTableRow = function(node, entering) { return this.$val.renderTableRow(node, entering); };
	HtmlRenderer.ptr.prototype.renderTableHead = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("thead", sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		} else {
			r.tag("/thead", sliceType$7.nil, false);
			r.BaseRenderer.Newline();
			if (!(ptrType$1.nil === node.Next)) {
				r.tag("tbody", sliceType$7.nil, false);
			}
			r.BaseRenderer.Newline();
		}
		return 2;
	};
	HtmlRenderer.prototype.renderTableHead = function(node, entering) { return this.$val.renderTableHead(node, entering); };
	HtmlRenderer.ptr.prototype.renderTable = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("table", sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		} else {
			if (!(ptrType$1.nil === node.FirstChild.Next)) {
				r.tag("/tbody", sliceType$7.nil, false);
			}
			r.BaseRenderer.Newline();
			r.tag("/table", sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		}
		return 2;
	};
	HtmlRenderer.prototype.renderTable = function(node, entering) { return this.$val.renderTable(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrikethrough = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.TextAutoSpacePrevious(node);
		} else {
			r.BaseRenderer.TextAutoSpaceNext(node);
		}
		return 2;
	};
	HtmlRenderer.prototype.renderStrikethrough = function(node, entering) { return this.$val.renderStrikethrough(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrikethrough1OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("del", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderStrikethrough1OpenMarker = function(node, entering) { return this.$val.renderStrikethrough1OpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrikethrough1CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/del", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderStrikethrough1CloseMarker = function(node, entering) { return this.$val.renderStrikethrough1CloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrikethrough2OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("del", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderStrikethrough2OpenMarker = function(node, entering) { return this.$val.renderStrikethrough2OpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrikethrough2CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/del", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderStrikethrough2CloseMarker = function(node, entering) { return this.$val.renderStrikethrough2CloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderLinkTitle = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderLinkTitle = function(node, entering) { return this.$val.renderLinkTitle(node, entering); };
	HtmlRenderer.ptr.prototype.renderLinkDest = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderLinkDest = function(node, entering) { return this.$val.renderLinkDest(node, entering); };
	HtmlRenderer.ptr.prototype.renderLinkSpace = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderLinkSpace = function(node, entering) { return this.$val.renderLinkSpace(node, entering); };
	HtmlRenderer.ptr.prototype.renderLinkText = function(node, entering) {
		var entering, node, r;
		r = this;
		if (r.BaseRenderer.Option.AutoSpace) {
			r.BaseRenderer.Space(node);
		}
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	HtmlRenderer.prototype.renderLinkText = function(node, entering) { return this.$val.renderLinkText(node, entering); };
	HtmlRenderer.ptr.prototype.renderCloseParen = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderCloseParen = function(node, entering) { return this.$val.renderCloseParen(node, entering); };
	HtmlRenderer.ptr.prototype.renderOpenParen = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderOpenParen = function(node, entering) { return this.$val.renderOpenParen(node, entering); };
	HtmlRenderer.ptr.prototype.renderCloseBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderCloseBracket = function(node, entering) { return this.$val.renderCloseBracket(node, entering); };
	HtmlRenderer.ptr.prototype.renderOpenBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderOpenBracket = function(node, entering) { return this.$val.renderOpenBracket(node, entering); };
	HtmlRenderer.ptr.prototype.renderBang = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderBang = function(node, entering) { return this.$val.renderBang(node, entering); };
	HtmlRenderer.ptr.prototype.renderImage = function(node, entering) {
		var _r, buf, destTokens, entering, idx, imgBuf, node, r, title, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; buf = $f.buf; destTokens = $f.destTokens; entering = $f.entering; idx = $f.idx; imgBuf = $f.imgBuf; node = $f.node; r = $f.r; title = $f.title; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (entering) {
			if (0 === r.BaseRenderer.DisableTags) {
				r.BaseRenderer.WriteString("<img src=\"");
				destTokens = node.ChildByType(41).Tokens;
				destTokens = r.BaseRenderer.Tree.Context.RelativePath(destTokens);
				if (!("" === r.BaseRenderer.Option.ImageLazyLoading)) {
					r.BaseRenderer.Write(util.EscapeHTML(util.StrToBytes(r.BaseRenderer.Option.ImageLazyLoading)));
					r.BaseRenderer.WriteString("\" data-src=\"");
				}
				r.BaseRenderer.Write(util.EscapeHTML(destTokens));
				r.BaseRenderer.WriteString("\" alt=\"");
			}
			r.BaseRenderer.DisableTags = r.BaseRenderer.DisableTags + (1) >> 0;
			$s = -1; return 2;
		}
		r.BaseRenderer.DisableTags = r.BaseRenderer.DisableTags - (1) >> 0;
		/* */ if (0 === r.BaseRenderer.DisableTags) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (0 === r.BaseRenderer.DisableTags) { */ case 1:
			r.BaseRenderer.WriteString("\"");
			title = node.ChildByType(42);
			if (!(ptrType$1.nil === title) && !(sliceType$3.nil === title.Tokens)) {
				r.BaseRenderer.WriteString(" title=\"");
				r.BaseRenderer.Write(util.EscapeHTML(title.Tokens));
				r.BaseRenderer.WriteString("\"");
			}
			r.BaseRenderer.WriteString(" />");
			/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (r.BaseRenderer.Option.Sanitize) { */ case 3:
				buf = r.BaseRenderer.Writer.Bytes();
				idx = bytes.LastIndex(buf, (new sliceType$3($stringToBytes("<img src="))));
				imgBuf = $subslice(buf, idx);
				/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if (r.BaseRenderer.Option.Sanitize) { */ case 5:
					_r = sanitize(imgBuf); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					imgBuf = _r;
				/* } */ case 6:
				r.BaseRenderer.Writer.Truncate(idx);
				r.BaseRenderer.Writer.Write(imgBuf);
			/* } */ case 4:
		/* } */ case 2:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.renderImage }; } $f._r = _r; $f.buf = buf; $f.destTokens = destTokens; $f.entering = entering; $f.idx = idx; $f.imgBuf = imgBuf; $f.node = node; $f.r = r; $f.title = title; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.renderImage = function(node, entering) { return this.$val.renderImage(node, entering); };
	HtmlRenderer.ptr.prototype.renderLink = function(node, entering) {
		var attrs, dest, destTokens, entering, node, r, title;
		r = this;
		if (entering) {
			r.BaseRenderer.LinkTextAutoSpacePrevious(node);
			dest = node.ChildByType(41);
			destTokens = dest.Tokens;
			destTokens = r.BaseRenderer.Tree.Context.RelativePath(destTokens);
			attrs = new sliceType$7([new sliceType(["href", util.BytesToStr(util.EscapeHTML(destTokens))])]);
			title = node.ChildByType(42);
			if (!(ptrType$1.nil === title) && !(sliceType$3.nil === title.Tokens)) {
				attrs = $append(attrs, new sliceType(["title", util.BytesToStr(util.EscapeHTML(title.Tokens))]));
			}
			r.tag("a", attrs, false);
		} else {
			r.tag("/a", sliceType$7.nil, false);
			r.BaseRenderer.LinkTextAutoSpaceNext(node);
		}
		return 2;
	};
	HtmlRenderer.prototype.renderLink = function(node, entering) { return this.$val.renderLink(node, entering); };
	HtmlRenderer.ptr.prototype.renderHTML = function(node, entering) {
		var _r, entering, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; entering = $f.entering; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.BaseRenderer.Newline();
		tokens = node.Tokens;
		/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.Option.Sanitize) { */ case 1:
			_r = sanitize(tokens); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tokens = _r;
		/* } */ case 2:
		r.BaseRenderer.Write(tokens);
		r.BaseRenderer.Newline();
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.renderHTML }; } $f._r = _r; $f.entering = entering; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.renderHTML = function(node, entering) { return this.$val.renderHTML(node, entering); };
	HtmlRenderer.ptr.prototype.renderInlineHTML = function(node, entering) {
		var _r, entering, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; entering = $f.entering; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		tokens = node.Tokens;
		/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.Option.Sanitize) { */ case 1:
			_r = sanitize(tokens); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tokens = _r;
		/* } */ case 2:
		r.BaseRenderer.Write(tokens);
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.renderInlineHTML }; } $f._r = _r; $f.entering = entering; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.renderInlineHTML = function(node, entering) { return this.$val.renderInlineHTML(node, entering); };
	HtmlRenderer.ptr.prototype.renderDocument = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	HtmlRenderer.prototype.renderDocument = function(node, entering) { return this.$val.renderDocument(node, entering); };
	HtmlRenderer.ptr.prototype.renderParagraph = function(node, entering) {
		var entering, grandparent, node, r;
		r = this;
		grandparent = node.Parent.Parent;
		if (!(ptrType$1.nil === grandparent) && (7 === grandparent.Type) && grandparent.ListData.Tight) {
			return 2;
		}
		if (entering) {
			r.BaseRenderer.Newline();
			r.tag("p", sliceType$7.nil, false);
			if (r.BaseRenderer.Option.ChineseParagraphBeginningSpace && (0 === node.Parent.Type)) {
				r.BaseRenderer.WriteString("&emsp;&emsp;");
			}
		} else {
			r.tag("/p", sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		}
		return 2;
	};
	HtmlRenderer.prototype.renderParagraph = function(node, entering) { return this.$val.renderParagraph(node, entering); };
	HtmlRenderer.ptr.prototype.renderText = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (r.BaseRenderer.Option.AutoSpace) {
			r.BaseRenderer.Space(node);
		}
		/* */ if (r.BaseRenderer.Option.FixTermTypo) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.Option.FixTermTypo) { */ case 1:
			$r = r.BaseRenderer.FixTermTypo(node); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (r.BaseRenderer.Option.ChinesePunct) {
			r.BaseRenderer.ChinesePunct(node);
		}
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.renderText }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.renderText = function(node, entering) { return this.$val.renderText(node, entering); };
	HtmlRenderer.ptr.prototype.renderCodeSpan = function(node, entering) {
		var _r, _r$1, _tuple, _tuple$1, entering, firstc, lastc, node, r, text$1, text$2, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; entering = $f.entering; firstc = $f.firstc; lastc = $f.lastc; node = $f.node; r = $f.r; text$1 = $f.text$1; text$2 = $f.text$2; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			/* */ if (r.BaseRenderer.Option.AutoSpace) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (r.BaseRenderer.Option.AutoSpace) { */ case 4:
				_r = node.PreviousNodeText(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				text$1 = _r;
				if (!("" === text$1)) {
					_tuple = utf8.DecodeLastRuneInString(text$1);
					lastc = _tuple[0];
					if (unicode.IsLetter(lastc) || unicode.IsDigit(lastc)) {
						r.BaseRenderer.WriteByte(32);
					}
				}
			/* } */ case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			/* */ if (r.BaseRenderer.Option.AutoSpace) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (r.BaseRenderer.Option.AutoSpace) { */ case 7:
				_r$1 = node.NextNodeText(); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				text$2 = _r$1;
				if (!("" === text$2)) {
					_tuple$1 = utf8.DecodeRuneInString(text$2);
					firstc = _tuple$1[0];
					if (unicode.IsLetter(firstc) || unicode.IsDigit(firstc)) {
						r.BaseRenderer.WriteByte(32);
					}
				}
			/* } */ case 8:
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.renderCodeSpan }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.entering = entering; $f.firstc = firstc; $f.lastc = lastc; $f.node = node; $f.r = r; $f.text$1 = text$1; $f.text$2 = text$2; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.renderCodeSpan = function(node, entering) { return this.$val.renderCodeSpan(node, entering); };
	HtmlRenderer.ptr.prototype.renderCodeSpanOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("<code>");
		return 0;
	};
	HtmlRenderer.prototype.renderCodeSpanOpenMarker = function(node, entering) { return this.$val.renderCodeSpanOpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderCodeSpanContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	HtmlRenderer.prototype.renderCodeSpanContent = function(node, entering) { return this.$val.renderCodeSpanContent(node, entering); };
	HtmlRenderer.ptr.prototype.renderCodeSpanCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("</code>");
		return 0;
	};
	HtmlRenderer.prototype.renderCodeSpanCloseMarker = function(node, entering) { return this.$val.renderCodeSpanCloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmphasis = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.TextAutoSpacePrevious(node);
		} else {
			r.BaseRenderer.TextAutoSpaceNext(node);
		}
		return 2;
	};
	HtmlRenderer.prototype.renderEmphasis = function(node, entering) { return this.$val.renderEmphasis(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmAsteriskOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("em", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderEmAsteriskOpenMarker = function(node, entering) { return this.$val.renderEmAsteriskOpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmAsteriskCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderEmAsteriskCloseMarker = function(node, entering) { return this.$val.renderEmAsteriskCloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmUnderscoreOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("em", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderEmUnderscoreOpenMarker = function(node, entering) { return this.$val.renderEmUnderscoreOpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderEmUnderscoreCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderEmUnderscoreCloseMarker = function(node, entering) { return this.$val.renderEmUnderscoreCloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrong = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.TextAutoSpacePrevious(node);
		} else {
			r.BaseRenderer.TextAutoSpaceNext(node);
		}
		return 2;
	};
	HtmlRenderer.prototype.renderStrong = function(node, entering) { return this.$val.renderStrong(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrongA6kOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("strong", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderStrongA6kOpenMarker = function(node, entering) { return this.$val.renderStrongA6kOpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrongA6kCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderStrongA6kCloseMarker = function(node, entering) { return this.$val.renderStrongA6kCloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrongU8eOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("strong", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderStrongU8eOpenMarker = function(node, entering) { return this.$val.renderStrongU8eOpenMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderStrongU8eCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$7.nil, false);
		return 0;
	};
	HtmlRenderer.prototype.renderStrongU8eCloseMarker = function(node, entering) { return this.$val.renderStrongU8eCloseMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderBlockquote = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.Newline();
			r.BaseRenderer.WriteString("<blockquote>");
			r.BaseRenderer.Newline();
		} else {
			r.BaseRenderer.Newline();
			r.BaseRenderer.WriteString("</blockquote>");
			r.BaseRenderer.Newline();
		}
		return 2;
	};
	HtmlRenderer.prototype.renderBlockquote = function(node, entering) { return this.$val.renderBlockquote(node, entering); };
	HtmlRenderer.ptr.prototype.renderBlockquoteMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderBlockquoteMarker = function(node, entering) { return this.$val.renderBlockquoteMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderHeading = function(node, entering) {
		var _r, _r$1, entering, id, id$1, level, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; entering = $f.entering; id = $f.id; id$1 = $f.id$1; level = $f.level; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.Newline();
			level = $substring(headingLevel, node.HeadingLevel, (node.HeadingLevel + 1 >> 0));
			r.BaseRenderer.WriteString("<h" + level);
			_r = HeadingID(node); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			id = _r;
			if (r.BaseRenderer.Option.ToC || r.BaseRenderer.Option.HeadingID) {
				r.BaseRenderer.WriteString(" id=\"" + id + "\"");
			}
			r.BaseRenderer.WriteString(">");
			$s = 3; continue;
		/* } else { */ case 2:
			/* */ if (r.BaseRenderer.Option.HeadingAnchor) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (r.BaseRenderer.Option.HeadingAnchor) { */ case 5:
				_r$1 = HeadingID(node); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				id$1 = _r$1;
				r.tag("a", new sliceType$7([new sliceType(["id", "vditorAnchor-" + id$1]), new sliceType(["class", "vditor-anchor"]), new sliceType(["href", "#" + id$1])]), false);
				r.BaseRenderer.WriteString("<svg viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>");
				r.tag("/a", sliceType$7.nil, false);
			/* } */ case 6:
			r.BaseRenderer.WriteString("</h" + $substring(headingLevel, node.HeadingLevel, (node.HeadingLevel + 1 >> 0)) + ">");
			r.BaseRenderer.Newline();
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HtmlRenderer.ptr.prototype.renderHeading }; } $f._r = _r; $f._r$1 = _r$1; $f.entering = entering; $f.id = id; $f.id$1 = id$1; $f.level = level; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	HtmlRenderer.prototype.renderHeading = function(node, entering) { return this.$val.renderHeading(node, entering); };
	HtmlRenderer.ptr.prototype.renderHeadingC8hMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	HtmlRenderer.prototype.renderHeadingC8hMarker = function(node, entering) { return this.$val.renderHeadingC8hMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderList = function(node, entering) {
		var _1, attrs, entering, node, r, tag;
		r = this;
		tag = "ul";
		if ((1 === node.ListData.Typ) || ((3 === node.ListData.Typ) && (0 === node.ListData.BulletChar))) {
			tag = "ol";
		}
		if (entering) {
			r.BaseRenderer.Newline();
			attrs = sliceType$7.nil;
			if (r.BaseRenderer.Option.RenderListMarker) {
				_1 = node.ListData.Typ;
				if (_1 === (0)) {
					attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
				} else if (_1 === (1)) {
					attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
				} else if (_1 === (3)) {
					if (0 === node.ListData.BulletChar) {
						attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
					} else {
						attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
					}
				}
			}
			if ((0 === node.ListData.BulletChar) && !((1 === node.ListData.Start))) {
				attrs = $append(attrs, new sliceType(["start", strconv.Itoa(node.ListData.Start)]));
			}
			r.tag(tag, attrs, false);
			r.BaseRenderer.Newline();
		} else {
			r.BaseRenderer.Newline();
			r.tag("/" + tag, sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		}
		return 2;
	};
	HtmlRenderer.prototype.renderList = function(node, entering) { return this.$val.renderList(node, entering); };
	HtmlRenderer.ptr.prototype.renderListItem = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			if ((3 === node.ListData.Typ) && !("" === r.BaseRenderer.Option.GFMTaskListItemClass) && !(ptrType$1.nil === node.FirstChild) && !(ptrType$1.nil === node.FirstChild.FirstChild) && (100 === node.FirstChild.FirstChild.Type)) {
				r.tag("li", new sliceType$7([new sliceType(["class", r.BaseRenderer.Option.GFMTaskListItemClass])]), false);
			} else {
				r.tag("li", sliceType$7.nil, false);
			}
		} else {
			r.tag("/li", sliceType$7.nil, false);
			r.BaseRenderer.Newline();
		}
		return 2;
	};
	HtmlRenderer.prototype.renderListItem = function(node, entering) { return this.$val.renderListItem(node, entering); };
	HtmlRenderer.ptr.prototype.renderTaskListItemMarker = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		if (entering) {
			attrs = sliceType$7.nil;
			if (node.TaskListItemChecked) {
				attrs = $append(attrs, new sliceType(["checked", ""]));
			}
			attrs = $append(attrs, new sliceType(["disabled", ""]), new sliceType(["type", "checkbox"]));
			r.tag("input", attrs, true);
		}
		return 2;
	};
	HtmlRenderer.prototype.renderTaskListItemMarker = function(node, entering) { return this.$val.renderTaskListItemMarker(node, entering); };
	HtmlRenderer.ptr.prototype.renderThematicBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Newline();
		r.tag("hr", sliceType$7.nil, true);
		r.BaseRenderer.Newline();
		return 0;
	};
	HtmlRenderer.prototype.renderThematicBreak = function(node, entering) { return this.$val.renderThematicBreak(node, entering); };
	HtmlRenderer.ptr.prototype.renderHardBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("br", sliceType$7.nil, true);
			r.BaseRenderer.Newline();
		}
		return 0;
	};
	HtmlRenderer.prototype.renderHardBreak = function(node, entering) { return this.$val.renderHardBreak(node, entering); };
	HtmlRenderer.ptr.prototype.renderSoftBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		if (r.BaseRenderer.Option.SoftBreak2HardBreak) {
			r.tag("br", sliceType$7.nil, true);
			r.BaseRenderer.Newline();
		} else {
			r.BaseRenderer.Newline();
		}
		return 0;
	};
	HtmlRenderer.prototype.renderSoftBreak = function(node, entering) { return this.$val.renderSoftBreak(node, entering); };
	HtmlRenderer.ptr.prototype.tag = function(name, attrs, selfclosing) {
		var _i, _ref, attr, attrs, name, r, selfclosing;
		r = this;
		if (r.BaseRenderer.DisableTags > 0) {
			return;
		}
		r.BaseRenderer.WriteString("<");
		r.BaseRenderer.WriteString(name);
		if (0 < attrs.$length) {
			_ref = attrs;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				attr = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				r.BaseRenderer.WriteString(" " + (0 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 0]) + "=\"" + (1 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 1]) + "\"");
				_i++;
			}
		}
		if (selfclosing) {
			r.BaseRenderer.WriteString(" /");
		}
		r.BaseRenderer.WriteString(">");
	};
	HtmlRenderer.prototype.tag = function(name, attrs, selfclosing) { return this.$val.tag(name, attrs, selfclosing); };
	BaseRenderer.ptr.prototype.renderMindmap = function(listContent) {
		var _i, _r, _ref, buf, c, c$1, listContent, r, toRemoved, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; buf = $f.buf; c = $f.c; c$1 = $f.c$1; listContent = $f.listContent; r = $f.r; toRemoved = $f.toRemoved; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		buf = [buf];
		r = this;
		listContent = bytes.ReplaceAll(listContent, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
		_r = parse.Parse("", listContent, r.Option); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tree = _r;
		if (ptrType$1.nil === tree.Root.FirstChild || !((7 === tree.Root.FirstChild.Type))) {
			$s = -1; return (new sliceType$3($stringToBytes("{}")));
		}
		toRemoved = sliceType$6.nil;
		c = tree.Root.FirstChild;
		while (true) {
			if (!(!(ptrType$1.nil === c))) { break; }
			if (!((7 === c.Type))) {
				toRemoved = $append(toRemoved, c);
			}
			c = c.Next;
		}
		_ref = toRemoved;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			c$1 = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			c$1.Unlink();
			_i++;
		}
		buf[0] = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
		$r = ast.Walk(tree.Root, (function(buf) { return function $b(n, entering) {
			var _1, _r$1, _r$2, children, entering, n, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r$1 = $f._r$1; _r$2 = $f._r$2; children = $f.children; entering = $f.entering; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
				_1 = n.Type;
				/* */ if (_1 === (0)) { $s = 2; continue; }
				/* */ if (_1 === (7)) { $s = 3; continue; }
				/* */ if (_1 === (8)) { $s = 4; continue; }
				/* */ $s = 5; continue;
				/* if (_1 === (0)) { */ case 2:
					if (entering) {
						if (needRoot(n)) {
							buf[0].WriteString("{\"name\": \"Root\", \"children\": [");
						}
					} else {
						if (needRoot(n)) {
							buf[0].WriteString("]}");
						}
					}
					$s = -1; return 2;
				/* } else if (_1 === (7)) { */ case 3:
					$s = -1; return 2;
				/* } else if (_1 === (8)) { */ case 4:
					children = !(ptrType$1.nil === n.ChildByType(7));
					/* */ if (entering) { $s = 7; continue; }
					/* */ $s = 8; continue;
					/* if (entering) { */ case 7:
						_r$1 = text(n.FirstChild); /* */ $s = 10; case 10: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						_r$2 = buf[0].WriteString("{\"name\": \"" + _r$1 + "\""); /* */ $s = 11; case 11: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
						_r$2;
						if (children) {
							buf[0].WriteString(", \"children\": [");
						}
						$s = 9; continue;
					/* } else { */ case 8:
						if (children) {
							buf[0].WriteString("]");
						}
						buf[0].WriteString("}");
						if (!(ptrType$1.nil === n.Next) || !(ptrType$1.nil === n.Parent.Next)) {
							buf[0].WriteString(", ");
						}
					/* } */ case 9:
					$s = 6; continue;
				/* } else { */ case 5:
					$s = -1; return 0;
				/* } */ case 6:
			case 1:
			$s = -1; return 2;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._1 = _1; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.children = children; $f.entering = entering; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
		}; })(buf)); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return util.EncodeDestination(buf[0].Bytes());
		/* */ } return; } if ($f === undefined) { $f = { $blk: BaseRenderer.ptr.prototype.renderMindmap }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.buf = buf; $f.c = c; $f.c$1 = c$1; $f.listContent = listContent; $f.r = r; $f.toRemoved = toRemoved; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	BaseRenderer.prototype.renderMindmap = function(listContent) { return this.$val.renderMindmap(listContent); };
	text = function(listItemFirstChild) {
		var listItemFirstChild, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; listItemFirstChild = $f.listItemFirstChild; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = [ret];
		ret[0] = "";
		if (ptrType$1.nil === listItemFirstChild) {
			ret[0] = "";
			$s = -1; return ret[0];
		}
		$r = ast.Walk(listItemFirstChild, (function(ret) { return function(n, entering) {
			var entering, n;
			if ((7 === n.Type) || (8 === n.Type)) {
				return 0;
			}
			if (((16 === n.Type) || (40 === n.Type)) && entering) {
				ret[0] = ret[0] + (util.BytesToStr(n.Tokens));
			}
			return 2;
		}; })(ret)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		ret[0] = strings.ReplaceAll(ret[0], "\\", "\\\\");
		ret[0] = strings.ReplaceAll(ret[0], "\"", "\\\"");
		ret[0] = strings.ReplaceAll(ret[0], "\xE2\x80\xB8", "");
		$s = -1; return ret[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: text }; } $f.listItemFirstChild = listItemFirstChild; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	needRoot = function(root) {
		var c, c$1, count, root;
		count = 0;
		c = root.FirstChild;
		while (true) {
			if (!(!(ptrType$1.nil === c))) { break; }
			if (7 === c.Type) {
				count = count + (1) >> 0;
			}
			c = c.Next;
		}
		if (1 < count) {
			return true;
		}
		if (0 === count) {
			return true;
		}
		count = 0;
		c$1 = root.FirstChild.FirstChild;
		while (true) {
			if (!(!(ptrType$1.nil === c$1))) { break; }
			if (8 === c$1.Type) {
				count = count + (1) >> 0;
			}
			c$1 = c$1.Next;
		}
		if (1 < count) {
			return true;
		}
		return false;
	};
	NewBaseRenderer = function(tree) {
		var ret, tree;
		ret = new BaseRenderer.ptr(tree.Context.Option, $makeMap(ast.NodeType.keyFor, []), $throwNilPointerError, $makeMap(ast.NodeType.keyFor, []), ptrType$3.nil, 0, tree, 0);
		ret.Writer = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
		ret.Writer.Grow(4096);
		return ret;
	};
	$pkg.NewBaseRenderer = NewBaseRenderer;
	BaseRenderer.ptr.prototype.Render = function() {
		var output, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; output = $f.output; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = [r];
		output = sliceType$3.nil;
		r[0] = this;
		r[0].LastOut = 10;
		r[0].Writer = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
		r[0].Writer.Grow(4096);
		$r = ast.Walk(r[0].Tree.Root, (function(r) { return function $b(n, entering) {
			var _entry, _entry$1, _r, _r$1, _r$2, _tuple, entering, extRender, n, output$1, render, status, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _entry$1 = $f._entry$1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _tuple = $f._tuple; entering = $f.entering; extRender = $f.extRender; n = $f.n; output$1 = $f.output$1; render = $f.render; status = $f.status; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			extRender = (_entry = r[0].ExtRendererFuncs[ast.NodeType.keyFor(n.Type)], _entry !== undefined ? _entry.v : $throwNilPointerError);
			/* */ if (!($throwNilPointerError === extRender)) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (!($throwNilPointerError === extRender)) { */ case 1:
				_r = extRender(n, entering); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				_tuple = _r;
				output$1 = _tuple[0];
				status = _tuple[1];
				r[0].WriteString(output$1);
				$s = -1; return status;
			/* } */ case 2:
			render = (_entry$1 = r[0].RendererFuncs[ast.NodeType.keyFor(n.Type)], _entry$1 !== undefined ? _entry$1.v : $throwNilPointerError);
			/* */ if ($throwNilPointerError === render) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if ($throwNilPointerError === render) { */ case 4:
				/* */ if (!($throwNilPointerError === r[0].DefaultRendererFunc)) { $s = 6; continue; }
				/* */ $s = 7; continue;
				/* if (!($throwNilPointerError === r[0].DefaultRendererFunc)) { */ case 6:
					_r$1 = r[0].DefaultRendererFunc(n, entering); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					$s = -1; return _r$1;
				/* } else { */ case 7:
					$s = -1; return r[0].renderDefault(n, entering);
				/* } */ case 8:
			/* } */ case 5:
			_r$2 = render(n, entering); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			$s = -1; return _r$2;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._entry = _entry; $f._entry$1 = _entry$1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._tuple = _tuple; $f.entering = entering; $f.extRender = extRender; $f.n = n; $f.output$1 = output$1; $f.render = render; $f.status = status; $f.$s = $s; $f.$r = $r; return $f;
		}; })(r)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		output = r[0].Writer.Bytes();
		$s = -1; return output;
		/* */ } return; } if ($f === undefined) { $f = { $blk: BaseRenderer.ptr.prototype.Render }; } $f.output = output; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	BaseRenderer.prototype.Render = function() { return this.$val.Render(); };
	BaseRenderer.ptr.prototype.renderDefault = function(n, entering) {
		var entering, n, r;
		r = this;
		r.WriteString("not found render function for node [type=" + new ast.NodeType(n.Type).String() + ", Tokens=" + util.BytesToStr(n.Tokens) + "]");
		return 2;
	};
	BaseRenderer.prototype.renderDefault = function(n, entering) { return this.$val.renderDefault(n, entering); };
	BaseRenderer.ptr.prototype.WriteByte = function(c) {
		var c, r;
		r = this;
		r.Writer.WriteByte(c);
		r.LastOut = c;
	};
	BaseRenderer.prototype.WriteByte = function(c) { return this.$val.WriteByte(c); };
	BaseRenderer.ptr.prototype.Write = function(content) {
		var content, length, r, x;
		r = this;
		length = content.$length;
		if (0 < length) {
			r.Writer.Write(content);
			r.LastOut = (x = length - 1 >> 0, ((x < 0 || x >= content.$length) ? ($throwRuntimeError("index out of range"), undefined) : content.$array[content.$offset + x]));
		}
	};
	BaseRenderer.prototype.Write = function(content) { return this.$val.Write(content); };
	BaseRenderer.ptr.prototype.WriteString = function(content) {
		var content, length, r;
		r = this;
		length = content.length;
		if (0 < length) {
			r.Writer.WriteString(content);
			r.LastOut = content.charCodeAt((length - 1 >> 0));
		}
	};
	BaseRenderer.prototype.WriteString = function(content) { return this.$val.WriteString(content); };
	BaseRenderer.ptr.prototype.Newline = function() {
		var r;
		r = this;
		if (!((10 === r.LastOut))) {
			r.Writer.WriteByte(10);
			r.LastOut = 10;
		}
	};
	BaseRenderer.prototype.Newline = function() { return this.$val.Newline(); };
	BaseRenderer.ptr.prototype.TextAutoSpacePrevious = function(node) {
		var _tuple, _tuple$1, first, node, prevLast, previous, r, text$1;
		r = this;
		if (r.Option.AutoSpace) {
			text$1 = node.ChildByType(16);
			if (!(ptrType$1.nil === text$1) && !(sliceType$3.nil === text$1.Tokens)) {
				previous = node.Previous;
				if (!(ptrType$1.nil === previous) && (16 === previous.Type)) {
					_tuple = utf8.DecodeLastRune(previous.Tokens);
					prevLast = _tuple[0];
					_tuple$1 = utf8.DecodeRune(text$1.Tokens);
					first = _tuple$1[0];
					if (allowSpace(prevLast, first)) {
						r.Writer.WriteByte(32);
					}
				}
			}
		}
	};
	BaseRenderer.prototype.TextAutoSpacePrevious = function(node) { return this.$val.TextAutoSpacePrevious(node); };
	BaseRenderer.ptr.prototype.TextAutoSpaceNext = function(node) {
		var _tuple, _tuple$1, last, next, nextFirst, node, r, text$1;
		r = this;
		if (r.Option.AutoSpace) {
			text$1 = node.ChildByType(16);
			if (!(ptrType$1.nil === text$1) && !(sliceType$3.nil === text$1.Tokens)) {
				next = node.Next;
				if (!(ptrType$1.nil === next) && (16 === next.Type)) {
					_tuple = utf8.DecodeRune(next.Tokens);
					nextFirst = _tuple[0];
					_tuple$1 = utf8.DecodeLastRune(text$1.Tokens);
					last = _tuple$1[0];
					if (allowSpace(last, nextFirst)) {
						r.Writer.WriteByte(32);
					}
				}
			}
		}
	};
	BaseRenderer.prototype.TextAutoSpaceNext = function(node) { return this.$val.TextAutoSpaceNext(node); };
	BaseRenderer.ptr.prototype.LinkTextAutoSpacePrevious = function(node) {
		var _tuple, _tuple$1, first, node, prevLast, previous, r, text$1;
		r = this;
		if (r.Option.AutoSpace) {
			text$1 = node.ChildByType(40);
			if (!(ptrType$1.nil === text$1) && !(sliceType$3.nil === text$1.Tokens)) {
				previous = node.Previous;
				if (!(ptrType$1.nil === previous) && (16 === previous.Type)) {
					_tuple = utf8.DecodeLastRune(previous.Tokens);
					prevLast = _tuple[0];
					_tuple$1 = utf8.DecodeRune(text$1.Tokens);
					first = _tuple$1[0];
					if (allowSpace(prevLast, first)) {
						r.Writer.WriteByte(32);
					}
				}
			}
		}
	};
	BaseRenderer.prototype.LinkTextAutoSpacePrevious = function(node) { return this.$val.LinkTextAutoSpacePrevious(node); };
	BaseRenderer.ptr.prototype.LinkTextAutoSpaceNext = function(node) {
		var _tuple, _tuple$1, last, next, nextFirst, node, r, text$1;
		r = this;
		if (r.Option.AutoSpace) {
			text$1 = node.ChildByType(40);
			if (!(ptrType$1.nil === text$1) && !(sliceType$3.nil === text$1.Tokens)) {
				next = node.Next;
				if (!(ptrType$1.nil === next) && (16 === next.Type)) {
					_tuple = utf8.DecodeRune(next.Tokens);
					nextFirst = _tuple[0];
					_tuple$1 = utf8.DecodeLastRune(text$1.Tokens);
					last = _tuple$1[0];
					if (allowSpace(last, nextFirst)) {
						r.Writer.WriteByte(32);
					}
				}
			}
		}
	};
	BaseRenderer.prototype.LinkTextAutoSpaceNext = function(node) { return this.$val.LinkTextAutoSpaceNext(node); };
	HeadingID = function(heading) {
		var heading, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; heading = $f.heading; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = "";
		/* */ if (0 === util.StrToBytes(heading.HeadingNormalizedID).$length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (0 === util.StrToBytes(heading.HeadingNormalizedID).$length) { */ case 1:
			$r = headingID0(heading); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		ret = heading.HeadingNormalizedID;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: HeadingID }; } $f.heading = heading; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.HeadingID = HeadingID;
	headingID0 = function(heading) {
		var heading, idOccurs, root, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; heading = $f.heading; idOccurs = $f.idOccurs; root = $f.root; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		idOccurs = [idOccurs];
		root = ptrType$1.nil;
		root = heading.Parent;
		while (true) {
			if (!(!((0 === root.Type)))) { break; }
			root = root.Parent;
		}
		idOccurs[0] = $makeMap($String.keyFor, []);
		$r = ast.Walk(root, (function(idOccurs) { return function $b(n, entering) {
			var _entry, _key, _r, entering, id, n, $s, $r;
			/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _key = $f._key; _r = $f._r; entering = $f.entering; id = $f.id; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
			/* */ if (entering) { $s = 1; continue; }
			/* */ $s = 2; continue;
			/* if (entering) { */ case 1:
				/* */ if (2 === n.Type) { $s = 3; continue; }
				/* */ $s = 4; continue;
				/* if (2 === n.Type) { */ case 3:
					_r = normalizeHeadingID(n); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					id = _r;
					while (true) {
						if (!(0 < (_entry = idOccurs[0][$String.keyFor(id)], _entry !== undefined ? _entry.v : 0))) { break; }
						id = id + ("-");
					}
					n.HeadingNormalizedID = id;
					_key = id; (idOccurs[0] || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: 1 };
				/* } */ case 4:
			/* } */ case 2:
			$s = -1; return 2;
			/* */ } return; } if ($f === undefined) { $f = { $blk: $b }; } $f._entry = _entry; $f._key = _key; $f._r = _r; $f.entering = entering; $f.id = id; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
		}; })(idOccurs)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: headingID0 }; } $f.heading = heading; $f.idOccurs = idOccurs; $f.root = root; $f.$s = $s; $f.$r = $r; return $f;
	};
	normalizeHeadingID = function(heading) {
		var _i, _r, _r$1, _ref, _rune, heading, id, r, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _rune = $f._rune; heading = $f.heading; id = $f.id; r = $f.r; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = "";
		id = util.BytesToStr(heading.HeadingID);
		/* */ if ("" === id) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ("" === id) { */ case 1:
			_r = heading.Text(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			id = _r;
		/* } */ case 2:
		_r$1 = strings.TrimLeft(id, "#"); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		id = _r$1;
		id = strings.ReplaceAll(id, "\xE2\x80\xB8", "");
		_ref = id;
		_i = 0;
		while (true) {
			if (!(_i < _ref.length)) { break; }
			_rune = $decodeRune(_ref, _i);
			r = _rune[0];
			if (unicode.IsLetter(r) || unicode.IsDigit(r)) {
				ret = ret + (($encodeRune(r)));
			} else {
				ret = ret + ("-");
			}
			_i += _rune[1];
		}
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: normalizeHeadingID }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._rune = _rune; $f.heading = heading; $f.id = id; $f.r = r; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	BaseRenderer.ptr.prototype.headings = function() {
		var n, r, ret;
		ret = sliceType$6.nil;
		r = this;
		n = r.Tree.Root.FirstChild;
		while (true) {
			if (!(!(ptrType$1.nil === n))) { break; }
			if (2 === n.Type) {
				ret = $append(ret, n);
			}
			n = n.Next;
		}
		return ret;
	};
	BaseRenderer.prototype.headings = function() { return this.$val.headings(); };
	sanitize = function(tokens) {
		var _1, _2, _entry, _entry$1, _r, _r$1, _r$10, _r$11, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _tuple, _tuple$1, buff, err, mostRecentlyStartedToken, ok, ok$1, skipElementContent, skippingElementsCount, token, tokenizer, tokens, x, x$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _entry = $f._entry; _entry$1 = $f._entry$1; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _tuple = $f._tuple; _tuple$1 = $f._tuple$1; buff = $f.buff; err = $f.err; mostRecentlyStartedToken = $f.mostRecentlyStartedToken; ok = $f.ok; ok$1 = $f.ok$1; skipElementContent = $f.skipElementContent; skippingElementsCount = $f.skippingElementsCount; token = $f.token; tokenizer = $f.tokenizer; tokens = $f.tokens; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		buff = [buff];
		buff[0] = new bytes.Buffer.ptr(sliceType$3.nil, 0, 0);
		skipElementContent = false;
		skippingElementsCount = new $Int64(0, 0);
		mostRecentlyStartedToken = "";
		_r = html.NewTokenizer(bytes.NewReader(tokens)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tokenizer = _r;
		/* while (true) { */ case 2:
			token = [token];
			_r$1 = tokenizer.Next(); /* */ $s = 6; case 6: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			/* */ if (_r$1 === 0) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (_r$1 === 0) { */ case 4:
				err = tokenizer.Err();
				if ($interfaceIsEqual(err, io.EOF)) {
					$s = -1; return buff[0].Bytes();
				}
				_r$2 = err.Error(); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				_r$3 = util.StrToBytes(_r$2); /* */ $s = 8; case 8: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				$s = -1; return _r$3;
			/* } */ case 5:
			token[0] = $clone(tokenizer.Token(), html.Token);
				_1 = token[0].Type;
				/* */ if (_1 === (6)) { $s = 10; continue; }
				/* */ if (_1 === (5)) { $s = 11; continue; }
				/* */ if (_1 === (2)) { $s = 12; continue; }
				/* */ if (_1 === (3)) { $s = 13; continue; }
				/* */ if (_1 === (4)) { $s = 14; continue; }
				/* */ if (_1 === (1)) { $s = 15; continue; }
				/* */ $s = 16; continue;
				/* if (_1 === (6)) { */ case 10:
					$s = 16; continue;
				/* } else if (_1 === (5)) { */ case 11:
					$s = 16; continue;
				/* } else if (_1 === (2)) { */ case 12:
					mostRecentlyStartedToken = token[0].Data;
					_tuple = (_entry = setOfElementsToSkipContent[$String.keyFor(token[0].Data)], _entry !== undefined ? [_entry.v, true] : [$ifaceNil, false]);
					ok = _tuple[1];
					if (ok) {
						skipElementContent = true;
						skippingElementsCount = (x = new $Int64(0, 1), new $Int64(skippingElementsCount.$high + x.$high, skippingElementsCount.$low + x.$low));
						buff[0].WriteString(" ");
						/* break; */ $s = 9; continue;
					}
					if (!((token[0].Attr.$length === 0))) {
						token[0].Attr = sanitizeAttrs(token[0].Attr);
					}
					/* */ if (!skipElementContent) { $s = 17; continue; }
					/* */ $s = 18; continue;
					/* if (!skipElementContent) { */ case 17:
						/* */ if (linkable(token[0].Data)) { $s = 19; continue; }
						/* */ $s = 20; continue;
						/* if (linkable(token[0].Data)) { */ case 19:
							$r = writeLinkableBuf(buff[0], token[0]); /* */ $s = 22; case 22: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = 21; continue;
						/* } else { */ case 20:
							_r$4 = $clone(token[0], html.Token).String(); /* */ $s = 23; case 23: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
							_r$5 = buff[0].WriteString(_r$4); /* */ $s = 24; case 24: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
							_r$5;
						/* } */ case 21:
					/* } */ case 18:
					$s = 16; continue;
				/* } else if (_1 === (3)) { */ case 13:
					if (mostRecentlyStartedToken === token[0].Data) {
						mostRecentlyStartedToken = "";
					}
					_tuple$1 = (_entry$1 = setOfElementsToSkipContent[$String.keyFor(token[0].Data)], _entry$1 !== undefined ? [_entry$1.v, true] : [$ifaceNil, false]);
					ok$1 = _tuple$1[1];
					if (ok$1) {
						skippingElementsCount = (x$1 = new $Int64(0, 1), new $Int64(skippingElementsCount.$high - x$1.$high, skippingElementsCount.$low - x$1.$low));
						if ((skippingElementsCount.$high === 0 && skippingElementsCount.$low === 0)) {
							skipElementContent = false;
						}
						buff[0].WriteString(" ");
						/* break; */ $s = 9; continue;
					}
					/* */ if (!skipElementContent) { $s = 25; continue; }
					/* */ $s = 26; continue;
					/* if (!skipElementContent) { */ case 25:
						_r$6 = $clone(token[0], html.Token).String(); /* */ $s = 27; case 27: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
						_r$7 = buff[0].WriteString(_r$6); /* */ $s = 28; case 28: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
						_r$7;
					/* } */ case 26:
					$s = 16; continue;
				/* } else if (_1 === (4)) { */ case 14:
					if (!((token[0].Attr.$length === 0))) {
						token[0].Attr = sanitizeAttrs(token[0].Attr);
					}
					/* */ if (!skipElementContent) { $s = 29; continue; }
					/* */ $s = 30; continue;
					/* if (!skipElementContent) { */ case 29:
						/* */ if (linkable(token[0].Data)) { $s = 31; continue; }
						/* */ $s = 32; continue;
						/* if (linkable(token[0].Data)) { */ case 31:
							$r = writeLinkableBuf(buff[0], token[0]); /* */ $s = 34; case 34: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
							$s = 33; continue;
						/* } else { */ case 32:
							_r$8 = $clone(token[0], html.Token).String(); /* */ $s = 35; case 35: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
							_r$9 = buff[0].WriteString(_r$8); /* */ $s = 36; case 36: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
							_r$9;
						/* } */ case 33:
					/* } */ case 30:
					$s = 16; continue;
				/* } else if (_1 === (1)) { */ case 15:
					/* */ if (!skipElementContent) { $s = 37; continue; }
					/* */ $s = 38; continue;
					/* if (!skipElementContent) { */ case 37:
							_2 = mostRecentlyStartedToken;
							/* */ if (_2 === ("script")) { $s = 40; continue; }
							/* */ if (_2 === ("style")) { $s = 41; continue; }
							/* */ $s = 42; continue;
							/* if (_2 === ("script")) { */ case 40:
								buff[0].WriteString(token[0].Data);
								$s = 43; continue;
							/* } else if (_2 === ("style")) { */ case 41:
								buff[0].WriteString(token[0].Data);
								$s = 43; continue;
							/* } else { */ case 42:
								_r$10 = $clone(token[0], html.Token).String(); /* */ $s = 44; case 44: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
								_r$11 = buff[0].WriteString(_r$10); /* */ $s = 45; case 45: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
								_r$11;
							/* } */ case 43:
						case 39:
					/* } */ case 38:
				/* } */ case 16:
			case 9:
		/* } */ $s = 2; continue; case 3:
		$s = -1; return sliceType$3.nil;
		/* */ } return; } if ($f === undefined) { $f = { $blk: sanitize }; } $f._1 = _1; $f._2 = _2; $f._entry = _entry; $f._entry$1 = _entry$1; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._tuple = _tuple; $f._tuple$1 = _tuple$1; $f.buff = buff; $f.err = err; $f.mostRecentlyStartedToken = mostRecentlyStartedToken; $f.ok = ok; $f.ok$1 = ok$1; $f.skipElementContent = skipElementContent; $f.skippingElementsCount = skippingElementsCount; $f.token = token; $f.tokenizer = tokenizer; $f.tokens = tokens; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	linkable = function(elementName) {
		var _1, elementName;
		_1 = elementName;
		if (_1 === ("a") || _1 === ("area") || _1 === ("blockquote") || _1 === ("img") || _1 === ("link") || _1 === ("script")) {
			return true;
		} else {
			return false;
		}
	};
	writeLinkableBuf = function(buff, token) {
		var _1, _i, _r, _r$1, _r$2, _r$3, _ref, attr, buff, token, tokenBuff, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _ref = $f._ref; attr = $f.attr; buff = $f.buff; token = $f.token; tokenBuff = $f.tokenBuff; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		tokenBuff = bytes.NewBufferString("");
		tokenBuff.WriteString("<");
		tokenBuff.WriteString(token.Data);
		_ref = token.Attr;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), html.Attribute);
			tokenBuff.WriteByte(32);
			tokenBuff.WriteString(attr.Key);
			tokenBuff.WriteString("=\"");
				_1 = attr.Key;
				/* */ if (_1 === ("href") || _1 === ("src")) { $s = 4; continue; }
				/* */ $s = 5; continue;
				/* if (_1 === ("href") || _1 === ("src")) { */ case 4:
					_r = html.EscapeString(attr.Val); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					_r$1 = tokenBuff.WriteString(_r); /* */ $s = 8; case 8: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
					_r$1;
					$s = 6; continue;
				/* } else { */ case 5:
					_r$2 = html.EscapeString(attr.Val); /* */ $s = 9; case 9: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					_r$3 = tokenBuff.WriteString(_r$2); /* */ $s = 10; case 10: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
					_r$3;
				/* } */ case 6:
			case 3:
			tokenBuff.WriteByte(34);
			_i++;
		/* } */ $s = 1; continue; case 2:
		if (token.Type === 4) {
			tokenBuff.WriteString("/");
		}
		tokenBuff.WriteString(">");
		buff.WriteString(tokenBuff.String());
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: writeLinkableBuf }; } $f._1 = _1; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._ref = _ref; $f.attr = attr; $f.buff = buff; $f.token = token; $f.tokenBuff = tokenBuff; $f.$s = $s; $f.$r = $r; return $f;
	};
	sanitizeAttrs = function(attrs) {
		var _i, _ref, attr, attrs, ret;
		ret = sliceType$8.nil;
		_ref = attrs;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), html.Attribute);
			if (!allowAttr(attr.Key)) {
				_i++;
				continue;
			}
			if ("src" === attr.Key) {
				if (strings.HasPrefix(attr.Val, "data:image/svg+xml") || strings.HasPrefix(attr.Val, "javascript")) {
					_i++;
					continue;
				}
			}
			ret = $append(ret, attr);
			_i++;
		}
		return ret;
	};
	allowAttr = function(attrName) {
		var _entry, _i, _keys, _ref, attrName, name;
		_ref = allowedAttrs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			name = _entry.k;
			if (strings.HasPrefix(attrName, name)) {
				return true;
			}
			_i++;
		}
		return false;
	};
	BaseRenderer.ptr.prototype.Space = function(textNode) {
		var r, text$1, textNode;
		r = this;
		text$1 = util.BytesToStr(textNode.Tokens);
		text$1 = Space0(text$1);
		textNode.Tokens = util.StrToBytes(text$1);
	};
	BaseRenderer.prototype.Space = function(textNode) { return this.$val.Space(textNode); };
	Space0 = function(text$1) {
		var i, length, r, ret, runes, text$1, x, x$1, x$2;
		ret = "";
		runes = (new sliceType$1($stringToRunes(text$1)));
		length = runes.$length;
		r = 0;
		i = 0;
		while (true) {
			if (!(i < length)) { break; }
			r = ((i < 0 || i >= runes.$length) ? ($throwRuntimeError("index out of range"), undefined) : runes.$array[runes.$offset + i]);
			if (i < (length - 3 >> 0) && (105 === (x = i + 1 >> 0, ((x < 0 || x >= runes.$length) ? ($throwRuntimeError("index out of range"), undefined) : runes.$array[runes.$offset + x]))) && (110 === (x$1 = i + 2 >> 0, ((x$1 < 0 || x$1 >= runes.$length) ? ($throwRuntimeError("index out of range"), undefined) : runes.$array[runes.$offset + x$1]))) && (103 === (x$2 = i + 3 >> 0, ((x$2 < 0 || x$2 >= runes.$length) ? ($throwRuntimeError("index out of range"), undefined) : runes.$array[runes.$offset + x$2]))) && unicode.Is(unicode.Han, ((i < 0 || i >= runes.$length) ? ($throwRuntimeError("index out of range"), undefined) : runes.$array[runes.$offset + i]))) {
				ret = ret + (($encodeRune(r)) + "ing");
				i = i + (4) >> 0;
				continue;
			}
			ret = addSpaceAtBoundary(ret, r);
			i = i + (1) >> 0;
		}
		return ret;
	};
	$pkg.Space0 = Space0;
	addSpaceAtBoundary = function(prefix, nextChar) {
		var _tuple, currentChar, nextChar, prefix;
		if (0 === prefix.length) {
			return ($encodeRune(nextChar));
		}
		if ("1" <= prefix && "9" >= prefix && (65039 === nextChar)) {
			return prefix + ($encodeRune(nextChar));
		}
		_tuple = utf8.DecodeLastRuneInString(prefix);
		currentChar = _tuple[0];
		if (allowSpace(currentChar, nextChar)) {
			return prefix + " " + ($encodeRune(nextChar));
		}
		return prefix + ($encodeRune(nextChar));
	};
	allowSpace = function(currentChar, nextChar) {
		var currentChar, currentIsASCII, currentIsDigit, currentIsLetter, currentIsPunct, currentIsSymbol, nextChar, nextIsASCII, nextIsDigit, nextIsLetter, nextIsPunct, nextIsSymbol;
		if (unicode.IsSpace(currentChar) || !unicode.IsPrint(currentChar)) {
			return false;
		}
		if (unicode.IsSpace(nextChar) || !unicode.IsPrint(nextChar)) {
			return false;
		}
		currentIsASCII = 128 > currentChar;
		nextIsASCII = 128 > nextChar;
		currentIsLetter = unicode.IsLetter(currentChar);
		nextIsLetter = unicode.IsLetter(nextChar);
		if (currentIsASCII === nextIsASCII && currentIsLetter && nextIsLetter) {
			return false;
		}
		if ((currentIsLetter && ((65509 === nextChar) || (8451 === nextChar))) || (((65509 === currentChar) || (8451 === currentChar)) && nextIsLetter)) {
			return true;
		}
		if (((37 === currentChar) && nextIsLetter && !nextIsASCII) || (!currentIsASCII && currentIsLetter && (37 === nextChar))) {
			return true;
		}
		currentIsDigit = 48 <= currentChar && 57 >= currentChar;
		nextIsDigit = 48 <= nextChar && 57 >= nextChar;
		nextIsSymbol = unicode.IsSymbol(nextChar) && !((126 === nextChar));
		currentIsPunct = !((35 === currentChar)) && (unicode.IsPunct(currentChar) || (126 === currentChar));
		nextIsPunct = !((35 === nextChar)) && (unicode.IsPunct(nextChar) || (126 === nextChar));
		if (!currentIsPunct && !currentIsASCII && !unicode.Is(unicode.Han, currentChar)) {
			return false;
		}
		if (currentIsASCII) {
			if (currentIsDigit && nextIsSymbol) {
				return false;
			}
			if (currentIsPunct && nextIsLetter) {
				return false;
			}
			if (nextIsPunct || nextIsSymbol) {
				return false;
			}
			return !nextIsASCII;
		} else {
			if (currentIsPunct) {
				return false;
			}
			if (nextIsSymbol) {
				return true;
			}
			currentIsSymbol = unicode.IsSymbol(currentChar) && !((126 === currentChar));
			if (currentIsSymbol && (nextIsDigit || nextIsPunct || !nextIsASCII)) {
				return false;
			}
			if (currentIsLetter && nextIsPunct) {
				return false;
			}
			return true;
		}
	};
	BaseRenderer.ptr.prototype.FixTermTypo = function(textNode) {
		var _r, r, textNode, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; r = $f.r; textNode = $f.textNode; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.fixTermTypo0(textNode.Tokens); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		textNode.Tokens = _r;
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: BaseRenderer.ptr.prototype.FixTermTypo }; } $f._r = _r; $f.r = r; $f.textNode = textNode; $f.$s = $s; $f.$r = $r; return $f;
	};
	BaseRenderer.prototype.FixTermTypo = function(textNode) { return this.$val.FixTermTypo(textNode); };
	BaseRenderer.ptr.prototype.fixTermTypo0 = function(tokens) {
		var _entry, _r, _tmp, _tmp$1, _tmp$2, _tmp$3, _tmp$4, _tmp$5, _tuple, after, before, i, j, k, l, length, ok, originalTerm, r, to, token, tokens, x, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _r = $f._r; _tmp = $f._tmp; _tmp$1 = $f._tmp$1; _tmp$2 = $f._tmp$2; _tmp$3 = $f._tmp$3; _tmp$4 = $f._tmp$4; _tmp$5 = $f._tmp$5; _tuple = $f._tuple; after = $f.after; before = $f.before; i = $f.i; j = $f.j; k = $f.k; l = $f.l; length = $f.length; ok = $f.ok; originalTerm = $f.originalTerm; r = $f.r; to = $f.to; token = $f.token; tokens = $f.tokens; x = $f.x; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		length = tokens.$length;
		token = 0;
		_tmp = 0;
		_tmp$1 = 0;
		_tmp$2 = 0;
		_tmp$3 = 0;
		i = _tmp;
		j = _tmp$1;
		k = _tmp$2;
		l = _tmp$3;
		_tmp$4 = 0;
		_tmp$5 = 0;
		before = _tmp$4;
		after = _tmp$5;
		originalTerm = sliceType$3.nil;
		/* while (true) { */ case 1:
			/* if (!(i < length)) { break; } */ if(!(i < length)) { $s = 2; continue; }
			token = ((i < 0 || i >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + i]);
			/* */ if (isNotTerm(token)) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (isNotTerm(token)) { */ case 3:
				i = i + (1) >> 0;
				/* continue; */ $s = 1; continue;
			/* } */ case 4:
			/* */ if (1 <= i) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (1 <= i) { */ case 5:
				before = (x = i - 1 >> 0, ((x < 0 || x >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + x]));
				if (!isNotTerm(before)) {
					i = i + (1) >> 0;
					/* continue; */ $s = 1; continue;
				}
			/* } */ case 6:
			/* */ if (lex.IsASCIIPunct(before)) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (lex.IsASCIIPunct(before)) { */ case 7:
				i = i + (1) >> 0;
				/* continue; */ $s = 1; continue;
			/* } */ case 8:
			j = i;
			while (true) {
				if (!(j < length)) { break; }
				after = ((j < 0 || j >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + j]);
				if (isNotTerm(after) || (46 === after)) {
					break;
				}
				j = j + (1) >> 0;
			}
			/* */ if (lex.IsASCIIPunct(after)) { $s = 9; continue; }
			/* */ $s = 10; continue;
			/* if (lex.IsASCIIPunct(after)) { */ case 9:
				i = i + (1) >> 0;
				/* continue; */ $s = 1; continue;
			/* } */ case 10:
			_r = bytes.ToLower($subslice(tokens, i, j)); /* */ $s = 11; case 11: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			originalTerm = _r;
			_tuple = (_entry = r.Option.Terms[$String.keyFor(util.BytesToStr(originalTerm))], _entry !== undefined ? [_entry.v, true] : ["", false]);
			to = _tuple[0];
			ok = _tuple[1];
			if (ok) {
				l = 0;
				k = i;
				while (true) {
					if (!(k < j)) { break; }
					((k < 0 || k >= tokens.$length) ? ($throwRuntimeError("index out of range"), undefined) : tokens.$array[tokens.$offset + k] = to.charCodeAt(l));
					l = l + (1) >> 0;
					k = k + (1) >> 0;
				}
			}
			i = i + (1) >> 0;
		/* } */ $s = 1; continue; case 2:
		$s = -1; return tokens;
		/* */ } return; } if ($f === undefined) { $f = { $blk: BaseRenderer.ptr.prototype.fixTermTypo0 }; } $f._entry = _entry; $f._r = _r; $f._tmp = _tmp; $f._tmp$1 = _tmp$1; $f._tmp$2 = _tmp$2; $f._tmp$3 = _tmp$3; $f._tmp$4 = _tmp$4; $f._tmp$5 = _tmp$5; $f._tuple = _tuple; $f.after = after; $f.before = before; $f.i = i; $f.j = j; $f.k = k; $f.l = l; $f.length = length; $f.ok = ok; $f.originalTerm = originalTerm; $f.r = r; $f.to = to; $f.token = token; $f.tokens = tokens; $f.x = x; $f.$s = $s; $f.$r = $r; return $f;
	};
	BaseRenderer.prototype.fixTermTypo0 = function(tokens) { return this.$val.fixTermTypo0(tokens); };
	isNotTerm = function(token) {
		var token;
		return token >= 128 || lex.IsWhitespace(token) || lex.IsASCIIPunct(token);
	};
	NewTerms = function() {
		var _entry, _i, _key, _keys, _ref, k, ret, v, x;
		ret = false;
		ret = (x = $keys(terms).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		_ref = terms;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = k; (ret || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_i++;
		}
		return ret;
	};
	$pkg.NewTerms = NewTerms;
	NewVditorRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$28, _key$29, _key$3, _key$30, _key$31, _key$32, _key$33, _key$34, _key$35, _key$36, _key$37, _key$38, _key$39, _key$4, _key$40, _key$41, _key$42, _key$43, _key$44, _key$45, _key$46, _key$47, _key$48, _key$49, _key$5, _key$50, _key$51, _key$52, _key$53, _key$54, _key$55, _key$56, _key$57, _key$58, _key$59, _key$6, _key$60, _key$61, _key$62, _key$63, _key$64, _key$65, _key$66, _key$67, _key$68, _key$69, _key$7, _key$70, _key$71, _key$8, _key$9, ret, tree;
		ret = new VditorRenderer.ptr(NewBaseRenderer(tree), false);
		_key = 0; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocument") };
		_key$1 = 1; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraph") };
		_key$2 = 16; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderText") };
		_key$3 = 27; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpan") };
		_key$4 = 28; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeSpanOpenMarker") };
		_key$5 = 29; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderCodeSpanContent") };
		_key$6 = 30; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderCodeSpanCloseMarker") };
		_key$7 = 11; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderCodeBlock") };
		_key$8 = 12; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderCodeBlockOpenMarker") };
		_key$9 = 14; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderCodeBlockInfoMarker") };
		_key$10 = 15; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderCodeBlockCode") };
		_key$11 = 13; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderCodeBlockCloseMarker") };
		_key$12 = 300; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderMathBlock") };
		_key$13 = 301; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderMathBlockOpenMarker") };
		_key$14 = 302; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderMathBlockContent") };
		_key$15 = 303; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderMathBlockCloseMarker") };
		_key$16 = 304; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderInlineMath") };
		_key$17 = 305; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderInlineMathOpenMarker") };
		_key$18 = 306; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderInlineMathContent") };
		_key$19 = 307; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderInlineMathCloseMarker") };
		_key$20 = 17; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderEmphasis") };
		_key$21 = 18; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderEmAsteriskOpenMarker") };
		_key$22 = 19; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderEmAsteriskCloseMarker") };
		_key$23 = 20; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderEmUnderscoreOpenMarker") };
		_key$24 = 21; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderEmUnderscoreCloseMarker") };
		_key$25 = 22; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderStrong") };
		_key$26 = 23; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderStrongA6kOpenMarker") };
		_key$27 = 24; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderStrongA6kCloseMarker") };
		_key$28 = 25; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$28)] = { k: _key$28, v: $methodVal(ret, "renderStrongU8eOpenMarker") };
		_key$29 = 26; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$29)] = { k: _key$29, v: $methodVal(ret, "renderStrongU8eCloseMarker") };
		_key$30 = 5; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$30)] = { k: _key$30, v: $methodVal(ret, "renderBlockquote") };
		_key$31 = 6; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$31)] = { k: _key$31, v: $methodVal(ret, "renderBlockquoteMarker") };
		_key$32 = 2; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$32)] = { k: _key$32, v: $methodVal(ret, "renderHeading") };
		_key$33 = 3; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$33)] = { k: _key$33, v: $methodVal(ret, "renderHeadingC8hMarker") };
		_key$34 = 7; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$34)] = { k: _key$34, v: $methodVal(ret, "renderList") };
		_key$35 = 8; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$35)] = { k: _key$35, v: $methodVal(ret, "renderListItem") };
		_key$36 = 4; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$36)] = { k: _key$36, v: $methodVal(ret, "renderThematicBreak") };
		_key$37 = 31; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$37)] = { k: _key$37, v: $methodVal(ret, "renderHardBreak") };
		_key$38 = 32; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$38)] = { k: _key$38, v: $methodVal(ret, "renderSoftBreak") };
		_key$39 = 9; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$39)] = { k: _key$39, v: $methodVal(ret, "renderHTML") };
		_key$40 = 10; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$40)] = { k: _key$40, v: $methodVal(ret, "renderInlineHTML") };
		_key$41 = 33; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$41)] = { k: _key$41, v: $methodVal(ret, "renderLink") };
		_key$42 = 34; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$42)] = { k: _key$42, v: $methodVal(ret, "renderImage") };
		_key$43 = 35; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$43)] = { k: _key$43, v: $methodVal(ret, "renderBang") };
		_key$44 = 36; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$44)] = { k: _key$44, v: $methodVal(ret, "renderOpenBracket") };
		_key$45 = 37; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$45)] = { k: _key$45, v: $methodVal(ret, "renderCloseBracket") };
		_key$46 = 38; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$46)] = { k: _key$46, v: $methodVal(ret, "renderOpenParen") };
		_key$47 = 39; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$47)] = { k: _key$47, v: $methodVal(ret, "renderCloseParen") };
		_key$48 = 40; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$48)] = { k: _key$48, v: $methodVal(ret, "renderLinkText") };
		_key$49 = 43; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$49)] = { k: _key$49, v: $methodVal(ret, "renderLinkSpace") };
		_key$50 = 41; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$50)] = { k: _key$50, v: $methodVal(ret, "renderLinkDest") };
		_key$51 = 42; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$51)] = { k: _key$51, v: $methodVal(ret, "renderLinkTitle") };
		_key$52 = 101; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$52)] = { k: _key$52, v: $methodVal(ret, "renderStrikethrough") };
		_key$53 = 102; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$53)] = { k: _key$53, v: $methodVal(ret, "renderStrikethrough1OpenMarker") };
		_key$54 = 103; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$54)] = { k: _key$54, v: $methodVal(ret, "renderStrikethrough1CloseMarker") };
		_key$55 = 104; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$55)] = { k: _key$55, v: $methodVal(ret, "renderStrikethrough2OpenMarker") };
		_key$56 = 105; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$56)] = { k: _key$56, v: $methodVal(ret, "renderStrikethrough2CloseMarker") };
		_key$57 = 100; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$57)] = { k: _key$57, v: $methodVal(ret, "renderTaskListItemMarker") };
		_key$58 = 106; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$58)] = { k: _key$58, v: $methodVal(ret, "renderTable") };
		_key$59 = 107; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$59)] = { k: _key$59, v: $methodVal(ret, "renderTableHead") };
		_key$60 = 108; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$60)] = { k: _key$60, v: $methodVal(ret, "renderTableRow") };
		_key$61 = 109; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$61)] = { k: _key$61, v: $methodVal(ret, "renderTableCell") };
		_key$62 = 200; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$62)] = { k: _key$62, v: $methodVal(ret, "renderEmoji") };
		_key$63 = 201; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$63)] = { k: _key$63, v: $methodVal(ret, "renderEmojiUnicode") };
		_key$64 = 202; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$64)] = { k: _key$64, v: $methodVal(ret, "renderEmojiImg") };
		_key$65 = 203; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$65)] = { k: _key$65, v: $methodVal(ret, "renderEmojiAlias") };
		_key$66 = 500; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$66)] = { k: _key$66, v: $methodVal(ret, "renderFootnotesDef") };
		_key$67 = 501; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$67)] = { k: _key$67, v: $methodVal(ret, "renderFootnotesRef") };
		_key$68 = 600; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$68)] = { k: _key$68, v: $methodVal(ret, "renderToC") };
		_key$69 = 400; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$69)] = { k: _key$69, v: $methodVal(ret, "renderBackslash") };
		_key$70 = 401; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$70)] = { k: _key$70, v: $methodVal(ret, "renderBackslashContent") };
		_key$71 = 44; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$71)] = { k: _key$71, v: $methodVal(ret, "renderHtmlEntity") };
		return ret;
	};
	$pkg.NewVditorRenderer = NewVditorRenderer;
	VditorRenderer.ptr.prototype.Render = function() {
		var _entry, _i, _keys, _r, _ref, dest, destStr, label, node, output, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _r = $f._r; _ref = $f._ref; dest = $f.dest; destStr = $f.destStr; label = $f.label; node = $f.node; output = $f.output; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		output = sliceType$3.nil;
		r = this;
		_r = r.BaseRenderer.Render(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		output = _r;
		if (1 > $keys(r.BaseRenderer.Tree.Context.LinkRefDefs).length || r.needRenderFootnotesDef) {
			$s = -1; return output;
		}
		r.BaseRenderer.WriteString("<div data-block=\"0\" data-type=\"link-ref-defs-block\">");
		_ref = r.BaseRenderer.Tree.Context.LinkRefDefs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			node = _entry.v;
			label = node.LinkRefLabel;
			dest = node.ChildByType(41).Tokens;
			destStr = util.BytesToStr(dest);
			r.BaseRenderer.WriteString("[" + util.BytesToStr(label) + "]:");
			if (!("\xE2\x80\xB8" === destStr)) {
				r.BaseRenderer.WriteString(" ");
			}
			r.BaseRenderer.WriteString(destStr + "\n");
			_i++;
		}
		r.BaseRenderer.WriteString("</div>");
		output = r.BaseRenderer.Writer.Bytes();
		$s = -1; return output;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.Render }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._r = _r; $f._ref = _ref; $f.dest = dest; $f.destStr = destStr; $f.label = label; $f.node = node; $f.output = output; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.Render = function() { return this.$val.Render(); };
	VditorRenderer.ptr.prototype.RenderFootnotesDefs = function(context) {
		var _i, _r, _ref, context, def, defContent, defRenderer, r, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; context = $f.context; def = $f.def; defContent = $f.defContent; defRenderer = $f.defRenderer; r = $f.r; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.BaseRenderer.WriteString("<div data-block=\"0\" data-type=\"footnotes-block\">");
		r.BaseRenderer.WriteString("<ol data-type=\"footnotes-defs-ol\">");
		_ref = context.FootnotesDefs;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			def = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			r.BaseRenderer.WriteString("<li data-type=\"footnotes-li\" data-marker=\"" + ($bytesToString(def.Tokens)) + "\">");
			tree = new parse.Tree.ptr("", ptrType$1.nil, context, ptrType$6.nil, ptrType$7.nil);
			tree.Context.Tree = tree;
			tree.Root = new ast.Node.ptr(0, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$3.nil, false, false, false, 0, false, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, sliceType$3.nil, 0, ptrType$4.nil, false, sliceType$5.nil, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, 0, sliceType$3.nil, 0, false, sliceType$3.nil, "", 0, sliceType$3.nil, "", sliceType$6.nil, sliceType$3.nil);
			tree.Root.AppendChild(def);
			defRenderer = NewVditorRenderer(tree);
			defRenderer.needRenderFootnotesDef = true;
			_r = defRenderer.Render(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			defContent = _r;
			r.BaseRenderer.Write(defContent);
			r.BaseRenderer.WriteString("</li>");
			_i++;
		/* } */ $s = 1; continue; case 2:
		r.BaseRenderer.WriteString("</ol></div>");
		$s = -1; return r.BaseRenderer.Writer.Bytes();
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.RenderFootnotesDefs }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.context = context; $f.def = def; $f.defContent = defContent; $f.defRenderer = defRenderer; $f.r = r; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.RenderFootnotesDefs = function(context) { return this.$val.RenderFootnotesDefs(context); };
	VditorRenderer.ptr.prototype.renderHtmlEntity = function(node, entering) {
		var _r, entering, node, previewTokens, previousNodeText, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; entering = $f.entering; node = $f.node; previewTokens = $f.previewTokens; previousNodeText = $f.previousNodeText; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = node.PreviousNodeText(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		previousNodeText = _r;
		previousNodeText = strings.ReplaceAll(previousNodeText, "\xE2\x80\xB8", "");
		if ("" === previousNodeText) {
			r.BaseRenderer.WriteString("\xE2\x80\x8B");
		}
		r.BaseRenderer.WriteString("<span class=\"vditor-wysiwyg__block\" data-type=\"html-entity\">");
		r.tag("code", new sliceType$7([new sliceType(["data-type", "html-entity"])]), false);
		tokens = $appendSlice((new sliceType$3($stringToBytes("\xE2\x80\x8B"))), node.Tokens);
		r.BaseRenderer.Write(util.EscapeHTML(util.EscapeHTML(tokens)));
		r.BaseRenderer.WriteString("</code>");
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-wysiwyg__preview"]), new sliceType(["data-render", "2"])]), false);
		r.tag("code", sliceType$7.nil, false);
		previewTokens = bytes.ReplaceAll(node.HtmlEntityTokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
		r.BaseRenderer.Write(util.UnescapeHTML(previewTokens));
		r.tag("/code", sliceType$7.nil, false);
		r.tag("/span", sliceType$7.nil, false);
		r.BaseRenderer.WriteString("</span>\xE2\x80\x8B");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderHtmlEntity }; } $f._r = _r; $f.entering = entering; $f.node = node; $f.previewTokens = previewTokens; $f.previousNodeText = previousNodeText; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderHtmlEntity = function(node, entering) { return this.$val.renderHtmlEntity(node, entering); };
	VditorRenderer.ptr.prototype.renderBackslashContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	VditorRenderer.prototype.renderBackslashContent = function(node, entering) { return this.$val.renderBackslashContent(node, entering); };
	VditorRenderer.ptr.prototype.renderBackslash = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.WriteString("<span data-type=\"backslash\">");
			r.BaseRenderer.WriteString("<span>");
			r.BaseRenderer.WriteByte(92);
			r.BaseRenderer.WriteString("</span>");
		} else {
			r.BaseRenderer.WriteString("</span>");
		}
		return 2;
	};
	VditorRenderer.prototype.renderBackslash = function(node, entering) { return this.$val.renderBackslash(node, entering); };
	VditorRenderer.ptr.prototype.renderToC = function(node, entering) {
		var _i, _r, _ref, caretInDest, entering, heading, headings, length, node, r, spaces, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; caretInDest = $f.caretInDest; entering = $f.entering; heading = $f.heading; headings = $f.headings; length = $f.length; node = $f.node; r = $f.r; spaces = $f.spaces; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		headings = r.BaseRenderer.headings();
		length = headings.$length;
		r.BaseRenderer.WriteString("<div class=\"vditor-toc\" data-block=\"0\" data-type=\"toc-block\" contenteditable=\"false\">");
		/* */ if (0 < length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (0 < length) { */ case 1:
			_ref = headings;
			_i = 0;
			/* while (true) { */ case 4:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
				heading = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				spaces = $imul(((heading.HeadingLevel - 1 >> 0)), 2);
				r.BaseRenderer.WriteString(strings.Repeat("&emsp;", spaces));
				r.BaseRenderer.WriteString("<span data-type=\"toc-h\">");
				_r = heading.Text(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = r.BaseRenderer.WriteString(_r + "</span><br>"); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_i++;
			/* } */ $s = 4; continue; case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			r.BaseRenderer.WriteString("[toc]<br>");
		/* } */ case 3:
		r.BaseRenderer.WriteString("</div>");
		caretInDest = bytes.Contains(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))));
		r.BaseRenderer.WriteString("<p data-block=\"0\">");
		if (caretInDest) {
			r.BaseRenderer.WriteString("\xE2\x80\xB8");
		}
		r.BaseRenderer.WriteString("</p>");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderToC }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.caretInDest = caretInDest; $f.entering = entering; $f.heading = heading; $f.headings = headings; $f.length = length; $f.node = node; $f.r = r; $f.spaces = spaces; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderToC = function(node, entering) { return this.$val.renderToC(node, entering); };
	VditorRenderer.ptr.prototype.renderFootnotesDef = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!r.needRenderFootnotesDef) {
			return 0;
		}
		return 2;
	};
	VditorRenderer.prototype.renderFootnotesDef = function(node, entering) { return this.$val.renderFootnotesDef(node, entering); };
	VditorRenderer.ptr.prototype.renderFootnotesRef = function(node, entering) {
		var _r, _tuple, entering, idx, idxStr, node, previousNodeText, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; entering = $f.entering; idx = $f.idx; idxStr = $f.idxStr; node = $f.node; previousNodeText = $f.previousNodeText; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = node.PreviousNodeText(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		previousNodeText = _r;
		previousNodeText = strings.ReplaceAll(previousNodeText, "\xE2\x80\xB8", "");
		if ("" === previousNodeText) {
			r.BaseRenderer.WriteString("\xE2\x80\x8B");
		}
		_tuple = r.BaseRenderer.Tree.Context.FindFootnotesDef(node.Tokens);
		idx = _tuple[0];
		idxStr = strconv.Itoa(idx);
		r.tag("sup", new sliceType$7([new sliceType(["data-type", "footnotes-ref"]), new sliceType(["data-footnotes-label", ($bytesToString(node.FootnotesRefLabel))])]), false);
		r.BaseRenderer.WriteString(idxStr);
		r.BaseRenderer.WriteString("</sup>\xE2\x80\x8B");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderFootnotesRef }; } $f._r = _r; $f._tuple = _tuple; $f.entering = entering; $f.idx = idx; $f.idxStr = idxStr; $f.node = node; $f.previousNodeText = previousNodeText; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderFootnotesRef = function(node, entering) { return this.$val.renderFootnotesRef(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderCodeBlockCloseMarker = function(node, entering) { return this.$val.renderCodeBlockCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeBlockInfoMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderCodeBlockInfoMarker = function(node, entering) { return this.$val.renderCodeBlockInfoMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderCodeBlockOpenMarker = function(node, entering) { return this.$val.renderCodeBlockOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmojiAlias = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderEmojiAlias = function(node, entering) { return this.$val.renderEmojiAlias(node, entering); };
	VditorRenderer.ptr.prototype.renderEmojiImg = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	VditorRenderer.prototype.renderEmojiImg = function(node, entering) { return this.$val.renderEmojiImg(node, entering); };
	VditorRenderer.ptr.prototype.renderEmojiUnicode = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	VditorRenderer.prototype.renderEmojiUnicode = function(node, entering) { return this.$val.renderEmojiUnicode(node, entering); };
	VditorRenderer.ptr.prototype.renderEmoji = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	VditorRenderer.prototype.renderEmoji = function(node, entering) { return this.$val.renderEmoji(node, entering); };
	VditorRenderer.ptr.prototype.renderInlineMathCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderInlineMathCloseMarker = function(node, entering) { return this.$val.renderInlineMathCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderInlineMathContent = function(node, entering) {
		var entering, node, previewTokens, r, tokens;
		r = this;
		r.BaseRenderer.WriteString("<span class=\"vditor-wysiwyg__block\" data-type=\"math-inline\">");
		r.tag("code", new sliceType$7([new sliceType(["data-type", "math-inline"])]), false);
		tokens = bytes.ReplaceAll(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\x8B"))), sliceType$3.nil);
		previewTokens = tokens;
		tokens = util.EscapeHTML(tokens);
		tokens = $appendSlice((new sliceType$3($stringToBytes("\xE2\x80\x8B"))), tokens);
		r.BaseRenderer.Write(tokens);
		r.BaseRenderer.WriteString("</code>");
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-wysiwyg__preview"]), new sliceType(["data-render", "2"])]), false);
		r.tag("code", new sliceType$7([new sliceType(["class", "language-math"])]), false);
		previewTokens = bytes.ReplaceAll(previewTokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
		r.BaseRenderer.Write(previewTokens);
		r.tag("/code", sliceType$7.nil, false);
		r.tag("/span", sliceType$7.nil, false);
		r.BaseRenderer.WriteString("</span>\xE2\x80\x8B");
		return 0;
	};
	VditorRenderer.prototype.renderInlineMathContent = function(node, entering) { return this.$val.renderInlineMathContent(node, entering); };
	VditorRenderer.ptr.prototype.renderInlineMathOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderInlineMathOpenMarker = function(node, entering) { return this.$val.renderInlineMathOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderInlineMath = function(node, entering) {
		var _r, entering, node, previousNodeText, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; entering = $f.entering; node = $f.node; previousNodeText = $f.previousNodeText; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			_r = node.PreviousNodeText(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			previousNodeText = _r;
			previousNodeText = strings.ReplaceAll(previousNodeText, "\xE2\x80\xB8", "");
			if ("" === previousNodeText) {
				r.BaseRenderer.WriteString("\xE2\x80\x8B");
			}
		/* } */ case 2:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderInlineMath }; } $f._r = _r; $f.entering = entering; $f.node = node; $f.previousNodeText = previousNodeText; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderInlineMath = function(node, entering) { return this.$val.renderInlineMath(node, entering); };
	VditorRenderer.ptr.prototype.renderMathBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderMathBlockCloseMarker = function(node, entering) { return this.$val.renderMathBlockCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderMathBlockContent = function(node, entering) {
		var _r, codeIsEmpty, codeLen, entering, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; codeIsEmpty = $f.codeIsEmpty; codeLen = $f.codeLen; entering = $f.entering; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = bytes.TrimSpace(node.Tokens); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		node.Tokens = _r;
		codeLen = node.Tokens.$length;
		codeIsEmpty = 1 > codeLen || ((3 === codeLen) && "\xE2\x80\xB8" === ($bytesToString(node.Tokens)));
		r.BaseRenderer.WriteString("<pre>");
		r.tag("code", new sliceType$7([new sliceType(["data-type", "math-block"])]), false);
		if (codeIsEmpty) {
			r.BaseRenderer.WriteString("<wbr>\n");
		} else {
			r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		}
		r.BaseRenderer.WriteString("</code></pre>");
		r.tag("pre", new sliceType$7([new sliceType(["class", "vditor-wysiwyg__preview"]), new sliceType(["data-render", "2"])]), false);
		r.tag("code", new sliceType$7([new sliceType(["data-type", "math-block"]), new sliceType(["class", "language-math"])]), false);
		tokens = node.Tokens;
		tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
		r.BaseRenderer.Write(util.EscapeHTML(tokens));
		r.BaseRenderer.WriteString("</code></pre>");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderMathBlockContent }; } $f._r = _r; $f.codeIsEmpty = codeIsEmpty; $f.codeLen = codeLen; $f.entering = entering; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderMathBlockContent = function(node, entering) { return this.$val.renderMathBlockContent(node, entering); };
	VditorRenderer.ptr.prototype.renderMathBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderMathBlockOpenMarker = function(node, entering) { return this.$val.renderMathBlockOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderMathBlock = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.WriteString("<div class=\"vditor-wysiwyg__block\" data-type=\"math-block\" data-block=\"0\">");
		} else {
			r.BaseRenderer.WriteString("</div>");
		}
		return 2;
	};
	VditorRenderer.prototype.renderMathBlock = function(node, entering) { return this.$val.renderMathBlock(node, entering); };
	VditorRenderer.ptr.prototype.renderTableCell = function(node, entering) {
		var _1, _r, attrs, entering, node, r, tag, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; attrs = $f.attrs; entering = $f.entering; node = $f.node; r = $f.r; tag = $f.tag; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		tag = "td";
		if (107 === node.Parent.Parent.Type) {
			tag = "th";
		}
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			attrs = sliceType$7.nil;
			_1 = node.TableCellAlign;
			if (_1 === (1)) {
				attrs = $append(attrs, new sliceType(["align", "left"]));
			} else if (_1 === (2)) {
				attrs = $append(attrs, new sliceType(["align", "center"]));
			} else if (_1 === (3)) {
				attrs = $append(attrs, new sliceType(["align", "right"]));
			}
			r.tag(tag, attrs, false);
			/* */ if (ptrType$1.nil === node.FirstChild) { $s = 4; continue; }
			/* */ if (bytes.Equal(node.FirstChild.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))))) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (ptrType$1.nil === node.FirstChild) { */ case 4:
				node.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$3($stringToBytes(" "))), false, false, false, 0, false, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, sliceType$3.nil, 0, ptrType$4.nil, false, sliceType$5.nil, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, 0, sliceType$3.nil, 0, false, sliceType$3.nil, "", 0, sliceType$3.nil, "", sliceType$6.nil, sliceType$3.nil));
				$s = 7; continue;
			/* } else if (bytes.Equal(node.FirstChild.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))))) { */ case 5:
				node.FirstChild.Tokens = (new sliceType$3($stringToBytes("\xE2\x80\xB8 ")));
				$s = 7; continue;
			/* } else { */ case 6:
				_r = bytes.TrimSpace(node.FirstChild.Tokens); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				node.FirstChild.Tokens = _r;
			/* } */ case 7:
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/" + tag, sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderTableCell }; } $f._1 = _1; $f._r = _r; $f.attrs = attrs; $f.entering = entering; $f.node = node; $f.r = r; $f.tag = tag; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderTableCell = function(node, entering) { return this.$val.renderTableCell(node, entering); };
	VditorRenderer.ptr.prototype.renderTableRow = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("tr", sliceType$7.nil, false);
		} else {
			r.tag("/tr", sliceType$7.nil, false);
		}
		return 2;
	};
	VditorRenderer.prototype.renderTableRow = function(node, entering) { return this.$val.renderTableRow(node, entering); };
	VditorRenderer.ptr.prototype.renderTableHead = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("thead", sliceType$7.nil, false);
		} else {
			r.tag("/thead", sliceType$7.nil, false);
			if (!(ptrType$1.nil === node.Next)) {
				r.tag("tbody", sliceType$7.nil, false);
			}
		}
		return 2;
	};
	VditorRenderer.prototype.renderTableHead = function(node, entering) { return this.$val.renderTableHead(node, entering); };
	VditorRenderer.ptr.prototype.renderTable = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("table", new sliceType$7([new sliceType(["data-block", "0"])]), false);
		} else {
			if (!(ptrType$1.nil === node.FirstChild.Next)) {
				r.tag("/tbody", sliceType$7.nil, false);
			}
			r.tag("/table", sliceType$7.nil, false);
		}
		return 2;
	};
	VditorRenderer.prototype.renderTable = function(node, entering) { return this.$val.renderTable(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	VditorRenderer.prototype.renderStrikethrough = function(node, entering) { return this.$val.renderStrikethrough(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough1OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("s", new sliceType$7([new sliceType(["data-marker", "~"])]), false);
		return 0;
	};
	VditorRenderer.prototype.renderStrikethrough1OpenMarker = function(node, entering) { return this.$val.renderStrikethrough1OpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough1CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/s", sliceType$7.nil, false);
		return 0;
	};
	VditorRenderer.prototype.renderStrikethrough1CloseMarker = function(node, entering) { return this.$val.renderStrikethrough1CloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough2OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("s", new sliceType$7([new sliceType(["data-marker", "~~"])]), false);
		return 0;
	};
	VditorRenderer.prototype.renderStrikethrough2OpenMarker = function(node, entering) { return this.$val.renderStrikethrough2OpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrikethrough2CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/s", sliceType$7.nil, false);
		return 0;
	};
	VditorRenderer.prototype.renderStrikethrough2CloseMarker = function(node, entering) { return this.$val.renderStrikethrough2CloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderLinkTitle = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderLinkTitle = function(node, entering) { return this.$val.renderLinkTitle(node, entering); };
	VditorRenderer.ptr.prototype.renderLinkDest = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderLinkDest = function(node, entering) { return this.$val.renderLinkDest(node, entering); };
	VditorRenderer.ptr.prototype.renderLinkSpace = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderLinkSpace = function(node, entering) { return this.$val.renderLinkSpace(node, entering); };
	VditorRenderer.ptr.prototype.renderLinkText = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	VditorRenderer.prototype.renderLinkText = function(node, entering) { return this.$val.renderLinkText(node, entering); };
	VditorRenderer.ptr.prototype.renderCloseParen = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderCloseParen = function(node, entering) { return this.$val.renderCloseParen(node, entering); };
	VditorRenderer.ptr.prototype.renderOpenParen = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderOpenParen = function(node, entering) { return this.$val.renderOpenParen(node, entering); };
	VditorRenderer.ptr.prototype.renderCloseBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderCloseBracket = function(node, entering) { return this.$val.renderCloseBracket(node, entering); };
	VditorRenderer.ptr.prototype.renderOpenBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderOpenBracket = function(node, entering) { return this.$val.renderOpenBracket(node, entering); };
	VditorRenderer.ptr.prototype.renderBang = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderBang = function(node, entering) { return this.$val.renderBang(node, entering); };
	VditorRenderer.ptr.prototype.renderImage = function(node, entering) {
		var _r, alt, buf, destTokens, entering, idx, imgBuf, node, r, title, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; alt = $f.alt; buf = $f.buf; destTokens = $f.destTokens; entering = $f.entering; idx = $f.idx; imgBuf = $f.imgBuf; node = $f.node; r = $f.r; title = $f.title; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (entering) {
			if (0 === r.BaseRenderer.DisableTags) {
				r.BaseRenderer.WriteString("<img src=\"");
				destTokens = node.ChildByType(41).Tokens;
				destTokens = r.BaseRenderer.Tree.Context.RelativePath(destTokens);
				destTokens = bytes.ReplaceAll(destTokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
				r.BaseRenderer.Write(destTokens);
				r.BaseRenderer.WriteString("\" alt=\"");
				alt = node.ChildByType(40);
				if (!(ptrType$1.nil === alt) && bytes.Contains(alt.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))))) {
					alt.Tokens = bytes.ReplaceAll(alt.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
				}
			}
			r.BaseRenderer.DisableTags = r.BaseRenderer.DisableTags + (1) >> 0;
			$s = -1; return 2;
		}
		r.BaseRenderer.DisableTags = r.BaseRenderer.DisableTags - (1) >> 0;
		/* */ if (0 === r.BaseRenderer.DisableTags) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (0 === r.BaseRenderer.DisableTags) { */ case 1:
			r.BaseRenderer.WriteString("\"");
			title = node.ChildByType(42);
			if (!(ptrType$1.nil === title) && !(sliceType$3.nil === title.Tokens)) {
				r.BaseRenderer.WriteString(" title=\"");
				title.Tokens = bytes.ReplaceAll(title.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
				r.BaseRenderer.Write(title.Tokens);
				r.BaseRenderer.WriteString("\"");
			}
			r.BaseRenderer.WriteString(" />");
			buf = r.BaseRenderer.Writer.Bytes();
			idx = bytes.LastIndex(buf, (new sliceType$3($stringToBytes("<img src="))));
			imgBuf = $subslice(buf, idx);
			/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (r.BaseRenderer.Option.Sanitize) { */ case 3:
				_r = sanitize(imgBuf); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				imgBuf = _r;
			/* } */ case 4:
			r.BaseRenderer.Writer.Truncate(idx);
			r.BaseRenderer.Writer.Write(imgBuf);
		/* } */ case 2:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderImage }; } $f._r = _r; $f.alt = alt; $f.buf = buf; $f.destTokens = destTokens; $f.entering = entering; $f.idx = idx; $f.imgBuf = imgBuf; $f.node = node; $f.r = r; $f.title = title; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderImage = function(node, entering) { return this.$val.renderImage(node, entering); };
	VditorRenderer.ptr.prototype.renderLink = function(node, entering) {
		var _r, attrs, attrs$1, caretInDest, dest, destTokens, entering, label, node, previousNodeText, r, text$1, text$2, title, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; attrs = $f.attrs; attrs$1 = $f.attrs$1; caretInDest = $f.caretInDest; dest = $f.dest; destTokens = $f.destTokens; entering = $f.entering; label = $f.label; node = $f.node; previousNodeText = $f.previousNodeText; r = $f.r; text$1 = $f.text$1; text$2 = $f.text$2; title = $f.title; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			/* */ if (3 === node.LinkType) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if (3 === node.LinkType) { */ case 4:
				_r = node.PreviousNodeText(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				previousNodeText = _r;
				previousNodeText = strings.ReplaceAll(previousNodeText, "\xE2\x80\xB8", "");
				if ("" === previousNodeText) {
					r.BaseRenderer.WriteString("\xE2\x80\x8B");
				}
				text$1 = ($bytesToString(node.ChildByType(40).Tokens));
				label = ($bytesToString(node.LinkRefLabel));
				attrs = new sliceType$7([new sliceType(["data-type", "link-ref"]), new sliceType(["data-link-label", label])]);
				r.tag("span", attrs, false);
				r.BaseRenderer.WriteString(text$1);
				r.tag("/span", sliceType$7.nil, false);
				r.BaseRenderer.WriteString("\xE2\x80\x8B");
				$s = -1; return 0;
			/* } */ case 5:
			dest = node.ChildByType(41);
			destTokens = dest.Tokens;
			destTokens = r.BaseRenderer.Tree.Context.RelativePath(destTokens);
			caretInDest = bytes.Contains(destTokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))));
			if (caretInDest) {
				text$2 = node.ChildByType(40);
				text$2.Tokens = $appendSlice(text$2.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))));
				destTokens = bytes.ReplaceAll(destTokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
			}
			attrs$1 = new sliceType$7([new sliceType(["href", ($bytesToString(destTokens))])]);
			title = node.ChildByType(42);
			if (!(ptrType$1.nil === title) && !(sliceType$3.nil === title.Tokens)) {
				title.Tokens = bytes.ReplaceAll(title.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
				attrs$1 = $append(attrs$1, new sliceType(["title", ($bytesToString(title.Tokens))]));
			}
			r.tag("a", attrs$1, false);
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/a", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderLink }; } $f._r = _r; $f.attrs = attrs; $f.attrs$1 = attrs$1; $f.caretInDest = caretInDest; $f.dest = dest; $f.destTokens = destTokens; $f.entering = entering; $f.label = label; $f.node = node; $f.previousNodeText = previousNodeText; $f.r = r; $f.text$1 = text$1; $f.text$2 = text$2; $f.title = title; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderLink = function(node, entering) { return this.$val.renderLink(node, entering); };
	VditorRenderer.ptr.prototype.renderHTML = function(node, entering) {
		var _r, _r$1, entering, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; entering = $f.entering; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.BaseRenderer.WriteString("<div class=\"vditor-wysiwyg__block\" data-type=\"html-block\" data-block=\"0\">");
		_r = bytes.TrimSpace(node.Tokens); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tokens = _r;
		/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (r.BaseRenderer.Option.Sanitize) { */ case 2:
			_r$1 = sanitize(tokens); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			tokens = _r$1;
		/* } */ case 3:
		r.BaseRenderer.WriteString("<pre>");
		r.tag("code", sliceType$7.nil, false);
		r.BaseRenderer.Write(util.EscapeHTML(tokens));
		r.BaseRenderer.WriteString("</code></pre>");
		r.tag("pre", new sliceType$7([new sliceType(["class", "vditor-wysiwyg__preview"]), new sliceType(["data-render", "2"])]), false);
		tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
		r.BaseRenderer.Write(tokens);
		r.BaseRenderer.WriteString("</pre>");
		r.BaseRenderer.WriteString("</div>");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderHTML }; } $f._r = _r; $f._r$1 = _r$1; $f.entering = entering; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderHTML = function(node, entering) { return this.$val.renderHTML(node, entering); };
	VditorRenderer.ptr.prototype.renderInlineHTML = function(node, entering) {
		var _r, _r$1, _r$2, entering, node, previousNodeText, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; entering = $f.entering; node = $f.node; previousNodeText = $f.previousNodeText; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (bytes.Equal(node.Tokens, (new sliceType$3($stringToBytes("<br />")))) && node.ParentIs(109, new sliceType$4([]))) {
			r.BaseRenderer.Write(node.Tokens);
			$s = -1; return 0;
		}
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			_r = node.PreviousNodeText(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			previousNodeText = _r;
			previousNodeText = strings.ReplaceAll(previousNodeText, "\xE2\x80\xB8", "");
			if ("" === previousNodeText) {
				r.BaseRenderer.WriteString("\xE2\x80\x8B");
			}
		/* } */ case 2:
		r.BaseRenderer.WriteString("<span class=\"vditor-wysiwyg__block\" data-type=\"html-inline\">");
		_r$1 = bytes.TrimSpace(node.Tokens); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		node.Tokens = _r$1;
		r.tag("code", new sliceType$7([new sliceType(["data-type", "html-inline"])]), false);
		tokens = bytes.ReplaceAll(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\x8B"))), sliceType$3.nil);
		/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 5; continue; }
		/* */ $s = 6; continue;
		/* if (r.BaseRenderer.Option.Sanitize) { */ case 5:
			_r$2 = sanitize(tokens); /* */ $s = 7; case 7: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			tokens = _r$2;
		/* } */ case 6:
		tokens = util.EscapeHTML(tokens);
		tokens = $appendSlice((new sliceType$3($stringToBytes("\xE2\x80\x8B"))), tokens);
		r.BaseRenderer.Write(tokens);
		r.BaseRenderer.WriteString("</code>");
		r.BaseRenderer.WriteString("</span>\xE2\x80\x8B");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderInlineHTML }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.entering = entering; $f.node = node; $f.previousNodeText = previousNodeText; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderInlineHTML = function(node, entering) { return this.$val.renderInlineHTML(node, entering); };
	VditorRenderer.ptr.prototype.renderDocument = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	VditorRenderer.prototype.renderDocument = function(node, entering) { return this.$val.renderDocument(node, entering); };
	VditorRenderer.ptr.prototype.renderParagraph = function(node, entering) {
		var entering, grandparent, node, r;
		r = this;
		grandparent = node.Parent.Parent;
		if (!(ptrType$1.nil === grandparent) && (7 === grandparent.Type) && grandparent.ListData.Tight) {
			return 2;
		}
		if (entering) {
			r.tag("p", new sliceType$7([new sliceType(["data-block", "0"])]), false);
		} else {
			r.BaseRenderer.WriteByte(10);
			r.tag("/p", sliceType$7.nil, false);
		}
		return 2;
	};
	VditorRenderer.prototype.renderParagraph = function(node, entering) { return this.$val.renderParagraph(node, entering); };
	VditorRenderer.ptr.prototype.renderText = function(node, entering) {
		var _r, entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (r.BaseRenderer.Option.AutoSpace) {
			r.BaseRenderer.Space(node);
		}
		/* */ if (r.BaseRenderer.Option.FixTermTypo) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.Option.FixTermTypo) { */ case 1:
			$r = r.BaseRenderer.FixTermTypo(node); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (r.BaseRenderer.Option.ChinesePunct) {
			r.BaseRenderer.ChinesePunct(node);
		}
		_r = bytes.TrimRight(node.Tokens, "\n"); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		node.Tokens = _r;
		if (!bytes.EqualFold(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8\xE2\x80\x8B"))))) {
			node.Tokens = bytes.ReplaceAll(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\x8B"))), sliceType$3.nil);
		}
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderText }; } $f._r = _r; $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderText = function(node, entering) { return this.$val.renderText(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeSpan = function(node, entering) {
		var _r, _tuple, entering, lastc, node, previousNodeText, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _tuple = $f._tuple; entering = $f.entering; lastc = $f.lastc; node = $f.node; previousNodeText = $f.previousNodeText; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			_r = node.PreviousNodeText(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			previousNodeText = _r;
			previousNodeText = strings.ReplaceAll(previousNodeText, "\xE2\x80\xB8", "");
			if ("" === previousNodeText) {
				r.BaseRenderer.WriteString("\xE2\x80\x8B");
			} else {
				_tuple = utf8.DecodeLastRuneInString(previousNodeText);
				lastc = _tuple[0];
				if (unicode.IsLetter(lastc) || unicode.IsDigit(lastc)) {
					r.BaseRenderer.WriteByte(32);
				}
			}
			r.tag("code", new sliceType$7([new sliceType(["data-marker", strings.Repeat("`", node.CodeMarkerLen)])]), false);
		/* } */ case 2:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderCodeSpan }; } $f._r = _r; $f._tuple = _tuple; $f.entering = entering; $f.lastc = lastc; $f.node = node; $f.previousNodeText = previousNodeText; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderCodeSpan = function(node, entering) { return this.$val.renderCodeSpan(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeSpanOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderCodeSpanOpenMarker = function(node, entering) { return this.$val.renderCodeSpanOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeSpanContent = function(node, entering) {
		var entering, node, r, tokens;
		r = this;
		tokens = bytes.ReplaceAll(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\x8B"))), sliceType$3.nil);
		tokens = util.EscapeHTML(tokens);
		tokens = $appendSlice((new sliceType$3($stringToBytes("\xE2\x80\x8B"))), tokens);
		r.BaseRenderer.Write(tokens);
		return 0;
	};
	VditorRenderer.prototype.renderCodeSpanContent = function(node, entering) { return this.$val.renderCodeSpanContent(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeSpanCloseMarker = function(node, entering) {
		var codeSpan, codeSpanParent, entering, node, r;
		r = this;
		r.BaseRenderer.WriteString("</code>");
		codeSpan = node.Parent;
		codeSpanParent = codeSpan.Parent;
		if (!(ptrType$1.nil === codeSpanParent) && (33 === codeSpanParent.Type)) {
			return 0;
		}
		r.BaseRenderer.WriteString("\xE2\x80\x8B");
		return 0;
	};
	VditorRenderer.prototype.renderCodeSpanCloseMarker = function(node, entering) { return this.$val.renderCodeSpanCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmphasis = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	VditorRenderer.prototype.renderEmphasis = function(node, entering) { return this.$val.renderEmphasis(node, entering); };
	VditorRenderer.ptr.prototype.renderEmAsteriskOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("em", new sliceType$7([new sliceType(["data-marker", "*"])]), false);
		return 0;
	};
	VditorRenderer.prototype.renderEmAsteriskOpenMarker = function(node, entering) { return this.$val.renderEmAsteriskOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmAsteriskCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$7.nil, false);
		return 0;
	};
	VditorRenderer.prototype.renderEmAsteriskCloseMarker = function(node, entering) { return this.$val.renderEmAsteriskCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmUnderscoreOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("em", new sliceType$7([new sliceType(["data-marker", "_"])]), false);
		return 0;
	};
	VditorRenderer.prototype.renderEmUnderscoreOpenMarker = function(node, entering) { return this.$val.renderEmUnderscoreOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderEmUnderscoreCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$7.nil, false);
		return 0;
	};
	VditorRenderer.prototype.renderEmUnderscoreCloseMarker = function(node, entering) { return this.$val.renderEmUnderscoreCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrong = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	VditorRenderer.prototype.renderStrong = function(node, entering) { return this.$val.renderStrong(node, entering); };
	VditorRenderer.ptr.prototype.renderStrongA6kOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("strong", new sliceType$7([new sliceType(["data-marker", "**"])]), false);
		return 0;
	};
	VditorRenderer.prototype.renderStrongA6kOpenMarker = function(node, entering) { return this.$val.renderStrongA6kOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrongA6kCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$7.nil, false);
		return 0;
	};
	VditorRenderer.prototype.renderStrongA6kCloseMarker = function(node, entering) { return this.$val.renderStrongA6kCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrongU8eOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("strong", new sliceType$7([new sliceType(["data-marker", "__"])]), false);
		return 0;
	};
	VditorRenderer.prototype.renderStrongU8eOpenMarker = function(node, entering) { return this.$val.renderStrongU8eOpenMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderStrongU8eCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$7.nil, false);
		return 0;
	};
	VditorRenderer.prototype.renderStrongU8eCloseMarker = function(node, entering) { return this.$val.renderStrongU8eCloseMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderBlockquote = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.WriteString("<blockquote data-block=\"0\">");
		} else {
			r.BaseRenderer.WriteString("</blockquote>");
		}
		return 2;
	};
	VditorRenderer.prototype.renderBlockquote = function(node, entering) { return this.$val.renderBlockquote(node, entering); };
	VditorRenderer.ptr.prototype.renderBlockquoteMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderBlockquoteMarker = function(node, entering) { return this.$val.renderBlockquoteMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderHeading = function(node, entering) {
		var _r, _r$1, entering, id, id$1, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; entering = $f.entering; id = $f.id; id$1 = $f.id$1; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			r.BaseRenderer.WriteString("<h" + $substring(headingLevel, node.HeadingLevel, (node.HeadingLevel + 1 >> 0)) + " data-block=\"0\"");
			id = ($bytesToString(node.HeadingID));
			if (r.BaseRenderer.Option.HeadingID && !("" === id)) {
				r.BaseRenderer.WriteString(" data-id=\"" + id + "\"");
			}
			/* */ if ("" === id) { $s = 4; continue; }
			/* */ $s = 5; continue;
			/* if ("" === id) { */ case 4:
				_r = HeadingID(node); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				id = _r;
			/* } */ case 5:
			r.BaseRenderer.WriteString(" id=\"wysiwyg-" + id + "\"");
			if (!node.HeadingSetext) {
				r.BaseRenderer.WriteString(" data-marker=\"#\">");
			} else {
				if (1 === node.HeadingLevel) {
					r.BaseRenderer.WriteString(" data-marker=\"=\">");
				} else {
					r.BaseRenderer.WriteString(" data-marker=\"-\">");
				}
			}
			/* */ if (r.BaseRenderer.Option.HeadingAnchor) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if (r.BaseRenderer.Option.HeadingAnchor) { */ case 7:
				_r$1 = HeadingID(node); /* */ $s = 9; case 9: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				id$1 = _r$1;
				r.tag("a", new sliceType$7([new sliceType(["id", "vditorAnchor-" + id$1]), new sliceType(["class", "vditor-anchor"]), new sliceType(["href", "#" + id$1])]), false);
				r.BaseRenderer.WriteString("<svg viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>");
				r.tag("/a", sliceType$7.nil, false);
			/* } */ case 8:
			$s = 3; continue;
		/* } else { */ case 2:
			r.BaseRenderer.WriteString("</h" + $substring(headingLevel, node.HeadingLevel, (node.HeadingLevel + 1 >> 0)) + ">");
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderHeading }; } $f._r = _r; $f._r$1 = _r$1; $f.entering = entering; $f.id = id; $f.id$1 = id$1; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderHeading = function(node, entering) { return this.$val.renderHeading(node, entering); };
	VditorRenderer.ptr.prototype.renderHeadingC8hMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorRenderer.prototype.renderHeadingC8hMarker = function(node, entering) { return this.$val.renderHeadingC8hMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderList = function(node, entering) {
		var _1, attrs, entering, node, r, tag;
		r = this;
		tag = "ul";
		if ((1 === node.ListData.Typ) || ((3 === node.ListData.Typ) && (0 === node.ListData.BulletChar))) {
			tag = "ol";
		}
		if (entering) {
			attrs = sliceType$7.nil;
			if (node.ListData.Tight) {
				attrs = $append(attrs, new sliceType(["data-tight", "true"]));
			}
			if (0 === node.ListData.BulletChar) {
				if (!((1 === node.ListData.Start))) {
					attrs = $append(attrs, new sliceType(["start", strconv.Itoa(node.ListData.Start)]));
				}
			}
			_1 = node.ListData.Typ;
			if (_1 === (0)) {
				attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
			} else if (_1 === (1)) {
				attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
			} else if (_1 === (3)) {
				if (0 === node.ListData.BulletChar) {
					attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
				} else {
					attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
				}
			}
			attrs = $append(attrs, new sliceType(["data-block", "0"]));
			r.tag(tag, attrs, false);
		} else {
			r.tag("/" + tag, sliceType$7.nil, false);
		}
		return 2;
	};
	VditorRenderer.prototype.renderList = function(node, entering) { return this.$val.renderList(node, entering); };
	VditorRenderer.ptr.prototype.renderListItem = function(node, entering) {
		var _1, attrs, entering, node, r;
		r = this;
		if (entering) {
			attrs = sliceType$7.nil;
			_1 = node.ListData.Typ;
			if (_1 === (0)) {
				attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
			} else if (_1 === (1)) {
				attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
			} else if (_1 === (3)) {
				if (0 === node.ListData.BulletChar) {
					attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
				} else {
					attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
				}
				if (!(ptrType$1.nil === node.FirstChild) && !(ptrType$1.nil === node.FirstChild.FirstChild) && (100 === node.FirstChild.FirstChild.Type)) {
					attrs = $append(attrs, new sliceType(["class", r.BaseRenderer.Option.GFMTaskListItemClass]));
				}
			}
			r.tag("li", attrs, false);
			if (ptrType$1.nil === node.FirstChild) {
				r.BaseRenderer.WriteString("\xE2\x80\x8B");
			}
		} else {
			r.tag("/li", sliceType$7.nil, false);
		}
		return 2;
	};
	VditorRenderer.prototype.renderListItem = function(node, entering) { return this.$val.renderListItem(node, entering); };
	VditorRenderer.ptr.prototype.renderTaskListItemMarker = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		attrs = sliceType$7.nil;
		if (node.TaskListItemChecked) {
			attrs = $append(attrs, new sliceType(["checked", ""]));
		}
		attrs = $append(attrs, new sliceType(["type", "checkbox"]));
		r.tag("input", attrs, true);
		return 0;
	};
	VditorRenderer.prototype.renderTaskListItemMarker = function(node, entering) { return this.$val.renderTaskListItemMarker(node, entering); };
	VditorRenderer.ptr.prototype.renderThematicBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("hr", new sliceType$7([new sliceType(["data-block", "0"])]), true);
		if (!(sliceType$3.nil === node.Tokens)) {
			r.tag("p", new sliceType$7([new sliceType(["data-block", "0"])]), false);
			r.BaseRenderer.Write(node.Tokens);
			r.BaseRenderer.WriteByte(10);
			r.tag("/p", sliceType$7.nil, false);
		}
		return 0;
	};
	VditorRenderer.prototype.renderThematicBreak = function(node, entering) { return this.$val.renderThematicBreak(node, entering); };
	VditorRenderer.ptr.prototype.renderHardBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("br", sliceType$7.nil, true);
		return 0;
	};
	VditorRenderer.prototype.renderHardBreak = function(node, entering) { return this.$val.renderHardBreak(node, entering); };
	VditorRenderer.ptr.prototype.renderSoftBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(10);
		return 0;
	};
	VditorRenderer.prototype.renderSoftBreak = function(node, entering) { return this.$val.renderSoftBreak(node, entering); };
	VditorRenderer.ptr.prototype.tag = function(name, attrs, selfclosing) {
		var _i, _ref, attr, attrs, name, r, selfclosing;
		r = this;
		if (r.BaseRenderer.DisableTags > 0) {
			return;
		}
		r.BaseRenderer.WriteString("<");
		r.BaseRenderer.WriteString(name);
		if (0 < attrs.$length) {
			_ref = attrs;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				attr = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				r.BaseRenderer.WriteString(" " + (0 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 0]) + "=\"" + (1 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 1]) + "\"");
				_i++;
			}
		}
		if (selfclosing) {
			r.BaseRenderer.WriteString(" /");
		}
		r.BaseRenderer.WriteString(">");
	};
	VditorRenderer.prototype.tag = function(name, attrs, selfclosing) { return this.$val.tag(name, attrs, selfclosing); };
	VditorRenderer.ptr.prototype.renderCodeBlock = function(node, entering) {
		var entering, marker, node, r;
		r = this;
		if (entering) {
			marker = "```";
			if (!(ptrType$1.nil === node.FirstChild)) {
				marker = ($bytesToString(node.FirstChild.Tokens));
			}
			r.BaseRenderer.WriteString("<div class=\"vditor-wysiwyg__block\" data-type=\"code-block\" data-block=\"0\" data-marker=\"" + marker + "\">");
		} else {
			r.BaseRenderer.WriteString("</div>");
		}
		return 2;
	};
	VditorRenderer.prototype.renderCodeBlock = function(node, entering) { return this.$val.renderCodeBlock(node, entering); };
	VditorRenderer.ptr.prototype.renderCodeBlockCode = function(node, entering) {
		var _r, attrs, caretInInfo, codeIsEmpty, codeLen, dataCode, entering, infoWords, isFenced, language, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; attrs = $f.attrs; caretInInfo = $f.caretInInfo; codeIsEmpty = $f.codeIsEmpty; codeLen = $f.codeLen; dataCode = $f.dataCode; entering = $f.entering; infoWords = $f.infoWords; isFenced = $f.isFenced; language = $f.language; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		codeLen = node.Tokens.$length;
		codeIsEmpty = 1 > codeLen || ((3 === codeLen) && "\xE2\x80\xB8" === ($bytesToString(node.Tokens)));
		isFenced = node.Parent.IsFencedCodeBlock;
		caretInInfo = false;
		attrs = sliceType$7.nil;
		/* */ if (isFenced && 0 < node.Previous.CodeBlockInfo.$length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (isFenced && 0 < node.Previous.CodeBlockInfo.$length) { */ case 1:
			if (bytes.Contains(node.Previous.CodeBlockInfo, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))))) {
				caretInInfo = true;
				node.Previous.CodeBlockInfo = bytes.ReplaceAll(node.Previous.CodeBlockInfo, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
			}
			/* */ if (0 < node.Previous.CodeBlockInfo.$length) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if (0 < node.Previous.CodeBlockInfo.$length) { */ case 3:
				infoWords = lex.Split(node.Previous.CodeBlockInfo, 32);
				language = ($bytesToString((0 >= infoWords.$length ? ($throwRuntimeError("index out of range"), undefined) : infoWords.$array[infoWords.$offset + 0])));
				attrs = $append(attrs, new sliceType(["class", "language-" + language]));
				/* */ if ("mindmap" === language) { $s = 5; continue; }
				/* */ $s = 6; continue;
				/* if ("mindmap" === language) { */ case 5:
					_r = r.BaseRenderer.renderMindmap(node.Tokens); /* */ $s = 7; case 7: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					dataCode = _r;
					attrs = $append(attrs, new sliceType(["data-code", ($bytesToString(dataCode))]));
				/* } */ case 6:
			/* } */ case 4:
		/* } */ case 2:
		r.tag("pre", new sliceType$7([new sliceType(["class", "vditor-wysiwyg__pre"])]), false);
		r.tag("code", attrs, false);
		if (codeIsEmpty) {
			r.BaseRenderer.WriteString("<wbr>\n");
		} else {
			if (caretInInfo) {
				r.BaseRenderer.WriteString("<wbr>");
			}
			r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
			r.BaseRenderer.Newline();
		}
		r.BaseRenderer.WriteString("</code></pre>");
		if (r.BaseRenderer.Option.VditorCodeBlockPreview) {
			r.tag("pre", new sliceType$7([new sliceType(["class", "vditor-wysiwyg__preview"]), new sliceType(["data-render", "2"])]), false);
			r.tag("code", attrs, false);
			tokens = node.Tokens;
			tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
			r.BaseRenderer.Write(util.EscapeHTML(tokens));
			r.BaseRenderer.WriteString("</code></pre>");
		}
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorRenderer.ptr.prototype.renderCodeBlockCode }; } $f._r = _r; $f.attrs = attrs; $f.caretInInfo = caretInInfo; $f.codeIsEmpty = codeIsEmpty; $f.codeLen = codeLen; $f.dataCode = dataCode; $f.entering = entering; $f.infoWords = infoWords; $f.isFenced = isFenced; $f.language = language; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorRenderer.prototype.renderCodeBlockCode = function(node, entering) { return this.$val.renderCodeBlockCode(node, entering); };
	NewVditorIRRenderer = function(tree) {
		var _key, _key$1, _key$10, _key$11, _key$12, _key$13, _key$14, _key$15, _key$16, _key$17, _key$18, _key$19, _key$2, _key$20, _key$21, _key$22, _key$23, _key$24, _key$25, _key$26, _key$27, _key$28, _key$29, _key$3, _key$30, _key$31, _key$32, _key$33, _key$34, _key$35, _key$36, _key$37, _key$38, _key$39, _key$4, _key$40, _key$41, _key$42, _key$43, _key$44, _key$45, _key$46, _key$47, _key$48, _key$49, _key$5, _key$50, _key$51, _key$52, _key$53, _key$54, _key$55, _key$56, _key$57, _key$58, _key$59, _key$6, _key$60, _key$61, _key$62, _key$63, _key$64, _key$65, _key$66, _key$67, _key$68, _key$69, _key$7, _key$70, _key$71, _key$8, _key$9, ret, tree;
		ret = new VditorIRRenderer.ptr(NewBaseRenderer(tree), false);
		_key = 0; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: $methodVal(ret, "renderDocument") };
		_key$1 = 1; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$1)] = { k: _key$1, v: $methodVal(ret, "renderParagraph") };
		_key$2 = 16; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$2)] = { k: _key$2, v: $methodVal(ret, "renderText") };
		_key$3 = 27; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$3)] = { k: _key$3, v: $methodVal(ret, "renderCodeSpan") };
		_key$4 = 28; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$4)] = { k: _key$4, v: $methodVal(ret, "renderCodeSpanOpenMarker") };
		_key$5 = 29; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$5)] = { k: _key$5, v: $methodVal(ret, "renderCodeSpanContent") };
		_key$6 = 30; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$6)] = { k: _key$6, v: $methodVal(ret, "renderCodeSpanCloseMarker") };
		_key$7 = 11; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$7)] = { k: _key$7, v: $methodVal(ret, "renderCodeBlock") };
		_key$8 = 12; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$8)] = { k: _key$8, v: $methodVal(ret, "renderCodeBlockOpenMarker") };
		_key$9 = 14; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$9)] = { k: _key$9, v: $methodVal(ret, "renderCodeBlockInfoMarker") };
		_key$10 = 15; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$10)] = { k: _key$10, v: $methodVal(ret, "renderCodeBlockCode") };
		_key$11 = 13; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$11)] = { k: _key$11, v: $methodVal(ret, "renderCodeBlockCloseMarker") };
		_key$12 = 300; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$12)] = { k: _key$12, v: $methodVal(ret, "renderMathBlock") };
		_key$13 = 301; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$13)] = { k: _key$13, v: $methodVal(ret, "renderMathBlockOpenMarker") };
		_key$14 = 302; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$14)] = { k: _key$14, v: $methodVal(ret, "renderMathBlockContent") };
		_key$15 = 303; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$15)] = { k: _key$15, v: $methodVal(ret, "renderMathBlockCloseMarker") };
		_key$16 = 304; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$16)] = { k: _key$16, v: $methodVal(ret, "renderInlineMath") };
		_key$17 = 305; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$17)] = { k: _key$17, v: $methodVal(ret, "renderInlineMathOpenMarker") };
		_key$18 = 306; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$18)] = { k: _key$18, v: $methodVal(ret, "renderInlineMathContent") };
		_key$19 = 307; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$19)] = { k: _key$19, v: $methodVal(ret, "renderInlineMathCloseMarker") };
		_key$20 = 17; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$20)] = { k: _key$20, v: $methodVal(ret, "renderEmphasis") };
		_key$21 = 18; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$21)] = { k: _key$21, v: $methodVal(ret, "renderEmAsteriskOpenMarker") };
		_key$22 = 19; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$22)] = { k: _key$22, v: $methodVal(ret, "renderEmAsteriskCloseMarker") };
		_key$23 = 20; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$23)] = { k: _key$23, v: $methodVal(ret, "renderEmUnderscoreOpenMarker") };
		_key$24 = 21; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$24)] = { k: _key$24, v: $methodVal(ret, "renderEmUnderscoreCloseMarker") };
		_key$25 = 22; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$25)] = { k: _key$25, v: $methodVal(ret, "renderStrong") };
		_key$26 = 23; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$26)] = { k: _key$26, v: $methodVal(ret, "renderStrongA6kOpenMarker") };
		_key$27 = 24; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$27)] = { k: _key$27, v: $methodVal(ret, "renderStrongA6kCloseMarker") };
		_key$28 = 25; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$28)] = { k: _key$28, v: $methodVal(ret, "renderStrongU8eOpenMarker") };
		_key$29 = 26; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$29)] = { k: _key$29, v: $methodVal(ret, "renderStrongU8eCloseMarker") };
		_key$30 = 5; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$30)] = { k: _key$30, v: $methodVal(ret, "renderBlockquote") };
		_key$31 = 6; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$31)] = { k: _key$31, v: $methodVal(ret, "renderBlockquoteMarker") };
		_key$32 = 2; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$32)] = { k: _key$32, v: $methodVal(ret, "renderHeading") };
		_key$33 = 3; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$33)] = { k: _key$33, v: $methodVal(ret, "renderHeadingC8hMarker") };
		_key$34 = 7; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$34)] = { k: _key$34, v: $methodVal(ret, "renderList") };
		_key$35 = 8; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$35)] = { k: _key$35, v: $methodVal(ret, "renderListItem") };
		_key$36 = 4; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$36)] = { k: _key$36, v: $methodVal(ret, "renderThematicBreak") };
		_key$37 = 31; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$37)] = { k: _key$37, v: $methodVal(ret, "renderHardBreak") };
		_key$38 = 32; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$38)] = { k: _key$38, v: $methodVal(ret, "renderSoftBreak") };
		_key$39 = 9; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$39)] = { k: _key$39, v: $methodVal(ret, "renderHTML") };
		_key$40 = 10; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$40)] = { k: _key$40, v: $methodVal(ret, "renderInlineHTML") };
		_key$41 = 33; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$41)] = { k: _key$41, v: $methodVal(ret, "renderLink") };
		_key$42 = 34; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$42)] = { k: _key$42, v: $methodVal(ret, "renderImage") };
		_key$43 = 35; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$43)] = { k: _key$43, v: $methodVal(ret, "renderBang") };
		_key$44 = 36; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$44)] = { k: _key$44, v: $methodVal(ret, "renderOpenBracket") };
		_key$45 = 37; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$45)] = { k: _key$45, v: $methodVal(ret, "renderCloseBracket") };
		_key$46 = 38; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$46)] = { k: _key$46, v: $methodVal(ret, "renderOpenParen") };
		_key$47 = 39; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$47)] = { k: _key$47, v: $methodVal(ret, "renderCloseParen") };
		_key$48 = 40; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$48)] = { k: _key$48, v: $methodVal(ret, "renderLinkText") };
		_key$49 = 43; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$49)] = { k: _key$49, v: $methodVal(ret, "renderLinkSpace") };
		_key$50 = 41; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$50)] = { k: _key$50, v: $methodVal(ret, "renderLinkDest") };
		_key$51 = 42; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$51)] = { k: _key$51, v: $methodVal(ret, "renderLinkTitle") };
		_key$52 = 101; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$52)] = { k: _key$52, v: $methodVal(ret, "renderStrikethrough") };
		_key$53 = 102; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$53)] = { k: _key$53, v: $methodVal(ret, "renderStrikethrough1OpenMarker") };
		_key$54 = 103; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$54)] = { k: _key$54, v: $methodVal(ret, "renderStrikethrough1CloseMarker") };
		_key$55 = 104; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$55)] = { k: _key$55, v: $methodVal(ret, "renderStrikethrough2OpenMarker") };
		_key$56 = 105; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$56)] = { k: _key$56, v: $methodVal(ret, "renderStrikethrough2CloseMarker") };
		_key$57 = 100; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$57)] = { k: _key$57, v: $methodVal(ret, "renderTaskListItemMarker") };
		_key$58 = 106; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$58)] = { k: _key$58, v: $methodVal(ret, "renderTable") };
		_key$59 = 107; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$59)] = { k: _key$59, v: $methodVal(ret, "renderTableHead") };
		_key$60 = 108; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$60)] = { k: _key$60, v: $methodVal(ret, "renderTableRow") };
		_key$61 = 109; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$61)] = { k: _key$61, v: $methodVal(ret, "renderTableCell") };
		_key$62 = 200; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$62)] = { k: _key$62, v: $methodVal(ret, "renderEmoji") };
		_key$63 = 201; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$63)] = { k: _key$63, v: $methodVal(ret, "renderEmojiUnicode") };
		_key$64 = 202; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$64)] = { k: _key$64, v: $methodVal(ret, "renderEmojiImg") };
		_key$65 = 203; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$65)] = { k: _key$65, v: $methodVal(ret, "renderEmojiAlias") };
		_key$66 = 500; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$66)] = { k: _key$66, v: $methodVal(ret, "renderFootnotesDef") };
		_key$67 = 501; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$67)] = { k: _key$67, v: $methodVal(ret, "renderFootnotesRef") };
		_key$68 = 600; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$68)] = { k: _key$68, v: $methodVal(ret, "renderToC") };
		_key$69 = 400; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$69)] = { k: _key$69, v: $methodVal(ret, "renderBackslash") };
		_key$70 = 401; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$70)] = { k: _key$70, v: $methodVal(ret, "renderBackslashContent") };
		_key$71 = 44; (ret.BaseRenderer.RendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key$71)] = { k: _key$71, v: $methodVal(ret, "renderHtmlEntity") };
		return ret;
	};
	$pkg.NewVditorIRRenderer = NewVditorIRRenderer;
	VditorIRRenderer.ptr.prototype.Render = function() {
		var _entry, _i, _keys, _r, _ref, dest, destStr, label, node, output, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _keys = $f._keys; _r = $f._r; _ref = $f._ref; dest = $f.dest; destStr = $f.destStr; label = $f.label; node = $f.node; output = $f.output; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		output = sliceType$3.nil;
		r = this;
		_r = r.BaseRenderer.Render(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		output = _r;
		if (1 > $keys(r.BaseRenderer.Tree.Context.LinkRefDefs).length || r.needRenderFootnotesDef) {
			$s = -1; return output;
		}
		r.BaseRenderer.WriteString("<div data-block=\"0\" data-type=\"link-ref-defs-block\">");
		_ref = r.BaseRenderer.Tree.Context.LinkRefDefs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			node = _entry.v;
			label = node.LinkRefLabel;
			dest = node.ChildByType(41).Tokens;
			destStr = ($bytesToString(dest));
			r.BaseRenderer.WriteString("[" + ($bytesToString(label)) + "]:");
			if (!("\xE2\x80\xB8" === destStr)) {
				r.BaseRenderer.WriteString(" ");
			}
			r.BaseRenderer.WriteString(destStr + "\n");
			_i++;
		}
		r.BaseRenderer.WriteString("</div>");
		output = r.BaseRenderer.Writer.Bytes();
		$s = -1; return output;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.Render }; } $f._entry = _entry; $f._i = _i; $f._keys = _keys; $f._r = _r; $f._ref = _ref; $f.dest = dest; $f.destStr = destStr; $f.label = label; $f.node = node; $f.output = output; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.Render = function() { return this.$val.Render(); };
	VditorIRRenderer.ptr.prototype.RenderFootnotesDefs = function(context) {
		var _i, _r, _ref, context, def, defContent, defRenderer, r, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; context = $f.context; def = $f.def; defContent = $f.defContent; defRenderer = $f.defRenderer; r = $f.r; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		r.BaseRenderer.WriteString("<div data-block=\"0\" data-type=\"footnotes-block\">");
		_ref = context.FootnotesDefs;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			def = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			r.BaseRenderer.WriteString("<div data-type=\"footnotes-def\">");
			tree = new parse.Tree.ptr("", ptrType$1.nil, context, ptrType$6.nil, ptrType$7.nil);
			tree.Context.Tree = tree;
			tree.Root = new ast.Node.ptr(0, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$3.nil, false, false, false, 0, false, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, sliceType$3.nil, 0, ptrType$4.nil, false, sliceType$5.nil, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, 0, sliceType$3.nil, 0, false, sliceType$3.nil, "", 0, sliceType$3.nil, "", sliceType$6.nil, sliceType$3.nil);
			tree.Root.AppendChild(def);
			defRenderer = NewVditorIRRenderer(tree);
			def.FirstChild.PrependChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$3($stringToBytes("[" + ($bytesToString(def.Tokens)) + "]: "))), false, false, false, 0, false, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, sliceType$3.nil, 0, ptrType$4.nil, false, sliceType$5.nil, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, 0, sliceType$3.nil, 0, false, sliceType$3.nil, "", 0, sliceType$3.nil, "", sliceType$6.nil, sliceType$3.nil));
			defRenderer.needRenderFootnotesDef = true;
			_r = defRenderer.Render(); /* */ $s = 3; case 3: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			defContent = _r;
			r.BaseRenderer.Write(defContent);
			r.BaseRenderer.WriteString("</div>");
			_i++;
		/* } */ $s = 1; continue; case 2:
		r.BaseRenderer.WriteString("</div>");
		$s = -1; return r.BaseRenderer.Writer.Bytes();
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.RenderFootnotesDefs }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.context = context; $f.def = def; $f.defContent = defContent; $f.defRenderer = defRenderer; $f.r = r; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.RenderFootnotesDefs = function(context) { return this.$val.RenderFootnotesDefs(context); };
	VditorIRRenderer.ptr.prototype.renderHtmlEntity = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			$r = r.renderSpanNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			r.tag("code", new sliceType$7([new sliceType(["data-newline", "1"]), new sliceType(["class", "vditor-ir__marker vditor-ir__marker--pre"]), new sliceType(["data-type", "html-entity"])]), false);
			r.BaseRenderer.Write(util.EscapeHTML(util.EscapeHTML(node.Tokens)));
			r.tag("/code", sliceType$7.nil, false);
			r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__preview"]), new sliceType(["data-render", "2"])]), false);
			r.tag("code", sliceType$7.nil, false);
			r.BaseRenderer.Write(util.UnescapeHTML(node.HtmlEntityTokens));
			r.tag("/code", sliceType$7.nil, false);
			r.tag("/span", sliceType$7.nil, false);
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/span", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderHtmlEntity }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderHtmlEntity = function(node, entering) { return this.$val.renderHtmlEntity(node, entering); };
	VditorIRRenderer.ptr.prototype.renderBackslashContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	VditorIRRenderer.prototype.renderBackslashContent = function(node, entering) { return this.$val.renderBackslashContent(node, entering); };
	VditorIRRenderer.ptr.prototype.renderBackslash = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.WriteString("<span data-type=\"backslash\">");
			r.BaseRenderer.WriteString("<span>");
			r.BaseRenderer.WriteByte(92);
			r.BaseRenderer.WriteString("</span>");
		} else {
			r.BaseRenderer.WriteString("</span>");
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderBackslash = function(node, entering) { return this.$val.renderBackslash(node, entering); };
	VditorIRRenderer.ptr.prototype.renderToC = function(node, entering) {
		var _i, _r, _ref, caretInDest, entering, heading, headings, length, node, r, spaces, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _ref = $f._ref; caretInDest = $f.caretInDest; entering = $f.entering; heading = $f.heading; headings = $f.headings; length = $f.length; node = $f.node; r = $f.r; spaces = $f.spaces; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		headings = r.BaseRenderer.headings();
		length = headings.$length;
		r.BaseRenderer.WriteString("<div class=\"vditor-toc\" data-block=\"0\" data-type=\"toc-block\" contenteditable=\"false\">");
		/* */ if (0 < length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (0 < length) { */ case 1:
			_ref = headings;
			_i = 0;
			/* while (true) { */ case 4:
				/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 5; continue; }
				heading = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				spaces = $imul(((heading.HeadingLevel - 1 >> 0)), 2);
				r.BaseRenderer.WriteString(strings.Repeat("&emsp;", spaces));
				r.BaseRenderer.WriteString("<span data-type=\"toc-h\">");
				_r = heading.Text(); /* */ $s = 6; case 6: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				$r = r.BaseRenderer.WriteString(_r + "</span><br>"); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				_i++;
			/* } */ $s = 4; continue; case 5:
			$s = 3; continue;
		/* } else { */ case 2:
			r.BaseRenderer.WriteString("[toc]<br>");
		/* } */ case 3:
		r.BaseRenderer.WriteString("</div>");
		caretInDest = bytes.Contains(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))));
		r.BaseRenderer.WriteString("<p data-block=\"0\">");
		if (caretInDest) {
			r.BaseRenderer.WriteString("\xE2\x80\xB8");
		}
		r.BaseRenderer.WriteString("</p>");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderToC }; } $f._i = _i; $f._r = _r; $f._ref = _ref; $f.caretInDest = caretInDest; $f.entering = entering; $f.heading = heading; $f.headings = headings; $f.length = length; $f.node = node; $f.r = r; $f.spaces = spaces; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderToC = function(node, entering) { return this.$val.renderToC(node, entering); };
	VditorIRRenderer.ptr.prototype.renderFootnotesDef = function(node, entering) {
		var entering, node, r;
		r = this;
		if (!r.needRenderFootnotesDef) {
			return 0;
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderFootnotesDef = function(node, entering) { return this.$val.renderFootnotesDef(node, entering); };
	VditorIRRenderer.ptr.prototype.renderFootnotesRef = function(node, entering) {
		var _r, _r$1, _tuple, attrs, entering, expand, idx, idxStr, node, previousNodeText, r, text$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; attrs = $f.attrs; entering = $f.entering; expand = $f.expand; idx = $f.idx; idxStr = $f.idxStr; node = $f.node; previousNodeText = $f.previousNodeText; r = $f.r; text$1 = $f.text$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = node.PreviousNodeText(); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		previousNodeText = _r;
		previousNodeText = strings.ReplaceAll(previousNodeText, "\xE2\x80\xB8", "");
		if ("" === previousNodeText) {
			r.BaseRenderer.WriteString("\xE2\x80\x8B");
		}
		_tuple = r.BaseRenderer.Tree.Context.FindFootnotesDef(node.Tokens);
		idx = _tuple[0];
		idxStr = strconv.Itoa(idx);
		attrs = new sliceType$7([new sliceType(["data-type", "footnotes-ref"])]);
		_r$1 = node.Text(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		text$1 = _r$1;
		expand = strings.Contains(text$1, "\xE2\x80\xB8");
		if (expand) {
			attrs = $append(attrs, new sliceType(["class", "vditor-ir__node vditor-ir__node--expand"]));
		} else {
			attrs = $append(attrs, new sliceType(["class", "vditor-ir__node"]));
		}
		r.tag("sup", attrs, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bracket"])]), false);
		r.BaseRenderer.WriteByte(91);
		r.tag("/span", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--link"])]), false);
		r.BaseRenderer.Write(node.Tokens);
		r.tag("/span", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker--hide"]), new sliceType(["data-render", "1"])]), false);
		r.BaseRenderer.WriteString(idxStr);
		r.tag("/span", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bracket"])]), false);
		r.BaseRenderer.WriteByte(93);
		r.tag("/span", sliceType$7.nil, false);
		r.BaseRenderer.WriteString("</sup>\xE2\x80\x8B");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderFootnotesRef }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.attrs = attrs; $f.entering = entering; $f.expand = expand; $f.idx = idx; $f.idxStr = idxStr; $f.node = node; $f.previousNodeText = previousNodeText; $f.r = r; $f.text$1 = text$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderFootnotesRef = function(node, entering) { return this.$val.renderFootnotesRef(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["data-type", "code-block-close-marker"])]), false);
		r.BaseRenderer.Write(node.Tokens);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderCodeBlockCloseMarker = function(node, entering) { return this.$val.renderCodeBlockCloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeBlockInfoMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--info"]), new sliceType(["data-type", "code-block-info"])]), false);
		r.BaseRenderer.WriteString("\xE2\x80\x8B");
		r.BaseRenderer.Write(node.CodeBlockInfo);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderCodeBlockInfoMarker = function(node, entering) { return this.$val.renderCodeBlockInfoMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["data-type", "code-block-open-marker"])]), false);
		r.BaseRenderer.Write(node.Tokens);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderCodeBlockOpenMarker = function(node, entering) { return this.$val.renderCodeBlockOpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeBlock = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			$r = r.renderDivNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			r.BaseRenderer.WriteString("</div>");
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderCodeBlock }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderCodeBlock = function(node, entering) { return this.$val.renderCodeBlock(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeBlockCode = function(node, entering) {
		var _r, attrs, caretInInfo, class$1, codeIsEmpty, codeLen, dataCode, entering, infoWords, isFenced, language, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; attrs = $f.attrs; caretInInfo = $f.caretInInfo; class$1 = $f.class$1; codeIsEmpty = $f.codeIsEmpty; codeLen = $f.codeLen; dataCode = $f.dataCode; entering = $f.entering; infoWords = $f.infoWords; isFenced = $f.isFenced; language = $f.language; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		codeLen = node.Tokens.$length;
		codeIsEmpty = 1 > codeLen || ((3 === codeLen) && "\xE2\x80\xB8" === ($bytesToString(node.Tokens)));
		isFenced = node.Parent.IsFencedCodeBlock;
		caretInInfo = false;
		if (isFenced) {
			caretInInfo = bytes.Contains(node.Previous.CodeBlockInfo, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))));
			node.Previous.CodeBlockInfo = bytes.ReplaceAll(node.Previous.CodeBlockInfo, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
		}
		attrs = sliceType$7.nil;
		/* */ if (isFenced && 0 < node.Previous.CodeBlockInfo.$length) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (isFenced && 0 < node.Previous.CodeBlockInfo.$length) { */ case 1:
			infoWords = lex.Split(node.Previous.CodeBlockInfo, 32);
			language = ($bytesToString((0 >= infoWords.$length ? ($throwRuntimeError("index out of range"), undefined) : infoWords.$array[infoWords.$offset + 0])));
			attrs = $append(attrs, new sliceType(["class", "language-" + language]));
			/* */ if ("mindmap" === language) { $s = 3; continue; }
			/* */ $s = 4; continue;
			/* if ("mindmap" === language) { */ case 3:
				_r = r.BaseRenderer.renderMindmap(node.Tokens); /* */ $s = 5; case 5: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				dataCode = _r;
				attrs = $append(attrs, new sliceType(["data-code", ($bytesToString(dataCode))]));
			/* } */ case 4:
		/* } */ case 2:
		class$1 = "vditor-ir__marker--pre";
		if (r.BaseRenderer.Option.VditorCodeBlockPreview) {
			class$1 = class$1 + (" vditor-ir__marker");
		}
		r.tag("pre", new sliceType$7([new sliceType(["class", class$1])]), false);
		r.tag("code", attrs, false);
		if (codeIsEmpty) {
			if (!caretInInfo) {
				r.BaseRenderer.WriteString("<wbr>");
			}
			r.BaseRenderer.WriteByte(10);
		} else {
			r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
			r.BaseRenderer.Newline();
		}
		r.BaseRenderer.WriteString("</code></pre>");
		if (r.BaseRenderer.Option.VditorCodeBlockPreview) {
			r.tag("pre", new sliceType$7([new sliceType(["class", "vditor-ir__preview"]), new sliceType(["data-render", "2"])]), false);
			r.tag("code", attrs, false);
			tokens = node.Tokens;
			tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
			r.BaseRenderer.Write(util.EscapeHTML(tokens));
			r.BaseRenderer.WriteString("</code></pre>");
		}
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderCodeBlockCode }; } $f._r = _r; $f.attrs = attrs; $f.caretInInfo = caretInInfo; $f.class$1 = class$1; $f.codeIsEmpty = codeIsEmpty; $f.codeLen = codeLen; $f.dataCode = dataCode; $f.entering = entering; $f.infoWords = infoWords; $f.isFenced = isFenced; $f.language = language; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderCodeBlockCode = function(node, entering) { return this.$val.renderCodeBlockCode(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmojiAlias = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorIRRenderer.prototype.renderEmojiAlias = function(node, entering) { return this.$val.renderEmojiAlias(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmojiImg = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	VditorIRRenderer.prototype.renderEmojiImg = function(node, entering) { return this.$val.renderEmojiImg(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmojiUnicode = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(node.Tokens);
		return 0;
	};
	VditorIRRenderer.prototype.renderEmojiUnicode = function(node, entering) { return this.$val.renderEmojiUnicode(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmoji = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	VditorIRRenderer.prototype.renderEmoji = function(node, entering) { return this.$val.renderEmoji(node, entering); };
	VditorIRRenderer.ptr.prototype.renderInlineMathCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteByte(36);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderInlineMathCloseMarker = function(node, entering) { return this.$val.renderInlineMathCloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderInlineMathContent = function(node, entering) {
		var entering, node, r, tokens;
		r = this;
		tokens = util.EscapeHTML(node.Tokens);
		r.BaseRenderer.Write(tokens);
		r.tag("/code", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__preview"]), new sliceType(["data-render", "2"])]), false);
		r.tag("code", new sliceType$7([new sliceType(["class", "language-math"])]), false);
		r.BaseRenderer.Write(tokens);
		r.tag("/code", sliceType$7.nil, false);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderInlineMathContent = function(node, entering) { return this.$val.renderInlineMathContent(node, entering); };
	VditorIRRenderer.ptr.prototype.renderInlineMathOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteByte(36);
		r.tag("/span", sliceType$7.nil, false);
		r.tag("code", new sliceType$7([new sliceType(["data-newline", "1"]), new sliceType(["class", "vditor-ir__marker vditor-ir__marker--pre"]), new sliceType(["data-type", "math-inline"])]), false);
		return 0;
	};
	VditorIRRenderer.prototype.renderInlineMathOpenMarker = function(node, entering) { return this.$val.renderInlineMathOpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderInlineMath = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			$r = r.renderSpanNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/span", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderInlineMath }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderInlineMath = function(node, entering) { return this.$val.renderInlineMath(node, entering); };
	VditorIRRenderer.ptr.prototype.renderMathBlockCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["data-type", "math-block-close-marker"])]), false);
		r.BaseRenderer.WriteString("$$");
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderMathBlockCloseMarker = function(node, entering) { return this.$val.renderMathBlockCloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderMathBlockContent = function(node, entering) {
		var _r, codeIsEmpty, codeLen, entering, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; codeIsEmpty = $f.codeIsEmpty; codeLen = $f.codeLen; entering = $f.entering; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = bytes.TrimSpace(node.Tokens); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		node.Tokens = _r;
		codeLen = node.Tokens.$length;
		codeIsEmpty = 1 > codeLen || ((3 === codeLen) && "\xE2\x80\xB8" === ($bytesToString(node.Tokens)));
		r.tag("pre", new sliceType$7([new sliceType(["class", "vditor-ir__marker--pre vditor-ir__marker"])]), false);
		r.tag("code", new sliceType$7([new sliceType(["data-type", "math-block"]), new sliceType(["class", "language-math"])]), false);
		if (codeIsEmpty) {
			r.BaseRenderer.WriteString("<wbr>\n");
		} else {
			r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		}
		r.BaseRenderer.WriteString("</code></pre>");
		r.tag("pre", new sliceType$7([new sliceType(["class", "vditor-ir__preview"]), new sliceType(["data-render", "2"])]), false);
		r.tag("code", new sliceType$7([new sliceType(["data-type", "math-block"]), new sliceType(["class", "language-math"])]), false);
		tokens = node.Tokens;
		tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
		r.BaseRenderer.Write(util.EscapeHTML(tokens));
		r.BaseRenderer.WriteString("</code></pre>");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderMathBlockContent }; } $f._r = _r; $f.codeIsEmpty = codeIsEmpty; $f.codeLen = codeLen; $f.entering = entering; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderMathBlockContent = function(node, entering) { return this.$val.renderMathBlockContent(node, entering); };
	VditorIRRenderer.ptr.prototype.renderMathBlockOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["data-type", "math-block-open-marker"])]), false);
		r.BaseRenderer.WriteString("$$");
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderMathBlockOpenMarker = function(node, entering) { return this.$val.renderMathBlockOpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderMathBlock = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			$r = r.renderDivNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			r.BaseRenderer.WriteString("</div>");
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderMathBlock }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderMathBlock = function(node, entering) { return this.$val.renderMathBlock(node, entering); };
	VditorIRRenderer.ptr.prototype.renderTableCell = function(node, entering) {
		var _1, _r, attrs, entering, node, r, tag, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; attrs = $f.attrs; entering = $f.entering; node = $f.node; r = $f.r; tag = $f.tag; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		tag = "td";
		if (107 === node.Parent.Parent.Type) {
			tag = "th";
		}
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			attrs = sliceType$7.nil;
			_1 = node.TableCellAlign;
			if (_1 === (1)) {
				attrs = $append(attrs, new sliceType(["align", "left"]));
			} else if (_1 === (2)) {
				attrs = $append(attrs, new sliceType(["align", "center"]));
			} else if (_1 === (3)) {
				attrs = $append(attrs, new sliceType(["align", "right"]));
			}
			r.tag(tag, attrs, false);
			/* */ if (ptrType$1.nil === node.FirstChild) { $s = 4; continue; }
			/* */ if (bytes.Equal(node.FirstChild.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))))) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (ptrType$1.nil === node.FirstChild) { */ case 4:
				node.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$3($stringToBytes(" "))), false, false, false, 0, false, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, sliceType$3.nil, 0, ptrType$4.nil, false, sliceType$5.nil, 0, 0, 0, sliceType$3.nil, sliceType$3.nil, 0, sliceType$3.nil, 0, false, sliceType$3.nil, "", 0, sliceType$3.nil, "", sliceType$6.nil, sliceType$3.nil));
				$s = 7; continue;
			/* } else if (bytes.Equal(node.FirstChild.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))))) { */ case 5:
				node.FirstChild.Tokens = (new sliceType$3($stringToBytes("\xE2\x80\xB8 ")));
				$s = 7; continue;
			/* } else { */ case 6:
				_r = bytes.TrimSpace(node.FirstChild.Tokens); /* */ $s = 8; case 8: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				node.FirstChild.Tokens = _r;
			/* } */ case 7:
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/" + tag, sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderTableCell }; } $f._1 = _1; $f._r = _r; $f.attrs = attrs; $f.entering = entering; $f.node = node; $f.r = r; $f.tag = tag; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderTableCell = function(node, entering) { return this.$val.renderTableCell(node, entering); };
	VditorIRRenderer.ptr.prototype.renderTableRow = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("tr", sliceType$7.nil, false);
		} else {
			r.tag("/tr", sliceType$7.nil, false);
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderTableRow = function(node, entering) { return this.$val.renderTableRow(node, entering); };
	VditorIRRenderer.ptr.prototype.renderTableHead = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("thead", sliceType$7.nil, false);
		} else {
			r.tag("/thead", sliceType$7.nil, false);
			if (!(ptrType$1.nil === node.Next)) {
				r.tag("tbody", sliceType$7.nil, false);
			}
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderTableHead = function(node, entering) { return this.$val.renderTableHead(node, entering); };
	VditorIRRenderer.ptr.prototype.renderTable = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.tag("table", new sliceType$7([new sliceType(["data-block", "0"]), new sliceType(["data-type", "table"])]), false);
		} else {
			if (!(ptrType$1.nil === node.FirstChild.Next)) {
				r.tag("/tbody", sliceType$7.nil, false);
			}
			r.tag("/table", sliceType$7.nil, false);
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderTable = function(node, entering) { return this.$val.renderTable(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrikethrough = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			$r = r.renderSpanNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/span", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderStrikethrough }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderStrikethrough = function(node, entering) { return this.$val.renderStrikethrough(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrikethrough1OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteString("~");
		r.tag("/span", sliceType$7.nil, false);
		r.tag("s", new sliceType$7([new sliceType(["data-newline", "1"])]), false);
		return 0;
	};
	VditorIRRenderer.prototype.renderStrikethrough1OpenMarker = function(node, entering) { return this.$val.renderStrikethrough1OpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrikethrough1CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/s", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteString("~");
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderStrikethrough1CloseMarker = function(node, entering) { return this.$val.renderStrikethrough1CloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrikethrough2OpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteString("~~");
		r.tag("/span", sliceType$7.nil, false);
		r.tag("s", new sliceType$7([new sliceType(["data-newline", "1"])]), false);
		return 0;
	};
	VditorIRRenderer.prototype.renderStrikethrough2OpenMarker = function(node, entering) { return this.$val.renderStrikethrough2OpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrikethrough2CloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/s", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteString("~~");
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderStrikethrough2CloseMarker = function(node, entering) { return this.$val.renderStrikethrough2CloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderLinkTitle = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--title"])]), false);
		r.BaseRenderer.WriteByte(34);
		r.BaseRenderer.Write(node.Tokens);
		r.BaseRenderer.WriteByte(34);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderLinkTitle = function(node, entering) { return this.$val.renderLinkTitle(node, entering); };
	VditorIRRenderer.ptr.prototype.renderLinkDest = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--link"])]), false);
		r.BaseRenderer.Write(node.Tokens);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderLinkDest = function(node, entering) { return this.$val.renderLinkDest(node, entering); };
	VditorIRRenderer.ptr.prototype.renderLinkSpace = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(32);
		return 0;
	};
	VditorIRRenderer.prototype.renderLinkSpace = function(node, entering) { return this.$val.renderLinkSpace(node, entering); };
	VditorIRRenderer.ptr.prototype.renderLinkText = function(node, entering) {
		var entering, node, r;
		r = this;
		if (34 === node.Parent.Type) {
			r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bracket"])]), false);
		} else {
			if (3 === node.Parent.LinkType) {
				r.tag("span", sliceType$7.nil, false);
			} else {
				r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__link"])]), false);
			}
		}
		r.BaseRenderer.Write(node.Tokens);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderLinkText = function(node, entering) { return this.$val.renderLinkText(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCloseParen = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--paren"])]), false);
		r.BaseRenderer.WriteByte(41);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderCloseParen = function(node, entering) { return this.$val.renderCloseParen(node, entering); };
	VditorIRRenderer.ptr.prototype.renderOpenParen = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--paren"])]), false);
		r.BaseRenderer.WriteByte(40);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderOpenParen = function(node, entering) { return this.$val.renderOpenParen(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCloseBracket = function(node, entering) {
		var entering, linkText, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bracket"])]), false);
		r.BaseRenderer.WriteByte(93);
		r.tag("/span", sliceType$7.nil, false);
		if (3 === node.Parent.LinkType) {
			linkText = node.Parent.ChildByType(40);
			if (!bytes.EqualFold(node.Parent.LinkRefLabel, linkText.Tokens)) {
				r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--link"])]), false);
				r.BaseRenderer.WriteByte(91);
				r.BaseRenderer.Write(node.Parent.LinkRefLabel);
				r.BaseRenderer.WriteByte(93);
				r.tag("/span", sliceType$7.nil, false);
			}
		}
		return 0;
	};
	VditorIRRenderer.prototype.renderCloseBracket = function(node, entering) { return this.$val.renderCloseBracket(node, entering); };
	VditorIRRenderer.ptr.prototype.renderOpenBracket = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bracket"])]), false);
		r.BaseRenderer.WriteByte(91);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderOpenBracket = function(node, entering) { return this.$val.renderOpenBracket(node, entering); };
	VditorIRRenderer.ptr.prototype.renderBang = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteByte(33);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderBang = function(node, entering) { return this.$val.renderBang(node, entering); };
	VditorIRRenderer.ptr.prototype.renderImage = function(node, entering) {
		var _r, _r$1, alt, altTokens, attrs, buf, class$1, destTokens, entering, idx, imgBuf, needResetCaret, node, r, text$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; alt = $f.alt; altTokens = $f.altTokens; attrs = $f.attrs; buf = $f.buf; class$1 = $f.class$1; destTokens = $f.destTokens; entering = $f.entering; idx = $f.idx; imgBuf = $f.imgBuf; needResetCaret = $f.needResetCaret; node = $f.node; r = $f.r; text$1 = $f.text$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		needResetCaret = !(ptrType$1.nil === node.Next) && (16 === node.Next.Type) && bytes.HasPrefix(node.Next.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))));
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			_r = r.Text(node); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			text$1 = _r;
			class$1 = "vditor-ir__node";
			if (strings.Contains(text$1, "\xE2\x80\xB8") || needResetCaret) {
				class$1 = class$1 + (" vditor-ir__node--expand");
			}
			r.tag("span", new sliceType$7([new sliceType(["class", class$1])]), false);
			$s = 3; continue;
		/* } else { */ case 2:
			if (needResetCaret) {
				r.BaseRenderer.WriteString("\xE2\x80\xB8");
				node.Next.Tokens = bytes.ReplaceAll(node.Next.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
			}
			destTokens = node.ChildByType(41).Tokens;
			destTokens = r.BaseRenderer.Tree.Context.RelativePath(destTokens);
			destTokens = bytes.ReplaceAll(destTokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
			attrs = new sliceType$7([new sliceType(["src", ($bytesToString(destTokens))])]);
			alt = node.ChildByType(40);
			if (!(ptrType$1.nil === alt) && 0 < alt.Tokens.$length) {
				altTokens = bytes.ReplaceAll(alt.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
				attrs = $append(attrs, new sliceType(["alt", ($bytesToString(altTokens))]));
			}
			r.tag("img", attrs, true);
			buf = r.BaseRenderer.Writer.Bytes();
			idx = bytes.LastIndex(buf, (new sliceType$3($stringToBytes("<img src="))));
			imgBuf = $subslice(buf, idx);
			/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (r.BaseRenderer.Option.Sanitize) { */ case 5:
				_r$1 = sanitize(imgBuf); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				imgBuf = _r$1;
			/* } */ case 6:
			r.BaseRenderer.Writer.Truncate(idx);
			r.BaseRenderer.Writer.Write(imgBuf);
			r.tag("/span", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderImage }; } $f._r = _r; $f._r$1 = _r$1; $f.alt = alt; $f.altTokens = altTokens; $f.attrs = attrs; $f.buf = buf; $f.class$1 = class$1; $f.destTokens = destTokens; $f.entering = entering; $f.idx = idx; $f.imgBuf = imgBuf; $f.needResetCaret = needResetCaret; $f.node = node; $f.r = r; $f.text$1 = text$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderImage = function(node, entering) { return this.$val.renderImage(node, entering); };
	VditorIRRenderer.ptr.prototype.renderLink = function(node, entering) {
		var entering, linkSpace, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; linkSpace = $f.linkSpace; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			if (3 === node.LinkType) {
				node.ChildByType(38).Unlink();
				node.ChildByType(41).Unlink();
				linkSpace = node.ChildByType(43);
				if (!(ptrType$1.nil === linkSpace)) {
					linkSpace.Unlink();
					node.ChildByType(42).Unlink();
				}
				node.ChildByType(39).Unlink();
			}
			$r = r.renderSpanNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/span", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderLink }; } $f.entering = entering; $f.linkSpace = linkSpace; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderLink = function(node, entering) { return this.$val.renderLink(node, entering); };
	VditorIRRenderer.ptr.prototype.renderHTML = function(node, entering) {
		var _r, _r$1, entering, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; entering = $f.entering; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		$r = r.renderDivNode(node); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		_r = bytes.TrimSpace(node.Tokens); /* */ $s = 2; case 2: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tokens = _r;
		/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (r.BaseRenderer.Option.Sanitize) { */ case 3:
			_r$1 = sanitize(tokens); /* */ $s = 5; case 5: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			tokens = _r$1;
		/* } */ case 4:
		r.BaseRenderer.WriteString("<pre class=\"vditor-ir__marker--pre vditor-ir__marker\">");
		r.tag("code", new sliceType$7([new sliceType(["data-type", "html-block"])]), false);
		r.BaseRenderer.Write(util.EscapeHTML(tokens));
		r.BaseRenderer.WriteString("</code></pre>");
		r.tag("pre", new sliceType$7([new sliceType(["class", "vditor-ir__preview"]), new sliceType(["data-render", "2"])]), false);
		tokens = bytes.ReplaceAll(tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8"))), sliceType$3.nil);
		r.BaseRenderer.Write(tokens);
		r.BaseRenderer.WriteString("</pre>");
		r.BaseRenderer.WriteString("</div>");
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderHTML }; } $f._r = _r; $f._r$1 = _r$1; $f.entering = entering; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderHTML = function(node, entering) { return this.$val.renderHTML(node, entering); };
	VditorIRRenderer.ptr.prototype.renderInlineHTML = function(node, entering) {
		var _r, entering, node, r, tokens, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; entering = $f.entering; node = $f.node; r = $f.r; tokens = $f.tokens; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		$r = r.renderSpanNode(node); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		r.tag("code", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		tokens = node.Tokens;
		/* */ if (r.BaseRenderer.Option.Sanitize) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (r.BaseRenderer.Option.Sanitize) { */ case 2:
			_r = sanitize(tokens); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			tokens = _r;
		/* } */ case 3:
		r.BaseRenderer.Write(util.EscapeHTML(tokens));
		r.tag("/code", sliceType$7.nil, false);
		r.tag("/span", sliceType$7.nil, false);
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderInlineHTML }; } $f._r = _r; $f.entering = entering; $f.node = node; $f.r = r; $f.tokens = tokens; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderInlineHTML = function(node, entering) { return this.$val.renderInlineHTML(node, entering); };
	VditorIRRenderer.ptr.prototype.renderDocument = function(node, entering) {
		var entering, node, r;
		r = this;
		return 2;
	};
	VditorIRRenderer.prototype.renderDocument = function(node, entering) { return this.$val.renderDocument(node, entering); };
	VditorIRRenderer.ptr.prototype.renderParagraph = function(node, entering) {
		var entering, grandparent, node, r;
		r = this;
		grandparent = node.Parent.Parent;
		if (!(ptrType$1.nil === grandparent) && (7 === grandparent.Type) && grandparent.ListData.Tight) {
			return 2;
		}
		if (entering) {
			r.tag("p", new sliceType$7([new sliceType(["data-block", "0"])]), false);
		} else {
			r.BaseRenderer.WriteByte(10);
			r.tag("/p", sliceType$7.nil, false);
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderParagraph = function(node, entering) { return this.$val.renderParagraph(node, entering); };
	VditorIRRenderer.ptr.prototype.renderText = function(node, entering) {
		var _r, entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		if (r.BaseRenderer.Option.AutoSpace) {
			r.BaseRenderer.Space(node);
		}
		/* */ if (r.BaseRenderer.Option.FixTermTypo) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (r.BaseRenderer.Option.FixTermTypo) { */ case 1:
			$r = r.BaseRenderer.FixTermTypo(node); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* } */ case 2:
		if (r.BaseRenderer.Option.ChinesePunct) {
			r.BaseRenderer.ChinesePunct(node);
		}
		_r = bytes.TrimRight(node.Tokens, "\n"); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		node.Tokens = _r;
		if (!bytes.EqualFold(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\xB8\xE2\x80\x8B"))))) {
			node.Tokens = bytes.ReplaceAll(node.Tokens, (new sliceType$3($stringToBytes("\xE2\x80\x8B"))), sliceType$3.nil);
		}
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		$s = -1; return 0;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderText }; } $f._r = _r; $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderText = function(node, entering) { return this.$val.renderText(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeSpan = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			$r = r.renderSpanNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/span", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderCodeSpan }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderCodeSpan = function(node, entering) { return this.$val.renderCodeSpan(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeSpanOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteString(strings.Repeat("`", node.Parent.CodeMarkerLen));
		r.tag("/span", sliceType$7.nil, false);
		r.tag("code", new sliceType$7([new sliceType(["data-newline", "1"])]), false);
		return 0;
	};
	VditorIRRenderer.prototype.renderCodeSpanOpenMarker = function(node, entering) { return this.$val.renderCodeSpanOpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeSpanContent = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.Write(util.EscapeHTML(node.Tokens));
		return 0;
	};
	VditorIRRenderer.prototype.renderCodeSpanContent = function(node, entering) { return this.$val.renderCodeSpanContent(node, entering); };
	VditorIRRenderer.ptr.prototype.renderCodeSpanCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/code", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker"])]), false);
		r.BaseRenderer.WriteString(strings.Repeat("`", node.Parent.CodeMarkerLen));
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderCodeSpanCloseMarker = function(node, entering) { return this.$val.renderCodeSpanCloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmphasis = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			$r = r.renderSpanNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/span", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderEmphasis }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderEmphasis = function(node, entering) { return this.$val.renderEmphasis(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmAsteriskOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bi"])]), false);
		r.BaseRenderer.WriteByte(42);
		r.tag("/span", sliceType$7.nil, false);
		r.tag("em", new sliceType$7([new sliceType(["data-newline", "1"])]), false);
		return 0;
	};
	VditorIRRenderer.prototype.renderEmAsteriskOpenMarker = function(node, entering) { return this.$val.renderEmAsteriskOpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmAsteriskCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bi"])]), false);
		r.BaseRenderer.WriteByte(42);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderEmAsteriskCloseMarker = function(node, entering) { return this.$val.renderEmAsteriskCloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmUnderscoreOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bi"])]), false);
		r.BaseRenderer.WriteByte(95);
		r.tag("/span", sliceType$7.nil, false);
		r.tag("em", new sliceType$7([new sliceType(["data-newline", "1"])]), false);
		return 0;
	};
	VditorIRRenderer.prototype.renderEmUnderscoreOpenMarker = function(node, entering) { return this.$val.renderEmUnderscoreOpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderEmUnderscoreCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/em", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bi"])]), false);
		r.BaseRenderer.WriteByte(95);
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderEmUnderscoreCloseMarker = function(node, entering) { return this.$val.renderEmUnderscoreCloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrong = function(node, entering) {
		var entering, node, r, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; entering = $f.entering; node = $f.node; r = $f.r; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			$r = r.renderSpanNode(node); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			$s = 3; continue;
		/* } else { */ case 2:
			r.tag("/span", sliceType$7.nil, false);
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderStrong }; } $f.entering = entering; $f.node = node; $f.r = r; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderStrong = function(node, entering) { return this.$val.renderStrong(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrongA6kOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bi"])]), false);
		r.BaseRenderer.WriteString("**");
		r.tag("/span", sliceType$7.nil, false);
		r.tag("strong", new sliceType$7([new sliceType(["data-newline", "1"])]), false);
		return 0;
	};
	VditorIRRenderer.prototype.renderStrongA6kOpenMarker = function(node, entering) { return this.$val.renderStrongA6kOpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrongA6kCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bi"])]), false);
		r.BaseRenderer.WriteString("**");
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderStrongA6kCloseMarker = function(node, entering) { return this.$val.renderStrongA6kCloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrongU8eOpenMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bi"])]), false);
		r.BaseRenderer.WriteString("__");
		r.tag("/span", sliceType$7.nil, false);
		r.tag("strong", new sliceType$7([new sliceType(["data-newline", "1"])]), false);
		return 0;
	};
	VditorIRRenderer.prototype.renderStrongU8eOpenMarker = function(node, entering) { return this.$val.renderStrongU8eOpenMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderStrongU8eCloseMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("/strong", sliceType$7.nil, false);
		r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--bi"])]), false);
		r.BaseRenderer.WriteString("__");
		r.tag("/span", sliceType$7.nil, false);
		return 0;
	};
	VditorIRRenderer.prototype.renderStrongU8eCloseMarker = function(node, entering) { return this.$val.renderStrongU8eCloseMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderBlockquote = function(node, entering) {
		var entering, node, r;
		r = this;
		if (entering) {
			r.BaseRenderer.WriteString("<blockquote data-block=\"0\">");
		} else {
			r.BaseRenderer.WriteString("</blockquote>");
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderBlockquote = function(node, entering) { return this.$val.renderBlockquote(node, entering); };
	VditorIRRenderer.ptr.prototype.renderBlockquoteMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorIRRenderer.prototype.renderBlockquoteMarker = function(node, entering) { return this.$val.renderBlockquoteMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderHeading = function(node, entering) {
		var _r, _r$1, _r$2, entering, id, id$1, node, r, text$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; entering = $f.entering; id = $f.id; id$1 = $f.id$1; node = $f.node; r = $f.r; text$1 = $f.text$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		/* */ if (entering) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (entering) { */ case 1:
			_r = r.Text(node); /* */ $s = 4; case 4: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
			text$1 = _r;
			if (strings.Contains(text$1, "\xE2\x80\xB8")) {
				r.BaseRenderer.WriteString("<h" + $substring(headingLevel, node.HeadingLevel, (node.HeadingLevel + 1 >> 0)) + " data-block=\"0\" class=\"vditor-ir__node vditor-ir__node--expand\"");
			} else {
				r.BaseRenderer.WriteString("<h" + $substring(headingLevel, node.HeadingLevel, (node.HeadingLevel + 1 >> 0)) + " data-block=\"0\" class=\"vditor-ir__node\"");
			}
			id = ($bytesToString(node.HeadingID));
			if (r.BaseRenderer.Option.HeadingID && !("" === id)) {
				r.BaseRenderer.WriteString(" data-id=\"" + id + "\"");
			}
			/* */ if ("" === id) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if ("" === id) { */ case 5:
				_r$1 = HeadingID(node); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				id = _r$1;
			/* } */ case 6:
			r.BaseRenderer.WriteString(" id=\"ir-" + id + "\"");
			if (!node.HeadingSetext) {
				r.BaseRenderer.WriteString(" data-marker=\"#\">");
			} else {
				if (1 === node.HeadingLevel) {
					r.BaseRenderer.WriteString(" data-marker=\"=\">");
				} else {
					r.BaseRenderer.WriteString(" data-marker=\"-\">");
				}
			}
			/* */ if (r.BaseRenderer.Option.HeadingAnchor) { $s = 8; continue; }
			/* */ $s = 9; continue;
			/* if (r.BaseRenderer.Option.HeadingAnchor) { */ case 8:
				_r$2 = HeadingID(node); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				id$1 = _r$2;
				r.tag("a", new sliceType$7([new sliceType(["id", "vditorAnchor-" + id$1]), new sliceType(["class", "vditor-anchor"]), new sliceType(["href", "#" + id$1])]), false);
				r.BaseRenderer.WriteString("<svg viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>");
				r.tag("/a", sliceType$7.nil, false);
			/* } */ case 9:
			r.tag("span", new sliceType$7([new sliceType(["class", "vditor-ir__marker vditor-ir__marker--heading"]), new sliceType(["data-type", "heading-marker"])]), false);
			r.BaseRenderer.WriteString(strings.Repeat("#", node.HeadingLevel) + " ");
			r.tag("/span", sliceType$7.nil, false);
			$s = 3; continue;
		/* } else { */ case 2:
			r.BaseRenderer.WriteString("</h" + $substring(headingLevel, node.HeadingLevel, (node.HeadingLevel + 1 >> 0)) + ">");
		/* } */ case 3:
		$s = -1; return 2;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderHeading }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.entering = entering; $f.id = id; $f.id$1 = id$1; $f.node = node; $f.r = r; $f.text$1 = text$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderHeading = function(node, entering) { return this.$val.renderHeading(node, entering); };
	VditorIRRenderer.ptr.prototype.renderHeadingC8hMarker = function(node, entering) {
		var entering, node, r;
		r = this;
		return 0;
	};
	VditorIRRenderer.prototype.renderHeadingC8hMarker = function(node, entering) { return this.$val.renderHeadingC8hMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderList = function(node, entering) {
		var _1, attrs, entering, node, r, tag;
		r = this;
		tag = "ul";
		if ((1 === node.ListData.Typ) || ((3 === node.ListData.Typ) && (0 === node.ListData.BulletChar))) {
			tag = "ol";
		}
		if (entering) {
			attrs = sliceType$7.nil;
			if (node.ListData.Tight) {
				attrs = $append(attrs, new sliceType(["data-tight", "true"]));
			}
			if (0 === node.ListData.BulletChar) {
				if (!((1 === node.ListData.Start))) {
					attrs = $append(attrs, new sliceType(["start", strconv.Itoa(node.ListData.Start)]));
				}
			}
			_1 = node.ListData.Typ;
			if (_1 === (0)) {
				attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
			} else if (_1 === (1)) {
				attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
			} else if (_1 === (3)) {
				if (0 === node.ListData.BulletChar) {
					attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
				} else {
					attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
				}
			}
			attrs = $append(attrs, new sliceType(["data-block", "0"]));
			r.tag(tag, attrs, false);
		} else {
			r.tag("/" + tag, sliceType$7.nil, false);
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderList = function(node, entering) { return this.$val.renderList(node, entering); };
	VditorIRRenderer.ptr.prototype.renderListItem = function(node, entering) {
		var _1, attrs, entering, node, r;
		r = this;
		if (entering) {
			attrs = sliceType$7.nil;
			_1 = node.ListData.Typ;
			if (_1 === (0)) {
				attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
			} else if (_1 === (1)) {
				attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
			} else if (_1 === (3)) {
				if (0 === node.ListData.BulletChar) {
					attrs = $append(attrs, new sliceType(["data-marker", strconv.Itoa(node.ListData.Num) + ($encodeRune(node.ListData.Delimiter))]));
				} else {
					attrs = $append(attrs, new sliceType(["data-marker", ($bytesToString(node.ListData.Marker))]));
				}
				if (!(ptrType$1.nil === node.FirstChild) && !(ptrType$1.nil === node.FirstChild.FirstChild) && (100 === node.FirstChild.FirstChild.Type)) {
					attrs = $append(attrs, new sliceType(["class", r.BaseRenderer.Option.GFMTaskListItemClass]));
				}
			}
			r.tag("li", attrs, false);
		} else {
			r.tag("/li", sliceType$7.nil, false);
		}
		return 2;
	};
	VditorIRRenderer.prototype.renderListItem = function(node, entering) { return this.$val.renderListItem(node, entering); };
	VditorIRRenderer.ptr.prototype.renderTaskListItemMarker = function(node, entering) {
		var attrs, entering, node, r;
		r = this;
		attrs = sliceType$7.nil;
		if (node.TaskListItemChecked) {
			attrs = $append(attrs, new sliceType(["checked", ""]));
		}
		attrs = $append(attrs, new sliceType(["type", "checkbox"]));
		r.tag("input", attrs, true);
		return 0;
	};
	VditorIRRenderer.prototype.renderTaskListItemMarker = function(node, entering) { return this.$val.renderTaskListItemMarker(node, entering); };
	VditorIRRenderer.ptr.prototype.renderThematicBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("hr", new sliceType$7([new sliceType(["data-block", "0"])]), true);
		if (!(sliceType$3.nil === node.Tokens)) {
			r.tag("p", new sliceType$7([new sliceType(["data-block", "0"])]), false);
			r.BaseRenderer.Write(node.Tokens);
			r.BaseRenderer.WriteByte(10);
			r.tag("/p", sliceType$7.nil, false);
		}
		return 0;
	};
	VditorIRRenderer.prototype.renderThematicBreak = function(node, entering) { return this.$val.renderThematicBreak(node, entering); };
	VditorIRRenderer.ptr.prototype.renderHardBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.tag("br", sliceType$7.nil, true);
		return 0;
	};
	VditorIRRenderer.prototype.renderHardBreak = function(node, entering) { return this.$val.renderHardBreak(node, entering); };
	VditorIRRenderer.ptr.prototype.renderSoftBreak = function(node, entering) {
		var entering, node, r;
		r = this;
		r.BaseRenderer.WriteByte(10);
		return 0;
	};
	VditorIRRenderer.prototype.renderSoftBreak = function(node, entering) { return this.$val.renderSoftBreak(node, entering); };
	VditorIRRenderer.ptr.prototype.tag = function(name, attrs, selfclosing) {
		var _i, _ref, attr, attrs, name, r, selfclosing;
		r = this;
		if (r.BaseRenderer.DisableTags > 0) {
			return;
		}
		r.BaseRenderer.WriteString("<");
		r.BaseRenderer.WriteString(name);
		if (0 < attrs.$length) {
			_ref = attrs;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				attr = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				r.BaseRenderer.WriteString(" " + (0 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 0]) + "=\"" + (1 >= attr.$length ? ($throwRuntimeError("index out of range"), undefined) : attr.$array[attr.$offset + 1]) + "\"");
				_i++;
			}
		}
		if (selfclosing) {
			r.BaseRenderer.WriteString(" /");
		}
		r.BaseRenderer.WriteString(">");
	};
	VditorIRRenderer.prototype.tag = function(name, attrs, selfclosing) { return this.$val.tag(name, attrs, selfclosing); };
	VditorIRRenderer.ptr.prototype.renderSpanNode = function(node) {
		var _1, _r, _r$1, _r$2, attrs, nexText, node, preText, r, text$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; attrs = $f.attrs; nexText = $f.nexText; node = $f.node; preText = $f.preText; r = $f.r; text$1 = $f.text$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Text(node); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		text$1 = _r;
		attrs = sliceType$7.nil;
		_1 = node.Type;
		if (_1 === (17)) {
			attrs = $append(attrs, new sliceType(["data-type", "em"]));
		} else if (_1 === (22)) {
			attrs = $append(attrs, new sliceType(["data-type", "strong"]));
		} else if (_1 === (101)) {
			attrs = $append(attrs, new sliceType(["data-type", "s"]));
		} else if (_1 === (33)) {
			if (!((3 === node.LinkType))) {
				attrs = $append(attrs, new sliceType(["data-type", "a"]));
			} else {
				attrs = $append(attrs, new sliceType(["data-type", "link-ref"]));
			}
		} else if (_1 === (34)) {
			attrs = $append(attrs, new sliceType(["data-type", "img"]));
		} else if (_1 === (27)) {
			attrs = $append(attrs, new sliceType(["data-type", "code"]));
		} else {
			attrs = $append(attrs, new sliceType(["data-type", "inline-node"]));
		}
		if (strings.Contains(text$1, "\xE2\x80\xB8")) {
			attrs = $append(attrs, new sliceType(["class", "vditor-ir__node vditor-ir__node--expand"]));
			r.tag("span", attrs, false);
			$s = -1; return;
		}
		_r$1 = node.PreviousNodeText(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		preText = _r$1;
		if (strings.HasSuffix(preText, "\xE2\x80\xB8")) {
			attrs = $append(attrs, new sliceType(["class", "vditor-ir__node vditor-ir__node--expand"]));
			r.tag("span", attrs, false);
			$s = -1; return;
		}
		_r$2 = node.NextNodeText(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		nexText = _r$2;
		if (strings.HasPrefix(nexText, "\xE2\x80\xB8")) {
			attrs = $append(attrs, new sliceType(["class", "vditor-ir__node vditor-ir__node--expand"]));
			r.tag("span", attrs, false);
			$s = -1; return;
		}
		attrs = $append(attrs, new sliceType(["class", "vditor-ir__node"]));
		r.tag("span", attrs, false);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderSpanNode }; } $f._1 = _1; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f.attrs = attrs; $f.nexText = nexText; $f.node = node; $f.preText = preText; $f.r = r; $f.text$1 = text$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderSpanNode = function(node) { return this.$val.renderSpanNode(node); };
	VditorIRRenderer.ptr.prototype.renderDivNode = function(node) {
		var _1, _r, attrs, node, r, text$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _r = $f._r; attrs = $f.attrs; node = $f.node; r = $f.r; text$1 = $f.text$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		r = this;
		_r = r.Text(node); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		text$1 = _r;
		attrs = new sliceType$7([new sliceType(["data-block", "0"])]);
		_1 = node.Type;
		if (_1 === (11)) {
			attrs = $append(attrs, new sliceType(["data-type", "code-block"]));
		} else if (_1 === (9)) {
			attrs = $append(attrs, new sliceType(["data-type", "html-block"]));
		} else if (_1 === (300)) {
			attrs = $append(attrs, new sliceType(["data-type", "math-block"]));
		}
		if (strings.Contains(text$1, "\xE2\x80\xB8")) {
			attrs = $append(attrs, new sliceType(["class", "vditor-ir__node vditor-ir__node--expand"]));
			r.tag("div", attrs, false);
			$s = -1; return;
		}
		attrs = $append(attrs, new sliceType(["class", "vditor-ir__node"]));
		r.tag("div", attrs, false);
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.renderDivNode }; } $f._1 = _1; $f._r = _r; $f.attrs = attrs; $f.node = node; $f.r = r; $f.text$1 = text$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.renderDivNode = function(node) { return this.$val.renderDivNode(node); };
	VditorIRRenderer.ptr.prototype.Text = function(node) {
		var node, r, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; node = $f.node; r = $f.r; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = [ret];
		ret[0] = "";
		r = this;
		$r = ast.Walk(node, (function(ret) { return function(n, entering) {
			var _1, entering, n;
			if (entering) {
				_1 = n.Type;
				if ((_1 === (16)) || (_1 === (40)) || (_1 === (41)) || (_1 === (42)) || (_1 === (15)) || (_1 === (29)) || (_1 === (306)) || (_1 === (302)) || (_1 === (9))) {
					ret[0] = ret[0] + (($bytesToString(n.Tokens)));
				} else if (_1 === (14)) {
					ret[0] = ret[0] + (($bytesToString(n.CodeBlockInfo)));
				} else if (_1 === (33)) {
					if (3 === n.LinkType) {
						ret[0] = ret[0] + (($bytesToString(n.LinkRefLabel)));
					}
				}
			}
			return 2;
		}; })(ret)); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$s = -1; return ret[0];
		/* */ } return; } if ($f === undefined) { $f = { $blk: VditorIRRenderer.ptr.prototype.Text }; } $f.node = node; $f.r = r; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	VditorIRRenderer.prototype.Text = function(node) { return this.$val.Text(node); };
	ptrType$10.methods = [{prop: "renderDefault", name: "renderDefault", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslashContent", name: "renderBackslashContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslash", name: "renderBackslash", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderToC", name: "renderToC", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesRef", name: "renderFootnotesRef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesDef", name: "renderFootnotesDef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMath", name: "renderInlineMath", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlock", name: "renderMathBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiImg", name: "renderEmojiImg", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiUnicode", name: "renderEmojiUnicode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiAlias", name: "renderEmojiAlias", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmoji", name: "renderEmoji", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableCell", name: "renderTableCell", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableRow", name: "renderTableRow", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableHead", name: "renderTableHead", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTable", name: "renderTable", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough", name: "renderStrikethrough", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderImage", name: "renderImage", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLink", name: "renderLink", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHTML", name: "renderHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineHTML", name: "renderInlineHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderDocument", name: "renderDocument", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderParagraph", name: "renderParagraph", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderText", name: "renderText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpan", name: "renderCodeSpan", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmphasis", name: "renderEmphasis", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrong", name: "renderStrong", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquote", name: "renderBlockquote", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeading", name: "renderHeading", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderList", name: "renderList", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderListItem", name: "renderListItem", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTaskListItemMarker", name: "renderTaskListItemMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderThematicBreak", name: "renderThematicBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHardBreak", name: "renderHardBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderSoftBreak", name: "renderSoftBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlock", name: "renderCodeBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "leaf", name: "leaf", pkg: "lute/render", typ: $funcType([$String, ptrType$1], [], false)}, {prop: "val", name: "val", pkg: "lute/render", typ: $funcType([$String, ptrType$1], [], false)}, {prop: "openObj", name: "openObj", pkg: "lute/render", typ: $funcType([], [], false)}, {prop: "closeObj", name: "closeObj", pkg: "lute/render", typ: $funcType([ptrType$1], [], false)}, {prop: "openChildren", name: "openChildren", pkg: "lute/render", typ: $funcType([ptrType$1], [], false)}, {prop: "closeChildren", name: "closeChildren", pkg: "lute/render", typ: $funcType([ptrType$1], [], false)}, {prop: "comma", name: "comma", pkg: "lute/render", typ: $funcType([], [], false)}, {prop: "ignore", name: "ignore", pkg: "lute/render", typ: $funcType([ptrType$1], [$Bool], false)}];
	ptrType$11.methods = [{prop: "Render", name: "Render", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "renderHtmlEntity", name: "renderHtmlEntity", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslashContent", name: "renderBackslashContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslash", name: "renderBackslash", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderToC", name: "renderToC", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesRef", name: "renderFootnotesRef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesDef", name: "renderFootnotesDef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiAlias", name: "renderEmojiAlias", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiImg", name: "renderEmojiImg", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiUnicode", name: "renderEmojiUnicode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmoji", name: "renderEmoji", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableCell", name: "renderTableCell", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableRow", name: "renderTableRow", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableHead", name: "renderTableHead", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTable", name: "renderTable", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough", name: "renderStrikethrough", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough1OpenMarker", name: "renderStrikethrough1OpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough1CloseMarker", name: "renderStrikethrough1CloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough2OpenMarker", name: "renderStrikethrough2OpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough2CloseMarker", name: "renderStrikethrough2CloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkTitle", name: "renderLinkTitle", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkDest", name: "renderLinkDest", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkSpace", name: "renderLinkSpace", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkText", name: "renderLinkText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCloseParen", name: "renderCloseParen", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderOpenParen", name: "renderOpenParen", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCloseBracket", name: "renderCloseBracket", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderOpenBracket", name: "renderOpenBracket", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBang", name: "renderBang", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderImage", name: "renderImage", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLink", name: "renderLink", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHTML", name: "renderHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineHTML", name: "renderInlineHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderDocument", name: "renderDocument", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderParagraph", name: "renderParagraph", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderText", name: "renderText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpan", name: "renderCodeSpan", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanOpenMarker", name: "renderCodeSpanOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanContent", name: "renderCodeSpanContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanCloseMarker", name: "renderCodeSpanCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathCloseMarker", name: "renderInlineMathCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathContent", name: "renderInlineMathContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathOpenMarker", name: "renderInlineMathOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMath", name: "renderInlineMath", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockCloseMarker", name: "renderMathBlockCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockContent", name: "renderMathBlockContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockOpenMarker", name: "renderMathBlockOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlock", name: "renderMathBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockCloseMarker", name: "renderCodeBlockCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockCode", name: "renderCodeBlockCode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockInfoMarker", name: "renderCodeBlockInfoMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockOpenMarker", name: "renderCodeBlockOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlock", name: "renderCodeBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmphasis", name: "renderEmphasis", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmAsteriskOpenMarker", name: "renderEmAsteriskOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmAsteriskCloseMarker", name: "renderEmAsteriskCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmUnderscoreOpenMarker", name: "renderEmUnderscoreOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmUnderscoreCloseMarker", name: "renderEmUnderscoreCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrong", name: "renderStrong", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongA6kOpenMarker", name: "renderStrongA6kOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongA6kCloseMarker", name: "renderStrongA6kCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongU8eOpenMarker", name: "renderStrongU8eOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongU8eCloseMarker", name: "renderStrongU8eCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquote", name: "renderBlockquote", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquoteMarker", name: "renderBlockquoteMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeading", name: "renderHeading", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeadingC8hMarker", name: "renderHeadingC8hMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderList", name: "renderList", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderListItem", name: "renderListItem", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTaskListItemMarker", name: "renderTaskListItemMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderThematicBreak", name: "renderThematicBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHardBreak", name: "renderHardBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderSoftBreak", name: "renderSoftBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "isLastNode", name: "isLastNode", pkg: "lute/render", typ: $funcType([ptrType$1, ptrType$1], [$Bool], false)}];
	ptrType$12.methods = [{prop: "renderCodeBlock", name: "renderCodeBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockCode", name: "renderCodeBlockCode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHtmlEntity", name: "renderHtmlEntity", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslashContent", name: "renderBackslashContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslash", name: "renderBackslash", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderToC", name: "renderToC", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "RenderFootnotesDefs", name: "RenderFootnotesDefs", pkg: "", typ: $funcType([ptrType$5], [sliceType$3], false)}, {prop: "renderFootnotesRef", name: "renderFootnotesRef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesDef", name: "renderFootnotesDef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockCloseMarker", name: "renderCodeBlockCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockInfoMarker", name: "renderCodeBlockInfoMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockOpenMarker", name: "renderCodeBlockOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiAlias", name: "renderEmojiAlias", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiImg", name: "renderEmojiImg", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiUnicode", name: "renderEmojiUnicode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmoji", name: "renderEmoji", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathCloseMarker", name: "renderInlineMathCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathContent", name: "renderInlineMathContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathOpenMarker", name: "renderInlineMathOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMath", name: "renderInlineMath", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockCloseMarker", name: "renderMathBlockCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockContent", name: "renderMathBlockContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockOpenMarker", name: "renderMathBlockOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlock", name: "renderMathBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableCell", name: "renderTableCell", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableRow", name: "renderTableRow", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableHead", name: "renderTableHead", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTable", name: "renderTable", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough", name: "renderStrikethrough", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough1OpenMarker", name: "renderStrikethrough1OpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough1CloseMarker", name: "renderStrikethrough1CloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough2OpenMarker", name: "renderStrikethrough2OpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough2CloseMarker", name: "renderStrikethrough2CloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkTitle", name: "renderLinkTitle", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkDest", name: "renderLinkDest", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkSpace", name: "renderLinkSpace", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkText", name: "renderLinkText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCloseParen", name: "renderCloseParen", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderOpenParen", name: "renderOpenParen", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCloseBracket", name: "renderCloseBracket", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderOpenBracket", name: "renderOpenBracket", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBang", name: "renderBang", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderImage", name: "renderImage", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLink", name: "renderLink", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHTML", name: "renderHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineHTML", name: "renderInlineHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderDocument", name: "renderDocument", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderParagraph", name: "renderParagraph", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderText", name: "renderText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpan", name: "renderCodeSpan", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanOpenMarker", name: "renderCodeSpanOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanContent", name: "renderCodeSpanContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanCloseMarker", name: "renderCodeSpanCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmphasis", name: "renderEmphasis", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmAsteriskOpenMarker", name: "renderEmAsteriskOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmAsteriskCloseMarker", name: "renderEmAsteriskCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmUnderscoreOpenMarker", name: "renderEmUnderscoreOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmUnderscoreCloseMarker", name: "renderEmUnderscoreCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrong", name: "renderStrong", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongA6kOpenMarker", name: "renderStrongA6kOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongA6kCloseMarker", name: "renderStrongA6kCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongU8eOpenMarker", name: "renderStrongU8eOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongU8eCloseMarker", name: "renderStrongU8eCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquote", name: "renderBlockquote", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquoteMarker", name: "renderBlockquoteMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeading", name: "renderHeading", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeadingC8hMarker", name: "renderHeadingC8hMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderList", name: "renderList", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderListItem", name: "renderListItem", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTaskListItemMarker", name: "renderTaskListItemMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderThematicBreak", name: "renderThematicBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHardBreak", name: "renderHardBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderSoftBreak", name: "renderSoftBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "tag", name: "tag", pkg: "lute/render", typ: $funcType([$String, sliceType$7, $Bool], [], false)}];
	ptrType$2.methods = [{prop: "ChinesePunct", name: "ChinesePunct", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "renderMindmap", name: "renderMindmap", pkg: "lute/render", typ: $funcType([sliceType$3], [sliceType$3], false)}, {prop: "Render", name: "Render", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "renderDefault", name: "renderDefault", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "WriteByte", name: "WriteByte", pkg: "", typ: $funcType([$Uint8], [], false)}, {prop: "Write", name: "Write", pkg: "", typ: $funcType([sliceType$3], [], false)}, {prop: "WriteString", name: "WriteString", pkg: "", typ: $funcType([$String], [], false)}, {prop: "Newline", name: "Newline", pkg: "", typ: $funcType([], [], false)}, {prop: "TextAutoSpacePrevious", name: "TextAutoSpacePrevious", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "TextAutoSpaceNext", name: "TextAutoSpaceNext", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "LinkTextAutoSpacePrevious", name: "LinkTextAutoSpacePrevious", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "LinkTextAutoSpaceNext", name: "LinkTextAutoSpaceNext", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "headings", name: "headings", pkg: "lute/render", typ: $funcType([], [sliceType$6], false)}, {prop: "Space", name: "Space", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "FixTermTypo", name: "FixTermTypo", pkg: "", typ: $funcType([ptrType$1], [], false)}, {prop: "fixTermTypo0", name: "fixTermTypo0", pkg: "lute/render", typ: $funcType([sliceType$3], [sliceType$3], false)}];
	ptrType$13.methods = [{prop: "Render", name: "Render", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "RenderFootnotesDefs", name: "RenderFootnotesDefs", pkg: "", typ: $funcType([ptrType$5], [sliceType$3], false)}, {prop: "renderHtmlEntity", name: "renderHtmlEntity", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslashContent", name: "renderBackslashContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslash", name: "renderBackslash", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderToC", name: "renderToC", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesDef", name: "renderFootnotesDef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesRef", name: "renderFootnotesRef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockCloseMarker", name: "renderCodeBlockCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockInfoMarker", name: "renderCodeBlockInfoMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockOpenMarker", name: "renderCodeBlockOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiAlias", name: "renderEmojiAlias", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiImg", name: "renderEmojiImg", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiUnicode", name: "renderEmojiUnicode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmoji", name: "renderEmoji", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathCloseMarker", name: "renderInlineMathCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathContent", name: "renderInlineMathContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathOpenMarker", name: "renderInlineMathOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMath", name: "renderInlineMath", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockCloseMarker", name: "renderMathBlockCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockContent", name: "renderMathBlockContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockOpenMarker", name: "renderMathBlockOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlock", name: "renderMathBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableCell", name: "renderTableCell", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableRow", name: "renderTableRow", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableHead", name: "renderTableHead", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTable", name: "renderTable", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough", name: "renderStrikethrough", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough1OpenMarker", name: "renderStrikethrough1OpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough1CloseMarker", name: "renderStrikethrough1CloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough2OpenMarker", name: "renderStrikethrough2OpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough2CloseMarker", name: "renderStrikethrough2CloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkTitle", name: "renderLinkTitle", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkDest", name: "renderLinkDest", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkSpace", name: "renderLinkSpace", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkText", name: "renderLinkText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCloseParen", name: "renderCloseParen", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderOpenParen", name: "renderOpenParen", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCloseBracket", name: "renderCloseBracket", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderOpenBracket", name: "renderOpenBracket", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBang", name: "renderBang", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderImage", name: "renderImage", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLink", name: "renderLink", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHTML", name: "renderHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineHTML", name: "renderInlineHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderDocument", name: "renderDocument", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderParagraph", name: "renderParagraph", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderText", name: "renderText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpan", name: "renderCodeSpan", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanOpenMarker", name: "renderCodeSpanOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanContent", name: "renderCodeSpanContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanCloseMarker", name: "renderCodeSpanCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmphasis", name: "renderEmphasis", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmAsteriskOpenMarker", name: "renderEmAsteriskOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmAsteriskCloseMarker", name: "renderEmAsteriskCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmUnderscoreOpenMarker", name: "renderEmUnderscoreOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmUnderscoreCloseMarker", name: "renderEmUnderscoreCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrong", name: "renderStrong", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongA6kOpenMarker", name: "renderStrongA6kOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongA6kCloseMarker", name: "renderStrongA6kCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongU8eOpenMarker", name: "renderStrongU8eOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongU8eCloseMarker", name: "renderStrongU8eCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquote", name: "renderBlockquote", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquoteMarker", name: "renderBlockquoteMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeading", name: "renderHeading", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeadingC8hMarker", name: "renderHeadingC8hMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderList", name: "renderList", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderListItem", name: "renderListItem", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTaskListItemMarker", name: "renderTaskListItemMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderThematicBreak", name: "renderThematicBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHardBreak", name: "renderHardBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderSoftBreak", name: "renderSoftBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "tag", name: "tag", pkg: "lute/render", typ: $funcType([$String, sliceType$7, $Bool], [], false)}, {prop: "renderCodeBlock", name: "renderCodeBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockCode", name: "renderCodeBlockCode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}];
	ptrType$14.methods = [{prop: "Render", name: "Render", pkg: "", typ: $funcType([], [sliceType$3], false)}, {prop: "RenderFootnotesDefs", name: "RenderFootnotesDefs", pkg: "", typ: $funcType([ptrType$5], [sliceType$3], false)}, {prop: "renderHtmlEntity", name: "renderHtmlEntity", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslashContent", name: "renderBackslashContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBackslash", name: "renderBackslash", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderToC", name: "renderToC", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesDef", name: "renderFootnotesDef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderFootnotesRef", name: "renderFootnotesRef", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockCloseMarker", name: "renderCodeBlockCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockInfoMarker", name: "renderCodeBlockInfoMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockOpenMarker", name: "renderCodeBlockOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlock", name: "renderCodeBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeBlockCode", name: "renderCodeBlockCode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiAlias", name: "renderEmojiAlias", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiImg", name: "renderEmojiImg", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmojiUnicode", name: "renderEmojiUnicode", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmoji", name: "renderEmoji", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathCloseMarker", name: "renderInlineMathCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathContent", name: "renderInlineMathContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMathOpenMarker", name: "renderInlineMathOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineMath", name: "renderInlineMath", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockCloseMarker", name: "renderMathBlockCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockContent", name: "renderMathBlockContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlockOpenMarker", name: "renderMathBlockOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderMathBlock", name: "renderMathBlock", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableCell", name: "renderTableCell", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableRow", name: "renderTableRow", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTableHead", name: "renderTableHead", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTable", name: "renderTable", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough", name: "renderStrikethrough", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough1OpenMarker", name: "renderStrikethrough1OpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough1CloseMarker", name: "renderStrikethrough1CloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough2OpenMarker", name: "renderStrikethrough2OpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrikethrough2CloseMarker", name: "renderStrikethrough2CloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkTitle", name: "renderLinkTitle", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkDest", name: "renderLinkDest", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkSpace", name: "renderLinkSpace", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLinkText", name: "renderLinkText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCloseParen", name: "renderCloseParen", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderOpenParen", name: "renderOpenParen", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCloseBracket", name: "renderCloseBracket", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderOpenBracket", name: "renderOpenBracket", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBang", name: "renderBang", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderImage", name: "renderImage", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderLink", name: "renderLink", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHTML", name: "renderHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderInlineHTML", name: "renderInlineHTML", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderDocument", name: "renderDocument", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderParagraph", name: "renderParagraph", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderText", name: "renderText", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpan", name: "renderCodeSpan", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanOpenMarker", name: "renderCodeSpanOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanContent", name: "renderCodeSpanContent", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderCodeSpanCloseMarker", name: "renderCodeSpanCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmphasis", name: "renderEmphasis", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmAsteriskOpenMarker", name: "renderEmAsteriskOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmAsteriskCloseMarker", name: "renderEmAsteriskCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmUnderscoreOpenMarker", name: "renderEmUnderscoreOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderEmUnderscoreCloseMarker", name: "renderEmUnderscoreCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrong", name: "renderStrong", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongA6kOpenMarker", name: "renderStrongA6kOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongA6kCloseMarker", name: "renderStrongA6kCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongU8eOpenMarker", name: "renderStrongU8eOpenMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderStrongU8eCloseMarker", name: "renderStrongU8eCloseMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquote", name: "renderBlockquote", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderBlockquoteMarker", name: "renderBlockquoteMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeading", name: "renderHeading", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHeadingC8hMarker", name: "renderHeadingC8hMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderList", name: "renderList", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderListItem", name: "renderListItem", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderTaskListItemMarker", name: "renderTaskListItemMarker", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderThematicBreak", name: "renderThematicBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderHardBreak", name: "renderHardBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "renderSoftBreak", name: "renderSoftBreak", pkg: "lute/render", typ: $funcType([ptrType$1, $Bool], [ast.WalkStatus], false)}, {prop: "tag", name: "tag", pkg: "lute/render", typ: $funcType([$String, sliceType$7, $Bool], [], false)}, {prop: "renderSpanNode", name: "renderSpanNode", pkg: "lute/render", typ: $funcType([ptrType$1], [], false)}, {prop: "renderDivNode", name: "renderDivNode", pkg: "lute/render", typ: $funcType([ptrType$1], [], false)}, {prop: "Text", name: "Text", pkg: "", typ: $funcType([ptrType$1], [$String], false)}];
	EChartsJSONRenderer.init("", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$2, tag: ""}]);
	FormatRenderer.init("lute/render", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$2, tag: ""}, {prop: "nodeWriterStack", name: "nodeWriterStack", embedded: false, exported: false, typ: sliceType$2, tag: ""}]);
	HtmlRenderer.init("lute/render", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$2, tag: ""}, {prop: "needRenderFootnotesDef", name: "needRenderFootnotesDef", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	RendererFunc.init([ptrType$1, $Bool], [ast.WalkStatus], false);
	ExtRendererFunc.init([ptrType$1, $Bool], [$String, ast.WalkStatus], false);
	BaseRenderer.init("", [{prop: "Option", name: "Option", embedded: false, exported: true, typ: ptrType$8, tag: ""}, {prop: "RendererFuncs", name: "RendererFuncs", embedded: false, exported: true, typ: mapType, tag: ""}, {prop: "DefaultRendererFunc", name: "DefaultRendererFunc", embedded: false, exported: true, typ: RendererFunc, tag: ""}, {prop: "ExtRendererFuncs", name: "ExtRendererFuncs", embedded: false, exported: true, typ: mapType$1, tag: ""}, {prop: "Writer", name: "Writer", embedded: false, exported: true, typ: ptrType$3, tag: ""}, {prop: "LastOut", name: "LastOut", embedded: false, exported: true, typ: $Uint8, tag: ""}, {prop: "Tree", name: "Tree", embedded: false, exported: true, typ: ptrType$9, tag: ""}, {prop: "DisableTags", name: "DisableTags", embedded: false, exported: true, typ: $Int, tag: ""}]);
	VditorRenderer.init("lute/render", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$2, tag: ""}, {prop: "needRenderFootnotesDef", name: "needRenderFootnotesDef", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	VditorIRRenderer.init("lute/render", [{prop: "BaseRenderer", name: "BaseRenderer", embedded: true, exported: true, typ: ptrType$2, tag: ""}, {prop: "needRenderFootnotesDef", name: "needRenderFootnotesDef", embedded: false, exported: false, typ: $Bool, tag: ""}]);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = io.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = ast.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = html.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = lex.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = parse.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = util.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = unicode.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = utf8.$init(); /* */ $s = 11; case 11: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		maxCommonFileTypeLen = 10;
		commonFileTypes = new sliceType(["jpg", "png", "gif", "webp", "cr2", "tif", "bmp", "heif", "jxr", "psd", "ico", "dwg", "mp4", "m4v", "mkv", "webm", "mov", "avi", "wmv", "mpg", "flv", "3gp", "mid", "mp3", "m4a", "ogg", "flac", "wav", "amr", "aac", "epub", "zip", "tar", "rar", "gz", "bz2", "7z", "xz", "pdf", "exe", "swf", "rtf", "iso", "eot", "ps", "sqli", "nes", "crx", "cab", "deb", "ar", "Z", "lz", "rpm", "elf", "dcm", "doc", "docx", "xls", "xlsx", "ppt", "pptx", "md", "txt", "woff", "woff2", "ttf", "otf", "wasm", "exe", "html", "js", "css", "go", "java", "textbundle"]);
		commonFileTypesLen = commonFileTypes.$length;
		headingLevel = " 123456";
		setOfElementsToSkipContent = $makeMap($String.keyFor, [{ k: "frame", v: $ifaceNil }, { k: "frameset", v: $ifaceNil }, { k: "noembed", v: $ifaceNil }, { k: "noframes", v: $ifaceNil }, { k: "noscript", v: $ifaceNil }, { k: "nostyle", v: $ifaceNil }, { k: "object", v: $ifaceNil }, { k: "script", v: $ifaceNil }, { k: "style", v: $ifaceNil }, { k: "title", v: $ifaceNil }]);
		allowedAttrs = $makeMap($String.keyFor, [{ k: "id", v: $ifaceNil }, { k: "title", v: $ifaceNil }, { k: "alt", v: $ifaceNil }, { k: "href", v: $ifaceNil }, { k: "src", v: $ifaceNil }, { k: "class", v: $ifaceNil }, { k: "value", v: $ifaceNil }, { k: "align", v: $ifaceNil }, { k: "height", v: $ifaceNil }, { k: "width", v: $ifaceNil }, { k: "data", v: $ifaceNil }]);
		terms = $makeMap($String.keyFor, [{ k: "flutter", v: "Flutter" }, { k: "netty", v: "Netty" }, { k: "jetty", v: "Jetty" }, { k: "tomcat", v: "Tomcat" }, { k: "jdbc", v: "JDBC" }, { k: "mariadb", v: "MariaDB" }, { k: "ipfs", v: "IPFS" }, { k: "saas", v: "SaaS" }, { k: "paas", v: "PaaS" }, { k: "iaas", v: "IaaS" }, { k: "ioc", v: "IoC" }, { k: "freemarker", v: "FreeMarker" }, { k: "ruby", v: "Ruby" }, { k: "rails", v: "Rails" }, { k: "mina", v: "Mina" }, { k: "puppet", v: "Puppet" }, { k: "vagrant", v: "Vagrant" }, { k: "chef", v: "Chef" }, { k: "beego", v: "Beego" }, { k: "gin", v: "Gin" }, { k: "iris", v: "Iris" }, { k: "php", v: "PHP" }, { k: "ssh", v: "SSH" }, { k: "web", v: "Web" }, { k: "websocket", v: "WebSocket" }, { k: "api", v: "API" }, { k: "css", v: "CSS" }, { k: "html", v: "HTML" }, { k: "json", v: "JSON" }, { k: "jsonp", v: "JSONP" }, { k: "xml", v: "XML" }, { k: "yaml", v: "YAML" }, { k: "csv", v: "CSV" }, { k: "soap", v: "SOAP" }, { k: "ajax", v: "AJAX" }, { k: "messagepack", v: "MessagePack" }, { k: "javascript", v: "JavaScript" }, { k: "java", v: "Java" }, { k: "jsp", v: "JSP" }, { k: "restful", v: "RESTFul" }, { k: "graphql", v: "GraphQL" }, { k: "gorm", v: "GORM" }, { k: "orm", v: "ORM" }, { k: "oauth", v: "OAuth" }, { k: "facebook", v: "Facebook" }, { k: "github", v: "GitHub" }, { k: "gist", v: "Gist" }, { k: "heroku", v: "Heroku" }, { k: "twitter", v: "Twitter" }, { k: "youtube", v: "YouTube" }, { k: "dynamodb", v: "DynamoDB" }, { k: "mysql", v: "MySQL" }, { k: "postgresql", v: "PostgreSQL" }, { k: "sqlite", v: "SQLite" }, { k: "memcached", v: "Memcached" }, { k: "mongodb", v: "MongoDB" }, { k: "redis", v: "Redis" }, { k: "elasticsearch", v: "Elasticsearch" }, { k: "solr", v: "Solr" }, { k: "b3log", v: "B3log" }, { k: "hacpai", v: "HacPai" }, { k: "sphinx", v: "Sphinx" }, { k: "linux", v: "Linux" }, { k: "ubuntu", v: "Ubuntu" }, { k: "centos", v: "CentOS" }, { k: "centos7", v: "CentOS7" }, { k: "redhat", v: "RedHat" }, { k: "gitlab", v: "GitLab" }, { k: "jquery", v: "jQuery" }, { k: "angularjs", v: "AngularJS" }, { k: "ffmpeg", v: "FFmpeg" }, { k: "git", v: "Git" }, { k: "svn", v: "SVN" }, { k: "vim", v: "VIM" }, { k: "emacs", v: "Emacs" }, { k: "sublime", v: "Sublime" }, { k: "virtualbox", v: "VirtualBox" }, { k: "safari", v: "Safari" }, { k: "chrome", v: "Chrome" }, { k: "ie", v: "IE" }, { k: "firefox", v: "Firefox" }, { k: "iterm", v: "iTerm" }, { k: "iterm2", v: "iTerm2" }, { k: "iwork", v: "iWork" }, { k: "itunes", v: "iTunes" }, { k: "iphoto", v: "iPhoto" }, { k: "ibook", v: "iBook" }, { k: "imessage", v: "iMessage" }, { k: "photoshop", v: "Photoshop" }, { k: "excel", v: "Excel" }, { k: "powerpoint", v: "PowerPoint" }, { k: "ios", v: "iOS" }, { k: "iphone", v: "iPhone" }, { k: "ipad", v: "iPad" }, { k: "android", v: "Android" }, { k: "imac", v: "iMac" }, { k: "macbook", v: "MacBook" }, { k: "vps", v: "VPS" }, { k: "vpn", v: "VPN" }, { k: "cpu", v: "CPU" }, { k: "spring", v: "Spring" }, { k: "springboot", v: "SpringBoot" }, { k: "springcloud", v: "SpringCloud" }, { k: "springmvc", v: "SpringMVC" }, { k: "mybatis", v: "MyBatis" }, { k: "qq", v: "QQ" }, { k: "sql", v: "SQL" }, { k: "markdown", v: "Markdown" }, { k: "jdk", v: "JDK" }, { k: "openjdk", v: "OpenJDK" }, { k: "cors", v: "CORS" }, { k: "protobuf", v: "Protobuf" }, { k: "google", v: "Google" }, { k: "ibm", v: "IBM" }, { k: "oracle", v: "Oracle" }, { k: "typora", v: "Typora" }]);
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute"] = (function() {
	var $pkg = {}, $init, bytes, js, ast, html, atom, parse, render, util, strconv, strings, Lute, Option, ptrType, sliceType, ptrType$1, ptrType$2, ptrType$3, ptrType$4, sliceType$1, ptrType$5, sliceType$2, sliceType$3, ptrType$6, ptrType$7, ptrType$8, mapType, sliceType$4, sliceType$5, sliceType$6, ptrType$9, sliceType$7, mapType$1, ptrType$10, mapType$2, mapType$3, ptrType$11, mapType$4, New, NewOptions;
	bytes = $packages["bytes"];
	js = $packages["github.com/gopherjs/gopherjs/js"];
	ast = $packages["lute/ast"];
	html = $packages["lute/html"];
	atom = $packages["lute/html/atom"];
	parse = $packages["lute/parse"];
	render = $packages["lute/render"];
	util = $packages["lute/util"];
	strconv = $packages["strconv"];
	strings = $packages["strings"];
	Lute = $pkg.Lute = $newType(0, $kindStruct, "lute.Lute", true, "lute", true, function(Options_, HTML2MdRendererFuncs_, HTML2VditorDOMRendererFuncs_, HTML2VditorIRDOMRendererFuncs_, Md2HTMLRendererFuncs_, Md2VditorDOMRendererFuncs_, Md2VditorIRDOMRendererFuncs_) {
		this.$val = this;
		if (arguments.length === 0) {
			this.Options = ptrType$7.nil;
			this.HTML2MdRendererFuncs = false;
			this.HTML2VditorDOMRendererFuncs = false;
			this.HTML2VditorIRDOMRendererFuncs = false;
			this.Md2HTMLRendererFuncs = false;
			this.Md2VditorDOMRendererFuncs = false;
			this.Md2VditorIRDOMRendererFuncs = false;
			return;
		}
		this.Options = Options_;
		this.HTML2MdRendererFuncs = HTML2MdRendererFuncs_;
		this.HTML2VditorDOMRendererFuncs = HTML2VditorDOMRendererFuncs_;
		this.HTML2VditorIRDOMRendererFuncs = HTML2VditorIRDOMRendererFuncs_;
		this.Md2HTMLRendererFuncs = Md2HTMLRendererFuncs_;
		this.Md2VditorDOMRendererFuncs = Md2VditorDOMRendererFuncs_;
		this.Md2VditorIRDOMRendererFuncs = Md2VditorIRDOMRendererFuncs_;
	});
	Option = $pkg.Option = $newType(4, $kindFunc, "lute.Option", true, "lute", true, null);
	ptrType = $ptrType(html.Node);
	sliceType = $sliceType(html.Attribute);
	ptrType$1 = $ptrType(ast.Node);
	ptrType$2 = $ptrType(parse.Context);
	ptrType$3 = $ptrType($packages["lute/lex"].Lexer);
	ptrType$4 = $ptrType(parse.InlineContext);
	sliceType$1 = $sliceType($Uint8);
	ptrType$5 = $ptrType(ast.ListData);
	sliceType$2 = $sliceType($Int);
	sliceType$3 = $sliceType(ptrType$1);
	ptrType$6 = $ptrType(parse.Tree);
	ptrType$7 = $ptrType(parse.Options);
	ptrType$8 = $ptrType(Lute);
	mapType = $mapType($String, $emptyInterface);
	sliceType$4 = $sliceType($emptyInterface);
	sliceType$5 = $sliceType(html.ParseOption);
	sliceType$6 = $sliceType(ptrType);
	ptrType$9 = $ptrType(sliceType$6);
	sliceType$7 = $sliceType(atom.Atom);
	mapType$1 = $mapType($String, $String);
	ptrType$10 = $ptrType(js.Object);
	mapType$2 = $mapType($String, ptrType$10);
	mapType$3 = $mapType($String, mapType$2);
	ptrType$11 = $ptrType(bytes.Buffer);
	mapType$4 = $mapType(ast.NodeType, render.ExtRendererFunc);
	Lute.ptr.prototype.HTML2Markdown = function(htmlStr) {
		var _entry, _i, _i$1, _key, _keys, _r, _r$1, _ref, _ref$1, _tuple, err, formatted, htmlNode, htmlNodes, htmlRoot, htmlStr, lute, markdown, nodeType, reader, renderer, rendererFunc, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _i$1 = $f._i$1; _key = $f._key; _keys = $f._keys; _r = $f._r; _r$1 = $f._r$1; _ref = $f._ref; _ref$1 = $f._ref$1; _tuple = $f._tuple; err = $f.err; formatted = $f.formatted; htmlNode = $f.htmlNode; htmlNodes = $f.htmlNodes; htmlRoot = $f.htmlRoot; htmlStr = $f.htmlStr; lute = $f.lute; markdown = $f.markdown; nodeType = $f.nodeType; reader = $f.reader; renderer = $f.renderer; rendererFunc = $f.rendererFunc; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		markdown = "";
		err = $ifaceNil;
		lute = this;
		reader = strings.NewReader(htmlStr);
		htmlRoot = new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, 0, "", "", sliceType.nil);
		_r = html.ParseFragment(reader, htmlRoot); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		htmlNodes = _tuple[0];
		err = _tuple[1];
		if (!($interfaceIsEqual($ifaceNil, err))) {
			$s = -1; return [markdown, err];
		}
		$r = lute.adjustVditorDOM(htmlNodes); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		tree = new parse.Tree.ptr("", new ast.Node.ptr(0, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil), new parse.Context.ptr(ptrType$6.nil, lute.Options, false, sliceType$3.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, 0, 0, 0, 0, 0, 0, 0, false, false, false, false, ptrType$1.nil), ptrType$3.nil, ptrType$4.nil);
		tree.Context.Tip = tree.Root;
		_ref = htmlNodes;
		_i = 0;
		/* while (true) { */ case 3:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 4; continue; }
			htmlNode = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			$r = lute.genASTByDOM(htmlNode, tree); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 3; continue; case 4:
		$r = ast.Walk(tree.Root, (function(n, entering) {
			var entering, n, previousLi;
			if (entering) {
				if (7 === n.Type) {
					if (!(ptrType$1.nil === n.Parent) && (7 === n.Parent.Type)) {
						previousLi = n.Previous;
						if (!(ptrType$1.nil === previousLi)) {
							n.Unlink();
							previousLi.AppendChild(n);
						}
					}
				}
			}
			return 2;
		})); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		formatted = sliceType$1.nil;
		renderer = render.NewFormatRenderer(tree);
		_ref$1 = lute.HTML2MdRendererFuncs;
		_i$1 = 0;
		_keys = $keys(_ref$1);
		while (true) {
			if (!(_i$1 < _keys.length)) { break; }
			_entry = _ref$1[_keys[_i$1]];
			if (_entry === undefined) {
				_i$1++;
				continue;
			}
			nodeType = _entry.k;
			rendererFunc = _entry.v;
			_key = nodeType; (renderer.BaseRenderer.ExtRendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: rendererFunc };
			_i$1++;
		}
		_r$1 = renderer.Render(); /* */ $s = 7; case 7: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		formatted = _r$1;
		markdown = util.BytesToStr(formatted);
		$s = -1; return [markdown, err];
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.HTML2Markdown }; } $f._entry = _entry; $f._i = _i; $f._i$1 = _i$1; $f._key = _key; $f._keys = _keys; $f._r = _r; $f._r$1 = _r$1; $f._ref = _ref; $f._ref$1 = _ref$1; $f._tuple = _tuple; $f.err = err; $f.formatted = formatted; $f.htmlNode = htmlNode; $f.htmlNodes = htmlNodes; $f.htmlRoot = htmlRoot; $f.htmlStr = htmlStr; $f.lute = lute; $f.markdown = markdown; $f.nodeType = nodeType; $f.reader = reader; $f.renderer = renderer; $f.rendererFunc = rendererFunc; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.HTML2Markdown = function(htmlStr) { return this.$val.HTML2Markdown(htmlStr); };
	Lute.ptr.prototype.genASTByDOM = function(n, tree) {
		var _1, _2, _3, _4, _r, _r$1, _r$2, _r$3, align, align$1, buf, buf$1, bullet, c, c$1, class$1, class$2, code, content, content$1, content$2, dataRender, emojiImg, firstc, imgAlt, imgClass, language, language$1, linkTitle, linkTitle$1, lute, marker, marker$1, marker$2, marker$3, marker$4, marker$5, marker$6, n, node, start, table, tableAlign, tableAligns, th, thead, tree, unescaped, x, x$1, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; align = $f.align; align$1 = $f.align$1; buf = $f.buf; buf$1 = $f.buf$1; bullet = $f.bullet; c = $f.c; c$1 = $f.c$1; class$1 = $f.class$1; class$2 = $f.class$2; code = $f.code; content = $f.content; content$1 = $f.content$1; content$2 = $f.content$2; dataRender = $f.dataRender; emojiImg = $f.emojiImg; firstc = $f.firstc; imgAlt = $f.imgAlt; imgClass = $f.imgClass; language = $f.language; language$1 = $f.language$1; linkTitle = $f.linkTitle; linkTitle$1 = $f.linkTitle$1; lute = $f.lute; marker = $f.marker; marker$1 = $f.marker$1; marker$2 = $f.marker$2; marker$3 = $f.marker$3; marker$4 = $f.marker$4; marker$5 = $f.marker$5; marker$6 = $f.marker$6; n = $f.n; node = $f.node; start = $f.start; table = $f.table; tableAlign = $f.tableAlign; tableAligns = $f.tableAligns; th = $f.th; thead = $f.thead; tree = $f.tree; unescaped = $f.unescaped; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		lute = this;
		if ((4 === n.Type) || (309252 === n.DataAtom)) {
			$s = -1; return;
		}
		if ("svg" === n.Namespace) {
			$s = -1; return;
		}
		dataRender = lute.domAttrValue(n, "data-render");
		if ("1" === dataRender) {
			$s = -1; return;
		}
		/* */ if ((0 === n.DataAtom) && (3 === n.Type)) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if ((0 === n.DataAtom) && (3 === n.Type)) { */ case 1:
			c = n.FirstChild;
			/* while (true) { */ case 3:
				/* if (!(!(c === ptrType.nil))) { break; } */ if(!(!(c === ptrType.nil))) { $s = 4; continue; }
				$r = lute.genASTByDOM(c, tree); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
				c = c.NextSibling;
			/* } */ $s = 3; continue; case 4:
			$s = -1; return;
		/* } */ case 2:
		node = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(n.Data), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
			_1 = n.DataAtom;
			/* */ if (_1 === (0)) { $s = 7; continue; }
			/* */ if ((_1 === (3073)) || (_1 === (92931)) || (_1 === (354311))) { $s = 8; continue; }
			/* */ if ((_1 === (89090)) || (_1 === (187906)) || (_1 === (199938)) || (_1 === (214274)) || (_1 === (216834)) || (_1 === (412930))) { $s = 9; continue; }
			/* */ if (_1 === (87810)) { $s = 10; continue; }
			/* */ if (_1 === (100106)) { $s = 11; continue; }
			/* */ if ((_1 === (79618)) || (_1 === (42754))) { $s = 12; continue; }
			/* */ if (_1 === (45570)) { $s = 13; continue; }
			/* */ if (_1 === (290819)) { $s = 14; continue; }
			/* */ if ((_1 === (28162)) || (_1 === (1537))) { $s = 15; continue; }
			/* */ if ((_1 === (449798)) || (_1 === (257))) { $s = 16; continue; }
			/* */ if (_1 === (378116)) { $s = 17; continue; }
			/* */ if (_1 === (514)) { $s = 18; continue; }
			/* */ if (_1 === (1)) { $s = 19; continue; }
			/* */ if (_1 === (198403)) { $s = 20; continue; }
			/* */ if (_1 === (281349)) { $s = 21; continue; }
			/* */ if ((_1 === (283139)) || (_1 === (9473)) || (_1 === (53766))) { $s = 22; continue; }
			/* */ if (_1 === (365829)) { $s = 23; continue; }
			/* */ if (_1 === (208901)) { $s = 24; continue; }
			/* */ if (_1 === (9989)) { $s = 25; continue; }
			/* */ if (_1 === (52226)) { $s = 26; continue; }
			/* */ if ((_1 === (87554)) || (_1 === (37378))) { $s = 27; continue; }
			/* */ if (_1 === (40708)) { $s = 28; continue; }
			/* */ if (_1 === (16132)) { $s = 29; continue; }
			/* */ if (_1 === (29191)) { $s = 30; continue; }
			/* */ if (_1 === (459783)) { $s = 31; continue; }
			/* */ if ((_1 === (195590)) || (_1 === (70917)) || (_1 === (192773))) { $s = 32; continue; }
			/* */ $s = 33; continue;
			/* if (_1 === (0)) { */ case 7:
				if (!(ptrType.nil === n.Parent) && (1 === n.Parent.DataAtom)) {
					node.Type = 40;
				}
				node.Tokens = bytes.ReplaceAll(node.Tokens, new sliceType$1([194, 160]), new sliceType$1([32]));
				tree.Context.Tip.AppendChild(node);
				$s = 33; continue;
			/* } else if ((_1 === (3073)) || (_1 === (92931)) || (_1 === (354311))) { */ case 8:
				if (92931 === n.DataAtom) {
					class$1 = lute.domAttrValue(n, "class");
					language = "";
					if (strings.Contains(class$1, "-source-")) {
						language = $substring(class$1, (strings.LastIndex(class$1, "-source-") + 8 >> 0));
					} else if (strings.Contains(class$1, "-text-html-basic")) {
						language = "html";
					}
					if (!("" === language)) {
						node.Type = 11;
						node.IsFencedCodeBlock = true;
						node.AppendChild(new ast.Node.ptr(12, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes("```"), false, false, false, 0, false, 0, 3, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						node.AppendChild(new ast.Node.ptr(14, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						buf = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0);
						node.LastChild.CodeBlockInfo = (new sliceType$1($stringToBytes(language)));
						buf.WriteString(lute.domText(n));
						content = new ast.Node.ptr(15, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, buf.Bytes(), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
						node.AppendChild(content);
						node.AppendChild(new ast.Node.ptr(13, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes("```"), false, false, false, 0, false, 0, 3, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						tree.Context.Tip.AppendChild(node);
						$s = -1; return;
					}
				}
				node.Type = 1;
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if ((_1 === (89090)) || (_1 === (187906)) || (_1 === (199938)) || (_1 === (214274)) || (_1 === (216834)) || (_1 === (412930))) { */ case 9:
				node.Type = 2;
				node.HeadingLevel = ((((x = node.Tokens, (1 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 1])) - 48 << 24 >>> 24) >> 0));
				node.AppendChild(new ast.Node.ptr(3, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(strings.Repeat("#", node.HeadingLevel)), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (87810)) { */ case 10:
				node.Type = 4;
				tree.Context.Tip.AppendChild(node);
				$s = 33; continue;
			/* } else if (_1 === (100106)) { */ case 11:
				node.Type = 5;
				node.AppendChild(new ast.Node.ptr(6, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(">"), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if ((_1 === (79618)) || (_1 === (42754))) { */ case 12:
				node.Type = 7;
				node.ListData = new ast.ListData.ptr(0, false, 0, 0, 0, 0, 0, false, sliceType$1.nil, 0);
				if (79618 === n.DataAtom) {
					node.ListData.Typ = 1;
				}
				node.ListData.Tight = true;
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (45570)) { */ case 13:
				node.Type = 8;
				marker = lute.domAttrValue(n, "data-marker");
				bullet = 0;
				if ("" === marker) {
					if (!(ptrType.nil === n.Parent) && (79618 === n.Parent.DataAtom)) {
						start = lute.domAttrValue(n.Parent, "start");
						if ("" === start) {
							marker = "1.";
						} else {
							marker = start + ".";
						}
					} else {
						marker = "*";
						bullet = marker.charCodeAt(0);
					}
				} else {
					if (!(ptrType.nil === n.Parent) && !("1." === marker) && (79618 === n.Parent.DataAtom) && !(ptrType.nil === n.Parent.Parent) && ((79618 === n.Parent.Parent.DataAtom) || (42754 === n.Parent.Parent.DataAtom))) {
						marker = "1.";
					}
				}
				node.ListData = new ast.ListData.ptr(0, false, bullet, 0, 0, 0, 0, false, (new sliceType$1($stringToBytes(marker))), 0);
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (290819)) { */ case 14:
				firstc = n.FirstChild;
				/* */ if (!(ptrType.nil === firstc)) { $s = 34; continue; }
				/* */ $s = 35; continue;
				/* if (!(ptrType.nil === firstc)) { */ case 34:
					/* */ if (378116 === firstc.DataAtom) { $s = 36; continue; }
					/* */ if (40708 === firstc.DataAtom) { $s = 37; continue; }
					/* */ $s = 38; continue;
					/* if (378116 === firstc.DataAtom) { */ case 36:
						node.Type = 11;
						node.IsFencedCodeBlock = true;
						node.AppendChild(new ast.Node.ptr(12, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes("```"), false, false, false, 0, false, 0, 3, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						node.AppendChild(new ast.Node.ptr(14, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						buf$1 = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0);
						class$2 = lute.domAttrValue(firstc, "class");
						if (strings.Contains(class$2, "language-")) {
							language$1 = $substring(class$2, 9);
							node.LastChild.CodeBlockInfo = (new sliceType$1($stringToBytes(language$1)));
						}
						buf$1.WriteString(lute.domText(n));
						content$1 = new ast.Node.ptr(15, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, buf$1.Bytes(), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
						node.AppendChild(content$1);
						node.AppendChild(new ast.Node.ptr(13, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes("```"), false, false, false, 0, false, 0, 3, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						tree.Context.Tip.AppendChild(node);
						$s = 39; continue;
					/* } else if (40708 === firstc.DataAtom) { */ case 37:
						/* break; */ $s = 6; continue;
						$s = 39; continue;
					/* } else { */ case 38:
						node.Type = 9;
						_r = lute.domHTML(n); /* */ $s = 40; case 40: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
						node.Tokens = _r;
						tree.Context.Tip.AppendChild(node);
					/* } */ case 39:
				/* } */ case 35:
				$s = -1; return;
			/* } else if ((_1 === (28162)) || (_1 === (1537))) { */ case 15:
				node.Type = 17;
				marker$1 = "*";
				node.AppendChild(new ast.Node.ptr(18, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(marker$1), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if ((_1 === (449798)) || (_1 === (257))) { */ case 16:
				node.Type = 22;
				marker$2 = "**";
				node.AppendChild(new ast.Node.ptr(23, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(marker$2), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (378116)) { */ case 17:
				if (ptrType.nil === n.FirstChild) {
					$s = -1; return;
				}
				_r$1 = lute.domHTML(n); /* */ $s = 41; case 41: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
				code = _r$1;
				if (bytes.Contains(code, (new sliceType$1($stringToBytes(">"))))) {
					code = $subslice(code, (bytes.Index(code, (new sliceType$1($stringToBytes(">")))) + 1 >> 0));
				}
				code = bytes.TrimSuffix(code, (new sliceType$1($stringToBytes("</code>"))));
				unescaped = html.UnescapeString(($bytesToString(code)));
				code = (new sliceType$1($stringToBytes(unescaped)));
				content$2 = new ast.Node.ptr(29, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, code, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
				node.Type = 27;
				node.AppendChild(new ast.Node.ptr(28, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("`"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				node.AppendChild(content$2);
				node.AppendChild(new ast.Node.ptr(30, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("`"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = -1; return;
			/* } else if (_1 === (514)) { */ case 18:
				node.Type = 31;
				node.Tokens = util.StrToBytes("\n");
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (1)) { */ case 19:
				node.Type = 33;
				if ("" === lute.domText(n) && ((89090 === n.Parent.DataAtom) || (187906 === n.Parent.DataAtom) || (199938 === n.Parent.DataAtom) || (214274 === n.Parent.DataAtom) || (216834 === n.Parent.DataAtom) || (412930 === n.Parent.DataAtom))) {
					$s = -1; return;
				}
				node.AppendChild(new ast.Node.ptr(36, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (198403)) { */ case 20:
				imgClass = lute.domAttrValue(n, "class");
				imgAlt = lute.domAttrValue(n, "alt");
				if ("emoji" === imgClass) {
					node.Type = 200;
					emojiImg = new ast.Node.ptr(202, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, tree.EmojiImgTokens(imgAlt, lute.domAttrValue(n, "src")), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					emojiImg.AppendChild(new ast.Node.ptr(203, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(":" + imgAlt + ":"), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node.AppendChild(emojiImg);
				} else {
					node.Type = 34;
					node.AppendChild(new ast.Node.ptr(35, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node.AppendChild(new ast.Node.ptr(36, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					if (!("" === imgAlt)) {
						node.AppendChild(new ast.Node.ptr(40, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(imgAlt), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					}
					node.AppendChild(new ast.Node.ptr(37, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node.AppendChild(new ast.Node.ptr(38, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node.AppendChild(new ast.Node.ptr(41, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(lute.domAttrValue(n, "src")), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					linkTitle = lute.domAttrValue(n, "title");
					if (!("" === linkTitle)) {
						node.AppendChild(new ast.Node.ptr(43, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						node.AppendChild(new ast.Node.ptr(42, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(linkTitle))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					}
					node.AppendChild(new ast.Node.ptr(39, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				}
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (281349)) { */ case 21:
				node.Type = 100;
				if (lute.hasAttr(n, "checked")) {
					node.TaskListItemChecked = true;
				}
				tree.Context.Tip.AppendChild(node);
				if (!(ptrType$1.nil === node.Parent.Parent)) {
					node.Parent.Parent.ListData.Typ = 3;
				}
				$s = 33; continue;
			/* } else if ((_1 === (283139)) || (_1 === (9473)) || (_1 === (53766))) { */ case 22:
				node.Type = 101;
				marker$3 = "~";
				node.AppendChild(new ast.Node.ptr(102, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(marker$3), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (365829)) { */ case 23:
				node.Type = 106;
				tableAligns = sliceType$2.nil;
				th = n.FirstChild.FirstChild.FirstChild;
				while (true) {
					if (!(!(ptrType.nil === th))) { break; }
					align = lute.domAttrValue(th, "align");
					_2 = align;
					if (_2 === ("left")) {
						tableAligns = $append(tableAligns, 1);
					} else if (_2 === ("center")) {
						tableAligns = $append(tableAligns, 2);
					} else if (_2 === ("right")) {
						tableAligns = $append(tableAligns, 3);
					} else {
						tableAligns = $append(tableAligns, 0);
					}
					th = th.NextSibling;
				}
				node.TableAligns = tableAligns;
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (208901)) { */ case 24:
				node.Type = 107;
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (9989)) { */ case 25:
				$s = 33; continue;
			/* } else if (_1 === (52226)) { */ case 26:
				table = n.Parent.Parent;
				node.Type = 108;
				if (!((208901 === table.FirstChild.DataAtom)) && n === n.Parent.FirstChild) {
					thead = new ast.Node.ptr(107, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					tree.Context.Tip.AppendChild(thead);
					tree.Context.Tip = thead;
					$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				}
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if ((_1 === (87554)) || (_1 === (37378))) { */ case 27:
				node.Type = 109;
				align$1 = lute.domAttrValue(n, "align");
				tableAlign = 0;
				_3 = align$1;
				if (_3 === ("left")) {
					tableAlign = 1;
				} else if (_3 === ("center")) {
					tableAlign = 2;
				} else if (_3 === ("right")) {
					tableAlign = 3;
				} else {
					tableAlign = 0;
				}
				node.TableCellAlign = tableAlign;
				tree.Context.Tip.AppendChild(node);
				tree.Context.Tip = node;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 33; continue;
			/* } else if (_1 === (40708)) { */ case 28:
				if (ptrType.nil === n.FirstChild) {
					$s = -1; return;
				}
				$s = 33; continue;
			/* } else if (_1 === (16132)) { */ case 29:
				$s = -1; return;
			/* } else if (_1 === (29191)) { */ case 30:
				node.Type = 9;
				_r$2 = lute.domHTML(n); /* */ $s = 42; case 42: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
				node.Tokens = _r$2;
				node.Tokens = (x$1 = bytes.SplitAfter(node.Tokens, (new sliceType$1($stringToBytes("</summary>")))), (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]));
				tree.Context.Tip.AppendChild(node);
				$s = 33; continue;
			/* } else if (_1 === (459783)) { */ case 31:
				$s = -1; return;
			/* } else if ((_1 === (195590)) || (_1 === (70917)) || (_1 === (192773))) { */ case 32:
				node.Type = 9;
				_r$3 = lute.domHTML(n); /* */ $s = 43; case 43: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				node.Tokens = _r$3;
				tree.Context.Tip.AppendChild(node);
				$s = -1; return;
			/* } */ case 33:
		case 6:
		c$1 = n.FirstChild;
		/* while (true) { */ case 44:
			/* if (!(!(c$1 === ptrType.nil))) { break; } */ if(!(!(c$1 === ptrType.nil))) { $s = 45; continue; }
			$r = lute.genASTByDOM(c$1, tree); /* */ $s = 46; case 46: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			c$1 = c$1.NextSibling;
		/* } */ $s = 44; continue; case 45:
		_4 = n.DataAtom;
		if ((_4 === (28162)) || (_4 === (1537))) {
			marker$4 = "*";
			node.AppendChild(new ast.Node.ptr(19, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(marker$4), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		} else if ((_4 === (449798)) || (_4 === (257))) {
			marker$5 = "**";
			node.AppendChild(new ast.Node.ptr(24, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(marker$5), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		} else if (_4 === (1)) {
			node.AppendChild(new ast.Node.ptr(37, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			node.AppendChild(new ast.Node.ptr(38, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			node.AppendChild(new ast.Node.ptr(41, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(lute.domAttrValue(n, "href")), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			linkTitle$1 = lute.domAttrValue(n, "title");
			if (!("" === linkTitle$1)) {
				node.AppendChild(new ast.Node.ptr(43, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				node.AppendChild(new ast.Node.ptr(42, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(linkTitle$1), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			}
			node.AppendChild(new ast.Node.ptr(39, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		} else if ((_4 === (283139)) || (_4 === (9473)) || (_4 === (53766))) {
			marker$6 = "~";
			node.AppendChild(new ast.Node.ptr(103, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, util.StrToBytes(marker$6), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		} else if (_4 === (29191)) {
			tree.Context.Tip.AppendChild(new ast.Node.ptr(9, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("</details>"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		}
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.genASTByDOM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.align = align; $f.align$1 = align$1; $f.buf = buf; $f.buf$1 = buf$1; $f.bullet = bullet; $f.c = c; $f.c$1 = c$1; $f.class$1 = class$1; $f.class$2 = class$2; $f.code = code; $f.content = content; $f.content$1 = content$1; $f.content$2 = content$2; $f.dataRender = dataRender; $f.emojiImg = emojiImg; $f.firstc = firstc; $f.imgAlt = imgAlt; $f.imgClass = imgClass; $f.language = language; $f.language$1 = language$1; $f.linkTitle = linkTitle; $f.linkTitle$1 = linkTitle$1; $f.lute = lute; $f.marker = marker; $f.marker$1 = marker$1; $f.marker$2 = marker$2; $f.marker$3 = marker$3; $f.marker$4 = marker$4; $f.marker$5 = marker$5; $f.marker$6 = marker$6; $f.n = n; $f.node = node; $f.start = start; $f.table = table; $f.tableAlign = tableAlign; $f.tableAligns = tableAligns; $f.th = th; $f.thead = thead; $f.tree = tree; $f.unescaped = unescaped; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Lute.prototype.genASTByDOM = function(n, tree) { return this.$val.genASTByDOM(n, tree); };
	New = function(opts) {
		var _i, _ref, opt, opts, ret, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _ref = $f._ref; opt = $f.opt; opts = $f.opts; ret = $f.ret; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ret = ptrType$8.nil;
		ret = new Lute.ptr(NewOptions(), false, false, false, false, false, false);
		_ref = opts;
		_i = 0;
		/* while (true) { */ case 1:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 2; continue; }
			opt = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			$r = opt(ret); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 1; continue; case 2:
		ret.HTML2MdRendererFuncs = $makeMap(ast.NodeType.keyFor, []);
		ret.HTML2VditorDOMRendererFuncs = $makeMap(ast.NodeType.keyFor, []);
		ret.HTML2VditorIRDOMRendererFuncs = $makeMap(ast.NodeType.keyFor, []);
		ret.Md2HTMLRendererFuncs = $makeMap(ast.NodeType.keyFor, []);
		ret.Md2VditorDOMRendererFuncs = $makeMap(ast.NodeType.keyFor, []);
		ret.Md2VditorIRDOMRendererFuncs = $makeMap(ast.NodeType.keyFor, []);
		ret = ret;
		$s = -1; return ret;
		/* */ } return; } if ($f === undefined) { $f = { $blk: New }; } $f._i = _i; $f._ref = _ref; $f.opt = opt; $f.opts = opts; $f.ret = ret; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.New = New;
	NewOptions = function() {
		var _tuple, emoji, emojis;
		_tuple = parse.NewEmojis();
		emojis = _tuple[0];
		emoji = _tuple[1];
		return new parse.Options.ptr(true, true, "vditor-task", true, true, true, true, false, false, false, "github", true, false, true, true, true, true, true, emojis, emoji, "https://cdn.jsdelivr.net/npm/vditor/dist/images/emoji", false, render.NewTerms(), false, false, false, "", true, false, true, false, "", false);
	};
	$pkg.NewOptions = NewOptions;
	Lute.ptr.prototype.Markdown = function(name, markdown) {
		var _entry, _i, _key, _keys, _r, _r$1, _r$2, _ref, html$1, lute, markdown, name, nodeType, renderer, rendererFunc, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _key = $f._key; _keys = $f._keys; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; html$1 = $f.html$1; lute = $f.lute; markdown = $f.markdown; name = $f.name; nodeType = $f.nodeType; renderer = $f.renderer; rendererFunc = $f.rendererFunc; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		html$1 = sliceType$1.nil;
		lute = this;
		_r = parse.Parse(name, markdown, lute.Options); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tree = _r;
		renderer = render.NewHtmlRenderer(tree);
		_ref = lute.Md2HTMLRendererFuncs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			nodeType = _entry.k;
			rendererFunc = _entry.v;
			_key = nodeType; (renderer.BaseRenderer.ExtRendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: rendererFunc };
			_i++;
		}
		_r$1 = renderer.BaseRenderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		html$1 = _r$1;
		/* */ if (lute.Options.Footnotes && 0 < tree.Context.FootnotesDefs.$length) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (lute.Options.Footnotes && 0 < tree.Context.FootnotesDefs.$length) { */ case 3:
			_r$2 = renderer.RenderFootnotesDefs(tree.Context); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			html$1 = _r$2;
		/* } */ case 4:
		$s = -1; return html$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.Markdown }; } $f._entry = _entry; $f._i = _i; $f._key = _key; $f._keys = _keys; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f.html$1 = html$1; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.nodeType = nodeType; $f.renderer = renderer; $f.rendererFunc = rendererFunc; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.Markdown = function(name, markdown) { return this.$val.Markdown(name, markdown); };
	Lute.ptr.prototype.MarkdownStr = function(name, markdown) {
		var _r, html$1, htmlBytes, lute, markdown, name, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; html$1 = $f.html$1; htmlBytes = $f.htmlBytes; lute = $f.lute; markdown = $f.markdown; name = $f.name; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		html$1 = "";
		lute = this;
		_r = lute.Markdown(name, (new sliceType$1($stringToBytes(markdown)))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		htmlBytes = _r;
		html$1 = util.BytesToStr(htmlBytes);
		$s = -1; return html$1;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.MarkdownStr }; } $f._r = _r; $f.html$1 = html$1; $f.htmlBytes = htmlBytes; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.MarkdownStr = function(name, markdown) { return this.$val.MarkdownStr(name, markdown); };
	Lute.ptr.prototype.Format = function(name, markdown) {
		var _r, _r$1, formatted, lute, markdown, name, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; formatted = $f.formatted; lute = $f.lute; markdown = $f.markdown; name = $f.name; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		formatted = sliceType$1.nil;
		lute = this;
		_r = parse.Parse(name, markdown, lute.Options); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tree = _r;
		renderer = render.NewFormatRenderer(tree);
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		formatted = _r$1;
		$s = -1; return formatted;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.Format }; } $f._r = _r; $f._r$1 = _r$1; $f.formatted = formatted; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.Format = function(name, markdown) { return this.$val.Format(name, markdown); };
	Lute.ptr.prototype.FormatStr = function(name, markdown) {
		var _r, formatted, formattedBytes, lute, markdown, name, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; formatted = $f.formatted; formattedBytes = $f.formattedBytes; lute = $f.lute; markdown = $f.markdown; name = $f.name; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		formatted = "";
		lute = this;
		formattedBytes = sliceType$1.nil;
		_r = lute.Format(name, (new sliceType$1($stringToBytes(markdown)))); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		formattedBytes = _r;
		formatted = util.BytesToStr(formattedBytes);
		$s = -1; return formatted;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.FormatStr }; } $f._r = _r; $f.formatted = formatted; $f.formattedBytes = formattedBytes; $f.lute = lute; $f.markdown = markdown; $f.name = name; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.FormatStr = function(name, markdown) { return this.$val.FormatStr(name, markdown); };
	Lute.ptr.prototype.Space = function(text) {
		var lute, text;
		lute = this;
		return render.Space0(text);
	};
	Lute.prototype.Space = function(text) { return this.$val.Space(text); };
	Lute.ptr.prototype.GetEmojis = function() {
		var _entry, _i, _key, _keys, _ref, k, lute, placeholder, ret, v, x;
		ret = false;
		lute = this;
		ret = (x = $keys(lute.Options.AliasEmoji).length, ((x < 0 || x > 2147483647) ? $throwRuntimeError("makemap: size out of range") : {}));
		placeholder = util.BytesToStr(parse.EmojiSitePlaceholder);
		_ref = lute.Options.AliasEmoji;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			if (strings.Contains(v, placeholder)) {
				v = strings.ReplaceAll(v, placeholder, lute.Options.EmojiSite);
			}
			_key = k; (ret || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_i++;
		}
		return ret;
	};
	Lute.prototype.GetEmojis = function() { return this.$val.GetEmojis(); };
	Lute.ptr.prototype.PutEmojis = function(emojiMap) {
		var _entry, _i, _key, _key$1, _keys, _ref, emojiMap, k, lute, v;
		lute = this;
		_ref = emojiMap;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = k; (lute.Options.AliasEmoji || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_key$1 = v; (lute.Options.EmojiAlias || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key$1)] = { k: _key$1, v: k };
			_i++;
		}
	};
	Lute.prototype.PutEmojis = function(emojiMap) { return this.$val.PutEmojis(emojiMap); };
	Lute.ptr.prototype.GetTerms = function() {
		var lute;
		lute = this;
		return lute.Options.Terms;
	};
	Lute.prototype.GetTerms = function() { return this.$val.GetTerms(); };
	Lute.ptr.prototype.PutTerms = function(termMap) {
		var _entry, _i, _key, _keys, _ref, k, lute, termMap, v;
		lute = this;
		_ref = termMap;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			k = _entry.k;
			v = _entry.v;
			_key = k; (lute.Options.Terms || $throwRuntimeError("assignment to entry in nil map"))[$String.keyFor(_key)] = { k: _key, v: v };
			_i++;
		}
	};
	Lute.prototype.PutTerms = function(termMap) { return this.$val.PutTerms(termMap); };
	Lute.ptr.prototype.SetGFMTable = function(b) {
		var b, lute;
		lute = this;
		lute.Options.GFMTable = b;
	};
	Lute.prototype.SetGFMTable = function(b) { return this.$val.SetGFMTable(b); };
	Lute.ptr.prototype.SetGFMTaskListItem = function(b) {
		var b, lute;
		lute = this;
		lute.Options.GFMTaskListItem = b;
	};
	Lute.prototype.SetGFMTaskListItem = function(b) { return this.$val.SetGFMTaskListItem(b); };
	Lute.ptr.prototype.SetGFMTaskListItemClass = function(class$1) {
		var class$1, lute;
		lute = this;
		lute.Options.GFMTaskListItemClass = class$1;
	};
	Lute.prototype.SetGFMTaskListItemClass = function(class$1) { return this.$val.SetGFMTaskListItemClass(class$1); };
	Lute.ptr.prototype.SetGFMStrikethrough = function(b) {
		var b, lute;
		lute = this;
		lute.Options.GFMStrikethrough = b;
	};
	Lute.prototype.SetGFMStrikethrough = function(b) { return this.$val.SetGFMStrikethrough(b); };
	Lute.ptr.prototype.SetGFMAutoLink = function(b) {
		var b, lute;
		lute = this;
		lute.Options.GFMAutoLink = b;
	};
	Lute.prototype.SetGFMAutoLink = function(b) { return this.$val.SetGFMAutoLink(b); };
	Lute.ptr.prototype.SetSoftBreak2HardBreak = function(b) {
		var b, lute;
		lute = this;
		lute.Options.SoftBreak2HardBreak = b;
	};
	Lute.prototype.SetSoftBreak2HardBreak = function(b) { return this.$val.SetSoftBreak2HardBreak(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlight = function(b) {
		var b, lute;
		lute = this;
		lute.Options.CodeSyntaxHighlight = b;
	};
	Lute.prototype.SetCodeSyntaxHighlight = function(b) { return this.$val.SetCodeSyntaxHighlight(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlightDetectLang = function(b) {
		var b, lute;
		lute = this;
		lute.Options.CodeSyntaxHighlightDetectLang = b;
	};
	Lute.prototype.SetCodeSyntaxHighlightDetectLang = function(b) { return this.$val.SetCodeSyntaxHighlightDetectLang(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlightInlineStyle = function(b) {
		var b, lute;
		lute = this;
		lute.Options.CodeSyntaxHighlightInlineStyle = b;
	};
	Lute.prototype.SetCodeSyntaxHighlightInlineStyle = function(b) { return this.$val.SetCodeSyntaxHighlightInlineStyle(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlightLineNum = function(b) {
		var b, lute;
		lute = this;
		lute.Options.CodeSyntaxHighlightLineNum = b;
	};
	Lute.prototype.SetCodeSyntaxHighlightLineNum = function(b) { return this.$val.SetCodeSyntaxHighlightLineNum(b); };
	Lute.ptr.prototype.SetCodeSyntaxHighlightStyleName = function(name) {
		var lute, name;
		lute = this;
		lute.Options.CodeSyntaxHighlightStyleName = name;
	};
	Lute.prototype.SetCodeSyntaxHighlightStyleName = function(name) { return this.$val.SetCodeSyntaxHighlightStyleName(name); };
	Lute.ptr.prototype.SetFootnotes = function(b) {
		var b, lute;
		lute = this;
		lute.Options.Footnotes = b;
	};
	Lute.prototype.SetFootnotes = function(b) { return this.$val.SetFootnotes(b); };
	Lute.ptr.prototype.SetToC = function(b) {
		var b, lute;
		lute = this;
		lute.Options.ToC = b;
	};
	Lute.prototype.SetToC = function(b) { return this.$val.SetToC(b); };
	Lute.ptr.prototype.SetHeadingID = function(b) {
		var b, lute;
		lute = this;
		lute.Options.HeadingID = b;
	};
	Lute.prototype.SetHeadingID = function(b) { return this.$val.SetHeadingID(b); };
	Lute.ptr.prototype.SetAutoSpace = function(b) {
		var b, lute;
		lute = this;
		lute.Options.AutoSpace = b;
	};
	Lute.prototype.SetAutoSpace = function(b) { return this.$val.SetAutoSpace(b); };
	Lute.ptr.prototype.SetFixTermTypo = function(b) {
		var b, lute;
		lute = this;
		lute.Options.FixTermTypo = b;
	};
	Lute.prototype.SetFixTermTypo = function(b) { return this.$val.SetFixTermTypo(b); };
	Lute.ptr.prototype.SetChinesePunct = function(b) {
		var b, lute;
		lute = this;
		lute.Options.ChinesePunct = b;
	};
	Lute.prototype.SetChinesePunct = function(b) { return this.$val.SetChinesePunct(b); };
	Lute.ptr.prototype.SetEmoji = function(b) {
		var b, lute;
		lute = this;
		lute.Options.Emoji = b;
	};
	Lute.prototype.SetEmoji = function(b) { return this.$val.SetEmoji(b); };
	Lute.ptr.prototype.SetEmojis = function(emojis) {
		var emojis, lute;
		lute = this;
		lute.Options.AliasEmoji = emojis;
	};
	Lute.prototype.SetEmojis = function(emojis) { return this.$val.SetEmojis(emojis); };
	Lute.ptr.prototype.SetEmojiSite = function(emojiSite) {
		var emojiSite, lute;
		lute = this;
		lute.Options.EmojiSite = emojiSite;
	};
	Lute.prototype.SetEmojiSite = function(emojiSite) { return this.$val.SetEmojiSite(emojiSite); };
	Lute.ptr.prototype.SetHeadingAnchor = function(b) {
		var b, lute;
		lute = this;
		lute.Options.HeadingAnchor = b;
	};
	Lute.prototype.SetHeadingAnchor = function(b) { return this.$val.SetHeadingAnchor(b); };
	Lute.ptr.prototype.SetTerms = function(terms) {
		var lute, terms;
		lute = this;
		lute.Options.Terms = terms;
	};
	Lute.prototype.SetTerms = function(terms) { return this.$val.SetTerms(terms); };
	Lute.ptr.prototype.SetVditorWYSIWYG = function(b) {
		var b, lute;
		lute = this;
		lute.Options.VditorWYSIWYG = b;
	};
	Lute.prototype.SetVditorWYSIWYG = function(b) { return this.$val.SetVditorWYSIWYG(b); };
	Lute.ptr.prototype.SetInlineMathAllowDigitAfterOpenMarker = function(b) {
		var b, lute;
		lute = this;
		lute.Options.InlineMathAllowDigitAfterOpenMarker = b;
	};
	Lute.prototype.SetInlineMathAllowDigitAfterOpenMarker = function(b) { return this.$val.SetInlineMathAllowDigitAfterOpenMarker(b); };
	Lute.ptr.prototype.SetLinkBase = function(linkBase) {
		var linkBase, lute;
		lute = this;
		lute.Options.LinkBase = linkBase;
	};
	Lute.prototype.SetLinkBase = function(linkBase) { return this.$val.SetLinkBase(linkBase); };
	Lute.ptr.prototype.SetVditorCodeBlockPreview = function(b) {
		var b, lute;
		lute = this;
		lute.Options.VditorCodeBlockPreview = b;
	};
	Lute.prototype.SetVditorCodeBlockPreview = function(b) { return this.$val.SetVditorCodeBlockPreview(b); };
	Lute.ptr.prototype.SetRenderListMarker = function(b) {
		var b, lute;
		lute = this;
		lute.Options.RenderListMarker = b;
	};
	Lute.prototype.SetRenderListMarker = function(b) { return this.$val.SetRenderListMarker(b); };
	Lute.ptr.prototype.SetSetext = function(b) {
		var b, lute;
		lute = this;
		lute.Options.Setext = b;
	};
	Lute.prototype.SetSetext = function(b) { return this.$val.SetSetext(b); };
	Lute.ptr.prototype.SetSanitize = function(b) {
		var b, lute;
		lute = this;
		lute.Options.Sanitize = b;
	};
	Lute.prototype.SetSanitize = function(b) { return this.$val.SetSanitize(b); };
	Lute.ptr.prototype.SetImageLazyLoading = function(dataSrc) {
		var dataSrc, lute;
		lute = this;
		lute.Options.ImageLazyLoading = dataSrc;
	};
	Lute.prototype.SetImageLazyLoading = function(dataSrc) { return this.$val.SetImageLazyLoading(dataSrc); };
	Lute.ptr.prototype.SetChineseParagraphBeginningSpace = function(b) {
		var b, lute;
		lute = this;
		lute.Options.ChineseParagraphBeginningSpace = b;
	};
	Lute.prototype.SetChineseParagraphBeginningSpace = function(b) { return this.$val.SetChineseParagraphBeginningSpace(b); };
	Lute.ptr.prototype.SetJSRenderers = function(options) {
		var _entry, _entry$1, _entry$2, _i, _i$1, _key, _keys, _keys$1, _ref, _ref$1, _ref$2, extRenderer, funcName, lute, nodeType, options, renderFuncs, rendererFuncs, rendererType;
		lute = this;
		_ref = (_entry = options[$String.keyFor("renderers")], _entry !== undefined ? _entry.v : false);
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			funcName = [funcName];
			_entry$1 = _ref[_keys[_i]];
			if (_entry$1 === undefined) {
				_i++;
				continue;
			}
			rendererType = _entry$1.k;
			extRenderer = _entry$1.v;
			_ref$1 = $internalize(extRenderer, $emptyInterface);
			switch (0) { default: if ($assertType(_ref$1, mapType, true)[1]) {
				break;
			} else {
				$panic(new $String("invalid type [" + rendererType + "]"));
			} }
			rendererFuncs = false;
			if ("HTML2Md" === rendererType) {
				rendererFuncs = lute.HTML2MdRendererFuncs;
			} else if ("HTML2VditorDOM" === rendererType) {
				rendererFuncs = lute.HTML2VditorDOMRendererFuncs;
			} else if ("HTML2VditorIRDOM" === rendererType) {
				rendererFuncs = lute.HTML2VditorIRDOMRendererFuncs;
			} else if ("Md2HTML" === rendererType) {
				rendererFuncs = lute.Md2HTMLRendererFuncs;
			} else if ("Md2VditorDOM" === rendererType) {
				rendererFuncs = lute.Md2VditorDOMRendererFuncs;
			} else if ("Md2VditorIRDOM" === rendererType) {
				rendererFuncs = lute.Md2VditorIRDOMRendererFuncs;
			} else {
				$panic(new $String("unknown ext renderer func [" + rendererType + "]"));
			}
			renderFuncs = $assertType($internalize(extRenderer, $emptyInterface), mapType);
			_ref$2 = renderFuncs;
			_i$1 = 0;
			_keys$1 = $keys(_ref$2);
			while (true) {
				if (!(_i$1 < _keys$1.length)) { break; }
				_entry$2 = _ref$2[_keys$1[_i$1]];
				if (_entry$2 === undefined) {
					_i$1++;
					continue;
				}
				funcName[0] = _entry$2.k;
				nodeType = "Node" + $substring(funcName[0], 6);
				_key = ast.Str2NodeType(nodeType); (rendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: (function(funcName) { return function(node, entering) {
					var entering, node, nodeType$1, ret;
					nodeType$1 = new ast.NodeType(node.Type).String();
					funcName[0] = "render" + $substring(nodeType$1, 4);
					ret = $assertType($internalize(extRenderer[$externalize(funcName[0], $String)](js.MakeWrapper(node), $externalize(entering, $Bool)), $emptyInterface), sliceType$4);
					return [$assertType((0 >= ret.$length ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + 0]), $String), (($assertType((1 >= ret.$length ? ($throwRuntimeError("index out of range"), undefined) : ret.$array[ret.$offset + 1]), $Float64) >> 0))];
				}; })(funcName) };
				_i$1++;
			}
			_i++;
		}
	};
	Lute.prototype.SetJSRenderers = function(options) { return this.$val.SetJSRenderers(options); };
	Lute.ptr.prototype.Md2HTML = function(markdown) {
		var _r, lute, markdown, sHTML, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; lute = $f.lute; markdown = $f.markdown; sHTML = $f.sHTML; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		sHTML = "";
		lute = this;
		lute.Options.VditorWYSIWYG = false;
		_r = lute.MarkdownStr("", markdown); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		sHTML = _r;
		$s = -1; return sHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.Md2HTML }; } $f._r = _r; $f.lute = lute; $f.markdown = markdown; $f.sHTML = sHTML; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.Md2HTML = function(markdown) { return this.$val.Md2HTML(markdown); };
	Lute.ptr.prototype.FormatMd = function(markdown) {
		var _r, formatted, lute, markdown, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; formatted = $f.formatted; lute = $f.lute; markdown = $f.markdown; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		formatted = "";
		lute = this;
		lute.Options.VditorWYSIWYG = false;
		_r = lute.FormatStr("", markdown); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		formatted = _r;
		$s = -1; return formatted;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.FormatMd }; } $f._r = _r; $f.formatted = formatted; $f.lute = lute; $f.markdown = markdown; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.FormatMd = function(markdown) { return this.$val.FormatMd(markdown); };
	Lute.ptr.prototype.SpinVditorDOM = function(ivHTML) {
		var _r, _r$1, _r$2, _r$3, ivHTML, lute, markdown, output, ovHTML, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; ivHTML = $f.ivHTML; lute = $f.lute; markdown = $f.markdown; output = $f.output; ovHTML = $f.ovHTML; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ovHTML = "";
		lute = this;
		lute.Options.VditorWYSIWYG = true;
		ivHTML = strings.ReplaceAll(ivHTML, "<wbr>", "\xE2\x80\xB8");
		_r = lute.vditorDOM2Md(ivHTML); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		markdown = _r;
		_r$1 = parse.Parse("", (new sliceType$1($stringToBytes(markdown))), lute.Options); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		tree = _r$1;
		renderer = render.NewVditorRenderer(tree);
		_r$2 = renderer.Render(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		output = _r$2;
		/* */ if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { */ case 4:
			_r$3 = renderer.RenderFootnotesDefs(renderer.BaseRenderer.Tree.Context); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			output = _r$3;
		/* } */ case 5:
		ovHTML = strings.ReplaceAll(($bytesToString(output)), "\xE2\x80\xB8", "<wbr>");
		$s = -1; return ovHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.SpinVditorDOM }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.ivHTML = ivHTML; $f.lute = lute; $f.markdown = markdown; $f.output = output; $f.ovHTML = ovHTML; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.SpinVditorDOM = function(ivHTML) { return this.$val.SpinVditorDOM(ivHTML); };
	Lute.ptr.prototype.HTML2VditorDOM = function(sHTML) {
		var _entry, _i, _key, _keys, _r, _r$1, _r$2, _r$3, _r$4, _ref, _tuple, err, lute, markdown, nodeType, output, renderer, rendererFunc, sHTML, tree, vHTML, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _key = $f._key; _keys = $f._keys; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _tuple = $f._tuple; err = $f.err; lute = $f.lute; markdown = $f.markdown; nodeType = $f.nodeType; output = $f.output; renderer = $f.renderer; rendererFunc = $f.rendererFunc; sHTML = $f.sHTML; tree = $f.tree; vHTML = $f.vHTML; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		vHTML = "";
		lute = this;
		lute.Options.VditorWYSIWYG = true;
		_r = lute.HTML2Markdown(sHTML); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		markdown = _tuple[0];
		err = _tuple[1];
		/* */ if (!($interfaceIsEqual($ifaceNil, err))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!($interfaceIsEqual($ifaceNil, err))) { */ case 2:
			_r$1 = err.Error(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			vHTML = _r$1;
			$s = -1; return vHTML;
		/* } */ case 3:
		_r$2 = parse.Parse("", (new sliceType$1($stringToBytes(markdown))), lute.Options); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		tree = _r$2;
		renderer = render.NewVditorRenderer(tree);
		_ref = lute.HTML2VditorDOMRendererFuncs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			nodeType = _entry.k;
			rendererFunc = _entry.v;
			_key = nodeType; (renderer.BaseRenderer.ExtRendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: rendererFunc };
			_i++;
		}
		_r$3 = renderer.Render(); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		output = _r$3;
		/* */ if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { */ case 7:
			_r$4 = renderer.RenderFootnotesDefs(renderer.BaseRenderer.Tree.Context); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			output = _r$4;
		/* } */ case 8:
		vHTML = ($bytesToString(output));
		$s = -1; return vHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.HTML2VditorDOM }; } $f._entry = _entry; $f._i = _i; $f._key = _key; $f._keys = _keys; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._tuple = _tuple; $f.err = err; $f.lute = lute; $f.markdown = markdown; $f.nodeType = nodeType; $f.output = output; $f.renderer = renderer; $f.rendererFunc = rendererFunc; $f.sHTML = sHTML; $f.tree = tree; $f.vHTML = vHTML; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.HTML2VditorDOM = function(sHTML) { return this.$val.HTML2VditorDOM(sHTML); };
	Lute.ptr.prototype.VditorDOM2HTML = function(vhtml) {
		var _r, _r$1, lute, markdown, sHTML, vhtml, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; lute = $f.lute; markdown = $f.markdown; sHTML = $f.sHTML; vhtml = $f.vhtml; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		sHTML = "";
		lute = this;
		lute.Options.VditorWYSIWYG = true;
		_r = lute.vditorDOM2Md(vhtml); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		markdown = _r;
		_r$1 = lute.Md2HTML(markdown); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		sHTML = _r$1;
		$s = -1; return sHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.VditorDOM2HTML }; } $f._r = _r; $f._r$1 = _r$1; $f.lute = lute; $f.markdown = markdown; $f.sHTML = sHTML; $f.vhtml = vhtml; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.VditorDOM2HTML = function(vhtml) { return this.$val.VditorDOM2HTML(vhtml); };
	Lute.ptr.prototype.Md2VditorDOM = function(markdown) {
		var _entry, _i, _key, _keys, _r, _r$1, _r$2, _ref, lute, markdown, nodeType, output, renderer, rendererFunc, tree, vHTML, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _key = $f._key; _keys = $f._keys; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; lute = $f.lute; markdown = $f.markdown; nodeType = $f.nodeType; output = $f.output; renderer = $f.renderer; rendererFunc = $f.rendererFunc; tree = $f.tree; vHTML = $f.vHTML; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		vHTML = "";
		lute = this;
		lute.Options.VditorWYSIWYG = true;
		_r = parse.Parse("", (new sliceType$1($stringToBytes(markdown))), lute.Options); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tree = _r;
		renderer = render.NewVditorRenderer(tree);
		_ref = lute.Md2VditorDOMRendererFuncs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			nodeType = _entry.k;
			rendererFunc = _entry.v;
			_key = nodeType; (renderer.BaseRenderer.ExtRendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: rendererFunc };
			_i++;
		}
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		output = _r$1;
		/* */ if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { */ case 3:
			_r$2 = renderer.RenderFootnotesDefs(renderer.BaseRenderer.Tree.Context); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			output = _r$2;
		/* } */ case 4:
		vHTML = ($bytesToString(output));
		$s = -1; return vHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.Md2VditorDOM }; } $f._entry = _entry; $f._i = _i; $f._key = _key; $f._keys = _keys; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f.lute = lute; $f.markdown = markdown; $f.nodeType = nodeType; $f.output = output; $f.renderer = renderer; $f.rendererFunc = rendererFunc; $f.tree = tree; $f.vHTML = vHTML; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.Md2VditorDOM = function(markdown) { return this.$val.Md2VditorDOM(markdown); };
	Lute.ptr.prototype.VditorDOM2Md = function(htmlStr) {
		var _r, htmlStr, lute, markdown, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; htmlStr = $f.htmlStr; lute = $f.lute; markdown = $f.markdown; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		markdown = "";
		lute = this;
		lute.Options.VditorWYSIWYG = true;
		htmlStr = strings.ReplaceAll(htmlStr, "\xE2\x80\x8B", "");
		_r = lute.vditorDOM2Md(htmlStr); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		markdown = _r;
		markdown = strings.ReplaceAll(markdown, "\xE2\x80\x8B", "");
		$s = -1; return markdown;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.VditorDOM2Md }; } $f._r = _r; $f.htmlStr = htmlStr; $f.lute = lute; $f.markdown = markdown; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.VditorDOM2Md = function(htmlStr) { return this.$val.VditorDOM2Md(htmlStr); };
	Lute.ptr.prototype.RenderEChartsJSON = function(markdown) {
		var _r, _r$1, json, lute, markdown, output, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; json = $f.json; lute = $f.lute; markdown = $f.markdown; output = $f.output; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		json = "";
		lute = this;
		_r = parse.Parse("", (new sliceType$1($stringToBytes(markdown))), lute.Options); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tree = _r;
		renderer = render.NewEChartsJSONRenderer(tree);
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		output = _r$1;
		json = ($bytesToString(output));
		$s = -1; return json;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.RenderEChartsJSON }; } $f._r = _r; $f._r$1 = _r$1; $f.json = json; $f.lute = lute; $f.markdown = markdown; $f.output = output; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.RenderEChartsJSON = function(markdown) { return this.$val.RenderEChartsJSON(markdown); };
	Lute.ptr.prototype.HTML2Md = function(html$1) {
		var _r, _r$1, _tuple, err, html$1, lute, markdown, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _tuple = $f._tuple; err = $f.err; html$1 = $f.html$1; lute = $f.lute; markdown = $f.markdown; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		markdown = "";
		lute = this;
		_r = lute.HTML2Markdown(html$1); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		markdown = _tuple[0];
		err = _tuple[1];
		/* */ if (!($interfaceIsEqual($ifaceNil, err))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!($interfaceIsEqual($ifaceNil, err))) { */ case 2:
			_r$1 = err.Error(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			markdown = _r$1;
			$s = -1; return markdown;
		/* } */ case 3:
		$s = -1; return markdown;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.HTML2Md }; } $f._r = _r; $f._r$1 = _r$1; $f._tuple = _tuple; $f.err = err; $f.html$1 = html$1; $f.lute = lute; $f.markdown = markdown; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.HTML2Md = function(html$1) { return this.$val.HTML2Md(html$1); };
	Lute.ptr.prototype.vditorDOM2Md = function(htmlStr) {
		var _i, _r, _r$1, _r$2, _ref, _tuple, err, formatted, htmlNode, htmlNodes, htmlRoot, htmlStr, lute, markdown, reader, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _tuple = $f._tuple; err = $f.err; formatted = $f.formatted; htmlNode = $f.htmlNode; htmlNodes = $f.htmlNodes; htmlRoot = $f.htmlRoot; htmlStr = $f.htmlStr; lute = $f.lute; markdown = $f.markdown; reader = $f.reader; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		markdown = "";
		lute = this;
		htmlStr = strings.ReplaceAll(htmlStr, "<wbr>", "");
		htmlStr = strings.ReplaceAll(htmlStr, "\t\n", "\n");
		htmlStr = strings.ReplaceAll(htmlStr, "    \n", "  \n");
		reader = strings.NewReader(htmlStr);
		htmlRoot = new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, 0, "", "", sliceType.nil);
		_r = html.ParseFragmentWithOptions(reader, htmlRoot, new sliceType$5([])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		htmlNodes = _tuple[0];
		err = _tuple[1];
		/* */ if (!($interfaceIsEqual($ifaceNil, err))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!($interfaceIsEqual($ifaceNil, err))) { */ case 2:
			_r$1 = err.Error(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			markdown = _r$1;
			$s = -1; return markdown;
		/* } */ case 3:
		$r = lute.adjustVditorDOM(htmlNodes); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		tree = new parse.Tree.ptr("", new ast.Node.ptr(0, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil), new parse.Context.ptr(ptrType$6.nil, lute.Options, false, sliceType$3.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, 0, 0, 0, 0, 0, 0, 0, false, false, false, false, ptrType$1.nil), ptrType$3.nil, ptrType$4.nil);
		tree.Context.Tip = tree.Root;
		_ref = htmlNodes;
		_i = 0;
		/* while (true) { */ case 6:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 7; continue; }
			htmlNode = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			$r = lute.genASTByVditorDOM(htmlNode, tree); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 6; continue; case 7:
		$r = ast.Walk(tree.Root, (function(n, entering) {
			var _1, entering, n, previousLi;
			if (entering) {
				_1 = n.Type;
				if ((_1 === (10)) || (_1 === (27)) || (_1 === (304)) || (_1 === (9)) || (_1 === (15)) || (_1 === (302))) {
					n.Tokens = util.UnescapeHTML(n.Tokens);
					if (!(ptrType$1.nil === n.Next) && (27 === n.Next.Type) && (n.CodeMarkerLen === n.Next.CodeMarkerLen)) {
						n.FirstChild.Next.Tokens = $appendSlice(n.FirstChild.Next.Tokens, n.Next.FirstChild.Next.Tokens);
						n.Next.Unlink();
					}
				} else if (_1 === (7)) {
					if (!(ptrType$1.nil === n.Parent) && (7 === n.Parent.Type)) {
						previousLi = n.Previous;
						if (!(ptrType$1.nil === previousLi)) {
							previousLi.AppendChild(n);
						}
					}
				}
			}
			return 2;
		})); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		renderer = render.NewFormatRenderer(tree);
		_r$2 = renderer.Render(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		formatted = _r$2;
		markdown = ($bytesToString(formatted));
		$s = -1; return markdown;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.vditorDOM2Md }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._tuple = _tuple; $f.err = err; $f.formatted = formatted; $f.htmlNode = htmlNode; $f.htmlNodes = htmlNodes; $f.htmlRoot = htmlRoot; $f.htmlStr = htmlStr; $f.lute = lute; $f.markdown = markdown; $f.reader = reader; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.vditorDOM2Md = function(htmlStr) { return this.$val.vditorDOM2Md(htmlStr); };
	Lute.ptr.prototype.adjustVditorDOM = function(nodes) {
		var _i, _ref, c, emptyTextNode, emptyTextNodes, i, j, length, lute, nodes, parent, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _ref = $f._ref; c = $f.c; emptyTextNode = $f.emptyTextNode; emptyTextNodes = $f.emptyTextNodes; i = $f.i; j = $f.j; length = $f.length; lute = $f.lute; nodes = $f.nodes; parent = $f.parent; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		emptyTextNodes = [emptyTextNodes];
		lute = this;
		length = nodes.$length;
		if (0 === length) {
			$s = -1; return;
		}
		if (1 < length) {
			i = 0;
			j = 1;
			while (true) {
				if (!(j < length)) { break; }
				((i < 0 || i >= nodes.$length) ? ($throwRuntimeError("index out of range"), undefined) : nodes.$array[nodes.$offset + i]).InsertAfter(((j < 0 || j >= nodes.$length) ? ($throwRuntimeError("index out of range"), undefined) : nodes.$array[nodes.$offset + j]));
				i = i + (1) >> 0;
				j = j + (1) >> 0;
			}
		}
		emptyTextNodes[0] = sliceType$6.nil;
		c = (0 >= nodes.$length ? ($throwRuntimeError("index out of range"), undefined) : nodes.$array[nodes.$offset + 0]);
		/* while (true) { */ case 1:
			/* if (!(!(ptrType.nil === c))) { break; } */ if(!(!(ptrType.nil === c))) { $s = 2; continue; }
			$r = lute.adjustVditorDOM0(c, (emptyTextNodes.$ptr || (emptyTextNodes.$ptr = new ptrType$9(function() { return this.$target[0]; }, function($v) { this.$target[0] = $v; }, emptyTextNodes)))); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			c = c.NextSibling;
		/* } */ $s = 1; continue; case 2:
		_ref = emptyTextNodes[0];
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			emptyTextNode = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			parent = emptyTextNode.Parent;
			if (!(ptrType.nil === parent) && ((365829 === parent.DataAtom) || (208901 === parent.DataAtom) || (9989 === parent.DataAtom) || (52226 === parent.DataAtom))) {
				emptyTextNode.Unlink();
				_i++;
				continue;
			}
			if (ptrType.nil === emptyTextNode.PrevSibling || ptrType.nil === emptyTextNode.NextSibling) {
				_i++;
				continue;
			}
			if ((40708 === emptyTextNode.PrevSibling.DataAtom) || (40708 === emptyTextNode.NextSibling.DataAtom)) {
				_i++;
				continue;
			}
			emptyTextNode.Unlink();
			_i++;
		}
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.adjustVditorDOM }; } $f._i = _i; $f._ref = _ref; $f.c = c; $f.emptyTextNode = emptyTextNode; $f.emptyTextNodes = emptyTextNodes; $f.i = i; $f.j = j; $f.length = length; $f.lute = lute; $f.nodes = nodes; $f.parent = parent; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.adjustVditorDOM = function(nodes) { return this.$val.adjustVditorDOM(nodes); };
	Lute.ptr.prototype.adjustVditorDOM0 = function(n, emptyTextNodes) {
		var _1, _i, _i$1, _r, _ref, _ref$1, c, c$1, c$2, c$3, emptyTextNodes, lastc, lute, n, nextTight, nextTight$1, nodes, p, p$1, pChild, pChild$1, tight, tight$1, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _i = $f._i; _i$1 = $f._i$1; _r = $f._r; _ref = $f._ref; _ref$1 = $f._ref$1; c = $f.c; c$1 = $f.c$1; c$2 = $f.c$2; c$3 = $f.c$3; emptyTextNodes = $f.emptyTextNodes; lastc = $f.lastc; lute = $f.lute; n = $f.n; nextTight = $f.nextTight; nextTight$1 = $f.nextTight$1; nodes = $f.nodes; p = $f.p; p$1 = $f.p$1; pChild = $f.pChild; pChild$1 = $f.pChild$1; tight = $f.tight; tight$1 = $f.tight$1; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		lute = this;
			_1 = n.DataAtom;
			/* */ if (_1 === (45570)) { $s = 2; continue; }
			/* */ if (_1 === (42754)) { $s = 3; continue; }
			/* */ if (_1 === (79618)) { $s = 4; continue; }
			/* */ if (_1 === (0)) { $s = 5; continue; }
			/* */ $s = 6; continue;
			/* if (_1 === (45570)) { */ case 2:
				nodes = sliceType$6.nil;
				lastc = ptrType.nil;
				c = n.FirstChild;
				while (true) {
					if (!(!(ptrType.nil === c))) { break; }
					if (!((3073 === c.DataAtom)) && !((100106 === c.DataAtom)) && !((42754 === c.DataAtom)) && !((79618 === c.DataAtom))) {
						nodes = $append(nodes, c);
					} else if (0 < nodes.$length) {
						p = new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, c.NextSibling, 3, 3073, "p", "", sliceType.nil);
						_ref = nodes;
						_i = 0;
						while (true) {
							if (!(_i < _ref.$length)) { break; }
							pChild = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
							pChild.Unlink();
							p.AppendChild(pChild);
							_i++;
						}
						nodes = sliceType$6.nil;
						c.InsertBefore(p);
						c = p;
					}
					if (ptrType.nil === c.NextSibling) {
						lastc = c;
					}
					c = c.NextSibling;
				}
				if (0 < nodes.$length) {
					p$1 = new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, lastc.NextSibling, 3, 3073, "p", "", sliceType.nil);
					lastc.InsertBefore(p$1);
					lastc.Unlink();
					p$1.AppendChild(lastc);
					_ref$1 = nodes;
					_i$1 = 0;
					while (true) {
						if (!(_i$1 < _ref$1.$length)) { break; }
						pChild$1 = ((_i$1 < 0 || _i$1 >= _ref$1.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref$1.$array[_ref$1.$offset + _i$1]);
						pChild$1.Unlink();
						p$1.AppendChild(pChild$1);
						_i$1++;
					}
					nodes = sliceType$6.nil;
				}
				$s = 6; continue;
			/* } else if (_1 === (42754)) { */ case 3:
				if (!(ptrType.nil === n.NextSibling) && (42754 === n.NextSibling.DataAtom)) {
					tight = lute.domAttrValue(n, "data-tight");
					nextTight = lute.domAttrValue(n.NextSibling, "data-tight");
					if ("" === nextTight || tight === nextTight) {
						c$1 = n.NextSibling.FirstChild;
						while (true) {
							if (!(!(ptrType.nil === c$1))) { break; }
							c$1.Unlink();
							n.AppendChild(c$1);
							c$1 = c$1.NextSibling;
						}
					}
				}
				$s = 6; continue;
			/* } else if (_1 === (79618)) { */ case 4:
				if (!(ptrType.nil === n.NextSibling) && (79618 === n.NextSibling.DataAtom)) {
					tight$1 = lute.domAttrValue(n, "data-tight");
					nextTight$1 = lute.domAttrValue(n.NextSibling, "data-tight");
					if ("" === nextTight$1 || tight$1 === nextTight$1) {
						c$2 = n.NextSibling.FirstChild;
						while (true) {
							if (!(!(ptrType.nil === c$2))) { break; }
							c$2.Unlink();
							n.AppendChild(c$2);
							c$2 = c$2.NextSibling;
						}
					}
				}
				$s = 6; continue;
			/* } else if (_1 === (0)) { */ case 5:
				_r = strings.TrimSpace(n.Data); /* */ $s = 9; case 9: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
				/* */ if ("" === _r) { $s = 7; continue; }
				/* */ $s = 8; continue;
				/* if ("" === _r) { */ case 7:
					emptyTextNodes.$set($append(emptyTextNodes.$get(), n));
				/* } */ case 8:
			/* } */ case 6:
		case 1:
		c$3 = n.FirstChild;
		/* while (true) { */ case 10:
			/* if (!(!(c$3 === ptrType.nil))) { break; } */ if(!(!(c$3 === ptrType.nil))) { $s = 11; continue; }
			$r = lute.adjustVditorDOM0(c$3, emptyTextNodes); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			c$3 = c$3.NextSibling;
		/* } */ $s = 10; continue; case 11:
		$s = -1; return;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.adjustVditorDOM0 }; } $f._1 = _1; $f._i = _i; $f._i$1 = _i$1; $f._r = _r; $f._ref = _ref; $f._ref$1 = _ref$1; $f.c = c; $f.c$1 = c$1; $f.c$2 = c$2; $f.c$3 = c$3; $f.emptyTextNodes = emptyTextNodes; $f.lastc = lastc; $f.lute = lute; $f.n = n; $f.nextTight = nextTight; $f.nextTight$1 = nextTight$1; $f.nodes = nodes; $f.p = p; $f.p$1 = p$1; $f.pChild = pChild; $f.pChild$1 = pChild$1; $f.tight = tight; $f.tight$1 = tight$1; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.adjustVditorDOM0 = function(n, emptyTextNodes) { return this.$val.adjustVditorDOM0(n, emptyTextNodes); };
	Lute.ptr.prototype.genASTByVditorDOM = function(n, tree) {
		var _1, _2, _3, _4, _5, _i, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$19, _r$2, _r$20, _r$21, _r$22, _r$23, _r$24, _r$25, _r$26, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _tuple, align, align$1, bullet, c, c$1, checkIndentCodeBlock, class$1, class$2, codeTokens, codeTokens$1, codeTokens$2, content, content$1, content$2, content$3, content$4, contentStr, dataRender, dataType, divDataType, emojiImg, err, firstLiMarker, headingC8hMarker, href, i, id, imgAlt, imgClass, label, language, li, line, lines, linkTitle, linkTitle$1, lute, marker, marker$1, marker$2, marker$3, marker$4, marker$5, marker$6, marker$7, marker$8, marker$9, md, n, node, node$1, node$2, node$3, ol, originalHTML, p, src, startAttr, startCaret, tableAlign, tableAligns, text, text$1, text$2, text$3, text$4, th, tight, tree, x, x$1, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$19 = $f._r$19; _r$2 = $f._r$2; _r$20 = $f._r$20; _r$21 = $f._r$21; _r$22 = $f._r$22; _r$23 = $f._r$23; _r$24 = $f._r$24; _r$25 = $f._r$25; _r$26 = $f._r$26; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tuple = $f._tuple; align = $f.align; align$1 = $f.align$1; bullet = $f.bullet; c = $f.c; c$1 = $f.c$1; checkIndentCodeBlock = $f.checkIndentCodeBlock; class$1 = $f.class$1; class$2 = $f.class$2; codeTokens = $f.codeTokens; codeTokens$1 = $f.codeTokens$1; codeTokens$2 = $f.codeTokens$2; content = $f.content; content$1 = $f.content$1; content$2 = $f.content$2; content$3 = $f.content$3; content$4 = $f.content$4; contentStr = $f.contentStr; dataRender = $f.dataRender; dataType = $f.dataType; divDataType = $f.divDataType; emojiImg = $f.emojiImg; err = $f.err; firstLiMarker = $f.firstLiMarker; headingC8hMarker = $f.headingC8hMarker; href = $f.href; i = $f.i; id = $f.id; imgAlt = $f.imgAlt; imgClass = $f.imgClass; label = $f.label; language = $f.language; li = $f.li; line = $f.line; lines = $f.lines; linkTitle = $f.linkTitle; linkTitle$1 = $f.linkTitle$1; lute = $f.lute; marker = $f.marker; marker$1 = $f.marker$1; marker$2 = $f.marker$2; marker$3 = $f.marker$3; marker$4 = $f.marker$4; marker$5 = $f.marker$5; marker$6 = $f.marker$6; marker$7 = $f.marker$7; marker$8 = $f.marker$8; marker$9 = $f.marker$9; md = $f.md; n = $f.n; node = $f.node; node$1 = $f.node$1; node$2 = $f.node$2; node$3 = $f.node$3; ol = $f.ol; originalHTML = $f.originalHTML; p = $f.p; src = $f.src; startAttr = $f.startAttr; startCaret = $f.startCaret; tableAlign = $f.tableAlign; tableAligns = $f.tableAligns; text = $f.text; text$1 = $f.text$1; text$2 = $f.text$2; text$3 = $f.text$3; text$4 = $f.text$4; th = $f.th; tight = $f.tight; tree = $f.tree; x = $f.x; x$1 = $f.x$1; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		lute = this;
		dataRender = lute.domAttrValue(n, "data-render");
		if ("1" === dataRender || "2" === dataRender) {
			$s = -1; return;
		}
		dataType = lute.domAttrValue(n, "data-type");
		/* */ if (92931 === n.DataAtom) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (92931 === n.DataAtom) { */ case 1:
			/* */ if ("code-block" === dataType || "html-block" === dataType || "math-block" === dataType) { $s = 3; continue; }
			/* */ if ("link-ref-defs-block" === dataType) { $s = 4; continue; }
			/* */ if ("footnotes-block" === dataType) { $s = 5; continue; }
			/* */ if ("toc-block" === dataType) { $s = 6; continue; }
			/* */ $s = 7; continue;
			/* if ("code-block" === dataType || "html-block" === dataType || "math-block" === dataType) { */ case 3:
				c = n.FirstChild;
				/* while (true) { */ case 8:
					/* if (!(!(c === ptrType.nil))) { break; } */ if(!(!(c === ptrType.nil))) { $s = 9; continue; }
					$r = lute.genASTByVditorDOM(c, tree); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					c = c.NextSibling;
				/* } */ $s = 8; continue; case 9:
				$s = 7; continue;
			/* } else if ("link-ref-defs-block" === dataType) { */ case 4:
				text = lute.domText(n);
				node = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(text))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
				tree.Context.Tip.AppendChild(node);
				$s = 7; continue;
			/* } else if ("footnotes-block" === dataType) { */ case 5:
				ol = n.FirstChild;
				if (!((79618 === ol.DataAtom))) {
					$s = -1; return;
				}
				li = ol.FirstChild;
				/* while (true) { */ case 11:
					/* if (!(!(ptrType.nil === li))) { break; } */ if(!(!(ptrType.nil === li))) { $s = 12; continue; }
					/* */ if ("\n" === li.Data) { $s = 13; continue; }
					/* */ $s = 14; continue;
					/* if ("\n" === li.Data) { */ case 13:
						li = li.NextSibling;
						/* continue; */ $s = 11; continue;
					/* } */ case 14:
					originalHTML = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0);
					_r = html.Render(originalHTML, li); /* */ $s = 15; case 15: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					err = _r;
					/* */ if ($interfaceIsEqual($ifaceNil, err)) { $s = 16; continue; }
					/* */ $s = 17; continue;
					/* if ($interfaceIsEqual($ifaceNil, err)) { */ case 16:
						_r$1 = lute.vditorDOM2Md("<ol>" + originalHTML.String() + "</ol>"); /* */ $s = 19; case 19: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						md = _r$1;
						label = lute.domAttrValue(li, "data-marker");
						md = $substring(md, 3);
						lines = strings.Split(md, "\n");
						md = "";
						_ref = lines;
						_i = 0;
						while (true) {
							if (!(_i < _ref.$length)) { break; }
							i = _i;
							line = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
							if (0 < i) {
								md = md + ("    " + line);
							} else {
								md = line;
							}
							md = md + ("\n");
							_i++;
						}
						md = "[" + label + "]: " + md;
						node$1 = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(md))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
						tree.Context.Tip.AppendChild(node$1);
						$s = 18; continue;
					/* } else { */ case 17:
						$panic(err);
					/* } */ case 18:
					li = li.NextSibling;
				/* } */ $s = 11; continue; case 12:
				$s = 7; continue;
			/* } else if ("toc-block" === dataType) { */ case 6:
				node$2 = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("[toc]\n\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
				tree.Context.Tip.AppendChild(node$2);
			/* } */ case 7:
			$s = -1; return;
		/* } */ case 2:
		class$1 = lute.domAttrValue(n, "class");
		content = strings.ReplaceAll(n.Data, "\xE2\x80\x8B", "");
		node$3 = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(content))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
			_1 = n.DataAtom;
			/* */ if (_1 === (0)) { $s = 21; continue; }
			/* */ if ((_1 === (3073)) || (_1 === (92931))) { $s = 22; continue; }
			/* */ if ((_1 === (89090)) || (_1 === (187906)) || (_1 === (199938)) || (_1 === (214274)) || (_1 === (216834)) || (_1 === (412930))) { $s = 23; continue; }
			/* */ if (_1 === (87810)) { $s = 24; continue; }
			/* */ if (_1 === (100106)) { $s = 25; continue; }
			/* */ if ((_1 === (79618)) || (_1 === (42754))) { $s = 26; continue; }
			/* */ if (_1 === (45570)) { $s = 27; continue; }
			/* */ if (_1 === (290819)) { $s = 28; continue; }
			/* */ if ((_1 === (28162)) || (_1 === (1537))) { $s = 29; continue; }
			/* */ if ((_1 === (449798)) || (_1 === (257))) { $s = 30; continue; }
			/* */ if ((_1 === (283139)) || (_1 === (9473)) || (_1 === (53766))) { $s = 31; continue; }
			/* */ if (_1 === (378116)) { $s = 32; continue; }
			/* */ if (_1 === (514)) { $s = 33; continue; }
			/* */ if (_1 === (1)) { $s = 34; continue; }
			/* */ if (_1 === (198403)) { $s = 35; continue; }
			/* */ if (_1 === (281349)) { $s = 36; continue; }
			/* */ if (_1 === (365829)) { $s = 37; continue; }
			/* */ if (_1 === (208901)) { $s = 38; continue; }
			/* */ if (_1 === (9989)) { $s = 39; continue; }
			/* */ if (_1 === (52226)) { $s = 40; continue; }
			/* */ if ((_1 === (87554)) || (_1 === (37378))) { $s = 41; continue; }
			/* */ if (_1 === (461571)) { $s = 42; continue; }
			/* */ if (_1 === (40708)) { $s = 43; continue; }
			/* */ if (_1 === (16132)) { $s = 44; continue; }
			/* */ if (_1 === (29191)) { $s = 45; continue; }
			/* */ if (_1 === (47363)) { $s = 46; continue; }
			/* */ if (_1 === (459783)) { $s = 47; continue; }
			/* */ $s = 48; continue;
			/* if (_1 === (0)) { */ case 21:
				if ("" === content) {
					$s = -1; return;
				}
				checkIndentCodeBlock = strings.ReplaceAll(content, "\xE2\x80\xB8", "");
				checkIndentCodeBlock = strings.ReplaceAll(checkIndentCodeBlock, "\t", "    ");
				/* */ if ((!lute.isInline(n.PrevSibling)) && strings.HasPrefix(checkIndentCodeBlock, "    ")) { $s = 50; continue; }
				/* */ $s = 51; continue;
				/* if ((!lute.isInline(n.PrevSibling)) && strings.HasPrefix(checkIndentCodeBlock, "    ")) { */ case 50:
					node$3.Type = 11;
					node$3.IsFencedCodeBlock = true;
					node$3.AppendChild(new ast.Node.ptr(12, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("```"))), false, false, false, 0, false, 0, 3, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(new ast.Node.ptr(14, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					startCaret = strings.HasPrefix(content, "\xE2\x80\xB8");
					if (startCaret) {
						content = strings.ReplaceAll(content, "\xE2\x80\xB8", "");
					}
					_r$2 = strings.TrimSpace(content); /* */ $s = 52; case 52: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					content = _r$2;
					if (startCaret) {
						content = "\xE2\x80\xB8" + content;
					}
					content$1 = new ast.Node.ptr(15, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(content))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					node$3.AppendChild(content$1);
					node$3.AppendChild(new ast.Node.ptr(13, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("```"))), false, false, false, 0, false, 0, 3, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				/* } */ case 51:
				if (!(ptrType.nil === n.Parent) && (1 === n.Parent.DataAtom)) {
					node$3.Type = 40;
				}
				tree.Context.Tip.AppendChild(node$3);
				$s = 49; continue;
			/* } else if ((_1 === (3073)) || (_1 === (92931))) { */ case 22:
				node$3.Type = 1;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if ((_1 === (89090)) || (_1 === (187906)) || (_1 === (199938)) || (_1 === (214274)) || (_1 === (216834)) || (_1 === (412930))) { */ case 23:
				_r$3 = strings.TrimSpace(lute.domText(n)); /* */ $s = 55; case 55: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				/* */ if ("" === _r$3) { $s = 53; continue; }
				/* */ $s = 54; continue;
				/* if ("" === _r$3) { */ case 53:
					$s = -1; return;
				/* } */ case 54:
				node$3.Type = 2;
				node$3.HeadingLevel = ((((x = node$3.Tokens, (1 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 1])) - 48 << 24 >>> 24) >> 0));
				marker = lute.domAttrValue(n, "data-marker");
				id = lute.domAttrValue(n, "data-id");
				if (!("" === id)) {
					node$3.HeadingID = (new sliceType$1($stringToBytes(id)));
				}
				node$3.HeadingSetext = "=" === marker || "-" === marker;
				if (!node$3.HeadingSetext) {
					headingC8hMarker = new ast.Node.ptr(3, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					headingC8hMarker.Tokens = (new sliceType$1($stringToBytes(strings.Repeat("#", node$3.HeadingLevel))));
					node$3.AppendChild(headingC8hMarker);
				}
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (87810)) { */ case 24:
				node$3.Type = 4;
				tree.Context.Tip.AppendChild(node$3);
				$s = 49; continue;
			/* } else if (_1 === (100106)) { */ case 25:
				_r$4 = strings.TrimSpace(lute.domText(n)); /* */ $s = 56; case 56: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				content$2 = _r$4;
				if ("" === content$2 || "&gt;" === content$2 || "\xE2\x80\xB8" === content$2) {
					$s = -1; return;
				}
				node$3.Type = 5;
				node$3.AppendChild(new ast.Node.ptr(6, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(">"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if ((_1 === (79618)) || (_1 === (42754))) { */ case 26:
				if (ptrType.nil === n.FirstChild) {
					$s = -1; return;
				}
				node$3.Type = 7;
				node$3.ListData = new ast.ListData.ptr(0, false, 0, 0, 0, 0, 0, false, sliceType$1.nil, 0);
				if (79618 === n.DataAtom) {
					node$3.ListData.Typ = 1;
				}
				tight = lute.domAttrValue(n, "data-tight");
				if ("true" === tight || "" === tight) {
					node$3.ListData.Tight = true;
				}
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (45570)) { */ case 27:
				p = n.FirstChild;
				if (!(ptrType.nil === p) && (3073 === p.DataAtom) && !(ptrType.nil === p.NextSibling) && (3073 === p.NextSibling.DataAtom)) {
					tree.Context.Tip.ListData.Tight = false;
				}
				node$3.Type = 8;
				marker$1 = lute.domAttrValue(n, "data-marker");
				bullet = 0;
				if ("" === marker$1) {
					if (!(ptrType.nil === n.Parent) && (79618 === n.Parent.DataAtom)) {
						firstLiMarker = lute.domAttrValue(n.Parent.FirstChild, "data-marker");
						startAttr = lute.domAttrValue(n.Parent, "start");
						if ("" === startAttr) {
							marker$1 = "1";
						} else {
							marker$1 = startAttr;
						}
						if (!("" === firstLiMarker)) {
							marker$1 = marker$1 + ($substring(firstLiMarker, (firstLiMarker.length - 1 >> 0)));
						} else {
							marker$1 = marker$1 + (".");
						}
					} else {
						marker$1 = lute.domAttrValue(n.Parent, "data-marker");
						if ("" === marker$1) {
							marker$1 = "*";
						}
						bullet = marker$1.charCodeAt(0);
					}
				} else {
					if (!(ptrType.nil === n.Parent)) {
						if (79618 === n.Parent.DataAtom) {
							if ("*" === marker$1 || "-" === marker$1 || "+" === marker$1) {
								marker$1 = "1.";
							}
							if (!("1." === marker$1) && !("1)" === marker$1) && !(ptrType.nil === n.PrevSibling) && !((45570 === n.PrevSibling.DataAtom)) && !(ptrType.nil === n.Parent.Parent) && ((79618 === n.Parent.Parent.DataAtom) || (42754 === n.Parent.Parent.DataAtom))) {
								marker$1 = "1.";
							}
							if (!("1." === marker$1) && !("1)" === marker$1) && (79618 === n.Parent.DataAtom) && n.Parent.FirstChild === n && "" === lute.domAttrValue(n.Parent, "start")) {
								marker$1 = "1.";
							}
						} else {
							if (!("*" === marker$1) && !("-" === marker$1) && !("+" === marker$1)) {
								marker$1 = "*";
							}
							bullet = marker$1.charCodeAt(0);
						}
					} else {
						marker$1 = lute.domAttrValue(n, "data-marker");
						if ("" === marker$1) {
							marker$1 = "*";
						}
						bullet = marker$1.charCodeAt(0);
					}
				}
				node$3.ListData = new ast.ListData.ptr(0, false, bullet, 0, 0, 0, 0, false, (new sliceType$1($stringToBytes(marker$1))), 0);
				if (0 === bullet) {
					_tuple = strconv.Atoi(($encodeRune(marker$1.charCodeAt(0))));
					node$3.ListData.Num = _tuple[0];
					node$3.ListData.Delimiter = marker$1.charCodeAt((marker$1.length - 1 >> 0));
				}
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (290819)) { */ case 28:
				if (378116 === n.FirstChild.DataAtom) {
					marker$2 = lute.domAttrValue(n.Parent, "data-marker");
					if ("" === marker$2) {
						marker$2 = "```";
					}
					codeTokens = sliceType$1.nil;
					if (!(ptrType.nil === n.FirstChild.FirstChild)) {
						codeTokens = (new sliceType$1($stringToBytes(n.FirstChild.FirstChild.Data)));
					}
					divDataType = lute.domAttrValue(n.Parent, "data-type");
					_2 = divDataType;
					if (_2 === ("math-block")) {
						node$3.Type = 300;
						node$3.AppendChild(new ast.Node.ptr(301, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						node$3.AppendChild(new ast.Node.ptr(302, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, codeTokens, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						node$3.AppendChild(new ast.Node.ptr(303, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						tree.Context.Tip.AppendChild(node$3);
					} else if (_2 === ("html-block")) {
						node$3.Type = 9;
						node$3.Tokens = codeTokens;
						tree.Context.Tip.AppendChild(node$3);
					} else {
						node$3.Type = 11;
						node$3.IsFencedCodeBlock = true;
						node$3.AppendChild(new ast.Node.ptr(12, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$2))), false, false, false, 0, false, 0, marker$2.length, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						node$3.AppendChild(new ast.Node.ptr(14, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						class$2 = lute.domAttrValue(n.FirstChild, "class");
						if (strings.Contains(class$2, "language-")) {
							language = $substring(class$2, 9);
							node$3.LastChild.CodeBlockInfo = (new sliceType$1($stringToBytes(language)));
						}
						content$3 = new ast.Node.ptr(15, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, codeTokens, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
						node$3.AppendChild(content$3);
						node$3.AppendChild(new ast.Node.ptr(13, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$2))), false, false, false, 0, false, 0, marker$2.length, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						tree.Context.Tip.AppendChild(node$3);
					}
				}
				$s = -1; return;
			/* } else if ((_1 === (28162)) || (_1 === (1537))) { */ case 29:
				if (ptrType.nil === n.FirstChild || (514 === n.FirstChild.DataAtom)) {
					$s = -1; return;
				}
				/* */ if (lute.starstWithNewline(n.FirstChild)) { $s = 57; continue; }
				/* */ $s = 58; continue;
				/* if (lute.starstWithNewline(n.FirstChild)) { */ case 57:
					_r$5 = strings.TrimLeft(n.FirstChild.Data, "\xE2\x80\x8B\n"); /* */ $s = 59; case 59: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$5;
					tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 58:
				_r$6 = strings.TrimSpace(lute.domText(n)); /* */ $s = 60; case 60: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				text$1 = _r$6;
				_r$7 = lute.isEmptyText(n); /* */ $s = 63; case 63: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				/* */ if (_r$7) { $s = 61; continue; }
				/* */ $s = 62; continue;
				/* if (_r$7) { */ case 61:
					$s = -1; return;
				/* } */ case 62:
				if ("\xE2\x80\xB8" === text$1) {
					node$3.Tokens = (new sliceType$1($stringToBytes("\xE2\x80\xB8")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				node$3.Type = 17;
				marker$3 = lute.domAttrValue(n, "data-marker");
				if ("" === marker$3) {
					marker$3 = "*";
				}
				if ("_" === marker$3) {
					node$3.AppendChild(new ast.Node.ptr(20, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$3))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				} else {
					node$3.AppendChild(new ast.Node.ptr(18, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$3))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				}
				tree.Context.Tip.AppendChild(node$3);
				if (!(ptrType.nil === n.FirstChild) && "\xE2\x80\xB8" === n.FirstChild.Data && !(ptrType.nil === n.LastChild) && "br" === n.LastChild.Data) {
					node$3.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\xB8"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					if ("_" === marker$3) {
						node$3.AppendChild(new ast.Node.ptr(21, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$3))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					} else {
						node$3.AppendChild(new ast.Node.ptr(19, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$3))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					}
					$s = -1; return;
				}
				n.FirstChild.Data = strings.ReplaceAll(n.FirstChild.Data, "\xE2\x80\x8B", "");
				/* */ if (strings.HasPrefix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.PrevSibling) { $s = 64; continue; }
				/* */ $s = 65; continue;
				/* if (strings.HasPrefix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.PrevSibling) { */ case 64:
					_r$8 = strings.TrimLeft(n.FirstChild.Data, " "); /* */ $s = 66; case 66: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$8;
					node$3.InsertBefore(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(" "))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 65:
				/* */ if (strings.HasSuffix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.NextSibling) { $s = 67; continue; }
				/* */ $s = 68; continue;
				/* if (strings.HasSuffix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.NextSibling) { */ case 67:
					_r$9 = strings.TrimRight(n.FirstChild.Data, " "); /* */ $s = 69; case 69: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$9;
					n.InsertAfter(new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, " ", "", sliceType.nil));
				/* } */ case 68:
				/* */ if (strings.HasSuffix(n.FirstChild.Data, "\n") && ptrType.nil === n.FirstChild.NextSibling) { $s = 70; continue; }
				/* */ $s = 71; continue;
				/* if (strings.HasSuffix(n.FirstChild.Data, "\n") && ptrType.nil === n.FirstChild.NextSibling) { */ case 70:
					_r$10 = strings.TrimRight(n.FirstChild.Data, "\n"); /* */ $s = 72; case 72: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$10;
					n.InsertAfter(new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, "\n", "", sliceType.nil));
				/* } */ case 71:
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if ((_1 === (449798)) || (_1 === (257))) { */ case 30:
				if (ptrType.nil === n.FirstChild || (514 === n.FirstChild.DataAtom)) {
					$s = -1; return;
				}
				/* */ if (lute.starstWithNewline(n.FirstChild)) { $s = 73; continue; }
				/* */ $s = 74; continue;
				/* if (lute.starstWithNewline(n.FirstChild)) { */ case 73:
					_r$11 = strings.TrimLeft(n.FirstChild.Data, "\xE2\x80\x8B\n"); /* */ $s = 75; case 75: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$11;
					tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 74:
				_r$12 = strings.TrimSpace(lute.domText(n)); /* */ $s = 76; case 76: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
				text$2 = _r$12;
				_r$13 = lute.isEmptyText(n); /* */ $s = 79; case 79: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				/* */ if (_r$13) { $s = 77; continue; }
				/* */ $s = 78; continue;
				/* if (_r$13) { */ case 77:
					$s = -1; return;
				/* } */ case 78:
				if ("\xE2\x80\xB8" === text$2) {
					node$3.Tokens = (new sliceType$1($stringToBytes("\xE2\x80\xB8")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				node$3.Type = 22;
				marker$4 = lute.domAttrValue(n, "data-marker");
				if ("" === marker$4) {
					marker$4 = "**";
				}
				if ("__" === marker$4) {
					node$3.AppendChild(new ast.Node.ptr(25, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$4))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				} else {
					node$3.AppendChild(new ast.Node.ptr(23, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$4))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				}
				tree.Context.Tip.AppendChild(node$3);
				if (!(ptrType.nil === n.FirstChild) && "\xE2\x80\xB8" === n.FirstChild.Data && !(ptrType.nil === n.LastChild) && "br" === n.LastChild.Data) {
					node$3.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\xB8"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					if ("__" === marker$4) {
						node$3.AppendChild(new ast.Node.ptr(26, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$4))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					} else {
						node$3.AppendChild(new ast.Node.ptr(24, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$4))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					}
					$s = -1; return;
				}
				n.FirstChild.Data = strings.ReplaceAll(n.FirstChild.Data, "\xE2\x80\x8B", "");
				/* */ if (strings.HasPrefix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.PrevSibling) { $s = 80; continue; }
				/* */ $s = 81; continue;
				/* if (strings.HasPrefix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.PrevSibling) { */ case 80:
					_r$14 = strings.TrimLeft(n.FirstChild.Data, " "); /* */ $s = 82; case 82: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$14;
					node$3.InsertBefore(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(" "))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 81:
				/* */ if (strings.HasSuffix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.NextSibling) { $s = 83; continue; }
				/* */ $s = 84; continue;
				/* if (strings.HasSuffix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.NextSibling) { */ case 83:
					_r$15 = strings.TrimRight(n.FirstChild.Data, " "); /* */ $s = 85; case 85: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$15;
					n.InsertAfter(new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, " ", "", sliceType.nil));
				/* } */ case 84:
				/* */ if (strings.HasSuffix(n.FirstChild.Data, "\n") && ptrType.nil === n.FirstChild.NextSibling) { $s = 86; continue; }
				/* */ $s = 87; continue;
				/* if (strings.HasSuffix(n.FirstChild.Data, "\n") && ptrType.nil === n.FirstChild.NextSibling) { */ case 86:
					_r$16 = strings.TrimRight(n.FirstChild.Data, "\n"); /* */ $s = 88; case 88: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$16;
					n.InsertAfter(new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, "\n", "", sliceType.nil));
				/* } */ case 87:
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if ((_1 === (283139)) || (_1 === (9473)) || (_1 === (53766))) { */ case 31:
				if (ptrType.nil === n.FirstChild || (514 === n.FirstChild.DataAtom)) {
					$s = -1; return;
				}
				/* */ if (lute.starstWithNewline(n.FirstChild)) { $s = 89; continue; }
				/* */ $s = 90; continue;
				/* if (lute.starstWithNewline(n.FirstChild)) { */ case 89:
					_r$17 = strings.TrimLeft(n.FirstChild.Data, "\xE2\x80\x8B\n"); /* */ $s = 91; case 91: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$17;
					tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 90:
				_r$18 = strings.TrimSpace(lute.domText(n)); /* */ $s = 92; case 92: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
				text$3 = _r$18;
				_r$19 = lute.isEmptyText(n); /* */ $s = 95; case 95: if($c) { $c = false; _r$19 = _r$19.$blk(); } if (_r$19 && _r$19.$blk !== undefined) { break s; }
				/* */ if (_r$19) { $s = 93; continue; }
				/* */ $s = 94; continue;
				/* if (_r$19) { */ case 93:
					$s = -1; return;
				/* } */ case 94:
				if ("\xE2\x80\xB8" === text$3) {
					node$3.Tokens = (new sliceType$1($stringToBytes("\xE2\x80\xB8")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				node$3.Type = 101;
				marker$5 = lute.domAttrValue(n, "data-marker");
				if ("~" === marker$5) {
					node$3.AppendChild(new ast.Node.ptr(102, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$5))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				} else {
					node$3.AppendChild(new ast.Node.ptr(104, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$5))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				}
				tree.Context.Tip.AppendChild(node$3);
				if (!(ptrType.nil === n.FirstChild) && "\xE2\x80\xB8" === n.FirstChild.Data && !(ptrType.nil === n.LastChild) && "br" === n.LastChild.Data) {
					node$3.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\xB8"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					if ("~" === marker$5) {
						node$3.AppendChild(new ast.Node.ptr(103, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$5))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					} else {
						node$3.AppendChild(new ast.Node.ptr(105, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$5))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					}
					$s = -1; return;
				}
				n.FirstChild.Data = strings.ReplaceAll(n.FirstChild.Data, "\xE2\x80\x8B", "");
				/* */ if (strings.HasPrefix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.PrevSibling) { $s = 96; continue; }
				/* */ $s = 97; continue;
				/* if (strings.HasPrefix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.PrevSibling) { */ case 96:
					_r$20 = strings.TrimLeft(n.FirstChild.Data, " "); /* */ $s = 98; case 98: if($c) { $c = false; _r$20 = _r$20.$blk(); } if (_r$20 && _r$20.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$20;
					node$3.InsertBefore(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(" "))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 97:
				/* */ if (strings.HasSuffix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.NextSibling) { $s = 99; continue; }
				/* */ $s = 100; continue;
				/* if (strings.HasSuffix(n.FirstChild.Data, " ") && ptrType.nil === n.FirstChild.NextSibling) { */ case 99:
					_r$21 = strings.TrimRight(n.FirstChild.Data, " "); /* */ $s = 101; case 101: if($c) { $c = false; _r$21 = _r$21.$blk(); } if (_r$21 && _r$21.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$21;
					n.InsertAfter(new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, " ", "", sliceType.nil));
				/* } */ case 100:
				/* */ if (strings.HasSuffix(n.FirstChild.Data, "\n") && ptrType.nil === n.FirstChild.NextSibling) { $s = 102; continue; }
				/* */ $s = 103; continue;
				/* if (strings.HasSuffix(n.FirstChild.Data, "\n") && ptrType.nil === n.FirstChild.NextSibling) { */ case 102:
					_r$22 = strings.TrimRight(n.FirstChild.Data, "\n"); /* */ $s = 104; case 104: if($c) { $c = false; _r$22 = _r$22.$blk(); } if (_r$22 && _r$22.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$22;
					n.InsertAfter(new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, "\n", "", sliceType.nil));
				/* } */ case 103:
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (378116)) { */ case 32:
				if (ptrType.nil === n.FirstChild) {
					$s = -1; return;
				}
				contentStr = strings.ReplaceAll(n.FirstChild.Data, "\xE2\x80\x8B", "");
				if ("\xE2\x80\xB8" === contentStr) {
					node$3.Tokens = (new sliceType$1($stringToBytes("\xE2\x80\xB8")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				if ("" === contentStr) {
					$s = -1; return;
				}
				codeTokens$1 = (new sliceType$1($stringToBytes(contentStr)));
				content$4 = new ast.Node.ptr(29, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, codeTokens$1, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
				marker$6 = lute.domAttrValue(n, "marker");
				if ("" === marker$6) {
					marker$6 = "`";
				}
				node$3.Type = 27;
				node$3.CodeMarkerLen = marker$6.length;
				node$3.AppendChild(new ast.Node.ptr(28, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				node$3.AppendChild(content$4);
				node$3.AppendChild(new ast.Node.ptr(30, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node$3);
				$s = -1; return;
			/* } else if (_1 === (514)) { */ case 33:
				if (!(ptrType.nil === n.Parent)) {
					if (lute.parentIs(n, new sliceType$7([37378, 87554]))) {
						if ((ptrType.nil === n.PrevSibling || "\xE2\x80\xB8" === n.PrevSibling.Data) && (ptrType.nil === n.NextSibling || "\xE2\x80\xB8" === n.NextSibling.Data)) {
							$s = -1; return;
						}
						if (ptrType.nil === n.NextSibling) {
							$s = -1; return;
						}
						node$3.Type = 10;
						node$3.Tokens = (new sliceType$1($stringToBytes("<br />")));
						tree.Context.Tip.AppendChild(node$3);
						$s = -1; return;
					}
					if (3073 === n.Parent.DataAtom) {
						if (!(ptrType.nil === n.Parent.NextSibling) && ((42754 === n.Parent.NextSibling.DataAtom) || (79618 === n.Parent.NextSibling.DataAtom) || (100106 === n.Parent.NextSibling.DataAtom))) {
							tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
							$s = -1; return;
						}
						if (!(ptrType.nil === n.Parent.Parent) && !(ptrType.nil === n.Parent.Parent.NextSibling) && (45570 === n.Parent.Parent.NextSibling.DataAtom)) {
							tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
							$s = -1; return;
						}
					}
				}
				node$3.Type = 31;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (1)) { */ case 34:
				text$4 = lute.domText(n);
				if ("" === text$4 || "\xE2\x80\x8B" === text$4) {
					$s = -1; return;
				}
				node$3.Type = 33;
				node$3.AppendChild(new ast.Node.ptr(36, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (198403)) { */ case 35:
				imgClass = class$1;
				imgAlt = lute.domAttrValue(n, "alt");
				if ("emoji" === imgClass) {
					node$3.Type = 200;
					emojiImg = new ast.Node.ptr(202, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, tree.EmojiImgTokens(imgAlt, lute.domAttrValue(n, "src")), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					emojiImg.AppendChild(new ast.Node.ptr(203, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(":" + imgAlt + ":"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(emojiImg);
				} else {
					node$3.Type = 34;
					node$3.AppendChild(new ast.Node.ptr(35, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(new ast.Node.ptr(36, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					if (!("" === imgAlt)) {
						node$3.AppendChild(new ast.Node.ptr(40, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(imgAlt))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					}
					node$3.AppendChild(new ast.Node.ptr(37, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(new ast.Node.ptr(38, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					src = lute.domAttrValue(n, "src");
					if (!("" === lute.Options.LinkBase)) {
						src = strings.ReplaceAll(src, lute.Options.LinkBase, "");
					}
					node$3.AppendChild(new ast.Node.ptr(41, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(src))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					linkTitle = lute.domAttrValue(n, "title");
					if (!("" === linkTitle)) {
						node$3.AppendChild(new ast.Node.ptr(43, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						node$3.AppendChild(new ast.Node.ptr(42, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(linkTitle))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					}
					node$3.AppendChild(new ast.Node.ptr(39, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				}
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (281349)) { */ case 36:
				if (ptrType.nil === n.Parent || ptrType.nil === n.Parent.Parent || (!((3073 === n.Parent.DataAtom)) && !((45570 === n.Parent.DataAtom)))) {
					$s = -1; return;
				}
				/* */ if (!(ptrType.nil === n.NextSibling) && (40708 === n.NextSibling.DataAtom)) { $s = 105; continue; }
				/* */ $s = 106; continue;
				/* if (!(ptrType.nil === n.NextSibling) && (40708 === n.NextSibling.DataAtom)) { */ case 105:
					_r$23 = strings.TrimSpace(n.NextSibling.FirstChild.Data); /* */ $s = 107; case 107: if($c) { $c = false; _r$23 = _r$23.$blk(); } if (_r$23 && _r$23.$blk !== undefined) { break s; }
					n.NextSibling.FirstChild.Data = _r$23;
					/* break; */ $s = 20; continue;
				/* } */ case 106:
				node$3.Type = 100;
				if (lute.hasAttr(n, "checked")) {
					node$3.TaskListItemChecked = true;
				}
				tree.Context.Tip.AppendChild(node$3);
				if (!(ptrType$1.nil === node$3.Parent.Parent) && !(ptrType$5.nil === node$3.Parent.Parent.ListData)) {
					node$3.Parent.Parent.ListData.Typ = 3;
				}
				if (!(ptrType$1.nil === node$3.Parent.Parent.Parent) && !(ptrType$5.nil === node$3.Parent.Parent.Parent.ListData)) {
					node$3.Parent.Parent.Parent.ListData.Typ = 3;
				}
				$s = 49; continue;
			/* } else if (_1 === (365829)) { */ case 37:
				node$3.Type = 106;
				tableAligns = sliceType$2.nil;
				th = n.FirstChild.FirstChild.FirstChild;
				while (true) {
					if (!(!(ptrType.nil === th))) { break; }
					align = lute.domAttrValue(th, "align");
					_3 = align;
					if (_3 === ("left")) {
						tableAligns = $append(tableAligns, 1);
					} else if (_3 === ("center")) {
						tableAligns = $append(tableAligns, 2);
					} else if (_3 === ("right")) {
						tableAligns = $append(tableAligns, 3);
					} else {
						tableAligns = $append(tableAligns, 0);
					}
					th = th.NextSibling;
				}
				node$3.TableAligns = tableAligns;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (208901)) { */ case 38:
				node$3.Type = 107;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (9989)) { */ case 39:
				$s = 49; continue;
			/* } else if (_1 === (52226)) { */ case 40:
				node$3.Type = 108;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if ((_1 === (87554)) || (_1 === (37378))) { */ case 41:
				node$3.Type = 109;
				align$1 = lute.domAttrValue(n, "align");
				tableAlign = 0;
				_4 = align$1;
				if (_4 === ("left")) {
					tableAlign = 1;
				} else if (_4 === ("center")) {
					tableAlign = 2;
				} else if (_4 === ("right")) {
					tableAlign = 3;
				} else {
					tableAlign = 0;
				}
				node$3.TableCellAlign = tableAlign;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 49; continue;
			/* } else if (_1 === (461571)) { */ case 42:
				if (ptrType.nil === n.FirstChild) {
					/* break; */ $s = 20; continue;
				}
				if ("footnotes-ref" === dataType) {
					node$3.Type = 16;
					node$3.Tokens = (new sliceType$1($stringToBytes("[" + lute.domAttrValue(n, "data-footnotes-label") + "]")));
					tree.Context.Tip.AppendChild(node$3);
				}
				$s = -1; return;
			/* } else if (_1 === (40708)) { */ case 43:
				if (ptrType.nil === n.FirstChild) {
					/* break; */ $s = 20; continue;
				}
				if ("link-ref" === dataType) {
					node$3.Type = 16;
					node$3.Tokens = (new sliceType$1($stringToBytes("[" + n.FirstChild.Data + "][" + lute.domAttrValue(n, "data-link-label") + "]")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				codeTokens$2 = sliceType$1.nil;
				if ("\xE2\x80\x8B" === n.FirstChild.Data && "" === lute.domAttrValue(n, "style") && !(ptrType.nil === n.FirstChild.NextSibling)) {
					codeTokens$2 = (new sliceType$1($stringToBytes(n.FirstChild.NextSibling.FirstChild.Data)));
				} else if (378116 === n.FirstChild.DataAtom) {
					codeTokens$2 = (new sliceType$1($stringToBytes(n.FirstChild.FirstChild.Data)));
					if ("\xE2\x80\x8B" === ($bytesToString(codeTokens$2))) {
						/* break; */ $s = 20; continue;
					}
				} else {
					/* break; */ $s = 20; continue;
				}
				if ("math-inline" === dataType) {
					node$3.Type = 304;
					node$3.AppendChild(new ast.Node.ptr(305, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(new ast.Node.ptr(306, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, codeTokens$2, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(new ast.Node.ptr(307, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					tree.Context.Tip.AppendChild(node$3);
				} else if ("html-inline" === dataType) {
					node$3.Type = 10;
					node$3.Tokens = codeTokens$2;
					tree.Context.Tip.AppendChild(node$3);
				} else if ("code-inline" === dataType) {
					node$3.Tokens = codeTokens$2;
					tree.Context.Tip.AppendChild(node$3);
				} else if ("html-entity" === dataType) {
					node$3.Type = 16;
					node$3.Tokens = codeTokens$2;
					tree.Context.Tip.AppendChild(node$3);
				}
				$s = -1; return;
			/* } else if (_1 === (16132)) { */ case 44:
				$s = -1; return;
			/* } else if (_1 === (29191)) { */ case 45:
				node$3.Type = 9;
				_r$24 = lute.domHTML(n); /* */ $s = 108; case 108: if($c) { $c = false; _r$24 = _r$24.$blk(); } if (_r$24 && _r$24.$blk !== undefined) { break s; }
				node$3.Tokens = _r$24;
				node$3.Tokens = (x$1 = bytes.SplitAfter(node$3.Tokens, (new sliceType$1($stringToBytes("</summary>")))), (0 >= x$1.$length ? ($throwRuntimeError("index out of range"), undefined) : x$1.$array[x$1.$offset + 0]));
				tree.Context.Tip.AppendChild(node$3);
				$s = 49; continue;
			/* } else if (_1 === (47363)) { */ case 46:
				node$3.Type = 10;
				_r$25 = lute.domHTML(n); /* */ $s = 109; case 109: if($c) { $c = false; _r$25 = _r$25.$blk(); } if (_r$25 && _r$25.$blk !== undefined) { break s; }
				node$3.Tokens = _r$25;
				tree.Context.Tip.AppendChild(node$3);
				$s = -1; return;
			/* } else if (_1 === (459783)) { */ case 47:
				$s = -1; return;
			/* } else { */ case 48:
				node$3.Type = 9;
				_r$26 = lute.domHTML(n); /* */ $s = 110; case 110: if($c) { $c = false; _r$26 = _r$26.$blk(); } if (_r$26 && _r$26.$blk !== undefined) { break s; }
				node$3.Tokens = _r$26;
				tree.Context.Tip.AppendChild(node$3);
				$s = -1; return;
			/* } */ case 49:
		case 20:
		c$1 = n.FirstChild;
		/* while (true) { */ case 111:
			/* if (!(!(c$1 === ptrType.nil))) { break; } */ if(!(!(c$1 === ptrType.nil))) { $s = 112; continue; }
			$r = lute.genASTByVditorDOM(c$1, tree); /* */ $s = 113; case 113: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			c$1 = c$1.NextSibling;
		/* } */ $s = 111; continue; case 112:
		_5 = n.DataAtom;
		if ((_5 === (28162)) || (_5 === (1537))) {
			marker$7 = lute.domAttrValue(n, "data-marker");
			if ("" === marker$7) {
				marker$7 = "*";
			}
			if ("_" === marker$7) {
				node$3.AppendChild(new ast.Node.ptr(21, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$7))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			} else {
				node$3.AppendChild(new ast.Node.ptr(19, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$7))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			}
		} else if ((_5 === (449798)) || (_5 === (257))) {
			marker$8 = lute.domAttrValue(n, "data-marker");
			if ("" === marker$8) {
				marker$8 = "**";
			}
			if ("__" === marker$8) {
				node$3.AppendChild(new ast.Node.ptr(26, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$8))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			} else {
				node$3.AppendChild(new ast.Node.ptr(24, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$8))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			}
		} else if (_5 === (1)) {
			node$3.AppendChild(new ast.Node.ptr(37, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			node$3.AppendChild(new ast.Node.ptr(38, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			href = lute.domAttrValue(n, "href");
			if (!("" === lute.Options.LinkBase)) {
				href = strings.ReplaceAll(href, lute.Options.LinkBase, "");
			}
			node$3.AppendChild(new ast.Node.ptr(41, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(href))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			linkTitle$1 = lute.domAttrValue(n, "title");
			if (!("" === linkTitle$1)) {
				node$3.AppendChild(new ast.Node.ptr(43, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				node$3.AppendChild(new ast.Node.ptr(42, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(linkTitle$1))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			}
			node$3.AppendChild(new ast.Node.ptr(39, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		} else if ((_5 === (283139)) || (_5 === (9473)) || (_5 === (53766))) {
			marker$9 = lute.domAttrValue(n, "data-marker");
			if ("~" === marker$9) {
				node$3.AppendChild(new ast.Node.ptr(103, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$9))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			} else {
				node$3.AppendChild(new ast.Node.ptr(105, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(marker$9))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			}
		} else if (_5 === (29191)) {
			tree.Context.Tip.AppendChild(new ast.Node.ptr(9, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("</details>"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		}
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.genASTByVditorDOM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$19 = _r$19; $f._r$2 = _r$2; $f._r$20 = _r$20; $f._r$21 = _r$21; $f._r$22 = _r$22; $f._r$23 = _r$23; $f._r$24 = _r$24; $f._r$25 = _r$25; $f._r$26 = _r$26; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tuple = _tuple; $f.align = align; $f.align$1 = align$1; $f.bullet = bullet; $f.c = c; $f.c$1 = c$1; $f.checkIndentCodeBlock = checkIndentCodeBlock; $f.class$1 = class$1; $f.class$2 = class$2; $f.codeTokens = codeTokens; $f.codeTokens$1 = codeTokens$1; $f.codeTokens$2 = codeTokens$2; $f.content = content; $f.content$1 = content$1; $f.content$2 = content$2; $f.content$3 = content$3; $f.content$4 = content$4; $f.contentStr = contentStr; $f.dataRender = dataRender; $f.dataType = dataType; $f.divDataType = divDataType; $f.emojiImg = emojiImg; $f.err = err; $f.firstLiMarker = firstLiMarker; $f.headingC8hMarker = headingC8hMarker; $f.href = href; $f.i = i; $f.id = id; $f.imgAlt = imgAlt; $f.imgClass = imgClass; $f.label = label; $f.language = language; $f.li = li; $f.line = line; $f.lines = lines; $f.linkTitle = linkTitle; $f.linkTitle$1 = linkTitle$1; $f.lute = lute; $f.marker = marker; $f.marker$1 = marker$1; $f.marker$2 = marker$2; $f.marker$3 = marker$3; $f.marker$4 = marker$4; $f.marker$5 = marker$5; $f.marker$6 = marker$6; $f.marker$7 = marker$7; $f.marker$8 = marker$8; $f.marker$9 = marker$9; $f.md = md; $f.n = n; $f.node = node; $f.node$1 = node$1; $f.node$2 = node$2; $f.node$3 = node$3; $f.ol = ol; $f.originalHTML = originalHTML; $f.p = p; $f.src = src; $f.startAttr = startAttr; $f.startCaret = startCaret; $f.tableAlign = tableAlign; $f.tableAligns = tableAligns; $f.text = text; $f.text$1 = text$1; $f.text$2 = text$2; $f.text$3 = text$3; $f.text$4 = text$4; $f.th = th; $f.tight = tight; $f.tree = tree; $f.x = x; $f.x$1 = x$1; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Lute.prototype.genASTByVditorDOM = function(n, tree) { return this.$val.genASTByVditorDOM(n, tree); };
	Lute.ptr.prototype.hasAttr = function(n, attrName) {
		var _i, _ref, attr, attrName, lute, n;
		lute = this;
		_ref = n.Attr;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), html.Attribute);
			if (attr.Key === attrName) {
				return true;
			}
			_i++;
		}
		return false;
	};
	Lute.prototype.hasAttr = function(n, attrName) { return this.$val.hasAttr(n, attrName); };
	Lute.ptr.prototype.domAttrValue = function(n, attrName) {
		var _i, _ref, attr, attrName, lute, n;
		lute = this;
		if (ptrType.nil === n) {
			return "";
		}
		_ref = n.Attr;
		_i = 0;
		while (true) {
			if (!(_i < _ref.$length)) { break; }
			attr = $clone(((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]), html.Attribute);
			if (attr.Key === attrName) {
				return attr.Val;
			}
			_i++;
		}
		return "";
	};
	Lute.prototype.domAttrValue = function(n, attrName) { return this.$val.domAttrValue(n, attrName); };
	Lute.ptr.prototype.parentIs = function(n, parentTypes) {
		var _i, _ref, lute, n, p, parentTypes, pt;
		lute = this;
		p = n.Parent;
		while (true) {
			if (!(!(ptrType.nil === p))) { break; }
			_ref = parentTypes;
			_i = 0;
			while (true) {
				if (!(_i < _ref.$length)) { break; }
				pt = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
				if (pt === p.DataAtom) {
					return true;
				}
				_i++;
			}
			p = p.Parent;
		}
		return false;
	};
	Lute.prototype.parentIs = function(n, parentTypes) { return this.$val.parentIs(n, parentTypes); };
	Lute.ptr.prototype.domText = function(n) {
		var buf, child, lute, n;
		lute = this;
		buf = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0);
		child = n.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			lute.domText0(child, buf);
			child = child.NextSibling;
		}
		return buf.String();
	};
	Lute.prototype.domText = function(n) { return this.$val.domText(n); };
	Lute.ptr.prototype.domText0 = function(n, buffer) {
		var _1, buffer, child, lute, n;
		lute = this;
		if (ptrType.nil === n || "1" === lute.domAttrValue(n, "data-render")) {
			return;
		}
		if ("svg" === n.Namespace) {
			return;
		}
		_1 = n.DataAtom;
		if (_1 === (0)) {
			buffer.WriteString(n.Data);
		} else if (_1 === (514)) {
			buffer.WriteString("\n");
		}
		child = n.FirstChild;
		while (true) {
			if (!(!(ptrType.nil === child))) { break; }
			lute.domText0(child, buffer);
			child = child.NextSibling;
		}
	};
	Lute.prototype.domText0 = function(n, buffer) { return this.$val.domText0(n, buffer); };
	Lute.ptr.prototype.domHTML = function(n) {
		var _r, buf, lute, n, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; buf = $f.buf; lute = $f.lute; n = $f.n; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		lute = this;
		buf = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0);
		_r = html.Render(buf, n); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_r;
		$s = -1; return bytes.ReplaceAll(buf.Bytes(), (new sliceType$1($stringToBytes("\xE2\x80\x8B"))), sliceType$1.nil);
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.domHTML }; } $f._r = _r; $f.buf = buf; $f.lute = lute; $f.n = n; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.domHTML = function(n) { return this.$val.domHTML(n); };
	Lute.ptr.prototype.isEmptyText = function(n) {
		var _r, lute, n, text, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; lute = $f.lute; n = $f.n; text = $f.text; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		lute = this;
		_r = strings.TrimSpace(lute.domText(n)); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		text = _r;
		if ("" === text || "\xE2\x80\x8B" === text) {
			$s = -1; return true;
		}
		if ("\xE2\x80\x8B\xE2\x80\xB8" === text || "\xE2\x80\xB8\xE2\x80\x8B" === text) {
			$s = -1; return true;
		}
		$s = -1; return false;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.isEmptyText }; } $f._r = _r; $f.lute = lute; $f.n = n; $f.text = text; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.isEmptyText = function(n) { return this.$val.isEmptyText(n); };
	Lute.ptr.prototype.starstWithNewline = function(n) {
		var lute, n;
		lute = this;
		return strings.HasPrefix(n.Data, "\n") || strings.HasPrefix(n.Data, "\xE2\x80\x8B\n");
	};
	Lute.prototype.starstWithNewline = function(n) { return this.$val.starstWithNewline(n); };
	Lute.ptr.prototype.isInline = function(n) {
		var lute, n;
		lute = this;
		if (ptrType.nil === n) {
			return false;
		}
		return (0 === n.DataAtom) || (378116 === n.DataAtom) || (449798 === n.DataAtom) || (28162 === n.DataAtom) || (1 === n.DataAtom) || (198403 === n.DataAtom) || (40708 === n.DataAtom);
	};
	Lute.prototype.isInline = function(n) { return this.$val.isInline(n); };
	Lute.ptr.prototype.SpinVditorIRDOM = function(ivHTML) {
		var _r, _r$1, _r$2, _r$3, ivHTML, lute, markdown, output, ovHTML, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; ivHTML = $f.ivHTML; lute = $f.lute; markdown = $f.markdown; output = $f.output; ovHTML = $f.ovHTML; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		ovHTML = "";
		lute = this;
		lute.Options.VditorIR = true;
		lute.Options.VditorWYSIWYG = true;
		ivHTML = strings.ReplaceAll(ivHTML, "<wbr>", "\xE2\x80\xB8");
		_r = lute.vditorIRDOM2Md(ivHTML); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		markdown = _r;
		_r$1 = parse.Parse("", (new sliceType$1($stringToBytes(markdown))), lute.Options); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		tree = _r$1;
		renderer = render.NewVditorIRRenderer(tree);
		_r$2 = renderer.Render(); /* */ $s = 3; case 3: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		output = _r$2;
		/* */ if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { $s = 4; continue; }
		/* */ $s = 5; continue;
		/* if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { */ case 4:
			_r$3 = renderer.RenderFootnotesDefs(renderer.BaseRenderer.Tree.Context); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
			output = _r$3;
		/* } */ case 5:
		ovHTML = strings.ReplaceAll(($bytesToString(output)), "\xE2\x80\xB8", "<wbr>");
		$s = -1; return ovHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.SpinVditorIRDOM }; } $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f.ivHTML = ivHTML; $f.lute = lute; $f.markdown = markdown; $f.output = output; $f.ovHTML = ovHTML; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.SpinVditorIRDOM = function(ivHTML) { return this.$val.SpinVditorIRDOM(ivHTML); };
	Lute.ptr.prototype.HTML2VditorIRDOM = function(sHTML) {
		var _entry, _i, _key, _keys, _r, _r$1, _r$2, _r$3, _r$4, _ref, _tuple, err, lute, markdown, nodeType, output, renderer, rendererFunc, sHTML, tree, vHTML, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _key = $f._key; _keys = $f._keys; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _ref = $f._ref; _tuple = $f._tuple; err = $f.err; lute = $f.lute; markdown = $f.markdown; nodeType = $f.nodeType; output = $f.output; renderer = $f.renderer; rendererFunc = $f.rendererFunc; sHTML = $f.sHTML; tree = $f.tree; vHTML = $f.vHTML; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		vHTML = "";
		lute = this;
		lute.Options.VditorIR = true;
		lute.Options.VditorWYSIWYG = true;
		_r = lute.HTML2Markdown(sHTML); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		markdown = _tuple[0];
		err = _tuple[1];
		/* */ if (!($interfaceIsEqual($ifaceNil, err))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!($interfaceIsEqual($ifaceNil, err))) { */ case 2:
			_r$1 = err.Error(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			vHTML = _r$1;
			$s = -1; return vHTML;
		/* } */ case 3:
		_r$2 = parse.Parse("", (new sliceType$1($stringToBytes(markdown))), lute.Options); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		tree = _r$2;
		renderer = render.NewVditorIRRenderer(tree);
		_ref = lute.HTML2VditorIRDOMRendererFuncs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			nodeType = _entry.k;
			rendererFunc = _entry.v;
			_key = nodeType; (renderer.BaseRenderer.ExtRendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: rendererFunc };
			_i++;
		}
		_r$3 = renderer.Render(); /* */ $s = 6; case 6: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
		output = _r$3;
		/* */ if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { $s = 7; continue; }
		/* */ $s = 8; continue;
		/* if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { */ case 7:
			_r$4 = renderer.RenderFootnotesDefs(renderer.BaseRenderer.Tree.Context); /* */ $s = 9; case 9: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
			output = _r$4;
		/* } */ case 8:
		vHTML = ($bytesToString(output));
		$s = -1; return vHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.HTML2VditorIRDOM }; } $f._entry = _entry; $f._i = _i; $f._key = _key; $f._keys = _keys; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._ref = _ref; $f._tuple = _tuple; $f.err = err; $f.lute = lute; $f.markdown = markdown; $f.nodeType = nodeType; $f.output = output; $f.renderer = renderer; $f.rendererFunc = rendererFunc; $f.sHTML = sHTML; $f.tree = tree; $f.vHTML = vHTML; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.HTML2VditorIRDOM = function(sHTML) { return this.$val.HTML2VditorIRDOM(sHTML); };
	Lute.ptr.prototype.VditorIRDOM2HTML = function(vhtml) {
		var _r, _r$1, lute, markdown, sHTML, vhtml, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; _r$1 = $f._r$1; lute = $f.lute; markdown = $f.markdown; sHTML = $f.sHTML; vhtml = $f.vhtml; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		sHTML = "";
		lute = this;
		lute.Options.VditorIR = true;
		lute.Options.VditorWYSIWYG = true;
		_r = lute.vditorIRDOM2Md(vhtml); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		markdown = _r;
		_r$1 = lute.Md2HTML(markdown); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		sHTML = _r$1;
		$s = -1; return sHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.VditorIRDOM2HTML }; } $f._r = _r; $f._r$1 = _r$1; $f.lute = lute; $f.markdown = markdown; $f.sHTML = sHTML; $f.vhtml = vhtml; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.VditorIRDOM2HTML = function(vhtml) { return this.$val.VditorIRDOM2HTML(vhtml); };
	Lute.ptr.prototype.Md2VditorIRDOM = function(markdown) {
		var _entry, _i, _key, _keys, _r, _r$1, _r$2, _ref, lute, markdown, nodeType, output, renderer, rendererFunc, tree, vHTML, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _entry = $f._entry; _i = $f._i; _key = $f._key; _keys = $f._keys; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; lute = $f.lute; markdown = $f.markdown; nodeType = $f.nodeType; output = $f.output; renderer = $f.renderer; rendererFunc = $f.rendererFunc; tree = $f.tree; vHTML = $f.vHTML; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		vHTML = "";
		lute = this;
		lute.Options.VditorIR = true;
		lute.Options.VditorWYSIWYG = true;
		_r = parse.Parse("", (new sliceType$1($stringToBytes(markdown))), lute.Options); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		tree = _r;
		renderer = render.NewVditorIRRenderer(tree);
		_ref = lute.Md2VditorIRDOMRendererFuncs;
		_i = 0;
		_keys = $keys(_ref);
		while (true) {
			if (!(_i < _keys.length)) { break; }
			_entry = _ref[_keys[_i]];
			if (_entry === undefined) {
				_i++;
				continue;
			}
			nodeType = _entry.k;
			rendererFunc = _entry.v;
			_key = nodeType; (renderer.BaseRenderer.ExtRendererFuncs || $throwRuntimeError("assignment to entry in nil map"))[ast.NodeType.keyFor(_key)] = { k: _key, v: rendererFunc };
			_i++;
		}
		_r$1 = renderer.Render(); /* */ $s = 2; case 2: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
		output = _r$1;
		/* */ if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { $s = 3; continue; }
		/* */ $s = 4; continue;
		/* if (renderer.BaseRenderer.Option.Footnotes && 0 < renderer.BaseRenderer.Tree.Context.FootnotesDefs.$length) { */ case 3:
			_r$2 = renderer.RenderFootnotesDefs(renderer.BaseRenderer.Tree.Context); /* */ $s = 5; case 5: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
			output = _r$2;
		/* } */ case 4:
		vHTML = ($bytesToString(output));
		$s = -1; return vHTML;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.Md2VditorIRDOM }; } $f._entry = _entry; $f._i = _i; $f._key = _key; $f._keys = _keys; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f.lute = lute; $f.markdown = markdown; $f.nodeType = nodeType; $f.output = output; $f.renderer = renderer; $f.rendererFunc = rendererFunc; $f.tree = tree; $f.vHTML = vHTML; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.Md2VditorIRDOM = function(markdown) { return this.$val.Md2VditorIRDOM(markdown); };
	Lute.ptr.prototype.VditorIRDOM2Md = function(htmlStr) {
		var _r, htmlStr, lute, markdown, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; htmlStr = $f.htmlStr; lute = $f.lute; markdown = $f.markdown; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		markdown = "";
		lute = this;
		lute.Options.VditorIR = true;
		lute.Options.VditorWYSIWYG = true;
		htmlStr = strings.ReplaceAll(htmlStr, "\xE2\x80\x8B", "");
		_r = lute.vditorIRDOM2Md(htmlStr); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		markdown = _r;
		markdown = strings.ReplaceAll(markdown, "\xE2\x80\x8B", "");
		$s = -1; return markdown;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.VditorIRDOM2Md }; } $f._r = _r; $f.htmlStr = htmlStr; $f.lute = lute; $f.markdown = markdown; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.VditorIRDOM2Md = function(htmlStr) { return this.$val.VditorIRDOM2Md(htmlStr); };
	Lute.ptr.prototype.vditorIRDOM2Md = function(htmlStr) {
		var _i, _r, _r$1, _r$2, _ref, _tuple, err, formatted, htmlNode, htmlNodes, htmlRoot, htmlStr, lute, markdown, reader, renderer, tree, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$2 = $f._r$2; _ref = $f._ref; _tuple = $f._tuple; err = $f.err; formatted = $f.formatted; htmlNode = $f.htmlNode; htmlNodes = $f.htmlNodes; htmlRoot = $f.htmlRoot; htmlStr = $f.htmlStr; lute = $f.lute; markdown = $f.markdown; reader = $f.reader; renderer = $f.renderer; tree = $f.tree; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		markdown = "";
		lute = this;
		htmlStr = strings.ReplaceAll(htmlStr, "<wbr>", "");
		htmlStr = strings.ReplaceAll(htmlStr, "\t\n", "\n");
		htmlStr = strings.ReplaceAll(htmlStr, "    \n", "  \n");
		reader = strings.NewReader(htmlStr);
		htmlRoot = new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 3, 0, "", "", sliceType.nil);
		_r = html.ParseFragment(reader, htmlRoot); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		_tuple = _r;
		htmlNodes = _tuple[0];
		err = _tuple[1];
		/* */ if (!($interfaceIsEqual($ifaceNil, err))) { $s = 2; continue; }
		/* */ $s = 3; continue;
		/* if (!($interfaceIsEqual($ifaceNil, err))) { */ case 2:
			_r$1 = err.Error(); /* */ $s = 4; case 4: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
			markdown = _r$1;
			$s = -1; return markdown;
		/* } */ case 3:
		$r = lute.adjustVditorDOM(htmlNodes); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		tree = new parse.Tree.ptr("", new ast.Node.ptr(0, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil), new parse.Context.ptr(ptrType$6.nil, lute.Options, false, sliceType$3.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, 0, 0, 0, 0, 0, 0, 0, false, false, false, false, ptrType$1.nil), ptrType$3.nil, ptrType$4.nil);
		tree.Context.Tip = tree.Root;
		_ref = htmlNodes;
		_i = 0;
		/* while (true) { */ case 6:
			/* if (!(_i < _ref.$length)) { break; } */ if(!(_i < _ref.$length)) { $s = 7; continue; }
			htmlNode = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
			$r = lute.genASTByVditorIRDOM(htmlNode, tree); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			_i++;
		/* } */ $s = 6; continue; case 7:
		$r = ast.Walk(tree.Root, (function(n, entering) {
			var _1, entering, n, previousLi;
			if (entering) {
				_1 = n.Type;
				if ((_1 === (10)) || (_1 === (27)) || (_1 === (304)) || (_1 === (9)) || (_1 === (15)) || (_1 === (302))) {
					n.Tokens = util.UnescapeHTML(n.Tokens);
					if (!(ptrType$1.nil === n.Next) && (27 === n.Next.Type) && (n.CodeMarkerLen === n.Next.CodeMarkerLen)) {
						n.FirstChild.Next.Tokens = $appendSlice(n.FirstChild.Next.Tokens, n.Next.FirstChild.Next.Tokens);
						n.Next.Unlink();
					}
				} else if (_1 === (7)) {
					if (!(ptrType$1.nil === n.Parent) && (7 === n.Parent.Type)) {
						previousLi = n.Previous;
						if (!(ptrType$1.nil === previousLi)) {
							previousLi.AppendChild(n);
						}
					}
				}
			}
			return 2;
		})); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		renderer = render.NewFormatRenderer(tree);
		_r$2 = renderer.Render(); /* */ $s = 10; case 10: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
		formatted = _r$2;
		markdown = ($bytesToString(formatted));
		$s = -1; return markdown;
		/* */ } return; } if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.vditorIRDOM2Md }; } $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$2 = _r$2; $f._ref = _ref; $f._tuple = _tuple; $f.err = err; $f.formatted = formatted; $f.htmlNode = htmlNode; $f.htmlNodes = htmlNodes; $f.htmlRoot = htmlRoot; $f.htmlStr = htmlStr; $f.lute = lute; $f.markdown = markdown; $f.reader = reader; $f.renderer = renderer; $f.tree = tree; $f.$s = $s; $f.$r = $r; return $f;
	};
	Lute.prototype.vditorIRDOM2Md = function(htmlStr) { return this.$val.vditorIRDOM2Md(htmlStr); };
	Lute.ptr.prototype.genASTByVditorIRDOM = function(n, tree) {
		var _1, _2, _3, _4, _5, _6, _i, _r, _r$1, _r$10, _r$11, _r$12, _r$13, _r$14, _r$15, _r$16, _r$17, _r$18, _r$2, _r$3, _r$4, _r$5, _r$6, _r$7, _r$8, _r$9, _ref, _tuple, align, align$1, bullet, c, c$1, c$2, caret, caretInMarker, checkIndentCodeBlock, class$1, codeTokens, codeTokens$1, codeTokens$2, content, content$1, content$2, content$3, contentStr, dataRender, dataType, def, divDataType, emojiImg, err, firstLiMarker, href, i, id, imgAlt, imgClass, info, lastBacktick, lastBacktick$1, level, line, lines, linkTitle, lute, marker, marker$1, marker$2, marker$3, marker$4, md, n, node, node$1, node$2, node$3, originalHTML, p, p$1, startAttr, startCaret, tableAlign, tableAligns, text, text$1, text$2, text$3, text$4, text$5, text$6, th, tight, tree, x, $s, $deferred, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _1 = $f._1; _2 = $f._2; _3 = $f._3; _4 = $f._4; _5 = $f._5; _6 = $f._6; _i = $f._i; _r = $f._r; _r$1 = $f._r$1; _r$10 = $f._r$10; _r$11 = $f._r$11; _r$12 = $f._r$12; _r$13 = $f._r$13; _r$14 = $f._r$14; _r$15 = $f._r$15; _r$16 = $f._r$16; _r$17 = $f._r$17; _r$18 = $f._r$18; _r$2 = $f._r$2; _r$3 = $f._r$3; _r$4 = $f._r$4; _r$5 = $f._r$5; _r$6 = $f._r$6; _r$7 = $f._r$7; _r$8 = $f._r$8; _r$9 = $f._r$9; _ref = $f._ref; _tuple = $f._tuple; align = $f.align; align$1 = $f.align$1; bullet = $f.bullet; c = $f.c; c$1 = $f.c$1; c$2 = $f.c$2; caret = $f.caret; caretInMarker = $f.caretInMarker; checkIndentCodeBlock = $f.checkIndentCodeBlock; class$1 = $f.class$1; codeTokens = $f.codeTokens; codeTokens$1 = $f.codeTokens$1; codeTokens$2 = $f.codeTokens$2; content = $f.content; content$1 = $f.content$1; content$2 = $f.content$2; content$3 = $f.content$3; contentStr = $f.contentStr; dataRender = $f.dataRender; dataType = $f.dataType; def = $f.def; divDataType = $f.divDataType; emojiImg = $f.emojiImg; err = $f.err; firstLiMarker = $f.firstLiMarker; href = $f.href; i = $f.i; id = $f.id; imgAlt = $f.imgAlt; imgClass = $f.imgClass; info = $f.info; lastBacktick = $f.lastBacktick; lastBacktick$1 = $f.lastBacktick$1; level = $f.level; line = $f.line; lines = $f.lines; linkTitle = $f.linkTitle; lute = $f.lute; marker = $f.marker; marker$1 = $f.marker$1; marker$2 = $f.marker$2; marker$3 = $f.marker$3; marker$4 = $f.marker$4; md = $f.md; n = $f.n; node = $f.node; node$1 = $f.node$1; node$2 = $f.node$2; node$3 = $f.node$3; originalHTML = $f.originalHTML; p = $f.p; p$1 = $f.p$1; startAttr = $f.startAttr; startCaret = $f.startCaret; tableAlign = $f.tableAlign; tableAligns = $f.tableAligns; text = $f.text; text$1 = $f.text$1; text$2 = $f.text$2; text$3 = $f.text$3; text$4 = $f.text$4; text$5 = $f.text$5; text$6 = $f.text$6; th = $f.th; tight = $f.tight; tree = $f.tree; x = $f.x; $s = $f.$s; $deferred = $f.$deferred; $r = $f.$r; } var $err = null; try { s: while (true) { switch ($s) { case 0: $deferred = []; $deferred.index = $curGoroutine.deferStack.length; $curGoroutine.deferStack.push($deferred);
		lute = this;
		dataRender = lute.domAttrValue(n, "data-render");
		if ("1" === dataRender || "2" === dataRender) {
			$s = -1; return;
		}
		dataType = lute.domAttrValue(n, "data-type");
		/* */ if (92931 === n.DataAtom) { $s = 1; continue; }
		/* */ $s = 2; continue;
		/* if (92931 === n.DataAtom) { */ case 1:
			/* */ if ("code-block" === dataType || "html-block" === dataType || "math-block" === dataType) { $s = 3; continue; }
			/* */ if ("link-ref-defs-block" === dataType) { $s = 4; continue; }
			/* */ if ("footnotes-def" === dataType) { $s = 5; continue; }
			/* */ if ("footnotes-block" === dataType) { $s = 6; continue; }
			/* */ if ("toc-block" === dataType) { $s = 7; continue; }
			/* */ $s = 8; continue;
			/* if ("code-block" === dataType || "html-block" === dataType || "math-block" === dataType) { */ case 3:
				if (("code-block" === dataType || "math-block" === dataType) && !strings.Contains(lute.domAttrValue(n.FirstChild, "data-type"), "-block-open-marker")) {
					p = new ast.Node.ptr(1, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					text = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(lute.domText(n.FirstChild)))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					p.AppendChild(text);
					tree.Context.Tip.AppendChild(p);
					tree.Context.Tip = p;
					$s = -1; return;
				}
				c = n.FirstChild;
				/* while (true) { */ case 10:
					/* if (!(!(c === ptrType.nil))) { break; } */ if(!(!(c === ptrType.nil))) { $s = 11; continue; }
					$r = lute.genASTByVditorIRDOM(c, tree); /* */ $s = 12; case 12: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					c = c.NextSibling;
				/* } */ $s = 10; continue; case 11:
				$s = 9; continue;
			/* } else if ("link-ref-defs-block" === dataType) { */ case 4:
				text$1 = lute.domText(n);
				node = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(text$1))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
				tree.Context.Tip.AppendChild(node);
				$s = 9; continue;
			/* } else if ("footnotes-def" === dataType) { */ case 5:
				c$1 = n.FirstChild;
				/* while (true) { */ case 13:
					/* if (!(!(c$1 === ptrType.nil))) { break; } */ if(!(!(c$1 === ptrType.nil))) { $s = 14; continue; }
					$r = lute.genASTByVditorIRDOM(c$1, tree); /* */ $s = 15; case 15: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
					c$1 = c$1.NextSibling;
				/* } */ $s = 13; continue; case 14:
				$s = 9; continue;
			/* } else if ("footnotes-block" === dataType) { */ case 6:
				def = n.FirstChild;
				/* while (true) { */ case 16:
					/* if (!(!(ptrType.nil === def))) { break; } */ if(!(!(ptrType.nil === def))) { $s = 17; continue; }
					originalHTML = new bytes.Buffer.ptr(sliceType$1.nil, 0, 0);
					_r = html.Render(originalHTML, def); /* */ $s = 18; case 18: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
					err = _r;
					/* */ if ($interfaceIsEqual($ifaceNil, err)) { $s = 19; continue; }
					/* */ $s = 20; continue;
					/* if ($interfaceIsEqual($ifaceNil, err)) { */ case 19:
						_r$1 = lute.vditorIRDOM2Md(originalHTML.String()); /* */ $s = 21; case 21: if($c) { $c = false; _r$1 = _r$1.$blk(); } if (_r$1 && _r$1.$blk !== undefined) { break s; }
						md = _r$1;
						lines = strings.Split(md, "\n");
						md = "";
						_ref = lines;
						_i = 0;
						while (true) {
							if (!(_i < _ref.$length)) { break; }
							i = _i;
							line = ((_i < 0 || _i >= _ref.$length) ? ($throwRuntimeError("index out of range"), undefined) : _ref.$array[_ref.$offset + _i]);
							if (0 < i) {
								md = md + ("    " + line);
							} else {
								md = line;
							}
							md = md + ("\n");
							_i++;
						}
						node$1 = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(md))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
						tree.Context.Tip.AppendChild(node$1);
					/* } */ case 20:
					def = def.NextSibling;
				/* } */ $s = 16; continue; case 17:
				$s = 9; continue;
			/* } else if ("toc-block" === dataType) { */ case 7:
				node$2 = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("[toc]\n\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
				tree.Context.Tip.AppendChild(node$2);
				$s = 9; continue;
			/* } else { */ case 8:
				text$2 = lute.domText(n);
				if ("\xE2\x80\xB8\n" === text$2) {
					tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\xB8\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				}
			/* } */ case 9:
			$s = -1; return;
		/* } */ case 2:
		class$1 = lute.domAttrValue(n, "class");
		content = strings.ReplaceAll(n.Data, "\xE2\x80\x8B", "");
		node$3 = new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(content))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
			_1 = n.DataAtom;
			/* */ if (_1 === (0)) { $s = 23; continue; }
			/* */ if ((_1 === (3073)) || (_1 === (92931))) { $s = 24; continue; }
			/* */ if ((_1 === (89090)) || (_1 === (187906)) || (_1 === (199938)) || (_1 === (214274)) || (_1 === (216834)) || (_1 === (412930))) { $s = 25; continue; }
			/* */ if (_1 === (87810)) { $s = 26; continue; }
			/* */ if (_1 === (100106)) { $s = 27; continue; }
			/* */ if ((_1 === (79618)) || (_1 === (42754))) { $s = 28; continue; }
			/* */ if (_1 === (45570)) { $s = 29; continue; }
			/* */ if (_1 === (290819)) { $s = 30; continue; }
			/* */ if ((_1 === (28162)) || (_1 === (1537))) { $s = 31; continue; }
			/* */ if ((_1 === (449798)) || (_1 === (257))) { $s = 32; continue; }
			/* */ if ((_1 === (283139)) || (_1 === (9473)) || (_1 === (53766))) { $s = 33; continue; }
			/* */ if (_1 === (378116)) { $s = 34; continue; }
			/* */ if (_1 === (514)) { $s = 35; continue; }
			/* */ if (_1 === (1)) { $s = 36; continue; }
			/* */ if (_1 === (198403)) { $s = 37; continue; }
			/* */ if (_1 === (281349)) { $s = 38; continue; }
			/* */ if (_1 === (365829)) { $s = 39; continue; }
			/* */ if (_1 === (208901)) { $s = 40; continue; }
			/* */ if (_1 === (9989)) { $s = 41; continue; }
			/* */ if (_1 === (52226)) { $s = 42; continue; }
			/* */ if ((_1 === (87554)) || (_1 === (37378))) { $s = 43; continue; }
			/* */ if (_1 === (461571)) { $s = 44; continue; }
			/* */ if (_1 === (40708)) { $s = 45; continue; }
			/* */ if (_1 === (16132)) { $s = 46; continue; }
			/* */ if (_1 === (29191)) { $s = 47; continue; }
			/* */ if (_1 === (47363)) { $s = 48; continue; }
			/* */ if (_1 === (459783)) { $s = 49; continue; }
			/* */ $s = 50; continue;
			/* if (_1 === (0)) { */ case 23:
				if ("" === content) {
					$s = -1; return;
				}
				checkIndentCodeBlock = strings.ReplaceAll(content, "\xE2\x80\xB8", "");
				checkIndentCodeBlock = strings.ReplaceAll(checkIndentCodeBlock, "\t", "    ");
				/* */ if ((!lute.isInline(n.PrevSibling)) && strings.HasPrefix(checkIndentCodeBlock, "    ")) { $s = 52; continue; }
				/* */ $s = 53; continue;
				/* if ((!lute.isInline(n.PrevSibling)) && strings.HasPrefix(checkIndentCodeBlock, "    ")) { */ case 52:
					node$3.Type = 11;
					node$3.IsFencedCodeBlock = true;
					node$3.AppendChild(new ast.Node.ptr(12, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("```"))), false, false, false, 0, false, 0, 3, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(new ast.Node.ptr(14, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					startCaret = strings.HasPrefix(content, "\xE2\x80\xB8");
					if (startCaret) {
						content = strings.ReplaceAll(content, "\xE2\x80\xB8", "");
					}
					_r$2 = strings.TrimSpace(content); /* */ $s = 54; case 54: if($c) { $c = false; _r$2 = _r$2.$blk(); } if (_r$2 && _r$2.$blk !== undefined) { break s; }
					content = _r$2;
					if (startCaret) {
						content = "\xE2\x80\xB8" + content;
					}
					content$1 = new ast.Node.ptr(15, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(content))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					node$3.AppendChild(content$1);
					node$3.AppendChild(new ast.Node.ptr(13, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("```"))), false, false, false, 0, false, 0, 3, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				/* } */ case 53:
				if (!(ptrType.nil === n.Parent) && (1 === n.Parent.DataAtom)) {
					node$3.Type = 40;
				}
				tree.Context.Tip.AppendChild(node$3);
				$s = 51; continue;
			/* } else if ((_1 === (3073)) || (_1 === (92931))) { */ case 24:
				node$3.Type = 1;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if ((_1 === (89090)) || (_1 === (187906)) || (_1 === (199938)) || (_1 === (214274)) || (_1 === (216834)) || (_1 === (412930))) { */ case 25:
				_r$3 = strings.TrimSpace(lute.domText(n)); /* */ $s = 57; case 57: if($c) { $c = false; _r$3 = _r$3.$blk(); } if (_r$3 && _r$3.$blk !== undefined) { break s; }
				/* */ if ("" === _r$3) { $s = 55; continue; }
				/* */ $s = 56; continue;
				/* if ("" === _r$3) { */ case 55:
					$s = -1; return;
				/* } */ case 56:
				node$3.Type = 2;
				marker = lute.domAttrValue(n, "data-marker");
				id = lute.domAttrValue(n, "data-id");
				if (!("" === id)) {
					node$3.HeadingID = (new sliceType$1($stringToBytes(id)));
				}
				node$3.HeadingSetext = "=" === marker || "-" === marker;
				if (!node$3.HeadingSetext) {
					marker$1 = lute.domText(n.FirstChild);
					level = bytes.Count((new sliceType$1($stringToBytes(marker$1))), (new sliceType$1($stringToBytes("#"))));
					node$3.HeadingLevel = level;
				} else {
					node$3.HeadingSetext = false;
					if ("=" === marker) {
						node$3.HeadingLevel = 1;
					} else {
						node$3.HeadingLevel = 2;
					}
				}
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (87810)) { */ case 26:
				node$3.Type = 4;
				tree.Context.Tip.AppendChild(node$3);
				$s = 51; continue;
			/* } else if (_1 === (100106)) { */ case 27:
				_r$4 = strings.TrimSpace(lute.domText(n)); /* */ $s = 58; case 58: if($c) { $c = false; _r$4 = _r$4.$blk(); } if (_r$4 && _r$4.$blk !== undefined) { break s; }
				content$2 = _r$4;
				if ("" === content$2 || "&gt;" === content$2 || "\xE2\x80\xB8" === content$2) {
					$s = -1; return;
				}
				node$3.Type = 5;
				node$3.AppendChild(new ast.Node.ptr(6, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(">"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if ((_1 === (79618)) || (_1 === (42754))) { */ case 28:
				if (ptrType.nil === n.FirstChild) {
					$s = -1; return;
				}
				node$3.Type = 7;
				node$3.ListData = new ast.ListData.ptr(0, false, 0, 0, 0, 0, 0, false, sliceType$1.nil, 0);
				if (79618 === n.DataAtom) {
					node$3.ListData.Typ = 1;
				}
				tight = lute.domAttrValue(n, "data-tight");
				if ("true" === tight || "" === tight) {
					node$3.ListData.Tight = true;
				}
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (45570)) { */ case 29:
				p$1 = n.FirstChild;
				if (!(ptrType.nil === p$1) && (3073 === p$1.DataAtom) && !(ptrType.nil === p$1.NextSibling) && (3073 === p$1.NextSibling.DataAtom)) {
					tree.Context.Tip.ListData.Tight = false;
				}
				node$3.Type = 8;
				marker$2 = lute.domAttrValue(n, "data-marker");
				bullet = 0;
				if ("" === marker$2) {
					if (!(ptrType.nil === n.Parent) && (79618 === n.Parent.DataAtom)) {
						firstLiMarker = lute.domAttrValue(n.Parent.FirstChild, "data-marker");
						startAttr = lute.domAttrValue(n.Parent, "start");
						if ("" === startAttr) {
							marker$2 = "1";
						} else {
							marker$2 = startAttr;
						}
						if (!("" === firstLiMarker)) {
							marker$2 = marker$2 + ($substring(firstLiMarker, (firstLiMarker.length - 1 >> 0)));
						} else {
							marker$2 = marker$2 + (".");
						}
					} else {
						marker$2 = lute.domAttrValue(n.Parent, "data-marker");
						if ("" === marker$2) {
							marker$2 = "*";
						}
						bullet = marker$2.charCodeAt(0);
					}
				} else {
					if (!(ptrType.nil === n.Parent)) {
						if (79618 === n.Parent.DataAtom) {
							if ("*" === marker$2 || "-" === marker$2 || "+" === marker$2) {
								marker$2 = "1.";
							}
							if (!("1." === marker$2) && !("1)" === marker$2) && !(ptrType.nil === n.PrevSibling) && !((45570 === n.PrevSibling.DataAtom)) && !(ptrType.nil === n.Parent.Parent) && ((79618 === n.Parent.Parent.DataAtom) || (42754 === n.Parent.Parent.DataAtom))) {
								marker$2 = "1.";
							}
							if (!("1." === marker$2) && !("1)" === marker$2) && (79618 === n.Parent.DataAtom) && n.Parent.FirstChild === n && "" === lute.domAttrValue(n.Parent, "start")) {
								marker$2 = "1.";
							}
						} else {
							if (!("*" === marker$2) && !("-" === marker$2) && !("+" === marker$2)) {
								marker$2 = "*";
							}
							bullet = marker$2.charCodeAt(0);
						}
					} else {
						marker$2 = lute.domAttrValue(n, "data-marker");
						if ("" === marker$2) {
							marker$2 = "*";
						}
						bullet = marker$2.charCodeAt(0);
					}
				}
				node$3.ListData = new ast.ListData.ptr(0, false, bullet, 0, 0, 0, 0, false, (new sliceType$1($stringToBytes(marker$2))), 0);
				if (0 === bullet) {
					_tuple = strconv.Atoi(($encodeRune(marker$2.charCodeAt(0))));
					node$3.ListData.Num = _tuple[0];
					node$3.ListData.Delimiter = marker$2.charCodeAt((marker$2.length - 1 >> 0));
				}
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (290819)) { */ case 30:
				if (378116 === n.FirstChild.DataAtom) {
					codeTokens = sliceType$1.nil;
					if (!(ptrType.nil === n.FirstChild.FirstChild)) {
						codeTokens = (new sliceType$1($stringToBytes(n.FirstChild.FirstChild.Data)));
					}
					divDataType = lute.domAttrValue(n.Parent, "data-type");
					_2 = divDataType;
					if (_2 === ("math-block")) {
						node$3.Type = 300;
						node$3.AppendChild(new ast.Node.ptr(302, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, codeTokens, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						tree.Context.Tip.AppendChild(node$3);
					} else if (_2 === ("html-block")) {
						node$3.Type = 9;
						node$3.Tokens = codeTokens;
						tree.Context.Tip.AppendChild(node$3);
					} else {
						node$3.Type = 15;
						node$3.Tokens = codeTokens;
						tree.Context.Tip.AppendChild(node$3);
					}
				}
				$s = -1; return;
			/* } else if ((_1 === (28162)) || (_1 === (1537))) { */ case 31:
				if (ptrType.nil === n.FirstChild || (514 === n.FirstChild.DataAtom)) {
					$s = -1; return;
				}
				/* */ if (lute.starstWithNewline(n.FirstChild)) { $s = 59; continue; }
				/* */ $s = 60; continue;
				/* if (lute.starstWithNewline(n.FirstChild)) { */ case 59:
					_r$5 = strings.TrimLeft(n.FirstChild.Data, "\xE2\x80\x8B\n"); /* */ $s = 61; case 61: if($c) { $c = false; _r$5 = _r$5.$blk(); } if (_r$5 && _r$5.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$5;
					tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 60:
				_r$6 = strings.TrimSpace(lute.domText(n)); /* */ $s = 62; case 62: if($c) { $c = false; _r$6 = _r$6.$blk(); } if (_r$6 && _r$6.$blk !== undefined) { break s; }
				text$3 = _r$6;
				_r$7 = lute.isEmptyText(n); /* */ $s = 65; case 65: if($c) { $c = false; _r$7 = _r$7.$blk(); } if (_r$7 && _r$7.$blk !== undefined) { break s; }
				/* */ if (_r$7) { $s = 63; continue; }
				/* */ $s = 64; continue;
				/* if (_r$7) { */ case 63:
					$s = -1; return;
				/* } */ case 64:
				if ("\xE2\x80\xB8" === text$3) {
					node$3.Tokens = (new sliceType$1($stringToBytes("\xE2\x80\xB8")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				node$3.Type = 17;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if ((_1 === (449798)) || (_1 === (257))) { */ case 32:
				if (ptrType.nil === n.FirstChild || (514 === n.FirstChild.DataAtom)) {
					$s = -1; return;
				}
				/* */ if (lute.starstWithNewline(n.FirstChild)) { $s = 66; continue; }
				/* */ $s = 67; continue;
				/* if (lute.starstWithNewline(n.FirstChild)) { */ case 66:
					_r$8 = strings.TrimLeft(n.FirstChild.Data, "\xE2\x80\x8B\n"); /* */ $s = 68; case 68: if($c) { $c = false; _r$8 = _r$8.$blk(); } if (_r$8 && _r$8.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$8;
					tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 67:
				_r$9 = strings.TrimSpace(lute.domText(n)); /* */ $s = 69; case 69: if($c) { $c = false; _r$9 = _r$9.$blk(); } if (_r$9 && _r$9.$blk !== undefined) { break s; }
				text$4 = _r$9;
				_r$10 = lute.isEmptyText(n); /* */ $s = 72; case 72: if($c) { $c = false; _r$10 = _r$10.$blk(); } if (_r$10 && _r$10.$blk !== undefined) { break s; }
				/* */ if (_r$10) { $s = 70; continue; }
				/* */ $s = 71; continue;
				/* if (_r$10) { */ case 70:
					$s = -1; return;
				/* } */ case 71:
				if ("\xE2\x80\xB8" === text$4) {
					node$3.Tokens = (new sliceType$1($stringToBytes("\xE2\x80\xB8")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				node$3.Type = 22;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if ((_1 === (283139)) || (_1 === (9473)) || (_1 === (53766))) { */ case 33:
				if (ptrType.nil === n.FirstChild || (514 === n.FirstChild.DataAtom)) {
					$s = -1; return;
				}
				/* */ if (lute.starstWithNewline(n.FirstChild)) { $s = 73; continue; }
				/* */ $s = 74; continue;
				/* if (lute.starstWithNewline(n.FirstChild)) { */ case 73:
					_r$11 = strings.TrimLeft(n.FirstChild.Data, "\xE2\x80\x8B\n"); /* */ $s = 75; case 75: if($c) { $c = false; _r$11 = _r$11.$blk(); } if (_r$11 && _r$11.$blk !== undefined) { break s; }
					n.FirstChild.Data = _r$11;
					tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B\n"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				/* } */ case 74:
				_r$12 = strings.TrimSpace(lute.domText(n)); /* */ $s = 76; case 76: if($c) { $c = false; _r$12 = _r$12.$blk(); } if (_r$12 && _r$12.$blk !== undefined) { break s; }
				text$5 = _r$12;
				_r$13 = lute.isEmptyText(n); /* */ $s = 79; case 79: if($c) { $c = false; _r$13 = _r$13.$blk(); } if (_r$13 && _r$13.$blk !== undefined) { break s; }
				/* */ if (_r$13) { $s = 77; continue; }
				/* */ $s = 78; continue;
				/* if (_r$13) { */ case 77:
					$s = -1; return;
				/* } */ case 78:
				if ("\xE2\x80\xB8" === text$5) {
					node$3.Tokens = (new sliceType$1($stringToBytes("\xE2\x80\xB8")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				node$3.Type = 101;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (378116)) { */ case 34:
				if (ptrType.nil === n.FirstChild) {
					$s = -1; return;
				}
				contentStr = strings.ReplaceAll(n.FirstChild.Data, "\xE2\x80\x8B", "");
				if ("\xE2\x80\xB8" === contentStr) {
					node$3.Tokens = (new sliceType$1($stringToBytes("\xE2\x80\xB8")));
					tree.Context.Tip.AppendChild(node$3);
					$s = -1; return;
				}
				if ("" === contentStr) {
					$s = -1; return;
				}
				codeTokens$1 = (new sliceType$1($stringToBytes(contentStr)));
				content$3 = new ast.Node.ptr(29, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, codeTokens$1, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
				node$3.Type = 27;
				node$3.AppendChild(content$3);
				tree.Context.Tip.AppendChild(node$3);
				$s = -1; return;
			/* } else if (_1 === (514)) { */ case 35:
				if (!(ptrType.nil === n.Parent)) {
					if (lute.parentIs(n, new sliceType$7([37378, 87554]))) {
						if ((ptrType.nil === n.PrevSibling || "\xE2\x80\xB8" === n.PrevSibling.Data) && (ptrType.nil === n.NextSibling || "\xE2\x80\xB8" === n.NextSibling.Data)) {
							$s = -1; return;
						}
						if (ptrType.nil === n.NextSibling) {
							$s = -1; return;
						}
						node$3.Type = 10;
						node$3.Tokens = (new sliceType$1($stringToBytes("<br />")));
						tree.Context.Tip.AppendChild(node$3);
						$s = -1; return;
					}
					if (3073 === n.Parent.DataAtom) {
						if (!(ptrType.nil === n.Parent.NextSibling) && ((42754 === n.Parent.NextSibling.DataAtom) || (79618 === n.Parent.NextSibling.DataAtom) || (100106 === n.Parent.NextSibling.DataAtom))) {
							tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
							$s = -1; return;
						}
						if (!(ptrType.nil === n.Parent.Parent) && !(ptrType.nil === n.Parent.Parent.NextSibling) && (45570 === n.Parent.Parent.NextSibling.DataAtom)) {
							tree.Context.Tip.AppendChild(new ast.Node.ptr(16, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("\xE2\x80\x8B"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
							$s = -1; return;
						}
					}
				}
				node$3.Type = 31;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (1)) { */ case 36:
				node$3.Type = 33;
				node$3.AppendChild(new ast.Node.ptr(36, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (198403)) { */ case 37:
				imgClass = class$1;
				imgAlt = lute.domAttrValue(n, "alt");
				if ("emoji" === imgClass) {
					node$3.Type = 200;
					emojiImg = new ast.Node.ptr(202, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, tree.EmojiImgTokens(imgAlt, lute.domAttrValue(n, "src")), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil);
					emojiImg.AppendChild(new ast.Node.ptr(203, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(":" + imgAlt + ":"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(emojiImg);
					tree.Context.Tip.AppendChild(node$3);
					tree.Context.Tip = node$3;
					$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				} else {
					$s = -1; return;
				}
				$s = 51; continue;
			/* } else if (_1 === (281349)) { */ case 38:
				if (ptrType.nil === n.Parent || ptrType.nil === n.Parent.Parent || (!((3073 === n.Parent.DataAtom)) && !((45570 === n.Parent.DataAtom)))) {
					$s = -1; return;
				}
				/* */ if (!(ptrType.nil === n.NextSibling) && (40708 === n.NextSibling.DataAtom)) { $s = 80; continue; }
				/* */ $s = 81; continue;
				/* if (!(ptrType.nil === n.NextSibling) && (40708 === n.NextSibling.DataAtom)) { */ case 80:
					_r$14 = strings.TrimSpace(n.NextSibling.FirstChild.Data); /* */ $s = 82; case 82: if($c) { $c = false; _r$14 = _r$14.$blk(); } if (_r$14 && _r$14.$blk !== undefined) { break s; }
					n.NextSibling.FirstChild.Data = _r$14;
					/* break; */ $s = 22; continue;
				/* } */ case 81:
				node$3.Type = 100;
				if (lute.hasAttr(n, "checked")) {
					node$3.TaskListItemChecked = true;
				}
				tree.Context.Tip.AppendChild(node$3);
				if (!(ptrType$1.nil === node$3.Parent.Parent) && !(ptrType$5.nil === node$3.Parent.Parent.ListData)) {
					node$3.Parent.Parent.ListData.Typ = 3;
				}
				if (!(ptrType$1.nil === node$3.Parent.Parent.Parent) && !(ptrType$5.nil === node$3.Parent.Parent.Parent.ListData)) {
					node$3.Parent.Parent.Parent.ListData.Typ = 3;
				}
				$s = 51; continue;
			/* } else if (_1 === (365829)) { */ case 39:
				node$3.Type = 106;
				tableAligns = sliceType$2.nil;
				th = n.FirstChild.FirstChild.FirstChild;
				while (true) {
					if (!(!(ptrType.nil === th))) { break; }
					align = lute.domAttrValue(th, "align");
					_3 = align;
					if (_3 === ("left")) {
						tableAligns = $append(tableAligns, 1);
					} else if (_3 === ("center")) {
						tableAligns = $append(tableAligns, 2);
					} else if (_3 === ("right")) {
						tableAligns = $append(tableAligns, 3);
					} else {
						tableAligns = $append(tableAligns, 0);
					}
					th = th.NextSibling;
				}
				node$3.TableAligns = tableAligns;
				tree.Context.Tip.AppendChild(new ast.Node.ptr(1, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (208901)) { */ case 40:
				node$3.Type = 107;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (9989)) { */ case 41:
				$s = 51; continue;
			/* } else if (_1 === (52226)) { */ case 42:
				node$3.Type = 108;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if ((_1 === (87554)) || (_1 === (37378))) { */ case 43:
				node$3.Type = 109;
				align$1 = lute.domAttrValue(n, "align");
				tableAlign = 0;
				_4 = align$1;
				if (_4 === ("left")) {
					tableAlign = 1;
				} else if (_4 === ("center")) {
					tableAlign = 2;
				} else if (_4 === ("right")) {
					tableAlign = 3;
				} else {
					tableAlign = 0;
				}
				node$3.TableCellAlign = tableAlign;
				tree.Context.Tip.AppendChild(node$3);
				tree.Context.Tip = node$3;
				$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
				$s = 51; continue;
			/* } else if (_1 === (461571)) { */ case 44:
				if (ptrType.nil === n.FirstChild) {
					/* break; */ $s = 22; continue;
				}
				if ("footnotes-ref" === dataType) {
					node$3.Type = 16;
					node$3.Tokens = (new sliceType$1($stringToBytes(lute.domText(n))));
					tree.Context.Tip.AppendChild(node$3);
				}
				$s = -1; return;
			/* } else if (_1 === (40708)) { */ case 45:
					_5 = dataType;
					/* */ if (_5 === ("inline-node") || _5 === ("em") || _5 === ("strong") || _5 === ("s") || _5 === ("a") || _5 === ("link-ref") || _5 === ("img") || _5 === ("code")) { $s = 84; continue; }
					/* */ if (_5 === ("math-block-close-marker")) { $s = 85; continue; }
					/* */ if (_5 === ("math-block-open-marker")) { $s = 86; continue; }
					/* */ if (_5 === ("code-block-open-marker")) { $s = 87; continue; }
					/* */ if (_5 === ("code-block-info")) { $s = 88; continue; }
					/* */ if (_5 === ("code-block-close-marker")) { $s = 89; continue; }
					/* */ if (_5 === ("heading-marker")) { $s = 90; continue; }
					/* */ $s = 91; continue;
					/* if (_5 === ("inline-node") || _5 === ("em") || _5 === ("strong") || _5 === ("s") || _5 === ("a") || _5 === ("link-ref") || _5 === ("img") || _5 === ("code")) { */ case 84:
						node$3.Type = 16;
						node$3.Tokens = (new sliceType$1($stringToBytes(lute.domText(n))));
						tree.Context.Tip.AppendChild(node$3);
						$s = -1; return;
					/* } else if (_5 === ("math-block-close-marker")) { */ case 85:
						tree.Context.Tip.AppendChild(new ast.Node.ptr(303, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("$$"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
						$s = -1; return;
					/* } else if (_5 === ("math-block-open-marker")) { */ case 86:
						node$3.Type = 300;
						node$3.AppendChild(new ast.Node.ptr(301, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("$$"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						tree.Context.Tip.AppendChild(node$3);
						tree.Context.Tip = node$3;
						$s = -1; return;
					/* } else if (_5 === ("code-block-open-marker")) { */ case 87:
						if (290819 === n.NextSibling.DataAtom) {
							n.InsertAfter(new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 0, 40708, "", "", new sliceType([new html.Attribute.ptr("", "data-type", "code-block-info")])));
						}
						marker$3 = (new sliceType$1($stringToBytes(lute.domText(n))));
						lastBacktick = bytes.LastIndex(marker$3, (new sliceType$1($stringToBytes("`")))) + 1 >> 0;
						if (0 < lastBacktick) {
							n.NextSibling.AppendChild(new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 0, 0, ($bytesToString($subslice(marker$3, lastBacktick))), "", sliceType.nil));
							marker$3 = $subslice(marker$3, 0, lastBacktick);
						}
						node$3.Type = 11;
						node$3.IsFencedCodeBlock = true;
						node$3.AppendChild(new ast.Node.ptr(12, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, marker$3, false, false, false, 0, false, 0, marker$3.$length, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						tree.Context.Tip.AppendChild(node$3);
						tree.Context.Tip = node$3;
						$s = -1; return;
					/* } else if (_5 === ("code-block-info")) { */ case 88:
						info = (new sliceType$1($stringToBytes(lute.domText(n))));
						info = bytes.ReplaceAll(info, (new sliceType$1($stringToBytes("\xE2\x80\x8B"))), sliceType$1.nil);
						tree.Context.Tip.AppendChild(new ast.Node.ptr(14, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, info, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						$s = -1; return;
					/* } else if (_5 === ("code-block-close-marker")) { */ case 89:
						marker$4 = (new sliceType$1($stringToBytes(lute.domText(n))));
						lastBacktick$1 = bytes.LastIndex(marker$4, (new sliceType$1($stringToBytes("`")))) + 1 >> 0;
						if (0 < lastBacktick$1) {
							marker$4 = $subslice(marker$4, 0, lastBacktick$1);
						}
						if (0 === marker$4.$length) {
							marker$4 = (new sliceType$1($stringToBytes("```")));
						}
						tree.Context.Tip.AppendChild(new ast.Node.ptr(13, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, marker$4, false, false, false, 0, false, 0, marker$4.$length, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
						$deferred.push([$methodVal(tree.Context, "ParentTip"), []]);
						$s = -1; return;
					/* } else if (_5 === ("heading-marker")) { */ case 90:
						text$6 = lute.domText(n);
						caretInMarker = strings.Contains(text$6, "\xE2\x80\xB8");
						/* */ if (caretInMarker) { $s = 92; continue; }
						/* */ $s = 93; continue;
						/* if (caretInMarker) { */ case 92:
							caret = new html.Node.ptr(ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, ptrType.nil, 1, 0, "\xE2\x80\xB8", "", sliceType.nil);
							n.InsertAfter(caret);
							text$6 = strings.ReplaceAll(text$6, "#", "");
							text$6 = strings.ReplaceAll(text$6, "\xE2\x80\xB8", "");
							_r$15 = strings.TrimSpace(text$6); /* */ $s = 94; case 94: if($c) { $c = false; _r$15 = _r$15.$blk(); } if (_r$15 && _r$15.$blk !== undefined) { break s; }
							text$6 = _r$15;
							if (0 < text$6.length) {
								caret.Data = text$6 + caret.Data;
							}
						/* } */ case 93:
						$s = -1; return;
					/* } */ case 91:
				case 83:
				if (ptrType.nil === n.FirstChild) {
					/* break; */ $s = 22; continue;
				}
				codeTokens$2 = sliceType$1.nil;
				if ("\xE2\x80\x8B" === n.FirstChild.Data && "" === lute.domAttrValue(n, "style") && !(ptrType.nil === n.FirstChild.NextSibling)) {
					codeTokens$2 = (new sliceType$1($stringToBytes(n.FirstChild.NextSibling.FirstChild.Data)));
				} else if (378116 === n.FirstChild.DataAtom) {
					codeTokens$2 = (new sliceType$1($stringToBytes(n.FirstChild.FirstChild.Data)));
					if ("\xE2\x80\x8B" === ($bytesToString(codeTokens$2))) {
						/* break; */ $s = 22; continue;
					}
				} else {
					/* break; */ $s = 22; continue;
				}
				if ("math-inline" === dataType) {
					node$3.Type = 304;
					node$3.AppendChild(new ast.Node.ptr(305, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(new ast.Node.ptr(306, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, codeTokens$2, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					node$3.AppendChild(new ast.Node.ptr(307, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
					tree.Context.Tip.AppendChild(node$3);
				} else if ("html-inline" === dataType) {
					node$3.Type = 10;
					node$3.Tokens = codeTokens$2;
					tree.Context.Tip.AppendChild(node$3);
				} else if ("code-inline" === dataType) {
					node$3.Tokens = codeTokens$2;
					tree.Context.Tip.AppendChild(node$3);
				} else if ("html-entity" === dataType) {
					node$3.Type = 16;
					node$3.Tokens = codeTokens$2;
					tree.Context.Tip.AppendChild(node$3);
				}
				$s = -1; return;
			/* } else if (_1 === (16132)) { */ case 46:
				$s = -1; return;
			/* } else if (_1 === (29191)) { */ case 47:
				node$3.Type = 9;
				_r$16 = lute.domHTML(n); /* */ $s = 95; case 95: if($c) { $c = false; _r$16 = _r$16.$blk(); } if (_r$16 && _r$16.$blk !== undefined) { break s; }
				node$3.Tokens = _r$16;
				node$3.Tokens = (x = bytes.SplitAfter(node$3.Tokens, (new sliceType$1($stringToBytes("</summary>")))), (0 >= x.$length ? ($throwRuntimeError("index out of range"), undefined) : x.$array[x.$offset + 0]));
				tree.Context.Tip.AppendChild(node$3);
				$s = 51; continue;
			/* } else if (_1 === (47363)) { */ case 48:
				node$3.Type = 10;
				_r$17 = lute.domHTML(n); /* */ $s = 96; case 96: if($c) { $c = false; _r$17 = _r$17.$blk(); } if (_r$17 && _r$17.$blk !== undefined) { break s; }
				node$3.Tokens = _r$17;
				tree.Context.Tip.AppendChild(node$3);
				$s = -1; return;
			/* } else if (_1 === (459783)) { */ case 49:
				$s = -1; return;
			/* } else { */ case 50:
				node$3.Type = 9;
				_r$18 = lute.domHTML(n); /* */ $s = 97; case 97: if($c) { $c = false; _r$18 = _r$18.$blk(); } if (_r$18 && _r$18.$blk !== undefined) { break s; }
				node$3.Tokens = _r$18;
				tree.Context.Tip.AppendChild(node$3);
				$s = -1; return;
			/* } */ case 51:
		case 22:
		c$2 = n.FirstChild;
		/* while (true) { */ case 98:
			/* if (!(!(c$2 === ptrType.nil))) { break; } */ if(!(!(c$2 === ptrType.nil))) { $s = 99; continue; }
			$r = lute.genASTByVditorIRDOM(c$2, tree); /* */ $s = 100; case 100: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
			c$2 = c$2.NextSibling;
		/* } */ $s = 98; continue; case 99:
		_6 = n.DataAtom;
		if (_6 === (1)) {
			node$3.AppendChild(new ast.Node.ptr(37, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			node$3.AppendChild(new ast.Node.ptr(38, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			href = lute.domAttrValue(n, "href");
			if (!("" === lute.Options.LinkBase)) {
				href = strings.ReplaceAll(href, lute.Options.LinkBase, "");
			}
			node$3.AppendChild(new ast.Node.ptr(41, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(href))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			linkTitle = lute.domAttrValue(n, "title");
			if (!("" === linkTitle)) {
				node$3.AppendChild(new ast.Node.ptr(43, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
				node$3.AppendChild(new ast.Node.ptr(42, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes(linkTitle))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
			}
			node$3.AppendChild(new ast.Node.ptr(39, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, sliceType$1.nil, false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		} else if (_6 === (29191)) {
			tree.Context.Tip.AppendChild(new ast.Node.ptr(9, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, ptrType$1.nil, (new sliceType$1($stringToBytes("</details>"))), false, false, false, 0, false, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, sliceType$1.nil, 0, ptrType$5.nil, false, sliceType$2.nil, 0, 0, 0, sliceType$1.nil, sliceType$1.nil, 0, sliceType$1.nil, 0, false, sliceType$1.nil, "", 0, sliceType$1.nil, "", sliceType$3.nil, sliceType$1.nil));
		}
		$s = -1; return;
		/* */ } return; } } catch(err) { $err = err; $s = -1; } finally { $callDeferred($deferred, $err); if($curGoroutine.asleep) { if ($f === undefined) { $f = { $blk: Lute.ptr.prototype.genASTByVditorIRDOM }; } $f._1 = _1; $f._2 = _2; $f._3 = _3; $f._4 = _4; $f._5 = _5; $f._6 = _6; $f._i = _i; $f._r = _r; $f._r$1 = _r$1; $f._r$10 = _r$10; $f._r$11 = _r$11; $f._r$12 = _r$12; $f._r$13 = _r$13; $f._r$14 = _r$14; $f._r$15 = _r$15; $f._r$16 = _r$16; $f._r$17 = _r$17; $f._r$18 = _r$18; $f._r$2 = _r$2; $f._r$3 = _r$3; $f._r$4 = _r$4; $f._r$5 = _r$5; $f._r$6 = _r$6; $f._r$7 = _r$7; $f._r$8 = _r$8; $f._r$9 = _r$9; $f._ref = _ref; $f._tuple = _tuple; $f.align = align; $f.align$1 = align$1; $f.bullet = bullet; $f.c = c; $f.c$1 = c$1; $f.c$2 = c$2; $f.caret = caret; $f.caretInMarker = caretInMarker; $f.checkIndentCodeBlock = checkIndentCodeBlock; $f.class$1 = class$1; $f.codeTokens = codeTokens; $f.codeTokens$1 = codeTokens$1; $f.codeTokens$2 = codeTokens$2; $f.content = content; $f.content$1 = content$1; $f.content$2 = content$2; $f.content$3 = content$3; $f.contentStr = contentStr; $f.dataRender = dataRender; $f.dataType = dataType; $f.def = def; $f.divDataType = divDataType; $f.emojiImg = emojiImg; $f.err = err; $f.firstLiMarker = firstLiMarker; $f.href = href; $f.i = i; $f.id = id; $f.imgAlt = imgAlt; $f.imgClass = imgClass; $f.info = info; $f.lastBacktick = lastBacktick; $f.lastBacktick$1 = lastBacktick$1; $f.level = level; $f.line = line; $f.lines = lines; $f.linkTitle = linkTitle; $f.lute = lute; $f.marker = marker; $f.marker$1 = marker$1; $f.marker$2 = marker$2; $f.marker$3 = marker$3; $f.marker$4 = marker$4; $f.md = md; $f.n = n; $f.node = node; $f.node$1 = node$1; $f.node$2 = node$2; $f.node$3 = node$3; $f.originalHTML = originalHTML; $f.p = p; $f.p$1 = p$1; $f.startAttr = startAttr; $f.startCaret = startCaret; $f.tableAlign = tableAlign; $f.tableAligns = tableAligns; $f.text = text; $f.text$1 = text$1; $f.text$2 = text$2; $f.text$3 = text$3; $f.text$4 = text$4; $f.text$5 = text$5; $f.text$6 = text$6; $f.th = th; $f.tight = tight; $f.tree = tree; $f.x = x; $f.$s = $s; $f.$deferred = $deferred; $f.$r = $r; return $f; } }
	};
	Lute.prototype.genASTByVditorIRDOM = function(n, tree) { return this.$val.genASTByVditorIRDOM(n, tree); };
	ptrType$8.methods = [{prop: "HTML2Markdown", name: "HTML2Markdown", pkg: "", typ: $funcType([$String], [$String, $error], false)}, {prop: "genASTByDOM", name: "genASTByDOM", pkg: "lute", typ: $funcType([ptrType, ptrType$6], [], false)}, {prop: "Markdown", name: "Markdown", pkg: "", typ: $funcType([$String, sliceType$1], [sliceType$1], false)}, {prop: "MarkdownStr", name: "MarkdownStr", pkg: "", typ: $funcType([$String, $String], [$String], false)}, {prop: "Format", name: "Format", pkg: "", typ: $funcType([$String, sliceType$1], [sliceType$1], false)}, {prop: "FormatStr", name: "FormatStr", pkg: "", typ: $funcType([$String, $String], [$String], false)}, {prop: "Space", name: "Space", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "GetEmojis", name: "GetEmojis", pkg: "", typ: $funcType([], [mapType$1], false)}, {prop: "PutEmojis", name: "PutEmojis", pkg: "", typ: $funcType([mapType$1], [], false)}, {prop: "GetTerms", name: "GetTerms", pkg: "", typ: $funcType([], [mapType$1], false)}, {prop: "PutTerms", name: "PutTerms", pkg: "", typ: $funcType([mapType$1], [], false)}, {prop: "SetGFMTable", name: "SetGFMTable", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetGFMTaskListItem", name: "SetGFMTaskListItem", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetGFMTaskListItemClass", name: "SetGFMTaskListItemClass", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetGFMStrikethrough", name: "SetGFMStrikethrough", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetGFMAutoLink", name: "SetGFMAutoLink", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetSoftBreak2HardBreak", name: "SetSoftBreak2HardBreak", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlight", name: "SetCodeSyntaxHighlight", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlightDetectLang", name: "SetCodeSyntaxHighlightDetectLang", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlightInlineStyle", name: "SetCodeSyntaxHighlightInlineStyle", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlightLineNum", name: "SetCodeSyntaxHighlightLineNum", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetCodeSyntaxHighlightStyleName", name: "SetCodeSyntaxHighlightStyleName", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetFootnotes", name: "SetFootnotes", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetToC", name: "SetToC", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetHeadingID", name: "SetHeadingID", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetAutoSpace", name: "SetAutoSpace", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetFixTermTypo", name: "SetFixTermTypo", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetChinesePunct", name: "SetChinesePunct", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetEmoji", name: "SetEmoji", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetEmojis", name: "SetEmojis", pkg: "", typ: $funcType([mapType$1], [], false)}, {prop: "SetEmojiSite", name: "SetEmojiSite", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetHeadingAnchor", name: "SetHeadingAnchor", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetTerms", name: "SetTerms", pkg: "", typ: $funcType([mapType$1], [], false)}, {prop: "SetVditorWYSIWYG", name: "SetVditorWYSIWYG", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetInlineMathAllowDigitAfterOpenMarker", name: "SetInlineMathAllowDigitAfterOpenMarker", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetLinkBase", name: "SetLinkBase", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetVditorCodeBlockPreview", name: "SetVditorCodeBlockPreview", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetRenderListMarker", name: "SetRenderListMarker", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetSetext", name: "SetSetext", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetSanitize", name: "SetSanitize", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetImageLazyLoading", name: "SetImageLazyLoading", pkg: "", typ: $funcType([$String], [], false)}, {prop: "SetChineseParagraphBeginningSpace", name: "SetChineseParagraphBeginningSpace", pkg: "", typ: $funcType([$Bool], [], false)}, {prop: "SetJSRenderers", name: "SetJSRenderers", pkg: "", typ: $funcType([mapType$3], [], false)}, {prop: "Md2HTML", name: "Md2HTML", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "FormatMd", name: "FormatMd", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "SpinVditorDOM", name: "SpinVditorDOM", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "HTML2VditorDOM", name: "HTML2VditorDOM", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "VditorDOM2HTML", name: "VditorDOM2HTML", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "Md2VditorDOM", name: "Md2VditorDOM", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "VditorDOM2Md", name: "VditorDOM2Md", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "RenderEChartsJSON", name: "RenderEChartsJSON", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "HTML2Md", name: "HTML2Md", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "vditorDOM2Md", name: "vditorDOM2Md", pkg: "lute", typ: $funcType([$String], [$String], false)}, {prop: "adjustVditorDOM", name: "adjustVditorDOM", pkg: "lute", typ: $funcType([sliceType$6], [], false)}, {prop: "adjustVditorDOM0", name: "adjustVditorDOM0", pkg: "lute", typ: $funcType([ptrType, ptrType$9], [], false)}, {prop: "genASTByVditorDOM", name: "genASTByVditorDOM", pkg: "lute", typ: $funcType([ptrType, ptrType$6], [], false)}, {prop: "hasAttr", name: "hasAttr", pkg: "lute", typ: $funcType([ptrType, $String], [$Bool], false)}, {prop: "domAttrValue", name: "domAttrValue", pkg: "lute", typ: $funcType([ptrType, $String], [$String], false)}, {prop: "domCode", name: "domCode", pkg: "lute", typ: $funcType([ptrType], [$String], false)}, {prop: "domCode0", name: "domCode0", pkg: "lute", typ: $funcType([ptrType, ptrType$11], [], false)}, {prop: "parentIs", name: "parentIs", pkg: "lute", typ: $funcType([ptrType, sliceType$7], [$Bool], true)}, {prop: "domText", name: "domText", pkg: "lute", typ: $funcType([ptrType], [$String], false)}, {prop: "domText0", name: "domText0", pkg: "lute", typ: $funcType([ptrType, ptrType$11], [], false)}, {prop: "domHTML", name: "domHTML", pkg: "lute", typ: $funcType([ptrType], [sliceType$1], false)}, {prop: "isEmptyText", name: "isEmptyText", pkg: "lute", typ: $funcType([ptrType], [$Bool], false)}, {prop: "starstWithNewline", name: "starstWithNewline", pkg: "lute", typ: $funcType([ptrType], [$Bool], false)}, {prop: "isInline", name: "isInline", pkg: "lute", typ: $funcType([ptrType], [$Bool], false)}, {prop: "SpinVditorIRDOM", name: "SpinVditorIRDOM", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "HTML2VditorIRDOM", name: "HTML2VditorIRDOM", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "VditorIRDOM2HTML", name: "VditorIRDOM2HTML", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "Md2VditorIRDOM", name: "Md2VditorIRDOM", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "VditorIRDOM2Md", name: "VditorIRDOM2Md", pkg: "", typ: $funcType([$String], [$String], false)}, {prop: "vditorIRDOM2Md", name: "vditorIRDOM2Md", pkg: "lute", typ: $funcType([$String], [$String], false)}, {prop: "genASTByVditorIRDOM", name: "genASTByVditorIRDOM", pkg: "lute", typ: $funcType([ptrType, ptrType$6], [], false)}];
	Lute.init("", [{prop: "Options", name: "Options", embedded: true, exported: true, typ: ptrType$7, tag: ""}, {prop: "HTML2MdRendererFuncs", name: "HTML2MdRendererFuncs", embedded: false, exported: true, typ: mapType$4, tag: ""}, {prop: "HTML2VditorDOMRendererFuncs", name: "HTML2VditorDOMRendererFuncs", embedded: false, exported: true, typ: mapType$4, tag: ""}, {prop: "HTML2VditorIRDOMRendererFuncs", name: "HTML2VditorIRDOMRendererFuncs", embedded: false, exported: true, typ: mapType$4, tag: ""}, {prop: "Md2HTMLRendererFuncs", name: "Md2HTMLRendererFuncs", embedded: false, exported: true, typ: mapType$4, tag: ""}, {prop: "Md2VditorDOMRendererFuncs", name: "Md2VditorDOMRendererFuncs", embedded: false, exported: true, typ: mapType$4, tag: ""}, {prop: "Md2VditorIRDOMRendererFuncs", name: "Md2VditorIRDOMRendererFuncs", embedded: false, exported: true, typ: mapType$4, tag: ""}]);
	Option.init([ptrType$8], [], false);
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = bytes.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = js.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = ast.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = html.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = atom.$init(); /* */ $s = 5; case 5: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = parse.$init(); /* */ $s = 6; case 6: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = render.$init(); /* */ $s = 7; case 7: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = util.$init(); /* */ $s = 8; case 8: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strconv.$init(); /* */ $s = 9; case 9: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = strings.$init(); /* */ $s = 10; case 10: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$packages["lute/javascript"] = (function() {
	var $pkg = {}, $init, js, lute, ast, render, sliceType, ptrType, mapType, mapType$1, funcType, ptrType$1, funcType$1, mapType$2, New, main;
	js = $packages["github.com/gopherjs/gopherjs/js"];
	lute = $packages["lute"];
	ast = $packages["lute/ast"];
	render = $packages["lute/render"];
	sliceType = $sliceType(lute.Option);
	ptrType = $ptrType(js.Object);
	mapType = $mapType($String, ptrType);
	mapType$1 = $mapType($String, mapType);
	funcType = $funcType([mapType$1], [ptrType], false);
	ptrType$1 = $ptrType(ast.Node);
	funcType$1 = $funcType([ptrType$1], [$String], false);
	mapType$2 = $mapType($String, $emptyInterface);
	New = function(options) {
		var _r, engine, options, $s, $r;
		/* */ $s = 0; var $f, $c = false; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; _r = $f._r; engine = $f.engine; options = $f.options; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		_r = lute.New(new sliceType([])); /* */ $s = 1; case 1: if($c) { $c = false; _r = _r.$blk(); } if (_r && _r.$blk !== undefined) { break s; }
		engine = _r;
		engine.SetJSRenderers(options);
		$s = -1; return js.MakeWrapper(engine);
		/* */ } return; } if ($f === undefined) { $f = { $blk: New }; } $f._r = _r; $f.engine = engine; $f.options = options; $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.New = New;
	main = function() {
		$global.Lute = $externalize($makeMap($String.keyFor, [{ k: "Version", v: new $String("1.4.7") }, { k: "New", v: new funcType(New) }, { k: "WalkStop", v: new $Int(0) }, { k: "WalkSkipChildren", v: new $Int(1) }, { k: "WalkContinue", v: new $Int(2) }, { k: "GetHeadingID", v: new funcType$1(render.HeadingID) }]), mapType$2);
	};
	$init = function() {
		$pkg.$init = function() {};
		/* */ var $f, $c = false, $s = 0, $r; if (this !== undefined && this.$blk !== undefined) { $f = this; $c = true; $s = $f.$s; $r = $f.$r; } s: while (true) { switch ($s) { case 0:
		$r = js.$init(); /* */ $s = 1; case 1: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = lute.$init(); /* */ $s = 2; case 2: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = ast.$init(); /* */ $s = 3; case 3: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		$r = render.$init(); /* */ $s = 4; case 4: if($c) { $c = false; $r = $r.$blk(); } if ($r && $r.$blk !== undefined) { break s; }
		if ($pkg === $mainPkg) {
			main();
			$mainFinished = true;
		}
		/* */ } return; } if ($f === undefined) { $f = { $blk: $init }; } $f.$s = $s; $f.$r = $r; return $f;
	};
	$pkg.$init = $init;
	return $pkg;
})();
$synthesizeMethods();
var $mainPkg = $packages["lute/javascript"];
$packages["runtime"].$init();
$go($mainPkg.$init, []);
$flushConsole();

}).call(this);
//# sourceMappingURL=lute.js.map
